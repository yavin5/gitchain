var h2=Object.defineProperty;var Pg=ne=>{throw TypeError(ne)};var f2=(ne,de,ve)=>de in ne?h2(ne,de,{enumerable:!0,configurable:!0,writable:!0,value:ve}):ne[de]=ve;var l=(ne,de,ve)=>f2(ne,typeof de!="symbol"?de+"":de,ve),Sc=(ne,de,ve)=>de.has(ne)||Pg("Cannot "+ve);var D=(ne,de,ve)=>(Sc(ne,de,"read from private field"),ve?ve.call(ne):de.get(ne)),ce=(ne,de,ve)=>de.has(ne)?Pg("Cannot add the same private member more than once"):de instanceof WeakSet?de.add(ne):de.set(ne,ve),ue=(ne,de,ve,ft)=>(Sc(ne,de,"write to private field"),ft?ft.call(ne,ve):de.set(ne,ve),ve),z=(ne,de,ve)=>(Sc(ne,de,"access private method"),ve);var wr=(ne,de,ve,ft)=>({set _(ps){ue(ne,de,ps,ve)},get _(){return D(ne,de,ft)}});(function(){"use strict";var fc,gc,mc,pc,yc,wc,bt,zf,qf,Kf,Vf,Wf,bc,Ec,Hf,dt,cr,lr,vc,Je,eo,to,no,Gf,dr,ro,Yf,st,fr,ht,Et,gr,mr,pr,en,ls,yr,vt,Mt,Ie,us,qe,xn,Nt,Qi,An,q,Rg,kg,Mg,Ng,Og,xc,Ac,Fg,so,Cc,_c,io,Bg,Cn,$g,fs,Ic,Xf,Zf,Qf,Jf,jf,eg,tg,ng,rg,sg,ig,og,ag,ds,Tc,cg,lg,ug,dg,hg,fg,gg,mg,pg,yg,wg,bg,je,Ug,gs,ms,Eg,vg,Sg,xg,Ag,Cg,_g,Ig;const ne="0x097efb2a92bc5205e1615db52338a118f1619f3f",de=Symbol.for("@libp2p/connection"),ve=Symbol.for("@libp2p/content-routing");let ft=(fc=class extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}},l(fc,"name","AbortError"),fc);class ps extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}l(ps,"name","UnexpectedPeerError");let zg=(gc=class extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},l(gc,"name","InvalidCryptoExchangeError"),gc),G=(mc=class extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},l(mc,"name","InvalidParametersError"),mc);class oo extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}l(oo,"name","InvalidPublicKeyError");class ys extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}l(ys,"name","ConnectionClosedError");class Lc extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}l(Lc,"name","ConnectionFailedError");class _n extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}l(_n,"name","MuxerClosedError");class ao extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}l(ao,"name","StreamResetError");class tn extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}l(tn,"name","StreamStateError");class co extends Error{constructor(t="The stream buffer was full"){super(t),this.name="StreamBufferError"}}l(co,"name","StreamBufferError");let lo=(pc=class extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}},l(pc,"name","NotFoundError"),pc);class uo extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}l(uo,"name","InvalidPeerIdError");let ws=(yc=class extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}},l(yc,"name","InvalidMultiaddrError"),yc);class Dc extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}l(Dc,"name","InvalidCIDError");class Pc extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}l(Pc,"name","InvalidMultihashError");class Rc extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}l(Rc,"name","UnsupportedProtocolError");class it extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}l(it,"name","InvalidMessageError");let qg=(wc=class extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}},l(wc,"name","TimeoutError"),wc);class br extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}l(br,"name","NotStartedError");class Er extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}l(Er,"name","DialError");class bs extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}l(bs,"name","ListenError");class ho extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}l(ho,"name","LimitedConnectionError");class kc extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}l(kc,"name","TooManyInboundProtocolStreamsError");class fo extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}l(fo,"name","TooManyOutboundProtocolStreamsError");class Es extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}l(Es,"name","UnsupportedKeyTypeError");class Kg extends Event{constructor(e,n){super("message",n);l(this,"data");this.data=e}}class vs extends Event{constructor(e,n,s){super("close",s);l(this,"error");l(this,"local");this.error=n,this.local=e}}class Vg extends vs{constructor(t,e){super(!0,t,e)}}class Wg extends vs{constructor(t,e){super(!1,t,e)}}const go=Symbol.for("@libp2p/peer-discovery"),mo=Symbol.for("@libp2p/peer-id");function vr(r){return!!(r!=null&&r[mo])}const Mc=Symbol.for("@libp2p/peer-routing"),po="keep-alive";function yo(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Nc(...r){const t=[];for(const e of r)yo(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function Oc(...r){const t=[];for(const e of r)yo(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}const Fc=Symbol.for("@libp2p/transport");var Ss;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Ss||(Ss={}));function g2(){}class Ye extends EventTarget{constructor(){super();ce(this,bt,new Map)}listenerCount(e){const n=D(this,bt).get(e);return n==null?0:n.length}addEventListener(e,n,s){super.addEventListener(e,n,s);let i=D(this,bt).get(e);i==null&&(i=[],D(this,bt).set(e,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(e,n,s){super.removeEventListener(e.toString(),n??null,s);let i=D(this,bt).get(e);i!=null&&(i=i.filter(({callback:o})=>o!==n),D(this,bt).set(e,i))}dispatchEvent(e){const n=super.dispatchEvent(e);let s=D(this,bt).get(e.type);return s==null||(s=s.filter(({once:i})=>!i),D(this,bt).set(e.type,s)),n}safeDispatchEvent(e,n={}){return this.dispatchEvent(new CustomEvent(e,n))}}bt=new WeakMap;const St=Symbol.for("@libp2p/service-capabilities"),xs=Symbol.for("@libp2p/service-dependencies");function Hg(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function As(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Gg(r){return new TextEncoder().encode(r)}function Yg(r){return new TextDecoder().decode(r)}function Xg(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function h(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,m=0,S=0,v=g.length;S!==v&&g[S]===0;)S++,y++;for(var E=(v-S)*d+1>>>0,L=new Uint8Array(E);S!==v;){for(var x=g[S],_=0,O=E-1;(x!==0||_<m)&&O!==-1;O--,_++)x+=256*L[O]>>>0,L[O]=x%a>>>0,x=x/a>>>0;if(x!==0)throw new Error("Non-zero carry");m=_,S++}for(var T=E-m;T!==E&&L[T]===0;)T++;for(var I=c.repeat(y);T<E;++T)I+=r.charAt(L[T]);return I}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var y=0;if(g[y]!==" "){for(var m=0,S=0;g[y]===c;)m++,y++;for(var v=(g.length-y)*u+1>>>0,E=new Uint8Array(v);g[y];){var L=e[g.charCodeAt(y)];if(L===255)return;for(var x=0,_=v-1;(L!==0||x<S)&&_!==-1;_--,x++)L+=a*E[_]>>>0,E[_]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");S=x,y++}if(g[y]!==" "){for(var O=v-S;O!==v&&E[O]===0;)O++;for(var T=new Uint8Array(m+(v-O)),I=m;O!==v;)T[I++]=E[O++];return T}}}function p(g){var y=f(g);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:h,decodeUnsafe:f,decode:p}}var Zg=Xg,Qg=Zg;class Jg{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}let jg=class{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseDecode");l(this,"prefixCodePoint");this.name=t,this.prefix=e;const s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Bc(this,t)}};class em{constructor(t){l(this,"decoders");this.decoders=t}or(t){return Bc(this,t)}decode(t){const e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Bc(r,t){return new em({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}class tm{constructor(t,e,n,s){l(this,"name");l(this,"prefix");l(this,"baseEncode");l(this,"baseDecode");l(this,"encoder");l(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Jg(t,e,n),this.decoder=new jg(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function Cs({name:r,prefix:t,encode:e,decode:n}){return new tm(r,t,e,n)}function Sr({name:r,prefix:t,alphabet:e}){const{encode:n,decode:s}=Qg(e,r);return Cs({prefix:t,name:r,encode:n,decode:i=>As(s(i))})}function nm(r,t,e,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const d=t[r[u]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|d,o+=e,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=e||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function rm(r,t,e){const n=t[t.length-1]==="=",s=(1<<e)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function sm(r){const t={};for(let e=0;e<r.length;++e)t[r[e]]=e;return t}function Le({name:r,prefix:t,bitsPerChar:e,alphabet:n}){const s=sm(n);return Cs({prefix:t,name:r,encode(i){return rm(i,n,e)},decode(i){return nm(i,s,e,r)}})}const De=Sr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),im=Sr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),om=Object.freeze(Object.defineProperty({__proto__:null,base58btc:De,base58flickr:im},Symbol.toStringTag,{value:"Module"})),Ot=Le({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),am=Le({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),cm=Le({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),lm=Le({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),um=Le({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),dm=Le({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),hm=Le({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),fm=Le({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),gm=Le({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),mm=Object.freeze(Object.defineProperty({__proto__:null,base32:Ot,base32hex:um,base32hexpad:hm,base32hexpadupper:fm,base32hexupper:dm,base32pad:cm,base32padupper:lm,base32upper:am,base32z:gm},Symbol.toStringTag,{value:"Module"})),_s=Sr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),pm=Sr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),ym=Object.freeze(Object.defineProperty({__proto__:null,base36:_s,base36upper:pm},Symbol.toStringTag,{value:"Module"}));var wm=Uc,$c=128,bm=-128,Em=Math.pow(2,31);function Uc(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Em;)t[e++]=r&255|$c,r/=128;for(;r&bm;)t[e++]=r&255|$c,r>>>=7;return t[e]=r|0,Uc.bytes=e-n+1,t}var vm=wo,Sm=128,zc=127;function wo(r,n){var e=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw wo.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&zc)<<s:(o&zc)*Math.pow(2,s),s+=7}while(o>=Sm);return wo.bytes=i-n,e}var xm=Math.pow(2,7),Am=Math.pow(2,14),Cm=Math.pow(2,21),_m=Math.pow(2,28),Im=Math.pow(2,35),Tm=Math.pow(2,42),Lm=Math.pow(2,49),Dm=Math.pow(2,56),Pm=Math.pow(2,63),Rm=function(r){return r<xm?1:r<Am?2:r<Cm?3:r<_m?4:r<Im?5:r<Tm?6:r<Lm?7:r<Dm?8:r<Pm?9:10},km={encode:wm,decode:vm,encodingLength:Rm},Is=km;function bo(r,t=0){return[Is.decode(r,t),Is.decode.bytes]}function Ts(r,t,e=0){return Is.encode(r,t,e),t}function Ls(r){return Is.encodingLength(r)}function Ds(r,t){const e=t.byteLength,n=Ls(r),s=n+Ls(e),i=new Uint8Array(s+e);return Ts(r,i,0),Ts(e,i,n),i.set(t,s),new Eo(r,e,t,i)}function xr(r){const t=As(r),[e,n]=bo(t),[s,i]=bo(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Eo(e,s,o,t)}function Mm(r,t){if(r===t)return!0;{const e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Hg(r.bytes,e.bytes)}}class Eo{constructor(t,e,n,s){l(this,"code");l(this,"size");l(this,"digest");l(this,"bytes");this.code=t,this.size=e,this.digest=n,this.bytes=s}}function qc(r,t){const{bytes:e,version:n}=r;switch(n){case 0:return Om(e,vo(r),t??De.encoder);default:return Fm(e,vo(r),t??Ot.encoder)}}const Kc=new WeakMap;function vo(r){const t=Kc.get(r);if(t==null){const e=new Map;return Kc.set(r,e),e}return t}class pe{constructor(t,e,n,s){l(this,"code");l(this,"version");l(this,"multihash");l(this,"bytes");l(this,"/");l(this,zf,"CID");this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==Ar)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Bm)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return pe.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,n=Ds(t,e);return pe.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return pe.equals(this,t)}static equals(t,e){const n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Mm(t.multihash,n.multihash)}toString(t){return qc(this,t)}toJSON(){return{"/":qc(this)}}link(){return this}[(zf=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof pe)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:n,code:s,multihash:i,bytes:o}=e;return new pe(n,s,i,o??Vc(n,s,i.bytes))}else if(e[$m]===!0){const{version:n,multihash:s,code:i}=e,o=xr(s);return pe.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Ar)throw new Error(`Version 0 CID must use dag-pb (code: ${Ar}) block encoding`);return new pe(t,e,n,n.bytes)}case 1:{const s=Vc(t,e,n.bytes);return new pe(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return pe.create(0,Ar,t)}static createV1(t,e){return pe.create(1,t,e)}static decode(t){const[e,n]=pe.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=pe.inspectBytes(t),n=e.size-e.multihashSize,s=As(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=s.subarray(e.multihashSize-e.digestSize),o=new Eo(e.multihashCode,e.digestSize,i,s);return[e.version===0?pe.createV0(o):pe.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const n=()=>{const[h,f]=bo(t.subarray(e));return e+=f,h};let s=n(),i=Ar;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=e,a=n(),c=n(),u=e+c,d=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:u}}static parse(t,e){const[n,s]=Nm(t,e),i=pe.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return vo(i).set(n,t),i}}function Nm(r,t){switch(r[0]){case"Q":{const e=t??De;return[De.prefix,e.decode(`${De.prefix}${r}`)]}case De.prefix:{const e=t??De;return[De.prefix,e.decode(r)]}case Ot.prefix:{const e=t??Ot;return[Ot.prefix,e.decode(r)]}case _s.prefix:{const e=t??_s;return[_s.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Om(r,t,e){const{prefix:n}=e;if(n!==De.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const s=t.get(n);if(s==null){const i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Fm(r,t,e){const{prefix:n}=e,s=t.get(n);if(s==null){const i=e.encode(r);return t.set(n,i),i}else return s}const Ar=112,Bm=18;function Vc(r,t,e){const n=Ls(r),s=n+Ls(t),i=new Uint8Array(s+e.byteLength);return Ts(r,i,0),Ts(t,i,n),i.set(e,s),i}const $m=Symbol.for("@ipld/js-cid/CID"),Wc=0,Um="identity",Hc=As;function zm(r,t){if((t==null?void 0:t.truncate)!=null&&t.truncate!==r.byteLength){if(t.truncate<0||t.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t.truncate)}return Ds(Wc,Hc(r))}const Cr={code:Wc,name:Um,encode:Hc,digest:zm};function Ke(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ae(r=0){return new Uint8Array(r)}function gt(r=0){return new Uint8Array(r)}function m2(r){return r}function Ft(r,t){t==null&&(t=r.reduce((s,i)=>s+i.length,0));const e=gt(t);let n=0;for(const s of r)e.set(s,n),n+=s.length;return e}const Gc=Symbol.for("@achingbrain/uint8arraylist");function Yc(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(const n of r){const s=e+n.byteLength;if(t<s)return{buf:n,index:t-e};e=s}throw new RangeError("index is out of bounds")}function Ps(r){return!!(r!=null&&r[Gc])}class Q{constructor(...t){l(this,"bufs");l(this,"length");l(this,qf,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(qf=Gc,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(const n of t)if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.push(n);else if(Ps(n))e+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(const n of t.reverse())if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.unshift(n);else if(Ps(n))e+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){const e=Yc(this.bufs,t);return e.buf[e.index]}set(t,e){const n=Yc(this.bufs,t);n.buf[n.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let n=0;n<t.length;n++)this.set(e+n,t[n]);else if(Ps(t))for(let n=0;n<t.length;n++)this.set(e+n,t.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){const{bufs:n,length:s}=this._subList(t,e);return Ft(n,s)}subarray(t,e){const{bufs:n,length:s}=this._subList(t,e);return n.length===1?n[0]:Ft(n,s)}sublist(t,e){const{bufs:n,length:s}=this._subList(t,e),i=new Q;return i.length=s,i.bufs=[...n],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const u=t>=a&&t<c,d=e>a&&e<=c;if(u&&d){if(t===a&&e===c){n.push(o);break}const h=t-a;n.push(o.subarray(h,h+(e-t)));break}if(u){if(t===0){n.push(o);continue}n.push(o.subarray(t-a));continue}if(d){if(e===c){n.push(o);break}n.push(o.subarray(0,e-a));break}n.push(o)}return{bufs:n,length:e-t}}indexOf(t,e=0){if(!Ps(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,u=n.byteLength-1;let d;for(let h=e;h<=c;h+=d){d=0;for(let f=u;f>=0;f--){const p=this.get(h+f);if(n[f]!==p){d=Math.max(1,f-a[p]);break}}if(d===0)return h}return-1}getInt8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,e),this.write(n,t)}getInt16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,e)}setInt16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,e,n),this.write(s,t)}getInt32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,e)}setInt32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,e,n),this.write(s,t)}getBigInt64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,e)}setBigInt64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,e,n),this.write(s,t)}getUint8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,e),this.write(n,t)}getUint16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,e)}setUint16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,e,n),this.write(s,t)}getUint32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,e)}setUint32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,e,n),this.write(s,t)}getBigUint64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,e)}setBigUint64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,e,n),this.write(s,t)}getFloat32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,e)}setFloat32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,e,n),this.write(s,t)}getFloat64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,e)}setFloat64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,e,n),this.write(s,t)}equals(t){if(t==null||!(t instanceof Q)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!Ke(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){const n=new Q;return n.bufs=t,e==null&&(e=t.reduce((s,i)=>s+i.byteLength,0)),n.length=e,n}}const qm=Sr({prefix:"9",name:"base10",alphabet:"0123456789"}),Km=Object.freeze(Object.defineProperty({__proto__:null,base10:qm},Symbol.toStringTag,{value:"Module"})),Vm=Le({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Wm=Le({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Hm=Object.freeze(Object.defineProperty({__proto__:null,base16:Vm,base16upper:Wm},Symbol.toStringTag,{value:"Module"})),Gm=Le({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Ym=Object.freeze(Object.defineProperty({__proto__:null,base2:Gm},Symbol.toStringTag,{value:"Module"})),Xc=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Xm=Xc.reduce((r,t,e)=>(r[e]=t,r),[]),Zm=Xc.reduce((r,t,e)=>{const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Qm(r){return r.reduce((t,e)=>(t+=Xm[e],t),"")}function Jm(r){const t=[];for(const e of r){const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);const s=Zm[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}const jm=Cs({prefix:"🚀",name:"base256emoji",encode:Qm,decode:Jm}),ep=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:jm},Symbol.toStringTag,{value:"Module"})),Zc=Le({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),tp=Le({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Qc=Le({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),np=Le({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),rp=Object.freeze(Object.defineProperty({__proto__:null,base64:Zc,base64pad:tp,base64url:Qc,base64urlpad:np},Symbol.toStringTag,{value:"Module"})),sp=Le({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ip=Object.freeze(Object.defineProperty({__proto__:null,base8:sp},Symbol.toStringTag,{value:"Module"})),op=Cs({prefix:"\0",name:"identity",encode:r=>Yg(r),decode:r=>Gg(r)}),ap=Object.freeze(Object.defineProperty({__proto__:null,identity:op},Symbol.toStringTag,{value:"Module"}));new TextEncoder,new TextDecoder;const cp=20;function lp({name:r,code:t,encode:e,minDigestLength:n,maxDigestLength:s}){return new up(r,t,e,n,s)}class up{constructor(t,e,n,s,i){l(this,"name");l(this,"code");l(this,"encode");l(this,"minDigestLength");l(this,"maxDigestLength");this.name=t,this.code=e,this.encode=n,this.minDigestLength=s??cp,this.maxDigestLength=i}digest(t,e){if((e==null?void 0:e.truncate)!=null){if(e.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&e.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const n=this.encode(t);return n instanceof Uint8Array?Jc(n,this.code,e==null?void 0:e.truncate):n.then(s=>Jc(s,this.code,e==null?void 0:e.truncate))}else throw Error("Unknown type, must be binary type")}}function Jc(r,t,e){if(e!=null&&e!==r.byteLength){if(e>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e)}return Ds(t,r)}function dp(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}const jc=lp({name:"sha2-256",code:18,encode:dp("SHA-256")}),So={...ap,...Ym,...ip,...Km,...Hm,...mm,...ym,...om,...rp,...ep};function el(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}const tl=el("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),xo=el("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);const t=gt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),nl={utf8:tl,"utf-8":tl,hex:So.base16,latin1:xo,ascii:xo,binary:xo,...So};function Y(r,t="utf8"){const e=nl[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function J(r,t="utf8"){const e=nl[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}const hp=parseInt("11111",2),Ao=parseInt("10000000",2),fp=parseInt("01111111",2),rl={0:Ir,1:Ir,2:gp,3:yp,4:wp,5:pp,6:mp,16:Ir,22:Ir,48:Ir};function Rs(r,t={offset:0}){const e=r[t.offset]&hp;if(t.offset++,rl[e]!=null)return rl[e](r,t);throw new Error("No decoder for tag "+e)}function _r(r,t){let e=0;if((r[t.offset]&Ao)===Ao){const n=r[t.offset]&fp;let s="0x";t.offset++;for(let i=0;i<n;i++,t.offset++)s+=r[t.offset].toString(16).padStart(2,"0");e=parseInt(s,16)}else e=r[t.offset],t.offset++;return e}function Ir(r,t){_r(r,t);const e=[];for(;!(t.offset>=r.byteLength);){const n=Rs(r,t);if(n===null)break;e.push(n)}return e}function gp(r,t){const e=_r(r,t),n=t.offset,s=t.offset+e,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return t.offset+=e,Uint8Array.from(i)}function mp(r,t){const e=_r(r,t),n=t.offset+e,s=r[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const u=r[t.offset];if(t.offset++,c.push(u&127),u<128){c.reverse();let d=0;for(let h=0;h<c.length;h++)d+=c[h]<<h*7;a+=`.${d}`,c=[]}}return a}function pp(r,t){return t.offset++,null}function yp(r,t){const e=_r(r,t),n=r[t.offset];t.offset++;const s=r.subarray(t.offset,t.offset+e-1);if(t.offset+=e,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function wp(r,t){const e=_r(r,t),n=r.subarray(t.offset,t.offset+e);return t.offset+=e,n}function bp(r){let t=r.toString(16);t.length%2===1&&(t="0"+t);const e=new Q;for(let n=0;n<t.length;n+=2)e.append(Uint8Array.from([parseInt(`${t[n]}${t[n+1]}`,16)]));return e}function Co(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const t=bp(r.byteLength);return new Q(Uint8Array.from([t.byteLength|Ao]),t)}function _o(r){const t=new Q,e=128;return(r.subarray()[0]&e)===e&&t.append(Uint8Array.from([0])),t.append(r),new Q(Uint8Array.from([2]),Co(t),t)}function sl(r){const t=Uint8Array.from([0]),e=new Q(t,r);return new Q(Uint8Array.from([3]),Co(e),e)}function Tr(r,t=48){const e=new Q;for(const n of r)e.append(n);return new Q(Uint8Array.from([t]),Co(e),e)}async function Ep(r,t,e,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const vp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Sp=Uint8Array.from([6,5,43,129,4,0,34]),xp=Uint8Array.from([6,5,43,129,4,0,35]),Ap={ext:!0,kty:"EC",crv:"P-256"},Cp={ext:!0,kty:"EC",crv:"P-384"},_p={ext:!0,kty:"EC",crv:"P-521"},Io=32,To=48,Lo=66;function il(r){const t=Rs(r);return Ip(t)}function Ip(r){const t=r[1][1][0],e=1;let n,s;if(t.byteLength===Io*2+1)return n=J(t.subarray(e,e+Io),"base64url"),s=J(t.subarray(e+Io),"base64url"),new Do({...Ap,key_ops:["verify"],x:n,y:s});if(t.byteLength===To*2+1)return n=J(t.subarray(e,e+To),"base64url"),s=J(t.subarray(e+To),"base64url"),new Do({...Cp,key_ops:["verify"],x:n,y:s});if(t.byteLength===Lo*2+1)return n=J(t.subarray(e,e+Lo),"base64url"),s=J(t.subarray(e+Lo),"base64url"),new Do({..._p,key_ops:["verify"],x:n,y:s});throw new G(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Tp(r){return Tr([_o(Uint8Array.from([1])),Tr([Lp(r.crv)],160),Tr([sl(new Q(Uint8Array.from([4]),Y(r.x??"","base64url"),Y(r.y??"","base64url")))],161)]).subarray()}function Lp(r){if(r==="P-256")return vp;if(r==="P-384")return Sp;if(r==="P-521")return xp;throw new G(`Invalid curve ${r}`)}class Do{constructor(t){l(this,"type","ECDSA");l(this,"jwk");l(this,"_raw");this.jwk=t}get raw(){return this._raw==null&&(this._raw=Tp(this.jwk)),this._raw}toMultihash(){return Cr.digest(It(this))}toCID(){return pe.createV1(114,this.toMultihash())}toString(){return De.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}async verify(t,e,n){return Ep(this.jwk,e,t,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ks(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Bt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function X(r,t,e=""){const n=ks(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Ms(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Bt(r.outputLen),Bt(r.blockLen)}function Ns(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Dp(r,t){X(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function nn(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function Po(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function mt(r,t){return r<<32-t|r>>>t}const ol=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Pp=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Lr(r){if(X(r),ol)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=Pp[r[e]];return t}const xt={_0:48,_9:57,A:65,F:70,a:97,f:102};function al(r){if(r>=xt._0&&r<=xt._9)return r-xt._0;if(r>=xt.A&&r<=xt.F)return r-(xt.A-10);if(r>=xt.a&&r<=xt.f)return r-(xt.a-10)}function Dr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(ol)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=al(r.charCodeAt(i)),a=al(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function pt(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];X(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function cl(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function Pr(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(t==null?void 0:t.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const ll=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Rp(r,t,e){return r&t^~r&e}function kp(r,t,e){return r&t^r&e^t&e}class ul{constructor(t,e,n,s){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=Po(this.buffer)}update(t){Ns(this),X(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Po(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ns(this),Dp(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,nn(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)e[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=Po(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,d[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const $t=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Oe=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Os=BigInt(2**32-1),dl=BigInt(32);function Mp(r,t=!1){return t?{h:Number(r&Os),l:Number(r>>dl&Os)}:{h:Number(r>>dl&Os)|0,l:Number(r&Os)|0}}function Np(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=Mp(r[i],t);[n[i],s[i]]=[o,a]}return[n,s]}const hl=(r,t,e)=>r>>>e,fl=(r,t,e)=>r<<32-e|t>>>e,In=(r,t,e)=>r>>>e|t<<32-e,Tn=(r,t,e)=>r<<32-e|t>>>e,Fs=(r,t,e)=>r<<64-e|t>>>e-32,Bs=(r,t,e)=>r>>>e-32|t<<64-e;function At(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Op=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Fp=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Bp=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),$p=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Up=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),zp=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,qp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ut=new Uint32Array(64);class Kp extends ul{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)Ut[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=Ut[h-15],p=Ut[h-2],g=mt(f,7)^mt(f,18)^f>>>3,y=mt(p,17)^mt(p,19)^p>>>10;Ut[h]=y+Ut[h-7]+g+Ut[h-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let h=0;h<64;h++){const f=mt(a,6)^mt(a,11)^mt(a,25),p=d+f+Rp(a,c,u)+qp[h]+Ut[h]|0,y=(mt(n,2)^mt(n,13)^mt(n,22))+kp(n,s,i)|0;d=u,u=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){nn(Ut)}destroy(){this.set(0,0,0,0,0,0,0,0),nn(this.buffer)}}class Vp extends Kp{constructor(){super(32);l(this,"A",$t[0]|0);l(this,"B",$t[1]|0);l(this,"C",$t[2]|0);l(this,"D",$t[3]|0);l(this,"E",$t[4]|0);l(this,"F",$t[5]|0);l(this,"G",$t[6]|0);l(this,"H",$t[7]|0)}}const gl=Np(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Wp=gl[0],Hp=gl[1],zt=new Uint32Array(80),qt=new Uint32Array(80);class Gp extends ul{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:d,Fh:h,Fl:f,Gh:p,Gl:g,Hh:y,Hl:m}=this;return[t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m]}set(t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=d|0,this.Fh=h|0,this.Fl=f|0,this.Gh=p|0,this.Gl=g|0,this.Hh=y|0,this.Hl=m|0}process(t,e){for(let E=0;E<16;E++,e+=4)zt[E]=t.getUint32(e),qt[E]=t.getUint32(e+=4);for(let E=16;E<80;E++){const L=zt[E-15]|0,x=qt[E-15]|0,_=In(L,x,1)^In(L,x,8)^hl(L,x,7),O=Tn(L,x,1)^Tn(L,x,8)^fl(L,x,7),T=zt[E-2]|0,I=qt[E-2]|0,$=In(T,I,19)^Fs(T,I,61)^hl(T,I,6),U=Tn(T,I,19)^Bs(T,I,61)^fl(T,I,6),M=Bp(O,U,qt[E-7],qt[E-16]),N=$p(M,_,$,zt[E-7],zt[E-16]);zt[E]=N|0,qt[E]=M|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:d,Eh:h,El:f,Fh:p,Fl:g,Gh:y,Gl:m,Hh:S,Hl:v}=this;for(let E=0;E<80;E++){const L=In(h,f,14)^In(h,f,18)^Fs(h,f,41),x=Tn(h,f,14)^Tn(h,f,18)^Bs(h,f,41),_=h&p^~h&y,O=f&g^~f&m,T=Up(v,x,O,Hp[E],qt[E]),I=zp(T,S,L,_,Wp[E],zt[E]),$=T|0,U=In(n,s,28)^Fs(n,s,34)^Fs(n,s,39),M=Tn(n,s,28)^Bs(n,s,34)^Bs(n,s,39),N=n&i^n&a^i&a,w=s&o^s&c^o&c;S=y|0,v=m|0,y=p|0,m=g|0,p=h|0,g=f|0,{h,l:f}=At(u|0,d|0,I|0,$|0),u=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=Op($,M,w);n=Fp(b,I,U,N),s=b|0}({h:n,l:s}=At(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=At(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=At(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:d}=At(this.Dh|0,this.Dl|0,u|0,d|0),{h,l:f}=At(this.Eh|0,this.El|0,h|0,f|0),{h:p,l:g}=At(this.Fh|0,this.Fl|0,p|0,g|0),{h:y,l:m}=At(this.Gh|0,this.Gl|0,y|0,m|0),{h:S,l:v}=At(this.Hh|0,this.Hl|0,S|0,v|0),this.set(n,s,i,o,a,c,u,d,h,f,p,g,y,m,S,v)}roundClean(){nn(zt,qt)}destroy(){nn(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Yp extends Gp{constructor(){super(64);l(this,"Ah",Oe[0]|0);l(this,"Al",Oe[1]|0);l(this,"Bh",Oe[2]|0);l(this,"Bl",Oe[3]|0);l(this,"Ch",Oe[4]|0);l(this,"Cl",Oe[5]|0);l(this,"Dh",Oe[6]|0);l(this,"Dl",Oe[7]|0);l(this,"Eh",Oe[8]|0);l(this,"El",Oe[9]|0);l(this,"Fh",Oe[10]|0);l(this,"Fl",Oe[11]|0);l(this,"Gh",Oe[12]|0);l(this,"Gl",Oe[13]|0);l(this,"Hh",Oe[14]|0);l(this,"Hl",Oe[15]|0)}}const Rr=cl(()=>new Vp,ll(1)),Xp=cl(()=>new Yp,ll(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ro=BigInt(0),ko=BigInt(1);function rn(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function ml(r){if(typeof r=="bigint"){if(!zs(r))throw new Error("positive bigint expected, got "+r)}else Bt(r);return r}function $s(r){const t=ml(r).toString(16);return t.length&1?"0"+t:t}function pl(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ro:BigInt("0x"+r)}function Us(r){return pl(Lr(r))}function sn(r){return pl(Lr(kr(X(r)).reverse()))}function Mo(r,t){Bt(t),r=ml(r);const e=Dr(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function No(r,t){return Mo(r,t).reverse()}function kr(r){return Uint8Array.from(r)}const zs=r=>typeof r=="bigint"&&Ro<=r;function Zp(r,t,e){return zs(r)&&zs(t)&&zs(e)&&t<=r&&r<e}function Mr(r,t,e,n){if(!Zp(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Qp(r){let t;for(t=0;r>Ro;r>>=ko,t+=1);return t}const Oo=r=>(ko<<BigInt(r))-ko;function Jp(r,t,e){if(Bt(r,"hashLen"),Bt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=m=>new Uint8Array(m),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),d=0;const h=()=>{c.fill(1),u.fill(0),d=0},f=(...m)=>e(u,pt(c,...m)),p=(m=s)=>{u=f(i,m),c=f(),m.length!==0&&(u=f(o,m),c=f())},g=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const S=[];for(;m<t;){c=f();const v=c.slice();S.push(v),m+=c.length}return pt(...S)};return(m,S)=>{h(),p(m);let v;for(;!(v=S(g()));)p();return h(),v}}function Ln(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(t,!1),s(e,!0)}function qs(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),Pe=BigInt(1),on=BigInt(2),yl=BigInt(3),wl=BigInt(4),bl=BigInt(5),jp=BigInt(7),El=BigInt(8),ey=BigInt(9),vl=BigInt(16);function Se(r,t){const e=r%t;return e>=Xe?e:t+e}function be(r,t,e){let n=r;for(;t-- >Xe;)n*=n,n%=e;return n}function Sl(r,t){if(r===Xe)throw new Error("invert: expected non-zero number");if(t<=Xe)throw new Error("invert: expected positive modulus, got "+t);let e=Se(r,t),n=t,s=Xe,i=Pe;for(;e!==Xe;){const a=n/e,c=n%e,u=s-i*a;n=e,e=c,s=i,i=u}if(n!==Pe)throw new Error("invert: does not exist");return Se(s,t)}function Fo(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function xl(r,t){const e=(r.ORDER+Pe)/wl,n=r.pow(t,e);return Fo(r,n,t),n}function ty(r,t){const e=(r.ORDER-bl)/El,n=r.mul(t,on),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,on),s),a=r.mul(i,r.sub(o,r.ONE));return Fo(r,a,t),a}function ny(r){const t=Ks(r),e=Al(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+jp)/vl;return(a,c)=>{let u=a.pow(c,o),d=a.mul(u,n);const h=a.mul(u,s),f=a.mul(u,i),p=a.eql(a.sqr(d),c),g=a.eql(a.sqr(h),c);u=a.cmov(u,d,p),d=a.cmov(f,h,g);const y=a.eql(a.sqr(d),c),m=a.cmov(u,d,y);return Fo(a,m,c),m}}function Al(r){if(r<yl)throw new Error("sqrt is not defined for small field");let t=r-Pe,e=0;for(;t%on===Xe;)t/=on,e++;let n=on;const s=Ks(r);for(;_l(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return xl;let i=s.pow(n,t);const o=(t+Pe)/on;return function(c,u){if(c.is0(u))return u;if(_l(c,u)!==1)throw new Error("Cannot find square root");let d=e,h=c.mul(c.ONE,i),f=c.pow(u,t),p=c.pow(u,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,y=c.sqr(f);for(;!c.eql(y,c.ONE);)if(g++,y=c.sqr(y),g===d)throw new Error("Cannot find square root");const m=Pe<<BigInt(d-g-1),S=c.pow(h,m);d=g,h=c.sqr(S),f=c.mul(f,h),p=c.mul(p,S)}return p}}function ry(r){return r%wl===yl?xl:r%El===bl?ty:r%vl===ey?ny(r):Al(r)}const sy=(r,t)=>(Se(r,t)&Pe)===Pe,iy=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function oy(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=iy.reduce((n,s)=>(n[s]="function",n),t);return Ln(r,e),r}function ay(r,t,e){if(e<Xe)throw new Error("invalid exponent, negatives unsupported");if(e===Xe)return r.ONE;if(e===Pe)return t;let n=r.ONE,s=t;for(;e>Xe;)e&Pe&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Pe;return n}function Cl(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return t.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function _l(r,t){const e=(r.ORDER-Pe)/on,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function cy(r,t){t!==void 0&&Bt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ly{constructor(t,e={}){l(this,"ORDER");l(this,"BITS");l(this,"BYTES");l(this,"isLE");l(this,"ZERO",Xe);l(this,"ONE",Pe);l(this,"_lengths");l(this,"_sqrt");l(this,"_mod");var o;if(t<=Xe)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=(o=e.allowedLengths)==null?void 0:o.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=cy(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return Se(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return Xe<=t&&t<this.ORDER}is0(t){return t===Xe}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&Pe)===Pe}neg(t){return Se(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return Se(t*t,this.ORDER)}add(t,e){return Se(t+e,this.ORDER)}sub(t,e){return Se(t-e,this.ORDER)}mul(t,e){return Se(t*e,this.ORDER)}pow(t,e){return ay(this,t,e)}div(t,e){return Se(t*Sl(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return Sl(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=ry(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?No(t,this.BYTES):Mo(t,this.BYTES)}fromBytes(t,e=!1){X(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?sn(t):Us(t);if(a&&(c=Se(c,o)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return Cl(this,t)}cmov(t,e,n){return n?e:t}}function Ks(r,t={}){return new ly(r,t)}function Il(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function Tl(r){const t=Il(r);return t+Math.ceil(t/2)}function uy(r,t,e=!1){X(r);const n=r.length,s=Il(t),i=Tl(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?sn(r):Us(r),a=Se(o,t-Pe)+Pe;return e?No(a,s):Mo(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dn=BigInt(0),an=BigInt(1);function Vs(r,t){const e=t.negate();return r?e:t}function Nr(r,t){const e=Cl(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function Ll(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function Bo(r,t){Ll(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=Oo(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function Dl(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=an);const u=t*n,d=u+Math.abs(a)-1,h=a===0,f=a<0,p=t%2!==0;return{nextN:c,offset:d,isZero:h,isNeg:f,isNegF:p,offsetF:u}}const $o=new WeakMap,Pl=new WeakMap;function Uo(r){return Pl.get(r)||1}function Rl(r){if(r!==Dn)throw new Error("invalid wNAF")}class kl{constructor(t,e){l(this,"BASE");l(this,"ZERO");l(this,"Fn");l(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Dn;)e&an&&(n=n.add(s)),s=s.double(),e>>=an;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=Bo(e,this.bits),i=[];let o=t,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=Bo(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:f,offsetF:p}=Dl(n,a,o);n=c,d?i=i.add(Vs(f,e[p])):s=s.add(Vs(h,e[u]))}return Rl(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=Bo(t,this.bits);for(let o=0;o<i.windows&&n!==Dn;o++){const{nextN:a,offset:c,isZero:u,isNeg:d}=Dl(n,o,i);if(n=a,!u){const h=e[c];s=s.add(d?h.negate():h)}}return Rl(n),s}getPrecomputes(t,e,n){let s=$o.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),$o.set(e,s))),s}cached(t,e,n){const s=Uo(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=Uo(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){Ll(e,this.bits),Pl.set(t,e),$o.delete(t)}hasCache(t){return Uo(t)!==1}}function dy(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>Dn||n>Dn;)e&an&&(i=i.add(s)),n&an&&(o=o.add(s)),s=s.double(),e>>=an,n>>=an;return{p1:i,p2:o}}function Ml(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return oy(t),t}else return Ks(r,{isLE:e})}function Nl(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>Dn))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Ml(t.p,e.Fp,n),i=Ml(t.n,e.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function zo(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Kt=BigInt(0),Te=BigInt(1),qo=BigInt(2),hy=BigInt(8);function fy(r,t,e,n){const s=r.sqr(e),i=r.sqr(n),o=r.add(r.mul(t.a,s),i),a=r.add(r.ONE,r.mul(t.d,r.mul(s,i)));return r.eql(o,a)}function gy(r,t={}){const e=Nl("edwards",r,t,t.FpFnLE),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o}=i;Ln(t,{},{uvRatio:"function"});const a=qo<<BigInt(s.BYTES*8)-Te,c=S=>n.create(S),u=t.uvRatio||((S,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(S,v))}}catch{return{isValid:!1,value:Kt}}});if(!fy(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(S,v,E=!1){const L=E?Te:Kt;return Mr("coordinate "+S,v,L,a),v}function h(S){if(!(S instanceof g))throw new Error("EdwardsPoint expected")}const f=qs((S,v)=>{const{X:E,Y:L,Z:x}=S,_=S.is0();v==null&&(v=_?hy:n.inv(x));const O=c(E*v),T=c(L*v),I=n.mul(x,v);if(_)return{x:Kt,y:Te};if(I!==Te)throw new Error("invZ was invalid");return{x:O,y:T}}),p=qs(S=>{const{a:v,d:E}=i;if(S.is0())throw new Error("bad point: ZERO");const{X:L,Y:x,Z:_,T:O}=S,T=c(L*L),I=c(x*x),$=c(_*_),U=c($*$),M=c(T*v),N=c($*c(M+I)),w=c(U+c(E*c(T*I)));if(N!==w)throw new Error("bad point: equation left != right (1)");const b=c(L*x),C=c(_*O);if(b!==C)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(v,E,L,x){l(this,"X");l(this,"Y");l(this,"Z");l(this,"T");this.X=d("x",v),this.Y=d("y",E),this.Z=d("z",L,!0),this.T=d("t",x),Object.freeze(this)}static CURVE(){return i}static fromAffine(v){if(v instanceof m)throw new Error("extended point not allowed");const{x:E,y:L}=v||{};return d("x",E),d("y",L),new m(E,L,Te,c(E*L))}static fromBytes(v,E=!1){const L=n.BYTES,{a:x,d:_}=i;v=kr(X(v,L,"point")),rn(E,"zip215");const O=kr(v),T=v[L-1];O[L-1]=T&-129;const I=sn(O),$=E?a:n.ORDER;Mr("point.y",I,Kt,$);const U=c(I*I),M=c(U-Te),N=c(_*U-x);let{isValid:w,value:b}=u(M,N);if(!w)throw new Error("bad point: invalid y coordinate");const C=(b&Te)===Te,P=(T&128)!==0;if(!E&&b===Kt&&P)throw new Error("bad point: x=0 and x_0=1");return P!==C&&(b=c(-b)),m.fromAffine({x:b,y:I})}static fromHex(v,E=!1){return m.fromBytes(Dr(v),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,E=!0){return y.createCache(this,v),E||this.multiply(qo),this}assertValidity(){p(this)}equals(v){h(v);const{X:E,Y:L,Z:x}=this,{X:_,Y:O,Z:T}=v,I=c(E*T),$=c(_*x),U=c(L*T),M=c(O*x);return I===$&&U===M}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=i,{X:E,Y:L,Z:x}=this,_=c(E*E),O=c(L*L),T=c(qo*c(x*x)),I=c(v*_),$=E+L,U=c(c($*$)-_-O),M=I+O,N=M-T,w=I-O,b=c(U*N),C=c(M*w),P=c(U*w),k=c(N*M);return new m(b,C,k,P)}add(v){h(v);const{a:E,d:L}=i,{X:x,Y:_,Z:O,T}=this,{X:I,Y:$,Z:U,T:M}=v,N=c(x*I),w=c(_*$),b=c(T*L*M),C=c(O*U),P=c((x+_)*(I+$)-N-w),k=C-b,A=C+b,F=c(w-E*N),R=c(P*k),B=c(A*F),K=c(P*F),re=c(k*A);return new m(R,B,re,K)}subtract(v){return this.add(v.negate())}multiply(v){if(!s.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:L}=y.cached(this,v,x=>Nr(m,x));return Nr(m,[E,L])[0]}multiplyUnsafe(v,E=m.ZERO){if(!s.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===Kt?m.ZERO:this.is0()||v===Te?this:y.unsafe(this,v,L=>Nr(m,L),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(v){return f(this,v)}clearCofactor(){return o===Te?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:E}=this.toAffine(),L=n.toBytes(E);return L[L.length-1]|=v&Te?128:0,L}toHex(){return Lr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(m,"BASE",new m(i.Gx,i.Gy,Te,c(i.Gx*i.Gy))),l(m,"ZERO",new m(Kt,Te,Te,Kt)),l(m,"Fp",n),l(m,"Fn",s);let g=m;const y=new kl(g,s.BITS);return g.BASE.precompute(8),g}function my(r,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');Ln(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=e,{BASE:s,Fp:i,Fn:o}=r,a=e.randomBytes||Pr,c=e.adjustScalarBytes||(T=>T),u=e.domain||((T,I,$)=>{if(rn($,"phflag"),I.length||$)throw new Error("Contexts/pre-hash are not supported");return T});function d(T){return o.create(sn(T))}function h(T){const I=E.secretKey;X(T,E.secretKey,"secretKey");const $=X(t(T),2*I,"hashedSecretKey"),U=c($.slice(0,I)),M=$.slice(I,2*I),N=d(U);return{head:U,prefix:M,scalar:N}}function f(T){const{head:I,prefix:$,scalar:U}=h(T),M=s.multiply(U),N=M.toBytes();return{head:I,prefix:$,scalar:U,point:M,pointBytes:N}}function p(T){return f(T).pointBytes}function g(T=Uint8Array.of(),...I){const $=pt(...I);return d(t(u($,X(T,void 0,"context"),!!n)))}function y(T,I,$={}){T=X(T,void 0,"message"),n&&(T=n(T));const{prefix:U,scalar:M,pointBytes:N}=f(I),w=g($.context,U,T),b=s.multiply(w).toBytes(),C=g($.context,b,N,T),P=o.create(w+C*M);if(!o.isValid(P))throw new Error("sign failed: invalid s");const k=pt(b,o.toBytes(P));return X(k,E.signature,"result")}const m={zip215:!0};function S(T,I,$,U=m){const{context:M,zip215:N}=U,w=E.signature;T=X(T,w,"signature"),I=X(I,void 0,"message"),$=X($,E.publicKey,"publicKey"),N!==void 0&&rn(N,"zip215"),n&&(I=n(I));const b=w/2,C=T.subarray(0,b),P=sn(T.subarray(b,w));let k,A,F;try{k=r.fromBytes($,N),A=r.fromBytes(C,N),F=s.multiplyUnsafe(P)}catch{return!1}if(!N&&k.isSmallOrder())return!1;const R=g(M,A.toBytes(),k.toBytes(),I);return A.add(k.multiplyUnsafe(R)).subtract(F).clearCofactor().is0()}const v=i.BYTES,E={secretKey:v,publicKey:v,signature:2*v,seed:v};function L(T=a(E.seed)){return X(T,E.seed,"seed")}function x(T){return ks(T)&&T.length===o.BYTES}function _(T,I){try{return!!r.fromBytes(T,I)}catch{return!1}}const O={getExtendedPublicKey:f,randomSecretKey:L,isValidSecretKey:x,isValidPublicKey:_,toMontgomery(T){const{y:I}=r.fromBytes(T),$=E.publicKey,U=$===32;if(!U&&$!==57)throw new Error("only defined for 25519 and 448");const M=U?i.div(Te+I,Te-I):i.div(I-Te,I+Te);return i.toBytes(M)},toMontgomerySecret(T){const I=E.secretKey;X(T,I);const $=t(T.subarray(0,I));return c($).subarray(0,I)}};return Object.freeze({keygen:zo(L,p),getPublicKey:p,sign:y,verify:S,utils:O,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Or=BigInt(0),Pn=BigInt(1),Ws=BigInt(2);function py(r){return Ln(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function yy(r){const t=py(r),{P:e,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=t,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||Pr,u=a?255:448,d=a?32:56,h=BigInt(a?9:5),f=BigInt(a?121665:39081),p=a?Ws**BigInt(254):Ws**BigInt(447),g=a?BigInt(8)*Ws**BigInt(251)-Pn:BigInt(4)*Ws**BigInt(445)-Pn,y=p+g+Pn,m=w=>Se(w,e),S=v(h);function v(w){return No(m(w),d)}function E(w){const b=kr(X(w,d,"uCoordinate"));return a&&(b[31]&=127),m(sn(b))}function L(w){return sn(s(kr(X(w,d,"scalar"))))}function x(w,b){const C=$(E(b),L(w));if(C===Or)throw new Error("invalid private or public key received");return v(C)}function _(w){return x(w,S)}const O=_,T=x;function I(w,b,C){const P=m(w*(b-C));return b=m(b-P),C=m(C+P),{x_2:b,x_3:C}}function $(w,b){Mr("u",w,Or,e),Mr("scalar",b,p,y);const C=b,P=w;let k=Pn,A=Or,F=w,R=Pn,B=Or;for(let re=BigInt(u-1);re>=Or;re--){const ee=C>>re&Pn;B^=ee,{x_2:k,x_3:F}=I(B,k,F),{x_2:A,x_3:R}=I(B,A,R),B=ee;const W=k+A,le=m(W*W),me=k-A,Ee=m(me*me),we=le-Ee,Ne=F+R,ji=F-R,hs=m(ji*W),Tg=m(Ne*me),Lg=hs+Tg,Dg=hs-Tg;F=m(Lg*Lg),R=m(P*m(Dg*Dg)),k=m(le*Ee),A=m(we*(le+m(f*we)))}({x_2:k,x_3:F}=I(B,k,F)),{x_2:A,x_3:R}=I(B,A,R);const K=i(A);return m(k*K)}const U={secretKey:d,publicKey:d,seed:d},M=(w=c(d))=>(X(w,U.seed,"seed"),w),N={randomSecretKey:M};return Object.freeze({keygen:zo(M,O),getSharedSecret:T,getPublicKey:O,scalarMult:x,scalarMultBase:_,utils:N,GuBytes:S.slice(),lengths:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wy=BigInt(1),Ol=BigInt(2),by=BigInt(3),Ey=BigInt(5),vy=BigInt(8),Hs=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Sy={p:Hs,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:vy,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Fl(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=Hs,a=r*r%i*r%i,c=be(a,Ol,i)*a%i,u=be(c,wy,i)*r%i,d=be(u,Ey,i)*u%i,h=be(d,t,i)*d%i,f=be(h,e,i)*h%i,p=be(f,n,i)*f%i,g=be(p,s,i)*p%i,y=be(g,s,i)*p%i,m=be(y,t,i)*d%i;return{pow_p_5_8:be(m,Ol,i)*r%i,b2:a}}function Bl(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const $l=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function xy(r,t){const e=Hs,n=Se(t*t*t,e),s=Se(n*n*t,e),i=Fl(r*s).pow_p_5_8;let o=Se(r*n*i,e);const a=Se(t*o*o,e),c=o,u=Se(o*$l,e),d=a===r,h=a===Se(-r,e),f=a===Se(-r*$l,e);return d&&(o=c),(h||f)&&(o=u),sy(o,e)&&(o=Se(-o,e)),{isValid:d||h,value:o}}const Ay=gy(Sy,{uvRatio:xy});function Cy(r){return my(Ay,Xp,Object.assign({adjustScalarBytes:Bl},r))}const Gs=Cy({}),Ys=(()=>{const r=Hs;return yy({P:r,type:"x25519",powPminus2:t=>{const{pow_p_5_8:e,b2:n}=Fl(t);return Se(be(e,by,r)*n,r)},adjustScalarBytes:Bl})})();class Ul extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class _y extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const cn={get(r=globalThis){const t=r.crypto;if((t==null?void 0:t.subtle)==null)throw new _y("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},zl=32,Ko=64,Vo=32;let Rn;const ql=(async()=>{try{return await cn.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Iy(){const r=Gs.utils.randomSecretKey(),t=Gs.getPublicKey(r);return{privateKey:My(r,t),publicKey:t}}async function Ty(r,t){let e;r.length===Ko?e=r.subarray(0,32):e=r;const n={crv:"Ed25519",kty:"OKP",x:J(r.subarray(32),"base64url"),d:J(e,"base64url"),ext:!0,key_ops:["sign"]},s=await cn.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await cn.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Ly(r,t){const e=r.subarray(0,Vo);return Gs.sign(t instanceof Uint8Array?t:t.subarray(),e)}async function Dy(r,t){return Rn==null&&(Rn=await ql),Rn?Ty(r,t):Ly(r,t)}async function Py(r,t,e){if(r.buffer instanceof ArrayBuffer){const n=await cn.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await cn.get().subtle.verify({name:"Ed25519"},n,t,e instanceof Uint8Array?e:e.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Ry(r,t,e){return Gs.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}async function ky(r,t,e){return Rn==null&&(Rn=await ql),Rn?Py(r,t,e):Ry(r,t,e)}function My(r,t){const e=new Uint8Array(Ko);for(let n=0;n<Vo;n++)e[n]=r[n],e[Vo+n]=t[n];return e}function Wo(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Kl{constructor(t){l(this,"type","Ed25519");l(this,"raw");this.raw=Ho(t,zl)}toMultihash(){return Cr.digest(It(this))}toCID(){return pe.createV1(114,this.toMultihash())}toString(){return De.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=ky(this.raw,e,t);return Wo(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class Ny{constructor(t,e){l(this,"type","Ed25519");l(this,"raw");l(this,"publicKey");this.raw=Ho(t,Ko),this.publicKey=new Kl(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}sign(t,e){var s,i;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const n=Dy(this.raw,t);return Wo(n)?n.then(o=>{var a;return(a=e==null?void 0:e.signal)==null||a.throwIfAborted(),o}):((i=e==null?void 0:e.signal)==null||i.throwIfAborted(),n)}}function Vl(r){return r=Ho(r,zl),new Kl(r)}async function Oy(){const{privateKey:r,publicKey:t}=Iy();return new Ny(r,t)}function Ho(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new G(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}const Fy=Math.pow(2,7),By=Math.pow(2,14),$y=Math.pow(2,21),Go=Math.pow(2,28),Yo=Math.pow(2,35),Xo=Math.pow(2,42),Zo=Math.pow(2,49),se=128,Fe=127;function Re(r){if(r<Fy)return 1;if(r<By)return 2;if(r<$y)return 3;if(r<Go)return 4;if(r<Yo)return 5;if(r<Xo)return 6;if(r<Zo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Xs(r,t,e=0){switch(Re(r)){case 8:t[e++]=r&255|se,r/=128;case 7:t[e++]=r&255|se,r/=128;case 6:t[e++]=r&255|se,r/=128;case 5:t[e++]=r&255|se,r/=128;case 4:t[e++]=r&255|se,r>>>=7;case 3:t[e++]=r&255|se,r>>>=7;case 2:t[e++]=r&255|se,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Uy(r,t,e=0){switch(Re(r)){case 8:t.set(e++,r&255|se),r/=128;case 7:t.set(e++,r&255|se),r/=128;case 6:t.set(e++,r&255|se),r/=128;case 5:t.set(e++,r&255|se),r/=128;case 4:t.set(e++,r&255|se),r>>>=7;case 3:t.set(e++,r&255|se),r>>>=7;case 2:t.set(e++,r&255|se),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Wl(r,t){let e=r[t],n=0;if(n+=e&Fe,e<se||(e=r[t+1],n+=(e&Fe)<<7,e<se)||(e=r[t+2],n+=(e&Fe)<<14,e<se)||(e=r[t+3],n+=(e&Fe)<<21,e<se)||(e=r[t+4],n+=(e&Fe)*Go,e<se)||(e=r[t+5],n+=(e&Fe)*Yo,e<se)||(e=r[t+6],n+=(e&Fe)*Xo,e<se)||(e=r[t+7],n+=(e&Fe)*Zo,e<se))return n;throw new RangeError("Could not decode varint")}function zy(r,t){let e=r.get(t),n=0;if(n+=e&Fe,e<se||(e=r.get(t+1),n+=(e&Fe)<<7,e<se)||(e=r.get(t+2),n+=(e&Fe)<<14,e<se)||(e=r.get(t+3),n+=(e&Fe)<<21,e<se)||(e=r.get(t+4),n+=(e&Fe)*Go,e<se)||(e=r.get(t+5),n+=(e&Fe)*Yo,e<se)||(e=r.get(t+6),n+=(e&Fe)*Xo,e<se)||(e=r.get(t+7),n+=(e&Fe)*Zo,e<se))return n;throw new RangeError("Could not decode varint")}function Fr(r,t,e=0){return t==null&&(t=gt(Re(r))),t instanceof Uint8Array?Xs(r,t,e):Uy(r,t,e)}function Br(r,t=0){return r instanceof Uint8Array?Wl(r,t):zy(r,t)}const Qo=new Float32Array([-0]),Vt=new Uint8Array(Qo.buffer);function qy(r,t,e){Qo[0]=r,t[e]=Vt[0],t[e+1]=Vt[1],t[e+2]=Vt[2],t[e+3]=Vt[3]}function Ky(r,t){return Vt[0]=r[t],Vt[1]=r[t+1],Vt[2]=r[t+2],Vt[3]=r[t+3],Qo[0]}const Jo=new Float64Array([-0]),Be=new Uint8Array(Jo.buffer);function Vy(r,t,e){Jo[0]=r,t[e]=Be[0],t[e+1]=Be[1],t[e+2]=Be[2],t[e+3]=Be[3],t[e+4]=Be[4],t[e+5]=Be[5],t[e+6]=Be[6],t[e+7]=Be[7]}function Wy(r,t){return Be[0]=r[t],Be[1]=r[t+1],Be[2]=r[t+2],Be[3]=r[t+3],Be[4]=r[t+4],Be[5]=r[t+5],Be[6]=r[t+6],Be[7]=r[t+7],Jo[0]}const Hy=BigInt(Number.MAX_SAFE_INTEGER),Gy=BigInt(Number.MIN_SAFE_INTEGER);class $e{constructor(t,e){l(this,"lo");l(this,"hi");this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return ln;if(t<Hy&&t>Gy)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Hl&&(s=0n,++n>Hl&&(n=0n))),new $e(Number(s),Number(n))}static fromNumber(t){if(t===0)return ln;const e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new $e(n,s)}static from(t){return typeof t=="number"?$e.fromNumber(t):typeof t=="bigint"?$e.fromBigInt(t):typeof t=="string"?$e.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new $e(t.low>>>0,t.high>>>0):ln}}const ln=new $e(0,0);ln.toBigInt=function(){return 0n},ln.zzEncode=ln.zzDecode=function(){return this},ln.length=function(){return 1};const Hl=4294967296n;function Yy(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Xy(r,t,e){if(e-t<1)return"";let s;const i=[];let o=0,a;for(;t<e;)a=r[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Gl(r,t,e){const n=e;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function ot(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function Zs(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}class Zy{constructor(t){l(this,"buf");l(this,"pos");l(this,"len");l(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,ot(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw ot(this,4);return Zs(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw ot(this,4);return Zs(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw ot(this,4);const t=Ky(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw ot(this,4);const t=Wy(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw ot(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){const t=this.bytes();return Xy(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw ot(this,t);this.pos+=t}else do if(this.pos>=this.len)throw ot(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new $e(0,0);let e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw ot(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw ot(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw ot(this,8);const t=Zs(this.buf,this.pos+=4),e=Zs(this.buf,this.pos+=4);return new $e(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=Wl(this.buf,this.pos);return this.pos+=Re(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Qy(r){return new Zy(r instanceof Uint8Array?r:r.subarray())}function xe(r,t,e){const n=Qy(r);return t.decode(n,void 0,e)}function Jy(r){let n,s=8192;return function(o){if(o<1||o>4096)return gt(o);s+o>8192&&(n=gt(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class $r{constructor(t,e,n){l(this,"fn");l(this,"len");l(this,"next");l(this,"val");this.fn=t,this.len=e,this.next=void 0,this.val=n}}function jo(){}class jy{constructor(t){l(this,"head");l(this,"tail");l(this,"len");l(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const ew=Jy();function tw(r){return globalThis.Buffer!=null?gt(r):ew(r)}class ea{constructor(){l(this,"len");l(this,"head");l(this,"tail");l(this,"states");this.len=0,this.head=new $r(jo,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new $r(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new rw((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Qs,10,$e.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=$e.fromBigInt(t);return this._push(Qs,e.length(),e)}uint64Number(t){return this._push(Xs,Re(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=$e.fromBigInt(t).zzEncode();return this._push(Qs,e.length(),e)}sint64Number(t){const e=$e.fromNumber(t).zzEncode();return this._push(Qs,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(ta,1,t?1:0)}fixed32(t){return this._push(Ur,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=$e.fromBigInt(t);return this._push(Ur,4,e.lo)._push(Ur,4,e.hi)}fixed64Number(t){const e=$e.fromNumber(t);return this._push(Ur,4,e.lo)._push(Ur,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(qy,4,t)}double(t){return this._push(Vy,8,t)}bytes(t){const e=t.length>>>0;return e===0?this._push(ta,1,0):this.uint32(e)._push(sw,e,t)}string(t){const e=Yy(t);return e!==0?this.uint32(e)._push(Gl,e,t):this._push(ta,1,0)}fork(){return this.states=new jy(this),this.head=this.tail=new $r(jo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new $r(jo,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next;const e=tw(this.len);let n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}}function ta(r,t,e){t[e]=r&255}function nw(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}class rw extends $r{constructor(e,n){super(nw,e,n);l(this,"next");this.next=void 0}}function Qs(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Ur(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function sw(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(ea.prototype.bytes=function(r){const t=r.length>>>0;return this.uint32(t),t>0&&this._push(iw,t,r),this},ea.prototype.string=function(r){const t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(ow,t,r),this});function iw(r,t,e){t.set(r,e)}function ow(r,t,e){r.length<40?Gl(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Y(r),e)}function aw(){return new ea}function Ae(r,t){const e=aw();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Js;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Js||(Js={}));function Yl(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function kn(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const e=function(i,o){const a=t(i);o.int32(a)},n=function(i){const o=i.int32();return t(o)};return Yl("enum",Js.VARINT,e,n)}function Ce(r,t){return Yl("message",Js.LENGTH_DELIMITED,r,t)}class Ct extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_LENGTH");l(this,"name","MaxLengthError")}}class Xl extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_SIZE");l(this,"name","MaxSizeError")}}var ke;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(ke||(ke={}));var na;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(na||(na={})),function(r){r.codec=()=>kn(na)}(ke||(ke={}));var Mn;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ke.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=ke.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Mn||(Mn={}));var Zl;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),ke.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=ke.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Zl||(Zl={}));function Ql(r){if(isNaN(r)||r<=0)throw new G("random bytes length must be a Number bigger than 0");return Pr(r)}class cw{constructor(t,e){l(this,"type","RSA");l(this,"jwk");l(this,"_raw");l(this,"_multihash");this.jwk=t,this._multihash=e}get raw(){return this._raw==null&&(this._raw=fw(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return pe.createV1(114,this._multihash)}toString(){return De.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){return pw(this.jwk,e,t,n)}}const lw=18,uw=1062,dw=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function hw(r){const t=Rs(r[1],{offset:0});return{kty:"RSA",n:J(t[0],"base64url"),e:J(t[1],"base64url")}}function fw(r){if(r.n==null||r.e==null)throw new G("JWK was missing components");return Tr([dw,sl(Tr([_o(Y(r.n,"base64url")),_o(Y(r.e,"base64url"))]))]).subarray()}function gw(r,t){if(r.byteLength>=uw)throw new oo("Key size is too large");const e=Rs(r,{offset:0});return mw(e,r,t)}function mw(r,t,e){const n=hw(r);if(e==null){const s=Rr(Mn.encode({Type:ke.RSA,Data:t}));e=Ds(lw,s)}return new cw(n,e)}async function pw(r,t,e,n){var o,a;const s=await cn.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await cn.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,e instanceof Uint8Array?e:e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}class Jl{constructor(t,e){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Ms(t),X(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),nn(s)}update(t){return Ns(this),this.iHash.update(t),this}digestInto(t){Ns(this),X(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const js=(r,t,e)=>new Jl(r,t).update(e).digest();js.create=(r,t)=>new Jl(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jl=(r,t)=>(r+(r>=0?t:-t)/eu)/t;function yw(r,t,e){const[[n,s],[i,o]]=t,a=jl(o*r,e),c=jl(-s*r,e);let u=r-a*n-c*i,d=-a*s-c*o;const h=u<_t,f=d<_t;h&&(u=-u),f&&(d=-d);const p=Oo(Math.ceil(Qp(e)/2))+Nn;if(u<_t||u>=p||d<_t||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:f,k2:d}}function ra(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function sa(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return rn(e.lowS,"lowS"),rn(e.prehash,"prehash"),e.format!==void 0&&ra(e.format),e}class ww extends Error{constructor(t=""){super(t)}}const Wt={Err:ww,_tlv:{encode:(r,t)=>{const{Err:e}=Wt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=$s(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?$s(s.length/2|128):"";return $s(r)+i+s+t},decode(r,t){const{Err:e}=Wt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+c);if(u.length!==c)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)o=o<<8|d;if(n+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=Wt;if(r<_t)throw new t("integer: negative integers are not allowed");let e=$s(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=Wt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Us(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=Wt,s=X(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=Wt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},_t=BigInt(0),Nn=BigInt(1),eu=BigInt(2),ei=BigInt(3),bw=BigInt(4);function Ew(r,t={}){const e=Nl("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;Ln(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=nu(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(N,w,b){const{x:C,y:P}=w.toAffine(),k=n.toBytes(C);if(rn(b,"isCompressed"),b){d();const A=!n.isOdd(P);return pt(tu(A),k)}else return pt(Uint8Array.of(4),k,n.toBytes(P))}function f(N){X(N,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=u,C=N.length,P=N[0],k=N.subarray(1);if(C===w&&(P===2||P===3)){const A=n.fromBytes(k);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const F=y(A);let R;try{R=n.sqrt(F)}catch(re){const ee=re instanceof Error?": "+re.message:"";throw new Error("bad point: is not on curve, sqrt error"+ee)}d();const B=n.isOdd(R);return(P&1)===1!==B&&(R=n.neg(R)),{x:A,y:R}}else if(C===b&&P===4){const A=n.BYTES,F=n.fromBytes(k.subarray(0,A)),R=n.fromBytes(k.subarray(A,A*2));if(!m(F,R))throw new Error("bad point: is not on curve");return{x:F,y:R}}else throw new Error(`bad point: got length ${C}, expected compressed=${w} or uncompressed=${b}`)}const p=t.toBytes||h,g=t.fromBytes||f;function y(N){const w=n.sqr(N),b=n.mul(w,N);return n.add(n.add(b,n.mul(N,i.a)),i.b)}function m(N,w){const b=n.sqr(w),C=y(N);return n.eql(b,C)}if(!m(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(i.a,ei),bw),v=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(S,v)))throw new Error("bad curve params: a or b");function E(N,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${N}`);return w}function L(N){if(!(N instanceof I))throw new Error("Weierstrass Point expected")}function x(N){if(!c||!c.basises)throw new Error("no endo");return yw(N,c.basises,s.ORDER)}const _=qs((N,w)=>{const{X:b,Y:C,Z:P}=N;if(n.eql(P,n.ONE))return{x:b,y:C};const k=N.is0();w==null&&(w=k?n.ONE:n.inv(P));const A=n.mul(b,w),F=n.mul(C,w),R=n.mul(P,w);if(k)return{x:n.ZERO,y:n.ZERO};if(!n.eql(R,n.ONE))throw new Error("invZ was invalid");return{x:A,y:F}}),O=qs(N=>{if(N.is0()){if(t.allowInfinityPoint&&!n.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=N.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!m(w,b))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function T(N,w,b,C,P){return b=new I(n.mul(b.X,N),b.Y,b.Z),w=Vs(C,w),b=Vs(P,b),w.add(b)}const M=class M{constructor(w,b,C){l(this,"X");l(this,"Y");l(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",C),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:C}=w||{};if(!w||!n.isValid(b)||!n.isValid(C))throw new Error("invalid affine point");if(w instanceof M)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(C)?M.ZERO:new M(b,C,n.ONE)}static fromBytes(w){const b=M.fromAffine(g(X(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return M.fromBytes(Dr(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return U.createCache(this,w),b||this.multiply(ei),this}assertValidity(){O(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){L(w);const{X:b,Y:C,Z:P}=this,{X:k,Y:A,Z:F}=w,R=n.eql(n.mul(b,F),n.mul(k,P)),B=n.eql(n.mul(C,F),n.mul(A,P));return R&&B}negate(){return new M(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,C=n.mul(b,ei),{X:P,Y:k,Z:A}=this;let F=n.ZERO,R=n.ZERO,B=n.ZERO,K=n.mul(P,P),re=n.mul(k,k),ee=n.mul(A,A),W=n.mul(P,k);return W=n.add(W,W),B=n.mul(P,A),B=n.add(B,B),F=n.mul(w,B),R=n.mul(C,ee),R=n.add(F,R),F=n.sub(re,R),R=n.add(re,R),R=n.mul(F,R),F=n.mul(W,F),B=n.mul(C,B),ee=n.mul(w,ee),W=n.sub(K,ee),W=n.mul(w,W),W=n.add(W,B),B=n.add(K,K),K=n.add(B,K),K=n.add(K,ee),K=n.mul(K,W),R=n.add(R,K),ee=n.mul(k,A),ee=n.add(ee,ee),K=n.mul(ee,W),F=n.sub(F,K),B=n.mul(ee,re),B=n.add(B,B),B=n.add(B,B),new M(F,R,B)}add(w){L(w);const{X:b,Y:C,Z:P}=this,{X:k,Y:A,Z:F}=w;let R=n.ZERO,B=n.ZERO,K=n.ZERO;const re=i.a,ee=n.mul(i.b,ei);let W=n.mul(b,k),le=n.mul(C,A),me=n.mul(P,F),Ee=n.add(b,C),we=n.add(k,A);Ee=n.mul(Ee,we),we=n.add(W,le),Ee=n.sub(Ee,we),we=n.add(b,P);let Ne=n.add(k,F);return we=n.mul(we,Ne),Ne=n.add(W,me),we=n.sub(we,Ne),Ne=n.add(C,P),R=n.add(A,F),Ne=n.mul(Ne,R),R=n.add(le,me),Ne=n.sub(Ne,R),K=n.mul(re,we),R=n.mul(ee,me),K=n.add(R,K),R=n.sub(le,K),K=n.add(le,K),B=n.mul(R,K),le=n.add(W,W),le=n.add(le,W),me=n.mul(re,me),we=n.mul(ee,we),le=n.add(le,me),me=n.sub(W,me),me=n.mul(re,me),we=n.add(we,me),W=n.mul(le,we),B=n.add(B,W),W=n.mul(Ne,we),R=n.mul(Ee,R),R=n.sub(R,W),W=n.mul(Ee,le),K=n.mul(Ne,K),K=n.add(K,W),new M(R,B,K)}subtract(w){return this.add(w.negate())}is0(){return this.equals(M.ZERO)}multiply(w){const{endo:b}=t;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let C,P;const k=A=>U.cached(this,A,F=>Nr(M,F));if(b){const{k1neg:A,k1:F,k2neg:R,k2:B}=x(w),{p:K,f:re}=k(F),{p:ee,f:W}=k(B);P=re.add(W),C=T(b.beta,K,ee,A,R)}else{const{p:A,f:F}=k(w);C=A,P=F}return Nr(M,[C,P])[0]}multiplyUnsafe(w){const{endo:b}=t,C=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===_t||C.is0())return M.ZERO;if(w===Nn)return C;if(U.hasCache(this))return this.multiply(w);if(b){const{k1neg:P,k1:k,k2neg:A,k2:F}=x(w),{p1:R,p2:B}=dy(M,C,k,F);return T(b.beta,R,B,P,A)}else return U.unsafe(C,w)}toAffine(w){return _(this,w)}isTorsionFree(){const{isTorsionFree:w}=t;return o===Nn?!0:w?w(M,this):U.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=t;return o===Nn?this:w?w(M,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return rn(w,"isCompressed"),this.assertValidity(),p(M,this,w)}toHex(w=!0){return Lr(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(M,"BASE",new M(i.Gx,i.Gy,n.ONE)),l(M,"ZERO",new M(n.ZERO,n.ONE,n.ZERO)),l(M,"Fp",n),l(M,"Fn",s);let I=M;const $=s.BITS,U=new kl(I,t.endo?Math.ceil($/2):$);return I.BASE.precompute(8),I}function tu(r){return Uint8Array.of(r?2:3)}function nu(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function vw(r,t={}){const{Fn:e}=r,n=t.randomBytes||Pr,s=Object.assign(nu(r.Fp,e),{seed:Tl(e.ORDER)});function i(p){try{const g=e.fromBytes(p);return e.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:y,publicKeyUncompressed:m}=s;try{const S=p.length;return g===!0&&S!==y||g===!1&&S!==m?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return uy(X(p,s.seed,"seed"),e.ORDER)}function c(p,g=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(g)}function u(p){const{secretKey:g,publicKey:y,publicKeyUncompressed:m}=s;if(!ks(p)||"_lengths"in e&&e._lengths||g===y)return;const S=X(p,void 0,"key").length;return S===y||S===m}function d(p,g,y=!0){if(u(p)===!0)throw new Error("first arg must be private key");if(u(g)===!1)throw new Error("second arg must be public key");const m=e.fromBytes(p);return r.fromBytes(g).multiply(m).toBytes(y)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},f=zo(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:f,Point:r,utils:h,lengths:s})}function Sw(r,t,e={}){Ms(t),Ln(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||Pr,s=e.hmac||((w,b)=>js(t,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p}=vw(r,e),g={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},y=a*eu<i.ORDER;function m(w){const b=a>>Nn;return w>b}function S(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function v(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){ra(b);const C=p.signature,P=b==="compact"?C:b==="recovered"?C+1:void 0;return X(w,P)}class L{constructor(b,C,P){l(this,"r");l(this,"s");l(this,"recovery");if(this.r=S("r",b),this.s=S("s",C),P!=null){if(v(),![0,1,2,3].includes(P))throw new Error("invalid recovery id");this.recovery=P}Object.freeze(this)}static fromBytes(b,C=g.format){E(b,C);let P;if(C==="der"){const{r:R,s:B}=Wt.toSig(X(b));return new L(R,B)}C==="recovered"&&(P=b[0],C="compact",b=b.subarray(1));const k=p.signature/2,A=b.subarray(0,k),F=b.subarray(k,k*2);return new L(o.fromBytes(A),o.fromBytes(F),P)}static fromHex(b,C){return this.fromBytes(Dr(b),C)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new L(this.r,this.s,b)}recoverPublicKey(b){const{r:C,s:P}=this,k=this.assertRecovery(),A=k===2||k===3?C+a:C;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const F=i.toBytes(A),R=r.fromBytes(pt(tu((k&1)===0),F)),B=o.inv(A),K=_(X(b,void 0,"msgHash")),re=o.create(-K*B),ee=o.create(P*B),W=r.BASE.multiplyUnsafe(re).add(R.multiplyUnsafe(ee));if(W.is0())throw new Error("invalid recovery: point at infinify");return W.assertValidity(),W}hasHighS(){return m(this.s)}toBytes(b=g.format){if(ra(b),b==="der")return Dr(Wt.hexFromSig(this));const{r:C,s:P}=this,k=o.toBytes(C),A=o.toBytes(P);return b==="recovered"?(v(),pt(Uint8Array.of(this.assertRecovery()),k,A)):pt(k,A)}toHex(b){return Lr(this.toBytes(b))}}const x=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const C=Us(b),P=b.length*8-c;return P>0?C>>BigInt(P):C},_=e.bits2int_modN||function(b){return o.create(x(b))},O=Oo(c);function T(w){return Mr("num < 2^"+c,w,_t,O),o.toBytes(w)}function I(w,b){return X(w,void 0,"message"),b?X(t(w),void 0,"prehashed message"):w}function $(w,b,C){const{lowS:P,prehash:k,extraEntropy:A}=sa(C,g);w=I(w,k);const F=_(w),R=o.fromBytes(b);if(!o.isValidNot0(R))throw new Error("invalid private key");const B=[T(R),T(F)];if(A!=null&&A!==!1){const W=A===!0?n(p.secretKey):A;B.push(X(W,void 0,"extraEntropy"))}const K=pt(...B),re=F;function ee(W){const le=x(W);if(!o.isValidNot0(le))return;const me=o.inv(le),Ee=r.BASE.multiply(le).toAffine(),we=o.create(Ee.x);if(we===_t)return;const Ne=o.create(me*o.create(re+we*R));if(Ne===_t)return;let ji=(Ee.x===we?0:2)|Number(Ee.y&Nn),hs=Ne;return P&&m(Ne)&&(hs=o.neg(Ne),ji^=1),new L(we,hs,y?void 0:ji)}return{seed:K,k2sig:ee}}function U(w,b,C={}){const{seed:P,k2sig:k}=$(w,b,C);return Jp(t.outputLen,o.BYTES,s)(P,k).toBytes(C.format)}function M(w,b,C,P={}){const{lowS:k,prehash:A,format:F}=sa(P,g);if(C=X(C,void 0,"publicKey"),b=I(b,A),!ks(w)){const R=w instanceof L?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+R)}E(w,F);try{const R=L.fromBytes(w,F),B=r.fromBytes(C);if(k&&R.hasHighS())return!1;const{r:K,s:re}=R,ee=_(b),W=o.inv(re),le=o.create(ee*W),me=o.create(K*W),Ee=r.BASE.multiplyUnsafe(le).add(B.multiplyUnsafe(me));return Ee.is0()?!1:o.create(Ee.x)===K}catch{return!1}}function N(w,b,C={}){const{prehash:P}=sa(C,g);return b=I(b,P),L.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p,Point:r,sign:U,verify:M,recoverPublicKey:N,Signature:L,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ia={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},xw={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},ru=BigInt(2);function Aw(r){const t=ia.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,d=u*u*r%t,h=be(d,e,t)*d%t,f=be(h,e,t)*d%t,p=be(f,ru,t)*u%t,g=be(p,s,t)*p%t,y=be(g,i,t)*g%t,m=be(y,a,t)*y%t,S=be(m,c,t)*m%t,v=be(S,a,t)*y%t,E=be(v,e,t)*d%t,L=be(E,o,t)*g%t,x=be(L,n,t)*u%t,_=be(x,ru,t);if(!oa.eql(oa.sqr(_),r))throw new Error("Cannot find square root");return _}const oa=Ks(ia.p,{sqrt:Aw}),ti=Sw(Ew(ia,{Fp:oa,endo:xw}),Rr);function Cw(r,t,e,n){var i;const s=jc.digest(e instanceof Uint8Array?e:e.subarray());if(Wo(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),ti.verify(t,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new Ul(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),ti.verify(t,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new Ul(String(o))}}class _w{constructor(t){l(this,"type","secp256k1");l(this,"raw");l(this,"_key");this._key=Tw(t),this.raw=Iw(this._key)}toMultihash(){return Cr.digest(It(this))}toCID(){return pe.createV1(114,this.toMultihash())}toString(){return De.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){return Cw(this._key,e,t,n)}}function su(r){return new _w(r)}function Iw(r){return ti.Point.fromBytes(r).toBytes()}function Tw(r){try{return ti.Point.fromBytes(r),r}catch(t){throw new oo(String(t))}}async function Lw(r,t){return Oy()}function Ht(r,t){const{Type:e,Data:n}=Mn.decode(r),s=n??new Uint8Array;switch(e){case ke.RSA:return gw(s,t);case ke.Ed25519:return Vl(s);case ke.secp256k1:return su(s);case ke.ECDSA:return il(s);default:throw new Es}}function Dw(r){const{Type:t,Data:e}=Mn.decode(r.digest),n=e??new Uint8Array;switch(t){case ke.Ed25519:return Vl(n);case ke.secp256k1:return su(n);case ke.ECDSA:return il(n);default:throw new Es}}function It(r){return Mn.encode({Type:ke[r.type],Data:r.raw})}const iu=Symbol.for("nodejs.util.inspect.custom"),Pw=114;class aa{constructor(t){l(this,"type");l(this,"multihash");l(this,"publicKey");l(this,"string");l(this,Kf,!0);this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=De.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return pe.createV1(Pw,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(t==null)return!1;if(t instanceof Uint8Array)return Ke(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(((e=t==null?void 0:t.toMultihash())==null?void 0:e.bytes)!=null)return Ke(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(Kf=mo,iu)](){return`PeerId(${this.toString()})`}}class ou extends aa{constructor(e){super({...e,type:"RSA"});l(this,"type","RSA");l(this,"publicKey");this.publicKey=e.publicKey}}class au extends aa{constructor(e){super({...e,type:"Ed25519"});l(this,"type","Ed25519");l(this,"publicKey");this.publicKey=e.publicKey}}class cu extends aa{constructor(e){super({...e,type:"secp256k1"});l(this,"type","secp256k1");l(this,"publicKey");this.publicKey=e.publicKey}}const Rw=2336;class lu{constructor(t){l(this,"type","url");l(this,"multihash");l(this,"publicKey");l(this,"url");l(this,Vf,!0);this.url=t.toString(),this.multihash=Cr.digest(Y(this.url))}[(Wf=iu,Vf=mo,Wf)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return pe.createV1(Rw,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=J(t)),t.toString()===this.toString())}}const kw=114,uu=2336;function at(r,t){let e;if(r.charAt(0)==="1"||r.charAt(0)==="Q")e=xr(De.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return Kr(pe.parse(r));throw new G('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return qr(e)}function zr(r){if(r.type==="Ed25519")return new au({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new cu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new ou({multihash:r.toCID().multihash,publicKey:r});throw new Es}function Mw(r){return zr(r.publicKey)}function qr(r){if(Ow(r))return new ou({multihash:r});if(Nw(r))try{const t=Dw(r);if(t.type==="Ed25519")return new au({multihash:r,publicKey:t});if(t.type==="secp256k1")return new cu({multihash:r,publicKey:t})}catch{const e=J(r.digest);return new lu(new URL(e))}throw new Pc("Supplied PeerID Multihash is invalid")}function Kr(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==kw&&r.code!==uu)throw new Dc("Supplied PeerID CID is invalid");if(r.code===uu){const t=J(r.multihash.digest);return new lu(new URL(t))}return qr(r.multihash)}function Nw(r){return r.code===Cr.code}function Ow(r){return r.code===jc.code}async function Fw(r){var t,e;if(r.connectionProtector===null&&((e=(t=globalThis.process)==null?void 0:t.env)==null?void 0:e.LIBP2P_FORCE_PNET)!=null)throw new G("Private network is enforced, but no protector was provided");return r}const On=1e3,Fn=On*60,Bn=Fn*60,un=Bn*24,Vr=un*7,$n=un*365.25,Wr=$n/12;function Bw(r,t){if(typeof r=="string")return $w(r);if(typeof r=="number")return qw(r,t);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var du=Bw;function $w(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(t!=null&&t.groups))return NaN;let{value:e,unit:n="ms"}=t.groups,s=parseFloat(e),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*$n;case"months":case"month":case"mo":return s*Wr;case"weeks":case"week":case"w":return s*Vr;case"days":case"day":case"d":return s*un;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Bn;case"minutes":case"minute":case"mins":case"min":case"m":return s*Fn;case"seconds":case"second":case"secs":case"sec":case"s":return s*On;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Uw(r){let t=Math.abs(r);return t>=$n?`${Math.round(r/$n)}y`:t>=Wr?`${Math.round(r/Wr)}mo`:t>=Vr?`${Math.round(r/Vr)}w`:t>=un?`${Math.round(r/un)}d`:t>=Bn?`${Math.round(r/Bn)}h`:t>=Fn?`${Math.round(r/Fn)}m`:t>=On?`${Math.round(r/On)}s`:`${r}ms`}function zw(r){let t=Math.abs(r);return t>=$n?dn(r,t,$n,"year"):t>=Wr?dn(r,t,Wr,"month"):t>=Vr?dn(r,t,Vr,"week"):t>=un?dn(r,t,un,"day"):t>=Bn?dn(r,t,Bn,"hour"):t>=Fn?dn(r,t,Fn,"minute"):t>=On?dn(r,t,On,"second"):`${r} ms`}function qw(r,t){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return t!=null&&t.long?zw(r):Uw(r)}function dn(r,t,e,n){let s=t>=e*1.5;return`${Math.round(r/e)} ${n}${s?"s":""}`}function Kw(r){e.debug=e,e.default=e,e.coerce=c,e.disable=i,e.enable=s,e.enabled=o,e.humanize=du,e.destroy=u,Object.keys(r).forEach(d=>{e[d]=r[d]}),e.names=[],e.skips=[],e.formatters={};function t(d){let h=0;for(let f=0;f<d.length;f++)h=(h<<5)-h+d.charCodeAt(f),h|=0;return e.colors[Math.abs(h)%e.colors.length]}e.selectColor=t;function e(d){let h,f=null,p,g;function y(...m){if(!y.enabled)return;const S=y,v=Number(new Date),E=v-(h||v);S.diff=E,S.prev=h,S.curr=v,h=v,m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let L=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(_,O)=>{if(_==="%%")return"%";L++;const T=e.formatters[O];if(typeof T=="function"){const I=m[L];_=T.call(S,I),m.splice(L,1),L--}return _}),e.formatArgs.call(S,m),(S.log||e.log).apply(S,m)}return y.namespace=d,y.useColors=e.useColors(),y.color=e.selectColor(d),y.extend=n,y.destroy=e.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(p!==e.namespaces&&(p=e.namespaces,g=e.enabled(d)),g),set:m=>{f=m}}),typeof e.init=="function"&&e.init(y),y}function n(d,h){const f=e(this.namespace+(typeof h>"u"?":":h)+d);return f.log=this.log,f}function s(d){e.save(d),e.namespaces=d,e.names=[],e.skips=[];let h;const f=(typeof d=="string"?d:"").split(/[\s,]+/),p=f.length;for(h=0;h<p;h++)f[h]&&(d=f[h].replace(/\*/g,".*?"),d[0]==="-"?e.skips.push(new RegExp("^"+d.substr(1)+"$")):e.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...e.names.map(a),...e.skips.map(a).map(h=>"-"+h)].join(",");return e.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,f;for(h=0,f=e.skips.length;h<f;h++)if(e.skips[h].test(d))return!1;for(h=0,f=e.names.length;h<f;h++)if(e.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return e.setupFormatters(e.formatters),e.enable(e.load()),e}var Vw={};const yt=Qw(),Ww=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Hw(){var r,t,e,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((e=(t=document.documentElement)==null?void 0:t.style)==null?void 0:e.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function Gw(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+du(this.diff),!this.useColors)return;const t="color: "+this.color;r.splice(1,0,t,"color: inherit");let e=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(e++,s==="%c"&&(n=e))}),r.splice(n,0,t)}const Yw=console.debug??console.log??(()=>{});function Xw(r){try{r?yt==null||yt.setItem("debug",r):yt==null||yt.removeItem("debug")}catch{}}function Zw(){let r;try{r=yt==null?void 0:yt.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Vw.DEBUG),r}function Qw(){try{return localStorage}catch{}}function Jw(r){r.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}const et=Kw({formatArgs:Gw,save:Xw,load:Zw,useColors:Hw,setupFormatters:Jw,colors:Ww,storage:yt,log:Yw});et.formatters.b=r=>r==null?"undefined":De.baseEncode(r),et.formatters.t=r=>r==null?"undefined":Ot.baseEncode(r),et.formatters.m=r=>r==null?"undefined":Zc.baseEncode(r),et.formatters.p=r=>r==null?"undefined":r.toString(),et.formatters.c=r=>r==null?"undefined":r.toString(),et.formatters.k=r=>r==null?"undefined":r.toString(),et.formatters.a=r=>r==null?"undefined":r.toString(),et.formatters.e=r=>{if(r==null)return"undefined";const t=gu(r.message),e=gu(r.stack);return t!=null&&e!=null?e.includes(t)?e:`${t}
${e}`:e??t??r.toString()};function jw(r){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=r,t.destroy=()=>!0,t.extend=()=>t,t}function hu(){return{forComponent(r){return fu(r)}}}function fu(r){let t=jw(`${r}:trace`);return et.enabled(`${r}:trace`)&&et.names.map(e=>e.toString()).find(e=>e.includes(":trace"))!=null&&(t=et(`${r}:trace`)),Object.assign(et(r),{error:et(`${r}:error`),trace:t,newScope:e=>fu(`${r}:${e}`)})}function gu(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function Hr(r,t){const e={[Symbol.iterator]:()=>e,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:t(s)}}};return e}function ca(r){const t=xr(De.decode(`z${r}`));return qr(t)}class Un{constructor(t){l(this,"map");if(this.map=new Map,t!=null)for(const[e,n]of t.entries())this.map.set(e.toString(),{key:e,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return Hr(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,n)=>{t(e.value,e.key,this)})}get(t){var e;return(e=this.map.get(t.toString()))==null?void 0:e.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return Hr(this.map.values(),t=>t.key)}values(){return Hr(this.map.values(),t=>t.value)}get size(){return this.map.size}}class zn{constructor(t){l(this,"set");if(this.set=new Set,t!=null)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return Hr(this.set.entries(),t=>{const e=ca(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const n=ca(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return Hr(this.set.values(),t=>ca(t))}intersection(t){const e=new zn;for(const n of t)this.has(n)&&e.add(n);return e}difference(t){const e=new zn;for(const n of this)t.has(n)||e.add(n);return e}union(t){const e=new zn;for(const n of t)e.add(n);for(const n of this)e.add(n);return e}}const la={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},mu={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},pu=new globalThis.TextEncoder;function eb(r,t){const e=la[t];let n=mu[t];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(t,n*e);return n}function tb(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=la[t];let s=mu[t],i=r;for(;i.length>0;){const o=pu.encodeInto(i,e);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(e[a]),s=BigInt.asUintN(t,s*n)}return s}function nb(r,{size:t=32,utf8Buffer:e}={}){if(!la[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return tb(r,t,e);r=pu.encode(r)}return eb(r,t)}const ua={hash:r=>Number(nb(r,{size:32})),hashV:(r,t)=>rb(ua.hash(r,t))};function rb(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),Y(t,"base16")}const yu=64;class hn{constructor(t,e,n,s=2){l(this,"fp");l(this,"h");l(this,"seed");if(s>yu)throw new TypeError("Invalid Fingerprint Size");const i=e.hashV(t,n),o=ae(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return(t==null?void 0:t.fp)instanceof Uint8Array?Ke(this.fp,t.fp):!1}}function ni(r,t){return Math.floor(Math.random()*(t-r))+r}class ri{constructor(t){l(this,"contents");this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof hn))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof hn))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof hn))throw new TypeError("Invalid Fingerprint");const e=ni(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof hn))throw new TypeError("Invalid Fingerprint");const e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}}const sb=500;class wu{constructor(t){l(this,"bucketSize");l(this,"filterSize");l(this,"fingerprintSize");l(this,"buckets");l(this,"count");l(this,"hash");l(this,"seed");this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??ua,this.seed=t.seed??ni(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=Y(t));const e=new hn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new ri(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new ri(this.bucketSize)),this.buckets[n].add(e)||this.buckets[s].add(e))return this.count++,!0;const i=[n,s];let o=i[ni(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new ri(this.bucketSize));for(let a=0;a<sb;a++){const c=this.buckets[o].swap(e);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new ri(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(t){var o,a;typeof t=="string"&&(t=Y(t));const e=new hn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(e))??!1;if(s)return s;const i=(n^e.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(e))??!1}remove(t){var a,c;typeof t=="string"&&(t=Y(t));const e=new hn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(e))??!1;if(s)return this.count--,s;const i=(n^e.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(e))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const ib={1:.5,2:.84,4:.95,8:.98};function ob(r=.001){return r>.002?2:r>1e-5?4:8}function ab(r,t=.001){const e=ob(t),n=ib[e],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),yu);return{filterSize:s,bucketSize:e,fingerprintSize:i}}class cb{constructor(t){l(this,"filterSize");l(this,"bucketSize");l(this,"fingerprintSize");l(this,"scale");l(this,"filterSeries");l(this,"hash");l(this,"seed");this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??ua,this.seed=t.seed??ni(0,Math.pow(2,10)),this.filterSeries=[new wu({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=Y(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new wu({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}}function Gr(r,t=.001,e){return new cb({...ab(r,t)})}function ye(r){var s,i,o,a,c,u;const t=r.getComponents(),e={};let n=0;if(((s=t[n])==null?void 0:s.name)==="ip6zone"&&(e.zone=`${t[n].value}`,n++),t[n].name==="ip4"||t[n].name==="ip6"||t[n].name==="dns"||t[n].name==="dns4"||t[n].name==="dns6"?(e.type=t[n].name,e.host=t[n].value,n++):t[n].name==="dnsaddr"&&(e.type=t[n].name,e.host=`_dnsaddr.${t[n].value}`,n++),(((i=t[n])==null?void 0:i.name)==="tcp"||((o=t[n])==null?void 0:o.name)==="udp")&&(e.protocol=t[n].name==="tcp"?"tcp":"udp",e.port=parseInt(`${t[n].value}`),n++),((a=t[n])==null?void 0:a.name)==="ipcidr"&&(e.type==="ip4"?e.cidr=parseInt(`${t[n].value}`):e.type==="ip6"&&(e.cidr=`${t[n].value}`),n++),e.type==null||e.host==null)throw new G(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=t[n])==null?void 0:c.name)==="tls"&&((u=t[n+1])==null?void 0:u.name)==="sni"&&(e.sni=t[n+1].value,n+=2),e}class lb{constructor(){l(this,"index",0);l(this,"input","")}new(t){return this.index=0,this.input=t,this}readAtomically(t){const e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){const e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{const e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const f=Number.parseInt(h,t);if(!Number.isNaN(f))return f});if(d===void 0)break;if(i*=t,i+=d,i>u||(o+=1,e!==void 0&&o>e))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const t=new Uint8Array(4);for(let e=0;e<t.length;e++){const n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){const t=e=>{for(let n=0;n<e.length/2;n++){const s=n*2;if(n<e.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return e[s]=o[0],e[s+1]=o[1],e[s+2]=o[2],e[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];e[s]=i>>8,e[s+1]=i&255}return[e.length,!1]};return this.readAtomically(()=>{const e=new Uint8Array(16),[n,s]=t(e);if(n===16)return e;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=t(i.subarray(0,o));return e.set(i.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const bu=45,ub=15,qn=new lb;function Eu(r){if(!(r.length>ub))return qn.new(r).parseWith(()=>qn.readIPv4Addr())}function vu(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>bu))return qn.new(r).parseWith(()=>qn.readIPv6Addr())}function da(r,t=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>bu)return;const e=qn.new(r).parseWith(()=>qn.readIPAddr());if(e)return t&&e.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,e[0],e[1],e[2],e[3]]):e}function db(r,t,e){let n=0;for(const s of r)if(!(n<t)){if(n>e)break;if(s!==255)return!1;n++}return!0}function hb(r,t,e,n){let s=0;for(const i of r)if(!(s<e)){if(s>n)break;if(i!==t[s])return!1;s++}return!0}function fb(r){switch(r.length){case Yr:return r.join(".");case Xr:{const t=[];for(let e=0;e<r.length;e++)e%2===0&&t.push(r[e].toString(16).padStart(2,"0")+r[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function gb(r){let t=0;for(let[e,n]of r.entries()){if(n===255){t+=8;continue}for(;n&128;)t++,n=n<<1;if(n&128)return-1;for(let s=e+1;s<r.length;s++)if(r[s]!=0)return-1;break}return t}function mb(r){let t="0x";for(const e of r)t+=(e>>4).toString(16)+(e&15).toString(16);return t}const Yr=4,Xr=16,pb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Su(r,t){t.length===Xr&&r.length===Yr&&db(t,0,11)&&(t=t.slice(12)),t.length===Yr&&r.length===Xr&&hb(r,pb,0,11)&&(r=r.slice(12));const e=r.length;if(e!=t.length)throw new Error("Failed to mask ip");const n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=r[s]&t[s];return n}function yb(r,t){if(typeof t=="string"&&(t=da(t)),t==null)throw new Error("Invalid ip");if(t.length!==r.network.length)return!1;for(let e=0;e<t.length;e++)if((r.network[e]&r.mask[e])!==(t[e]&r.mask[e]))return!1;return!0}function wb(r){const[t,e]=r.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+r);let n=Yr,s=Eu(t);if(s==null&&(n=Xr,s=vu(t),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(e,10);if(Number.isNaN(i)||String(i).length!==e.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=xu(i,8*n);return{network:Su(s,o),mask:o}}function xu(r,t){if(t!==8*Yr&&t!==8*Xr)throw new Error("Invalid CIDR mask");if(r<0||r>t)throw new Error("Invalid CIDR mask");const e=t/8,n=new Uint8Array(e);for(let s=0;s<e;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class Au{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=wb(t));else{const n=da(t);if(n==null)throw new Error("Failed to parse network");e=String(e);const s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>n.length*8){const i=da(e);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=xu(s,8*n.length);this.network=Su(n,this.mask)}}contains(t){return yb({network:this.network,mask:this.mask},t)}toString(){const t=gb(this.mask),e=t!==-1?String(t):mb(this.mask);return fb(this.network)+"/"+e}}function bb(r,t){return new Au(r).contains(t)}function Eb(r){try{const t=ye(r);switch(t.type){case"ip6":return bb("2000::/3",t.host);default:return!1}}catch{return!1}}function vb(r){try{const t=ye(r);switch(t.type){case"ip4":return t.host.startsWith("169.254.");case"ip6":return t.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function Sb(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function ha(r){try{const t=ye(r);switch(t.type){case"ip4":case"ip6":return Sb(t.host);default:return!1}}catch{return!1}}function ct(r){try{return ye(r),!0}catch{return!1}}function Kn(r){return!!Eu(r)}function Cu(r){return!!vu(r)}var xb=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function _u(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Iu;(function(){var r,t,e,n,s,i,o,a;a=function(c){var u,d,h,f;return u=(c&255<<24)>>>24,d=(c&255<<16)>>>16,h=(c&65280)>>>8,f=c&255,[u,d,h,f].join(".")},o=function(c){var u,d,h,f,p,g;for(u=[],h=f=0;f<=3&&c.length!==0;h=++f){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=t(c),p=g[0],d=g[1],c=c.substring(d),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},n=e("0"),i=e("a"),s=e("A"),t=function(c){var u,d,h,f,p;for(f=0,u=10,d="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,u=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<c.length;){if("0"<=c[h]&&c[h]<=d)f=f*u+(e(c[h])-n)>>>0;else if(u===16)if("a"<=c[h]&&c[h]<="f")f=f*u+(10+e(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")f=f*u+(10+e(c[h])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[f,h]},r=function(){function c(u,d){var h,f,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=f=32;f>=0;h=--f)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var d,h,f;for(f=o(this.first),h=o(this.last),d=0;f<=h;)u(a(f),f,d),d++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Iu=r}).call(xb);const Ab=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(r=>new Iu(r));function fa(r){for(const t of Ab)if(t.contains(r))return!0;return!1}function Cb(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function _b(r){const t=r.split(":");if(t.length<2)return!1;const e=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return fa(s)}function Ib(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Tb(r){const t=r.split(":"),e=t[t.length-1];return fa(e)}function Lb(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function ga(r){if(Kn(r))return fa(r);if(Cb(r))return _b(r);if(Ib(r))return Tb(r);if(Cu(r))return Lb(r)}function Vn(r){try{const t=ye(r);switch(t.type){case"ip4":case"ip6":return ga(t.host)??!1;default:return t.host==="localhost"}}catch{return!1}}function rt(){const r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}class Tu{constructor(t){l(this,"buffer");l(this,"mask");l(this,"top");l(this,"btm");l(this,"next");if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}}class ma{constructor(t={}){l(this,"size");l(this,"hwm");l(this,"head");l(this,"tail");this.hwm=t.splitLimit??16,this.head=new Tu(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return(t==null?void 0:t.byteLength)!=null?t.byteLength:1}push(t){if((t==null?void 0:t.value)!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new Tu(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return(t==null?void 0:t.value)!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}let Db=class extends Error{constructor(e,n){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function si(r={}){return Pb(e=>{const n=e.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Pb(r,t){t=t??{};let e=t.onEnd,n=new ma,s,i,o,a=rt();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,S)=>{i=v=>{i=null,n.push(v);try{m(r(n))}catch(E){S(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=rt()})}},u=m=>i!=null?i(m):(n.push(m),s),d=m=>(n=new ma,i!=null?i({error:m}):(n.push({error:m}),s)),h=m=>{if(o)return s;if((t==null?void 0:t.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:m})},f=m=>o?s:(o=!0,m!=null?d(m):u({done:!0})),p=()=>(n=new ma,f(),{done:!0}),g=m=>(f(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:h,end:f,get readableLength(){return n.size},onEmpty:async m=>{const S=m==null?void 0:m.signal;if(S==null||S.throwIfAborted(),n.isEmpty())return;let v,E;S!=null&&(v=new Promise((L,x)=>{E=()=>{x(new Db)},S.addEventListener("abort",E)}));try{await Promise.race([a.promise,v])}finally{E!=null&&S!=null&&(S==null||S.removeEventListener("abort",E))}}},e==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(m){return y.throw(m),e!=null&&(e(m),e=void 0),{done:!0}},return(){return y.return(),e!=null&&(e(),e=void 0),{done:!0}},push:h,end(m){return y.end(m),e!=null&&(e(m),e=void 0),s},get readableLength(){return y.readableLength},onEmpty:m=>y.onEmpty(m)},s}let Rb=class extends Error{constructor(t){super(t),this.name="TimeoutError"}},kb=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}};const Lu=r=>globalThis.DOMException===void 0?new kb(r):new DOMException(r),Du=r=>{const t=r.reason===void 0?Lu("This operation was aborted."):r.reason;return t instanceof Error?t:Lu(t)};function Mb(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const u=new Promise((d,h)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:p}=t;p.aborted&&h(Du(p)),a=()=>{h(Du(p))},p.addEventListener("abort",a,{once:!0})}if(e===Number.POSITIVE_INFINITY){r.then(d,h);return}const f=new Rb;o=i.setTimeout.call(void 0,()=>{if(n){try{d(n())}catch(p){h(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?d():s instanceof Error?h(s):(f.message=s??`Promise timed out after ${e} milliseconds`,h(f))},e),(async()=>{try{d(await r)}catch(p){h(p)}})()}).finally(()=>{u.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Nb=r=>{const t=r.addEventListener||r.on||r.addListener,e=r.removeEventListener||r.off||r.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(r),removeListener:e.bind(r)}};function Ob(r,t,e){let n;const s=new Promise((i,o)=>{var p;if(e={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=e.signal)==null||p.throwIfAborted();const a=[t].flat(),c=[],{addListener:u,removeListener:d}=Nb(r),h=async(...g)=>{const y=e.multiArgs?g:g[0];if(e.filter)try{if(!await e.filter(y))return}catch(m){n(),o(m);return}c.push(y),e.count===c.length&&(n(),i(c))},f=(...g)=>{n(),o(e.rejectionMultiArgs?g:g[0])};n=()=>{for(const g of a)d(g,h);for(const g of e.rejectionEvents)a.includes(g)||d(g,f)};for(const g of a)u(g,h);for(const g of e.rejectionEvents)a.includes(g)||u(g,f);e.signal&&e.signal.addEventListener("abort",()=>{f(e.signal.reason)},{once:!0}),e.resolveImmediately&&i(c)});if(s.cancel=n,typeof e.timeout=="number"){const i=Mb(s,{milliseconds:e.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function Ue(r,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};const n=Ob(r,t,e),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function ii(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class Fb extends Error{constructor(e="Rate limit exceeded",n){super(e);l(this,"remainingPoints");l(this,"msBeforeNext");l(this,"consumedPoints");l(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}let Bb=(bc=class extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}},l(bc,"name","QueueFullError"),bc),oi=(Ec=class extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError")}},l(Ec,"name","UnexpectedEOFError"),Ec);class Pu extends Error{constructor(){super(...arguments);l(this,"name","MaxEarlyStreamsError")}}l(Pu,"name","MaxEarlyStreamsError");class Ru extends Error{constructor(){super(...arguments);l(this,"name","StreamClosedError")}}l(Ru,"name","StreamClosedError");function $b(r){return r.reason}async function wt(r,t,e){if(t==null)return r;const n=$b;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}let Ub=class{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=rt(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new ft)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}};function zb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let qb=class{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=zb(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new ft),this.cleanup())}async join(t={}){var n;const e=new Ub(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await wt(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}},ku=class extends Ye{constructor(e={}){var n;super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"paused");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,e.metricName!=null&&((n=e.metrics)==null||n.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=e.sort,this.queue=[],this.emitEmpty=ii(this.emitEmpty.bind(this),1),this.emitIdle=ii(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Bb;const s=new qb(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new ft)}),this.clear()}async onEmpty(e){this.size!==0&&await Ue(this,"empty",e)}async onSizeLessThan(e,n){this.size<e||await Ue(this,"next",{...n,filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ue(this,"idle",e)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=si({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new ft("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}};const Kb=Math.pow(2,20)*4;class pa extends Ye{constructor(e){super();l(this,"status");l(this,"timeline");l(this,"inactivityTimeout");l(this,"maxReadBufferLength");l(this,"maxWriteBufferLength");l(this,"log");l(this,"direction");l(this,"maxMessageSize");l(this,"readStatus");l(this,"writeStatus");l(this,"remoteReadStatus");l(this,"remoteWriteStatus");l(this,"writableNeedsDrain");l(this,"readBuffer");l(this,"writeBuffer");l(this,"sendingData");l(this,"onDrainPromise");this.status="open",this.log=e.log,this.direction=e.direction??"outbound",this.inactivityTimeout=e.inactivityTimeout??12e4,this.maxReadBufferLength=e.maxReadBufferLength??Kb,this.maxWriteBufferLength=e.maxWriteBufferLength,this.maxMessageSize=e.maxMessageSize,this.readBuffer=new Q,this.writeBuffer=new Q,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new Ru)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(e){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),wt(this.onDrainPromise.promise,e==null?void 0:e.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const e=si(),n=o=>{e.push(o.data)};this.addEventListener("message",n);const s=o=>{e.end(o.error)};this.addEventListener("close",s);const i=()=>{e.end()};this.addEventListener("remoteCloseWrite",i);try{yield*e}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(e){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new tn(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",e.byteLength),this.writeBuffer.append(e),this.processSendQueue()}abort(e){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",e),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(e)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Vg(e))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new tn("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new tn("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new tn(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.append(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new tn(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.prepend(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(e){if(e.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(e),this.dispatchReadBuffer()}}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const e=new ao;this.dispatchEvent(new Wg(e))}onTransportClosed(e){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),e!=null?this.abort(e):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new vs))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let e=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){e=!1;break}const o=this.writeBuffer.sublist(0,i),a=new Q(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(e=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!e)break}return e||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),e}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const e=this.readBuffer.sublist();this.readBuffer.consume(e.byteLength),this.dispatchEvent(new Kg(e))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new co(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new co(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Mu extends pa{constructor(e){super(e);l(this,"remoteAddr");l(this,"metricPrefix");l(this,"metrics");this.metricPrefix=e.metricPrefix??"",this.metrics=e.metrics,this.remoteAddr=e.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(e){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Ue(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Ue(this,"drain",{...e,rejectionEvents:["close"]})),await this.sendClose(e),this.onTransportClosed())}}function Vb(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Nu extends Ye{constructor(e,n){super();l(this,"streams");l(this,"protocol");l(this,"status");l(this,"log");l(this,"maConn");l(this,"streamOptions");l(this,"earlyStreams");l(this,"maxEarlyStreams");l(this,"metrics");this.maConn=e,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=e.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(e){const n=this.maConn.send(e);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(e){this.status==="closed"||this.status==="closing"||(this.status="closing",await wt(Promise.all([...this.streams].map(async n=>{await n.close(e)})),e==null?void 0:e.signal),this.status="closed")}abort(e){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(e)}),this.status="closed")}onTransportClosed(e){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(e)})}catch(n){this.abort(n)}this.status="closed"}async createStream(e){if(this.status!=="open")throw new _n;let n=this.onCreateStream({...this.streamOptions,...e});return Vb(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(e){if(this.streams.push(e),this.cleanUpStream(e),this.listenerCount("stream")===0){this.earlyStreams.push(e),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new Pu(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:e})}cleanUpStream(e){var s;const n=i=>{var a,c,u;const o=this.streams.findIndex(d=>d===e);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${e.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${e.direction}_stream_abort`]:!0}):(u=this.metrics)==null||u.increment({[`${e.direction}_stream_end`]:!0})};e.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${e.direction}_stream`]:!0})}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Ou extends pa{constructor(e){super(e);l(this,"id");l(this,"protocol");this.id=e.id,this.protocol=e.protocol??""}async close(e){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Ue(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await Ue(this,"drain",{...e,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(e),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(e){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(e),this.readStatus="closed",this.log("closed readable end gracefully"))}}function fn(r){const t=new globalThis.AbortController;function e(){t.abort();for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}for(const i of r){if((i==null?void 0:i.aborted)===!0){e();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",e)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}const s=t.signal;return s.clear=n,s}class ya{constructor(t){l(this,"movingAverage");l(this,"variance");l(this,"deviation");l(this,"forecast");l(this,"timeSpan");l(this,"previousTime");this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(this.previousTime!=null){const n=this.alpha(e,this.previousTime),s=t-this.movingAverage,i=n*s;this.movingAverage=n*t+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=t;this.previousTime=e}}const Wb=1.2,Hb=2,Gb=5e3,Yb=6e4,Xb=5e3;class Zb{constructor(t={}){l(this,"success");l(this,"failure");l(this,"next");l(this,"metric");l(this,"timeoutMultiplier");l(this,"failureMultiplier");l(this,"minTimeout");l(this,"maxTimeout");var n;const e=t.interval??Xb;this.success=new ya(e),this.failure=new ya(e),this.next=new ya(e),this.failureMultiplier=t.failureMultiplier??Hb,this.timeoutMultiplier=t.timeoutMultiplier??Wb,this.minTimeout=t.minTimeout??Gb,this.maxTimeout=t.maxTimeout??Yb,t.metricName!=null&&(this.metric=(n=t.metrics)==null?void 0:n.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){let e=Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier));e<this.minTimeout&&(e=this.minTimeout),e>this.maxTimeout&&(e=this.maxTimeout);const n=AbortSignal.timeout(e),s=fn([t.signal,n]);return s.start=Date.now(),s.timeout=e,s}cleanUp(t){var n,s;const e=Date.now()-t.start;t.aborted?(this.failure.push(e),this.next.push(e*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:e})):(this.success.push(e),this.next.push(e),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:e}))}}class tt extends Error{constructor(){super(...arguments);l(this,"name","InvalidMultiaddrError")}}l(tt,"name","InvalidMultiaddrError");class Wn extends Error{constructor(){super(...arguments);l(this,"name","ValidationError")}}l(Wn,"name","ValidationError");class Fu extends Error{constructor(){super(...arguments);l(this,"name","InvalidParametersError")}}l(Fu,"name","InvalidParametersError");class Bu extends Error{constructor(){super(...arguments);l(this,"name","UnknownProtocolError")}}l(Bu,"name","UnknownProtocolError");const ai=4,Hn=6,$u=273,Qb=33,Gn=41,wa=42,ba=43,Uu=53,zu=54,qu=55,Ku=56,Jb=132,jb=301,e0=302,Vu=400,H=421,t0=444,n0=445,r0=446,s0=447,Yn=448,ci=449,i0=454,Wu=460,Hu=461,Gu=465,Zr=466,Xn=480,o0=481,Ea=443,va=477,Yu=478,a0=479,c0=277,l0=275,u0=276,Xu=280,Qr=281,Zn=290,Zu=777;function Qu(r){return t=>J(t,r)}function Ju(r){return t=>Y(t,r)}function Jr(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Qn(r){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(t)}function d0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=Y(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Qn(n);return Ft([e,s],e.length+s.length)}function h0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=Ot.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Qn(n);return Ft([e,s],e.length+s.length)}function ju(r){const t=r.subarray(0,r.length-2),e=r.subarray(r.length-2),n=J(t,"base32"),s=Jr(e);return`${n}:${s}`}const ed=function(r){r=r.toString().trim();const t=new Uint8Array(4);return r.split(/\./g).forEach((e,n)=>{const s=parseInt(e,10);if(isNaN(s)||s<0||s>255)throw new tt("Invalid byte value in IP address");t[n]=s}),t},f0=function(r){let t=0;r=r.toString().trim();const e=r.split(":",8);let n;for(n=0;n<e.length;n++){const i=Kn(e[n]);let o;i&&(o=ed(e[n]),e[n]=J(o.subarray(0,2),"base16")),o!=null&&++n<8&&e.splice(n,0,J(o.subarray(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);const i=[n,1];for(n=9-e.length;n>0;n--)i.push("0");e.splice.apply(e,i)}const s=new Uint8Array(t+16);for(n=0;n<e.length;n++){e[n]===""&&(e[n]="0");const i=parseInt(e[n],16);if(isNaN(i)||i<0||i>65535)throw new tt("Invalid byte value in IP address");s[t++]=i>>8&255,s[t++]=i&255}return s},g0=function(r){if(r.byteLength!==4)throw new tt("IPv4 address was incorrect length");const t=[];for(let e=0;e<r.byteLength;e++)t.push(r[e]);return t.join(".")},m0=function(r){if(r.byteLength!==16)throw new tt("IPv6 address was incorrect length");const t=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;t.push(o)}const e=t.join(":");try{const n=new URL(`http://[${e}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new tt(`Invalid IPv6 address "${e}"`)}};function p0(r){try{const t=new URL(`http://[${r}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new tt(`Invalid IPv6 address "${r}"`)}}const Sa=Object.values(So).map(r=>r.decoder),y0=function(){let r=Sa[0].or(Sa[1]);return Sa.slice(2).forEach(t=>r=r.or(t)),r}();function w0(r){return y0.decode(r)}function b0(r){return t=>r.encoder.encode(t)}function E0(r){if(parseInt(r).toString()!==r)throw new Wn("Value must be an integer")}function v0(r){if(r<0)throw new Wn("Value must be a positive integer, or zero")}function S0(r){return t=>{if(t>r)throw new Wn(`Value must be smaller than or equal to ${r}`)}}function x0(...r){return t=>{for(const e of r)e(t)}}const li=x0(E0,v0,S0(65535)),ze=-1;class A0{constructor(){l(this,"protocolsByCode",new Map);l(this,"protocolsByName",new Map)}getProtocol(t){let e;if(typeof t=="string"?e=this.protocolsByName.get(t):e=this.protocolsByCode.get(t),e==null)throw new Bu(`Protocol ${t} was unknown`);return e}addProtocol(t){var e;this.protocolsByCode.set(t.code,t),this.protocolsByName.set(t.name,t),(e=t.aliases)==null||e.forEach(n=>{this.protocolsByName.set(n,t)})}removeProtocol(t){var n;const e=this.protocolsByCode.get(t);e!=null&&(this.protocolsByCode.delete(e.code),this.protocolsByName.delete(e.name),(n=e.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const Jn=new A0;[{code:ai,name:"ip4",size:32,valueToBytes:ed,bytesToValue:g0,validate:r=>{if(!Kn(r))throw new Wn(`Invalid IPv4 address "${r}"`)}},{code:Hn,name:"tcp",size:16,valueToBytes:Qn,bytesToValue:Jr,validate:li},{code:$u,name:"udp",size:16,valueToBytes:Qn,bytesToValue:Jr,validate:li},{code:Qb,name:"dccp",size:16,valueToBytes:Qn,bytesToValue:Jr,validate:li},{code:Gn,name:"ip6",size:128,valueToBytes:f0,bytesToValue:m0,stringToValue:p0,validate:r=>{if(!Cu(r))throw new Wn(`Invalid IPv6 address "${r}"`)}},{code:wa,name:"ip6zone",size:ze},{code:ba,name:"ipcidr",size:8,bytesToValue:Qu("base10"),valueToBytes:Ju("base10")},{code:Uu,name:"dns",size:ze},{code:zu,name:"dns4",size:ze},{code:qu,name:"dns6",size:ze},{code:Ku,name:"dnsaddr",size:ze},{code:Jb,name:"sctp",size:16,valueToBytes:Qn,bytesToValue:Jr,validate:li},{code:jb,name:"udt"},{code:e0,name:"utp"},{code:Vu,name:"unix",size:ze,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:H,name:"p2p",aliases:["ipfs"],size:ze,bytesToValue:Qu("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?Ju("base58btc")(r):pe.parse(r).multihash.bytes},{code:t0,name:"onion",size:96,bytesToValue:ju,valueToBytes:d0},{code:n0,name:"onion3",size:296,bytesToValue:ju,valueToBytes:h0},{code:r0,name:"garlic64",size:ze},{code:s0,name:"garlic32",size:ze},{code:Yn,name:"tls"},{code:ci,name:"sni",size:ze},{code:i0,name:"noise"},{code:Wu,name:"quic"},{code:Hu,name:"quic-v1"},{code:Gu,name:"webtransport"},{code:Zr,name:"certhash",size:ze,bytesToValue:b0(Qc),valueToBytes:w0},{code:Xn,name:"http"},{code:o0,name:"http-path",size:ze,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:Ea,name:"https"},{code:va,name:"ws"},{code:Yu,name:"wss"},{code:a0,name:"p2p-websocket-star"},{code:c0,name:"p2p-stardust"},{code:l0,name:"p2p-webrtc-star"},{code:u0,name:"p2p-webrtc-direct"},{code:Xu,name:"webrtc-direct"},{code:Qr,name:"webrtc"},{code:Zn,name:"p2p-circuit"},{code:Zu,name:"memory",size:ze}].forEach(r=>{Jn.addProtocol(r)});function C0(r){var n;const t=[];let e=0;for(;e<r.length;){const s=Br(r,e),i=Jn.getProtocol(s),o=Re(s),a=L0(i,r,e+o);let c=0;a>0&&i.size===ze&&(c=Re(a));const u=o+c+a,d={code:s,name:i.name,bytes:r.subarray(e,e+u)};if(a>0){const h=e+o+c,f=r.subarray(h,h+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,f))??J(f)}t.push(d),e+=u}return t}function _0(r){var n;let t=0;const e=[];for(const s of r){if(s.bytes==null){const i=Jn.getProtocol(s.code),o=Re(s.code);let a,c=0,u=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??Y(s.value),c=a.byteLength,i.size===ze&&(u=Re(c)));const d=new Uint8Array(o+u+c);let h=0;Xs(s.code,d,h),h+=o,a!=null&&(i.size===ze&&(Xs(c,d,h),h+=u),d.set(a,h)),s.bytes=d}e.push(s.bytes),t+=s.bytes.byteLength}return Ft(e,t)}function I0(r){var i;if(r.charAt(0)!=="/")throw new tt('String multiaddr must start with "/"');const t=[];let e="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(e==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const u=Jn.getProtocol(s);if(e==="protocol"){if(u.size==null||u.size===0){t.push({code:u.code,name:u.name}),n="",s="",e="protocol";continue}else if(c)throw new tt(`Component ${s} was missing value`);e="value"}else if(e==="value"){const d={code:u.code,name:u.name};if(u.size!=null&&u.size!==0){if(n==="")throw new tt(`Component ${s} was missing value`);d.value=((i=u.stringToValue)==null?void 0:i.call(u,n))??n}t.push(d),n="",s="",e="protocol"}}}if(s!==""&&n!=="")throw new tt("Incomplete multiaddr");return t}function T0(r){return`/${r.flatMap(t=>{var n;if(t.value==null)return t.name;const e=Jn.getProtocol(t.code);if(e==null)throw new tt(`Unknown protocol code ${t.code}`);return[t.name,((n=e.valueToString)==null?void 0:n.call(e,t.value))??t.value]}).join("/")}`}function L0(r,t,e){return r.size==null||r.size===0?0:r.size>0?r.size/8:Br(t,e)}const D0=Symbol.for("nodejs.util.inspect.custom"),td=Symbol.for("@multiformats/multiaddr");function P0(r){if(r==null&&(r="/"),ui(r))return r.getComponents();if(r instanceof Uint8Array)return C0(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),I0(r);if(Array.isArray(r))return r;throw new tt("Must be a string, Uint8Array, Component[], or another Multiaddr")}const ur=class ur{constructor(t="/",e={}){l(this,Hf,!0);ce(this,dt);ce(this,cr);ce(this,lr);ue(this,dt,P0(t)),e.validate!==!1&&R0(this)}get bytes(){return D(this,lr)==null&&ue(this,lr,_0(D(this,dt))),D(this,lr)}toString(){return D(this,cr)==null&&ue(this,cr,T0(D(this,dt))),D(this,cr)}toJSON(){return this.toString()}getComponents(){return[...D(this,dt).map(t=>({...t}))]}encapsulate(t){const e=new ur(t);return new ur([...D(this,dt),...e.getComponents()],{validate:!1})}decapsulate(t){const e=t.toString(),n=this.toString(),s=n.lastIndexOf(e);if(s<0)throw new Fu(`Address ${this.toString()} does not contain subaddress: ${e}`);return new ur(n.slice(0,s),{validate:!1})}decapsulateCode(t){let e;for(let n=D(this,dt).length-1;n>-1;n--)if(D(this,dt)[n].code===t){e=n;break}return new ur(D(this,dt).slice(0,e),{validate:!1})}equals(t){return Ke(this.bytes,t.bytes)}[(Hf=td,D0)](){return`Multiaddr(${this.toString()})`}};dt=new WeakMap,cr=new WeakMap,lr=new WeakMap;let xa=ur;function R0(r){r.getComponents().forEach(t=>{var n;const e=Jn.getProtocol(t.code);t.value!=null&&((n=e.validate)==null||n.call(e,t.value))})}function ui(r){return!!(r!=null&&r[td])}function Z(r){return new xa(r)}let nd=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function k0(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new nd(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new nd(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class M0{constructor(){l(this,"readNext");l(this,"haveNext");l(this,"ended");l(this,"nextResult");l(this,"error");this.ended=!1,this.readNext=rt(),this.haveNext=rt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=rt(),t}async throw(t){return this.ended=!0,this.error=t,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=rt(),await k0(this.readNext.promise,e==null?void 0:e.signal,e)}}function N0(){return new M0}function O0(r){return r[Symbol.asyncIterator]!=null}async function F0(r,t,e){try{await Promise.all(r.map(async n=>{for await(const s of n)await t.push(s,{signal:e}),e.throwIfAborted()})),await t.end(void 0,{signal:e})}catch(n){await t.end(n,{signal:e}).catch(()=>{})}}async function*B0(r){const t=new AbortController,e=N0();F0(r,e,t.signal).catch(()=>{});try{yield*e}finally{t.abort()}}function*$0(r){for(const t of r)yield*t}function Aa(...r){const t=[];for(const e of r)O0(e)||t.push(e);return t.length===r.length?$0(t):B0(r)}const U0=4194304;class Ca extends Error{constructor(){super(...arguments);l(this,"name","UnwrappedError")}}l(Ca,"name","UnwrappedError");let rd=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}},z0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}},q0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function K0(r){return typeof(r==null?void 0:r.closeRead)=="function"}function V0(r){return typeof(r==null?void 0:r.close)=="function"}function _a(r){return K0(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:V0(r)?r.status!=="open":!1}function W0(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function sd(r,t){const e=(t==null?void 0:t.maxBufferSize)??U0,n=new Q;let s,i=!1;if(!W0(r))throw new G("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>e){const h=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${h} > ${e}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const u={readBuffer:n,async read(d){if(i===!0)throw new Ca("Stream was unwrapped");if(_a(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new oi(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await wt(s.promise,d==null?void 0:d.signal),_a(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const f=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<f){if(_a(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,f),new oi(`Unexpected EOF - stream closed while reading ${n.byteLength}/${f} bytes`);return u.read(d)}const p=n.sublist(0,f);return n.consume(f),p},async write(d,h){if(i===!0)throw new Ca("Stream was unwrapped");r.send(d)||await Ue(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function jr(r,t={}){const e=sd(r,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=Re(t.maxDataLength));const n=(t==null?void 0:t.lengthDecoder)??Br,s=(t==null?void 0:t.lengthEncoder)??Fr;return{async read(o){let a=-1;const c=new Q;for(;;){const d=await e.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new rd("Invalid message length");if((t==null?void 0:t.maxLengthLength)!=null&&c.byteLength>t.maxLengthLength)throw new q0(`Message length length too long - ${c.byteLength} > ${t.maxLengthLength}`);if(a>-1)break}if((t==null?void 0:t.maxDataLength)!=null&&a>t.maxDataLength)throw new z0(`Message length too long - ${a} > ${t.maxDataLength}`);const u=await e.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new oi(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new oi(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await e.write(new Q(s(o.byteLength),o),a)},async writeV(o,a){const c=new Q(...o.flatMap(u=>[s(u.byteLength),u]));await e.write(c,a)},unwrap(){return e.unwrap()}}}function gn(r,t){const e=jr(r,t),n={read:async(s,i)=>{const o=await e.read(i);return s.decode(o)},write:async(s,i,o)=>{await e.write(i.encode(s),o)},writeV:async(s,i,o)=>{await e.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>e.unwrap()};return n}const H0=1024*1024*4,G0=1024*1024*4;class Y0{constructor(t={}){l(this,"buffer");l(this,"maxBufferSize");l(this,"lengthDecoder");l(this,"maxDataLength");l(this,"encodingLength");this.buffer=new Q,this.maxBufferSize=t.maxBufferSize??H0,this.maxDataLength=t.maxDataLength??G0,this.lengthDecoder=t.lengthDecoder??Br,this.encodingLength=t.encodingLength??Re}*decode(t){if(this.buffer.append(t),this.buffer.byteLength>this.maxBufferSize)throw new G(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let e;try{e=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(e<0||e>this.maxDataLength)throw new rd("Invalid message length");const n=this.encodingLength(e),s=n+e;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const X0=8,Ia=1024*1024*4;class Z0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}}class id extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}}class Q0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class od extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError");l(this,"code","ERR_UNEXPECTED_EOF")}}function ad(r){return r[Symbol.asyncIterator]!=null}function cd(r,t){if(r.byteLength>t)throw new id("Message length too long")}const di=r=>{const t=Re(r),e=gt(t);return Fr(r,e),di.bytes=t,e};di.bytes=0;function hi(r,t){t=t??{};const e=t.lengthEncoder??di,n=(t==null?void 0:t.maxDataLength)??Ia;function*s(i){cd(i,n);const o=e(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return ad(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}hi.single=(r,t)=>{t=t??{};const e=t.lengthEncoder??di,n=(t==null?void 0:t.maxDataLength)??Ia;return cd(r,n),new Q(e(r.byteLength),r)};var mn;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(mn||(mn={}));const Ta=r=>{const t=Br(r);return Ta.bytes=Re(t),t};Ta.bytes=0;function La(r,t){const e=new Q;let n=mn.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??Ta,o=(t==null?void 0:t.maxLengthLength)??X0,a=(t==null?void 0:t.maxDataLength)??Ia;function*c(){for(;e.byteLength>0;){if(n===mn.LENGTH)try{if(s=i(e),s<0)throw new Z0("Invalid message length");if(s>a)throw new id("Message length too long");const u=i.bytes;e.consume(u),(t==null?void 0:t.onLength)!=null&&t.onLength(s),n=mn.DATA}catch(u){if(u instanceof RangeError){if(e.byteLength>o)throw new Q0("Message length length too long");break}throw u}if(n===mn.DATA){if(e.byteLength<s)break;const u=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(u),yield u,n=mn.LENGTH}}}return ad(r)?async function*(){for await(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new od("Unexpected end of input")}():function*(){for(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new od("Unexpected end of input")}()}La.fromReader=(r,t)=>{let e=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return La(n,{...t??{},onLength:i=>{e=i}})};class Da extends ku{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}}let J0=class extends ku{constructor(t={}){super({...t,sort:(e,n)=>e.options.priority>n.options.priority?-1:e.options.priority<n.options.priority?1:0})}};class j0{constructor(t={}){l(this,"memoryStorage");l(this,"points");l(this,"duration");l(this,"blockDuration");l(this,"keyPrefix");this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new eE}consume(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,e,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+e&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Fb("Rate limit exceeded",o);return o}penalty(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(t,e){const n=e*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(t),s,e),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(t,e,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(t),e,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return e!=null&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return(t==null?void 0:t.customDuration)!=null&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class eE{constructor(){l(this,"storage");this.storage=new Map}incrby(t,e,n){const s=this.storage.get(t);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=e,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(t,e,n)}return this.set(t,e,n)}set(t,e,n){const s=n*1e3,i=this.storage.get(t);i!=null&&clearTimeout(i.timeoutId);const o={value:e,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(t,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(t)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(e!=null)return{remainingPoints:0,msBeforeNext:e.expiresAt!=null?e.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}delete(t){const e=this.storage.get(t);return e!=null?(e.timeoutId!=null&&clearTimeout(e.timeoutId),this.storage.delete(t),!0):!1}}function tE(r,t,e){let n,s,i=!1;function o(){const u={signal:s.signal};if((e==null?void 0:e.timeout)!=null){const d=fn([s.signal,AbortSignal.timeout(e.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,t))})}const a=ii(o,(e==null?void 0:e.debounce)??100);let c=!1;return{setInterval:u=>{t!==u&&(t=u,n!=null&&(clearTimeout(n),n=setTimeout(o,t)))},setTimeout:u=>{e??(e={}),e.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(e==null?void 0:e.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,t))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class nE extends Map{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Tt(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new nE({name:t,metrics:e}):n=new Map,n}class rE{constructor(t,e){l(this,"filter");this.filter=Gr(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){var e,n;(n=(e=this.filter).remove)==null||n.call(e,t.toMultihash().bytes)}}function sE(r,t=.001){return new rE(r,t)}class iE extends Un{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function oE(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new iE({name:t,metrics:e}):n=new Un,n}var fi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&e.payload.byteLength>0&&(n.uint32(26),n.bytes(e.payload)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={publicKey:ae(0),payloadType:ae(0),payload:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=e.bytes();break}case 5:{i.signature=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(fi||(fi={}));class aE extends Error{constructor(t="Invalid signature"){super(t),this.name="InvalidSignatureError"}}const jt=class jt{constructor(t){l(this,"publicKey");l(this,"payloadType");l(this,"payload");l(this,"signature");l(this,"marshaled");const{publicKey:e,payloadType:n,payload:s,signature:i}=t;this.publicKey=e,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=fi.encode({publicKey:It(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(t){return t==null?!1:Ke(this.marshal(),t.marshal())}async validate(t,e){const n=ld(t,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,e)}};l(jt,"createFromProtobuf",t=>{const e=fi.decode(t),n=Ht(e.publicKey);return new jt({publicKey:n,payloadType:e.payloadType,payload:e.payload,signature:e.signature})}),l(jt,"seal",async(t,e,n)=>{if(e==null)throw new Error("Missing private key");const s=t.domain,i=t.codec,o=t.marshal(),a=ld(s,i,o),c=await e.sign(a.subarray(),n);return new jt({publicKey:e.publicKey,payloadType:i,payload:o,signature:c})}),l(jt,"openAndCertify",async(t,e,n)=>{const s=jt.createFromProtobuf(t);if(!await s.validate(e,n))throw new aE("Envelope signature is not valid for the given domain");return s});let pn=jt;const ld=(r,t,e)=>{const n=Y(r),s=Fr(n.byteLength),i=Fr(t.length),o=Fr(e.length);return new Q(s,n,i,t,o,e)},cE="libp2p-peer-record",lE=Uint8Array.from([3,1]);var gi;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.peerId!=null&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),e.seq!=null&&e.seq!==0n&&(n.uint32(16),n.uint64(e.seq)),e.addresses!=null)for(const i of e.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={peerId:ae(0),seq:0n,addresses:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.peerId=e.bytes();break}case 2:{i.seq=e.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Ct('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(gi||(gi={}));function uE(r,t){const e=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==t.length?!1:(t.sort(e),r.sort(e).every((n,s)=>t[s].equals(n)))}const kt=class kt{constructor(t){l(this,"peerId");l(this,"multiaddrs");l(this,"seqNumber");l(this,"domain",kt.DOMAIN);l(this,"codec",kt.CODEC);l(this,"marshaled");const{peerId:e,multiaddrs:n,seqNumber:s}=t;this.peerId=e,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=gi.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(t){return!(!(t instanceof kt)||!this.peerId.equals(t.peerId)||this.seqNumber!==t.seqNumber||!uE(this.multiaddrs,t.multiaddrs))}};l(kt,"createFromProtobuf",t=>{const e=gi.decode(t),n=qr(xr(e.peerId)),s=(e.addresses??[]).map(o=>Z(o.multiaddr)),i=e.seq;return new kt({peerId:n,multiaddrs:s,seqNumber:i})}),l(kt,"DOMAIN",cE),l(kt,"CODEC",lE);let Lt=kt;function dE(r){return r[Symbol.asyncIterator]!=null}function Pa(r){if(dE(r))return(async()=>{const e=[];for await(const n of r)e.push(n);return e})();const t=[];for(const e of r)t.push(e);return t}let jn=(vc=class extends Error{constructor(e="The operation was aborted",...n){super(e,...n);l(this,"name","AbortError")}},l(vc,"name","AbortError"),vc);async function Ra(r,t,e,n){const s=new jn(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(e==null?void 0:e.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Ma(e,"abort",h),Ma(r,t,u),Ma(r,i,d)}const u=f=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,f))===!1)return}catch(g){c(),a(g);return}c(),o(f)},d=f=>{if(c(),f instanceof Error){a(f);return}a(f.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};ka(e,"abort",h),ka(r,t,u),ka(r,i,d)})}function ka(r,t,e){r!=null&&(ud(r)?r.addEventListener(t,e):r.addListener(t,e))}function Ma(r,t,e){r!=null&&(ud(r)?r.removeEventListener(t,e):r.removeListener(t,e))}function ud(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class dd extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}l(dd,"name","QueueFullError");let hd=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function hE(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new hd(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new hd(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class fE{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new jn)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}}function gE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class mE{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=gE(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new jn),this.cleanup())}async join(t={}){var n;const e=new fE(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await hE(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}}function fd(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class gd extends Ye{constructor(e={}){super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"autoStart");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=fd(this.emitEmpty.bind(this),1),this.emitIdle=fd(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new dd;const s=new mE(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new jn)}),this.clear()}async onEmpty(e){this.size!==0&&await Ra(this,"empty",e==null?void 0:e.signal)}async onSizeLessThan(e,n){this.size<e||await Ra(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ra(this,"idle",e==null?void 0:e.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=si({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail.result)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new jn("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}}const md="lock:worker:request-read",pd="lock:worker:abort-read-request",yd="lock:worker:release-read",wd="lock:master:grant-read",bd="lock:master:error-read",Ed="lock:worker:request-write",vd="lock:worker:abort-write-request",Sd="lock:worker:release-write",xd="lock:master:grant-write",Ad="lock:master:error-write",Cd="lock:worker:finalize",_d="mortice",pE={singleProcess:!1},Id=(r,t,e,n,s,i,o,a,c)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(e,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{t.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(h=>{const f=p=>{if((p==null?void 0:p.data)==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===d.identifier&&(t.removeEventListener("message",f),h())};t.addEventListener("message",f)})},onError:h=>{t.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===Cd&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},yE=(r=10)=>Math.random().toString().substring(2,r+2);class wE{constructor(t){l(this,"name");l(this,"channel");this.name=t,this.channel=new BroadcastChannel(_d)}readLock(t){return this.sendRequest(md,pd,wd,bd,yd,t)}writeLock(t){return this.sendRequest(Ed,vd,xd,Ad,Sd,t)}finalize(){this.channel.postMessage({type:Cd,name:this.name}),this.channel.close()}async sendRequest(t,e,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=yE();return this.channel.postMessage({type:t,identifier:a,name:this.name}),new Promise((u,d)=>{var p;const h=()=>{this.channel.postMessage({type:e,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",h,{once:!0});const f=g=>{var y,m,S,v;if(((y=g.data)==null?void 0:y.identifier)===a&&(((m=g.data)==null?void 0:m.type)===n&&(this.channel.removeEventListener("message",f),(S=o==null?void 0:o.signal)==null||S.removeEventListener("abort",h),u(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),g.data.type===s)){this.channel.removeEventListener("message",f),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const E=new Error;g.data.error!=null&&(E.message=g.data.error.message,E.name=g.data.error.name,E.stack=g.data.error.stack),d(E)}};this.channel.addEventListener("message",f)})}}const bE=r=>{if(r=Object.assign({},pE,r),!!globalThis.document||r.singleProcess){const e=new BroadcastChannel(_d),n=new Ye;return e.addEventListener("message",Id(n,e,"requestReadLock","abortReadLockRequest",md,pd,bd,yd,wd)),e.addEventListener("message",Id(n,e,"requestWriteLock","abortWriteLockRequest",Ed,vd,Ad,Sd,xd)),n}return new wE(r.name)},yn=new Map;let es;function Td(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function EE(r){if(es==null&&(es=bE(r),!Td(es))){const t=es;t.addEventListener("requestReadLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=yn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortReadLockRequest",a)})}),t.addEventListener("requestWriteLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=yn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortWriteLockRequest",a)})}),t.addEventListener("finalizeRequest",e=>{const n=e.detail.name,s=yn.get(n);s!=null&&s.finalize()})}return es}async function Na(r,t){var o;let e,n;const s=new Promise((a,c)=>{e=a,n=c}),i=()=>{n(new jn)};return(o=t==null?void 0:t.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{e(()=>{var c;(c=t==null?void 0:t.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:t==null?void 0:t.signal}).catch(a=>{n(a)}),s}const vE=(r,t)=>{let e=yn.get(r);if(e!=null)return e;const n=EE(t);if(Td(n))return e=n,yn.set(r,e),e;const s=new gd({concurrency:1});let i;return e={async readLock(o){if(i!=null)return Na(i,o);i=new gd({concurrency:t.concurrency,autoStart:!1});const a=i,c=Na(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Na(s,o)},finalize:()=>{yn.delete(r)},queue:s},yn.set(r,e),t.autoFinalize===!0&&s.addEventListener("idle",()=>{e.finalize()},{once:!0}),e},SE={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function xE(r){const t=Object.assign({},SE,r);return vE(t.name,t)}const AE=36e5,CE=216e5;var wn;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),pi.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var u;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=pi.codec().decode(s,s.uint32(),{limits:(u=o.limits)==null?void 0:u.value});break}default:{s.skipType(d&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.addresses!=null)for(const i of e.addresses)n.uint32(10),mi.codec().encode(i,n);if(e.protocols!=null)for(const i of e.protocols)n.uint32(18),n.string(i);if(e.publicKey!=null&&(n.uint32(34),n.bytes(e.publicKey)),e.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),e.metadata!=null&&e.metadata.size!==0)for(const[i,o]of e.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(e.tags!=null&&e.tags.size!==0)for(const[i,o]of e.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);e.updated!=null&&(n.uint32(64),n.uint64Number(e.updated)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c,u,d,h,f;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const p=e.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Ct('Decode error - map field "addresses" had too many elements');i.addresses.push(mi.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((u=s.limits)==null?void 0:u.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Ct('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 4:{i.publicKey=e.bytes();break}case 5:{i.peerRecordEnvelope=e.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new Xl('Decode error - map field "metadata" had too many elements');const g=r.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(g.key,g.value);break}case 7:{if(((h=s.limits)==null?void 0:h.tags)!=null&&i.tags.size===s.limits.tags)throw new Xl('Decode error - map field "tags" had too many elements');const g=r.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:(f=s.limits)==null?void 0:f.tags$value}});i.tags.set(g.key,g.value);break}case 8:{i.updated=e.uint64Number();break}default:{e.skipType(p&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(wn||(wn={}));var mi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.multiaddr!=null&&e.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(e.multiaddr)),e.isCertified!=null&&(n.uint32(16),n.bool(e.isCertified)),e.observed!=null&&(n.uint32(24),n.uint64Number(e.observed)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={multiaddr:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.multiaddr=e.bytes();break}case 2:{i.isCertified=e.bool();break}case 3:{i.observed=e.uint64Number();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(mi||(mi={}));var pi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.value!=null&&e.value!==0&&(n.uint32(8),n.uint32(e.value)),e.expiry!=null&&(n.uint32(16),n.uint64(e.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={value:0},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.value=e.uint32();break}case 2:{i.expiry=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(pi||(pi={}));function _E(r,t){if(r.publicKey!=null||t.publicKey==null)return r;let e;r.type==="RSA"&&(e=r.toMultihash());const n=Ht(t.publicKey,e);return zr(n)}function IE(r,t,e){const n=wn.decode(t);return ts(r,n,e)}function ts(r,t,e){const n=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...t,id:_E(r,t),addresses:t.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-e).map(({multiaddr:i,isCertified:o})=>({multiaddr:Z(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function TE(r,t){return LE(r.addresses,t.addresses)&&DE(r.protocols,t.protocols)&&PE(r.publicKey,t.publicKey)&&RE(r.peerRecordEnvelope,t.peerRecordEnvelope)&&kE(r.metadata,t.metadata)&&ME(r.tags,t.tags)}function LE(r,t){return Dd(r,t,(e,n)=>!(e.isCertified!==n.isCertified||!Ke(e.multiaddr,n.multiaddr)))}function DE(r,t){return Dd(r,t,(e,n)=>e===n)}function PE(r,t){return Ld(r,t)}function RE(r,t){return Ld(r,t)}function kE(r,t){return Pd(r,t,(e,n)=>Ke(e,n))}function ME(r,t){return Pd(r,t,(e,n)=>e.value===n.value&&e.expiry===n.expiry)}function Ld(r,t){return r==null&&t==null?!0:r!=null&&t!=null?Ke(r,t):!1}function Dd(r,t,e){if(r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(!e(r[n],t[n]))return!1;return!0}function Pd(r,t,e){if(r.size!==t.size)return!1;for(const[n,s]of r.entries()){const i=t.get(n);if(i==null||!e(s,i))return!1}return!0}const Dt="/",Rd=new TextEncoder().encode(Dt),yi=Rd[0];class Ve{constructor(t,e){l(this,"_buf");if(typeof t=="string")this._buf=Y(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==yi)throw new Error("Invalid key")}toString(t="utf8"){return J(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new Ve(t.join(Dt))}static random(){return new Ve(Math.random().toString().substring(2))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new Ve(t):typeof t.uint8Array=="function"?new Ve(t.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Rd),this._buf[0]!==yi){const t=new Uint8Array(this._buf.byteLength+1);t.fill(yi,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===yi;)this._buf=this._buf.subarray(0,-1)}less(t){const e=this.list(),n=t.list();for(let s=0;s<e.length;s++){if(n.length<s+1)return!1;const i=e[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return e.length<n.length}reverse(){return Ve.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(Dt).slice(1)}type(){return NE(this.baseNamespace())}name(){return OE(this.baseNamespace())}instance(t){return new Ve(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(Dt)||(t+=Dt),t+=this.type(),new Ve(t)}parent(){const t=this.list();return t.length===1?new Ve(Dt):new Ve(t.slice(0,-1).join(Dt))}child(t){return this.toString()===Dt?t:t.toString()===Dt?this:new Ve(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return Ve.withNamespaces([...this.namespaces(),...FE(t.map(e=>e.namespaces()))])}}function NE(r){const t=r.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function OE(r){const t=r.split(":");return t[t.length-1]}function FE(r){return[].concat(...r)}const kd="/peers/";function wi(r){if(!vr(r)||r.type==null)throw new G("Invalid PeerId");const t=r.toCID().toString();return new Ve(`${kd}${t}`)}async function BE(r,t,e,n,s){const i=new Map;for(const o of e){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=Z(o.multiaddr)),!ui(o.multiaddr))throw new G("Multiaddr was invalid");if(!await t(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var u;const c=(u=a.getComponents().find(d=>d.code===H))==null?void 0:u.value;return r.equals(c)&&(a=a.decapsulate(Z(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function Oa(r,t,e,n){var f,p;if(t==null)throw new G("Invalid PeerData");if(t.publicKey!=null&&r.publicKey!=null&&!t.publicKey.equals(r.publicKey))throw new G("publicKey bytes do not match peer id publicKey bytes");const s=(f=n.existingPeer)==null?void 0:f.peer;if(s!=null&&!r.equals(s.id))throw new G("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,u=s==null?void 0:s.peerRecordEnvelope;if(e==="patch"){if((t.multiaddrs!=null||t.addresses!=null)&&(i=[],t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses)),t.protocols!=null&&(o=new Set(t.protocols)),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);a=bi(g,{validate:Md})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags);c=bi(g,{validate:Nd,map:Od})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}if(e==="merge"){if(t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses),t.protocols!=null&&(o=new Set([...o,...t.protocols])),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[y,m]of g)m==null?a.delete(y):a.set(y,m);a=bi([...a.entries()],{validate:Md})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),y=new Map(c);for(const[m,S]of g)S==null?y.delete(m):y.set(m,S);c=bi([...y.entries()],{validate:Nd,map:Od})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=It(s.id.publicKey):t.publicKey!=null?d=It(t.publicKey):r.publicKey!=null&&(d=It(r.publicKey));const h={addresses:await BE(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((g,y)=>g.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(g=>{var y,m,S;g.observed=((S=(m=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:m.find(v=>Ke(v.multiaddr,v.multiaddr)))==null?void 0:S.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function bi(r,t){var n;const e=new Map;for(const[s,i]of r)i!=null&&t.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&e.set(s,((n=t.map)==null?void 0:n.call(t,s,i))??i);return e}function Md(r,t){if(typeof r!="string")throw new G("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new G("Metadata value must be a Uint8Array")}function Nd(r,t){if(typeof r!="string")throw new G("Tag name must be a string");if(t.value!=null){if(parseInt(`${t.value}`,10)!==t.value)throw new G("Tag value must be an integer");if(t.value<0||t.value>100)throw new G("Tag value must be between 0-100")}if(t.ttl!=null){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new G("Tag ttl must be an integer");if(t.ttl<0)throw new G("Tag ttl must be between greater than 0")}}function Od(r,t){let e;t.expiry!=null&&(e=t.expiry),t.ttl!=null&&(e=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return e!=null&&(n.expiry=e),n}function Fd(r){const t=r.toString().split("/")[2],e=pe.parse(t,Ot);return Kr(e)}function Fa(r,t,e){const n=Fd(r);return IE(n,t,e)}function $E(r,t){return{prefix:kd,filters:(r.filters??[]).map(e=>({key:n,value:s})=>e(Fa(n,s,t))),orders:(r.orders??[]).map(e=>(n,s)=>e(Fa(n.key,n.value,t),Fa(s.key,s.value,t)))}}class UE{constructor(t,e={}){ce(this,Je);l(this,"peerId");l(this,"datastore");l(this,"locks");l(this,"addressFilter");l(this,"log");l(this,"maxAddressAge");l(this,"maxPeerAge");this.log=t.logger.forComponent("libp2p:peer-store"),this.peerId=t.peerId,this.datastore=t.datastore,this.addressFilter=e.addressFilter,this.locks=oE({name:"libp2p_peer_store_locks",metrics:t.metrics}),this.maxAddressAge=e.maxAddressAge??AE,this.maxPeerAge=e.maxPeerAge??CE}getLock(t){let e=this.locks.get(t);return e==null&&(e={refs:0,lock:xE({name:t.toString(),singleProcess:!0})},this.locks.set(t,e)),e.refs++,e}maybeRemoveLock(t,e){e.refs--,e.refs===0&&(e.lock.finalize(),this.locks.delete(t))}async getReadLock(t,e){const n=this.getLock(t);try{const s=await n.lock.readLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async getWriteLock(t,e){const n=this.getLock(t);try{const s=await n.lock.writeLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async has(t,e){try{return await this.load(t,e),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(t,e){this.peerId.equals(t)||await this.datastore.delete(wi(t),e)}async load(t,e){const n=wi(t),s=await this.datastore.get(n,e),i=wn.decode(s);if(z(this,Je,no).call(this,t,i))throw await this.datastore.delete(n,e),new lo;return ts(t,i,this.peerId.equals(t)?1/0:this.maxAddressAge)}async save(t,e,n){const s=await z(this,Je,eo).call(this,t,n),i=await Oa(t,e,"patch",{...n,addressFilter:this.addressFilter});return z(this,Je,to).call(this,t,i,s)}async patch(t,e,n){const s=await z(this,Je,eo).call(this,t,n),i=await Oa(t,e,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return z(this,Je,to).call(this,t,i,s)}async merge(t,e,n){const s=await z(this,Je,eo).call(this,t,n),i=await Oa(t,e,"merge",{addressFilter:this.addressFilter,existingPeer:s});return z(this,Je,to).call(this,t,i,s)}async*all(t){for await(const{key:e,value:n}of this.datastore.query($E(t??{},this.maxAddressAge),t)){const s=Fd(e);if(s.equals(this.peerId))continue;const i=wn.decode(n);if(z(this,Je,no).call(this,s,i)){await this.datastore.delete(e,t);continue}yield ts(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Je=new WeakSet,eo=async function(t,e){try{const n=wi(t),s=await this.datastore.get(n,e),i=wn.decode(s);if(z(this,Je,no).call(this,t,i))throw await this.datastore.delete(n,e),new lo;return{peerPB:i,peer:ts(t,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},to=async function(t,e,n,s){e.updated=Date.now();const i=wn.encode(e);return await this.datastore.put(wi(t),i,s),{peer:ts(t,e,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!TE(e,n.peerPB)}},no=function(t,e){if(e.updated==null)return!0;if(this.peerId.equals(t))return!1;const n=e.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=e.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0},Gf=Symbol.toStringTag;class zE{constructor(t,e={}){ce(this,dr);l(this,"store");l(this,"events");l(this,"peerId");l(this,"log");l(this,Gf,"@libp2p/peer-store");this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new UE(t,e)}async forEach(t,e){for await(const n of this.store.all(e))t(n)}async all(t){return Pa(this.store.all(t))}async delete(t,e){const n=await this.store.getReadLock(t,e);try{await this.store.delete(t,e)}finally{n()}}async has(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.has(t,e)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.load(t,e)}finally{n==null||n()}}async getInfo(t,e){const n=await this.get(t,e);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.save(t,e,n);return z(this,dr,ro).call(this,t,i),i.peer}finally{s==null||s()}}async patch(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.patch(t,e,n);return z(this,dr,ro).call(this,t,i),i.peer}finally{s==null||s()}}async merge(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.merge(t,e,n);return z(this,dr,ro).call(this,t,i),i.peer}finally{s==null||s()}}async consumePeerRecord(t,e,n){const s=vr(e)?e:vr(e==null?void 0:e.expectedPeer)?e.expectedPeer:void 0,i=vr(e)||e===void 0?n:e,o=await pn.openAndCertify(t,Lt.DOMAIN,i),a=Kr(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=Lt.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((u==null?void 0:u.peerRecordEnvelope)!=null){const d=pn.createFromProtobuf(u.peerRecordEnvelope),h=Lt.createFromProtobuf(d.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:t,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}dr=new WeakSet,ro=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};function qE(r,t={}){return new zE(r,t)}const hr=class hr extends Error{constructor(e="Not Found"){super(e);l(this,"name",hr.name);l(this,"code",hr.code)}};l(hr,"name","NotFoundError"),l(hr,"code","ERR_NOT_FOUND");let Ba=hr;function KE(r){return r[Symbol.asyncIterator]!=null}function Bd(r){if(KE(r))return(async()=>{for await(const t of r);})();for(const t of r);}function VE(r){const[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[e](){return this}}}function WE(r){return r[Symbol.asyncIterator]!=null}function er(r,t){let e=0;if(WE(r))return async function*(){for await(const c of r)await t(c,e++)&&(yield c)}();const n=VE(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await t(c,e++)&&(yield c)}();const a=t;return function*(){o===!0&&(yield s);for(const c of n)a(c,e++)&&(yield c)}()}function HE(r){return r[Symbol.asyncIterator]!=null}function $d(r,t){return HE(r)?async function*(){yield*(await Pa(r)).sort(t)}():function*(){yield*Pa(r).sort(t)}()}function GE(r){return r[Symbol.asyncIterator]!=null}function Ud(r,t){return GE(r)?async function*(){let e=0;if(!(t<1)){for await(const n of r)if(yield n,e++,e===t)return}}():function*(){let e=0;if(!(t<1)){for(const n of r)if(yield n,e++,e===t)return}}()}class YE{put(t,e,n){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:n,value:s}of t)await this.put(n,s,e),yield n}async*getMany(t,e={}){for await(const n of t)yield{key:n,value:await this.get(n,e)}}async*deleteMany(t,e={}){for await(const n of t)await this.delete(n,e),yield n}batch(){let t=[],e=[];return{put(n,s){t.push({key:n,value:s})},delete(n){e.push(n)},commit:async n=>{await Bd(this.putMany(t,n)),t=[],await Bd(this.deleteMany(e,n)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let n=this._all(t,e);if(t.prefix!=null){const s=t.prefix;n=er(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>er(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>$d(s,i),n)),t.offset!=null){let s=0;const i=t.offset;n=er(n,()=>s++>=i)}return t.limit!=null&&(n=Ud(n,t.limit)),n}queryKeys(t,e){let n=this._allKeys(t,e);if(t.prefix!=null){const s=t.prefix;n=er(n,i=>i.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>er(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>$d(s,i),n)),t.offset!=null){const s=t.offset;let i=0;n=er(n,()=>i++>=s)}return t.limit!=null&&(n=Ud(n,t.limit)),n}}class XE extends YE{constructor(){super();l(this,"data");this.data=new Map}put(e,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(e.toString(),n),e}get(e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(e.toString());if(s==null)throw new Ba;return s}has(e,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(e.toString())}delete(e,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(e.toString())}*_all(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new Ve(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new Ve(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const he=r=>({match:t=>{const e=t[0];return e==null||e.code!==r||e.value!=null?!1:t.slice(1)}}),V=(r,t)=>({match:e=>{const n=e[0];return(n==null?void 0:n.code)!==r||n.value==null||t!=null&&n.value!==t?!1:e.slice(1)}}),ZE=r=>({match:t=>r.match(t)===!1?t:!1}),j=r=>({match:t=>{const e=r.match(t);return e===!1?t:e}}),We=(...r)=>({match:t=>{let e;for(const n of r){const s=n.match(t);s!==!1&&(e==null||s.length<e.length)&&(e=s)}return e??!1}}),ie=(...r)=>({match:t=>{for(const e of r){const n=e.match(t);if(n===!1)return!1;t=n}return t}});function fe(...r){function t(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function e(s){return t(s)!==!1}function n(s){const i=t(s);return i===!1?!1:i.length===0}return{matchers:r,matches:e,exactMatch:n}}const QE=V(H),JE=fe(QE),Ei=V(zu),vi=V(qu),Si=V(Ku),$a=V(Uu);fe(Ei,j(V(H))),fe(vi,j(V(H))),fe(Si,j(V(H))),fe(We($a,Si,Ei,vi),j(V(H)));const zd=ie(V(ai),j(V(ba))),qd=ie(j(V(wa)),V(Gn),j(V(ba))),Ua=We(zd,qd),bn=We(Ua,$a,Ei,vi,Si),jE=fe(We(Ua,ie(We($a,Si,Ei,vi),j(V(H))))),Kd=fe(zd),Vd=fe(qd);fe(Ua);const za=ie(bn,V(Hn)),ns=ie(bn,V($u)),xi=fe(ie(za,j(V(H))));fe(ns);const qa=ie(ns,he(Wu),j(V(H))),Ai=ie(ns,he(Hu),j(V(H))),ev=We(qa,Ai);fe(qa);const tv=fe(Ai),Ka=We(bn,za,ns,qa,Ai),Wd=We(ie(Ka,he(va),j(V(H)))),Ci=fe(Wd),Hd=We(ie(Ka,he(Yu),j(V(H))),ie(Ka,he(Yn),j(V(ci)),he(va),j(V(H)))),Va=fe(Hd),Gd=ie(ns,he(Xu),j(V(Zr)),j(V(Zr)),j(V(H))),Yd=fe(Gd),Xd=ie(Ai,he(Gu),j(V(Zr)),j(V(Zr)),j(V(H))),Zd=fe(Xd),_i=We(Wd,Hd,ie(za,j(V(H))),ie(ev,j(V(H))),ie(bn,j(V(H))),Gd,Xd,V(H)),Wa=fe(_i),nv=ie(j(_i),he(Zn),ZE(he(Qr)),j(V(H))),tr=fe(nv),rv=We(ie(_i,he(Zn),he(Qr),j(V(H))),ie(_i,he(Qr),j(V(H))),ie(he(Qr),j(V(H)))),Ha=fe(rv),sv=We(ie(bn,V(Hn),he(Xn),j(V(H))),ie(bn,he(Xn),j(V(H))));fe(sv);const iv=ie(bn,We(ie(V(Hn,"443"),he(Xn)),ie(V(Hn),he(Ea)),ie(V(Hn),he(Yn),he(Xn)),ie(he(Yn),he(Xn)),he(Yn),he(Ea)),j(V(H)));fe(iv);const ov=We(ie(V(Zu),j(V(H))));fe(ov);const av=We(ie(V(Vu),j(V(H))));fe(av);const Qd=864e13;class cv{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Tt({name:"libp2p_address_manager_dns_mappings",metrics:t.metrics})}has(t){const e=ye(t);let n=e.host;(e.type==="ip4"||e.type==="ip6")&&e.sni!=null&&(n=e.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(t,e){e.forEach(n=>{this.log("add DNS mapping %s to %s",n,t);const s=ga(n)===!0;this.mappings.set(n,{domain:t,verified:s,expires:s?Qd-Date.now():0,lastVerified:s?Qd-Date.now():void 0})})}remove(t){const e=ye(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===e.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(t){const e=[];for(let n=0;n<t.length;n++){const s=t[n].multiaddr;if(!ct(s))continue;const i=ye(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(t.splice(n,1),n--,e.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return e}maybeAddSNIComponent(t,e){var s;const n=t.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===Yn&&((s=n[i+1])==null?void 0:s.code)!==ci)return n.splice(i+1,0,{name:"sni",code:ci,value:e}),Z(n)}confirm(t,e){const n=ye(t);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+e,a.lastVerified=Date.now());return i}unconfirm(t,e){const n=ye(t);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+e);return i}}class lv{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Tt({name:"libp2p_address_manager_ip_mappings",metrics:t.metrics})}has(t){const e=ye(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===e.host)return!0;return!1}add(t,e,n,s=e,i="tcp"){const o=`${t}-${e}-${i}`,a=this.mappings.get(o)??[],c={internalIp:t,internalPort:e,externalIp:n,externalPort:s,externalFamily:Kn(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(t){const e=ye(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===e.host&&a.externalPort===e.port&&a.protocol===e.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,e.host,e.port,e.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(t){const e=[];for(const{multiaddr:n}of t){if(!ct(n))continue;const s=ye(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)e.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return e}maybeOverrideIp(t,e,n,s,i){const o=t.getComponents(),a=o.findIndex(u=>u.code===ai||u.code===Gn),c=o.findIndex(u=>u.name===s);return a>-1&&c>-1?(o[a].value=e,o[a].code=n===4?ai:Gn,o[c].value=`${i}`,Z(o)):t}confirm(t,e){if(!ct(t))return!1;const n=ye(t);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+e,o.lastVerified=Date.now());return s}unconfirm(t,e){if(!ct(t))return!1;const n=ye(t);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+e)}return s}}const uv={maxObservedAddresses:10};class dv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Tt({name:"libp2p_address_manager_observed_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??uv.maxObservedAddresses}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(Vn(t)||vb(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:Z(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var n;const e=((n=this.addresses.get(t.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),e}confirm(t,e){const n=t.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const hv={maxObservedAddresses:10};class fv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Tt({name:"libp2p_address_manager_transport_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??hv.maxObservedAddresses}get(t,e){if(Vn(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const n=this.toKey(t);let s=this.addresses.get(n);return s==null&&(s={verified:!ct(t),expires:0},this.addresses.set(n,s)),{multiaddr:t,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var s;const e=this.toKey(t),n=((s=this.addresses.get(e))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(e),n}confirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+e,this.addresses.set(n,s),i}toKey(t){if(!ct(t))return t.toString();const e=ye(t);return`${e.host}-${e.port}-${e.protocol}`}}const Jd=6e4,jd={addressVerificationTTL:Jd*10,addressVerificationRetry:Jd*5},gv=r=>r;function Ga(r,t){var n;const e=(n=r.getComponents().findLast(s=>s.code===H))==null?void 0:n.value;return e!=null&&at(e).equals(t)&&(r=r.decapsulate(Z(`/p2p/${t.toString()}`))),r}Yf=Symbol.toStringTag;class mv{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"listen");l(this,"announce");l(this,"appendAnnounce");l(this,"announceFilter");l(this,"observed");l(this,"dnsMappings");l(this,"ipMappings");l(this,"transportAddresses");l(this,"observedAddressFilter");l(this,"addressVerificationTTL");l(this,"addressVerificationRetry");l(this,Yf,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new dv(t,e),this.dnsMappings=new cv(t,e),this.ipMappings=new lv(t,e),this.transportAddresses=new fv(t,e),this.announceFilter=e.announceFilter??gv,this.observedAddressFilter=Gr(1024),this.addressVerificationTTL=e.addressVerificationTTL??jd.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??jd.addressVerificationRetry,this._updatePeerStoreAddresses=ii(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(e=>{var n;return((n=e.getComponents().findLast(s=>s.code===H))==null?void 0:n.value)===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e});this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(e=>{this.log.error("error updating addresses - %e",e)})}getListenAddrs(){return Array.from(this.listen).map(t=>Z(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>Z(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>Z(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=ye(t);let n;switch(e.type){case"ip4":{n=`${e.host}:${e.port}`;break}case"ip6":{n=`[${e.host}]:${e.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),t=Ga(t,this.components.peerId),!this.ipMappings.has(t)&&(this.dnsMappings.has(t)||this.observed.add(t)))}confirmObservedAddr(t,e){t=Ga(t,this.components.peerId);let n=!0;((e==null?void 0:e.type)==="transport"||this.transportAddresses.has(t))&&!this.transportAddresses.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="dns-mapping"||this.dnsMappings.has(t))&&!this.dnsMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="ip-mapping"||this.ipMappings.has(t))&&!this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="observed"||this.observed.has(t))&&(this.maybeUpgradeToIPMapping(t)?(this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=Ga(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(e.map(n=>{const s=Z(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(t)}),t.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];e=e.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),e=e.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(Z(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.add(t,e,n,s,i),this.observed.removePrefixed(`/ip${Kn(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.remove(Z(`/ip${Kn(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t)||!ct(t))return!1;const e=ye(t);if(e.type!=="ip4"||ga(e.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>Ci.exactMatch(i)||Va.exactMatch(i),i=>xi.exactMatch(i),i=>tv.exactMatch(i)];for(const i of s){if(!i(t))continue;const o=n.filter(u=>u.getAddrs().filter(d=>ye(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!ha(u)).pop();if(a==null)continue;const c=ye(a);return c.port==null?!1:(this.observed.remove(t),this.ipMappings.add(c.host,c.port,e.host,e.port,e.protocol),!0)}return!1}}var eh;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(eh||(eh={}));class pv extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class yv extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class Ya extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class th extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class wv extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class bv extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class Ev extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class nh extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class vv extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class Sv extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class xv extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class Av extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class Cv extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class Ii extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class Ti extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class _v extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class Iv extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}class Tv{constructor(t={}){l(this,"components",{});l(this,"_started",!1);this.components={};for(const[e,n]of Object.entries(t))this.components[e]=n;this.components.logger==null&&(this.components.logger=hu())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(e=>yo(e)).map(async e=>{var n;await((n=e[t])==null?void 0:n.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Lv=["metrics","connectionProtector","dns"],Dv=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Pv(r={}){const t=new Tv(r);return new Proxy(t,{get(n,s,i){if(typeof s=="string"&&!Dv.includes(s)){const o=t.components[s];if(o==null&&!Lv.includes(s))throw new pv(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?t.components[s]=i:Reflect.set(n,s,i),!0}})}function Rv(r){const t={};for(const e of Object.values(r.components))for(const n of kv(e))t[n]=!0;for(const e of Object.values(r.components))for(const n of Mv(e))if(t[n]!==!0)throw new yv(`Service "${Nv(e)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function kv(r){return Array.isArray(r==null?void 0:r[St])?r[St]:[]}function Mv(r){return Array.isArray(r==null?void 0:r[xs])?r[xs]:[]}function Nv(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function Ov(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=t=>Ci.matches(t)?!0:Vn(t)),r}class ge extends Event{constructor(e,n){super(e);l(this,"type");l(this,"detail");this.type=e,this.detail=n}}function rh(r){var n;if(vr(r))return{peerId:r,multiaddrs:[]};let t=Array.isArray(r)?r:[r],e;if(t.length>0){const s=(n=t[0].getComponents().findLast(i=>i.code===H))==null?void 0:n.value;e=s==null?void 0:at(s),t.forEach(i=>{var a;if(!ui(i))throw new ws("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===H))==null?void 0:a.value;if(o==null){if(e!=null)throw new G("Multiaddrs must all have the same peer id or have no peer id")}else{const c=at(o);if((e==null?void 0:e.equals(c))!==!0)throw new G("Multiaddrs must all have the same peer id or have no peer id")}})}return t=t.filter(s=>!JE.exactMatch(s)),{peerId:e,multiaddrs:t}}const Fv=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function Bv(r,t){var s;const e=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(t==null?void 0:t.closableProtocols)??Fv;if(!(e.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(t))}catch(i){r==null||r.abort(i)}}function Xa(r){const t=ye(r);let e=t.cidr;if(t.type!=="ip4"&&t.type!=="ip6")throw new G(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(e==null)switch(t.type){case"ip4":{e=32;break}case"ip6":{e=128;break}default:throw new G(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new Au(t.host,e)}function sh(r){return!tr.exactMatch(r)}function ih(r,t,e){if(r==null||t==null)return;const n=t.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||e==null)return n;if(!e.some(i=>sh(i)))return n}class $v{constructor(t,e={}){l(this,"connectionManager");l(this,"peerStore");l(this,"allow");l(this,"events");l(this,"log");this.allow=(e.allow??[]).map(n=>Xa(n)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections - %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",e,n),e<=n)return;const s=new Un;for(const c of t){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,f)=>h+f.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(t,s),o=Math.max(e-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(ct(c.remoteAddr)){const h=ye(c.remoteAddr);return d.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await Bv(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(t,e){return t.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=e.get(n.remotePeer)??0,o=e.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const oh=1e4,ah=1e3,Uv=1e4,Li=1e4,ch=25,zv=5,qv=10,Kv=5,Vv="last-dial-failure",Wv="last-dial-success",lh=500,Hv=32,Gv=100,uh=50;function Yv(r,t){const e=xi.exactMatch(r.multiaddr),n=xi.exactMatch(t.multiaddr);if(e&&!n)return-1;if(!e&&n)return 1;const s=Va.exactMatch(r.multiaddr),i=Va.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=Ci.exactMatch(r.multiaddr),a=Ci.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Ha.exactMatch(r.multiaddr),u=Ha.exactMatch(t.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const d=Yd.exactMatch(r.multiaddr),h=Yd.exactMatch(t.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const f=Zd.exactMatch(r.multiaddr),p=Zd.exactMatch(t.multiaddr);return f&&!p?-1:!f&&p?1:0}function Xv(r,t){const e=ha(r.multiaddr),n=ha(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Zv(r,t){const e=Vn(r.multiaddr),n=Vn(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Qv(r,t){return r.isCertified&&!t.isCertified?-1:!r.isCertified&&t.isCertified?1:0}function Jv(r,t){const e=tr.exactMatch(r.multiaddr),n=tr.exactMatch(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function jv(r){return r.sort(Yv).sort(Qv).sort(Jv).sort(Zv).sort(Xv)}var dh={exports:{}};(function(r){var t=Object.prototype.hasOwnProperty,e="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(e=!1));function s(c,u,d){this.fn=c,this.context=u,this.once=d||!1}function i(c,u,d,h,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||c,f),g=e?e+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)t.call(d,h)&&u.push(e?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=e?e+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var f=0,p=h.length,g=new Array(p);f<p;f++)g[f]=h[f].fn;return g},a.prototype.listenerCount=function(u){var d=e?e+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,f,p,g){var y=e?e+u:u;if(!this._events[y])return!1;var m=this._events[y],S=arguments.length,v,E;if(m.fn){switch(m.once&&this.removeListener(u,m.fn,void 0,!0),S){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,d),!0;case 3:return m.fn.call(m.context,d,h),!0;case 4:return m.fn.call(m.context,d,h,f),!0;case 5:return m.fn.call(m.context,d,h,f,p),!0;case 6:return m.fn.call(m.context,d,h,f,p,g),!0}for(E=1,v=new Array(S-1);E<S;E++)v[E-1]=arguments[E];m.fn.apply(m.context,v)}else{var L=m.length,x;for(E=0;E<L;E++)switch(m[E].once&&this.removeListener(u,m[E].fn,void 0,!0),S){case 1:m[E].fn.call(m[E].context);break;case 2:m[E].fn.call(m[E].context,d);break;case 3:m[E].fn.call(m[E].context,d,h);break;case 4:m[E].fn.call(m[E].context,d,h,f);break;default:if(!v)for(x=1,v=new Array(S-1);x<S;x++)v[x-1]=arguments[x];m[E].fn.apply(m[E].context,v)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,f){var p=e?e+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===d&&(!f||g.once)&&(!h||g.context===h)&&o(this,p);else{for(var y=0,m=[],S=g.length;y<S;y++)(g[y].fn!==d||f&&!g[y].once||h&&g[y].context!==h)&&m.push(g[y]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=e?e+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,r.exports=a})(dh);var eS=dh.exports;const tS=_u(eS);class Za extends Error{constructor(e,n){var s;super(e,n);l(this,"name","TimeoutError");(s=Error.captureStackTrace)==null||s.call(Error,this,Za)}}const hh=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function nS(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout},signal:o}=t;let a,c;const d=new Promise((h,f)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(o!=null&&o.aborted){f(hh(o));return}if(o&&(c=()=>{f(hh(o))},o.addEventListener("abort",c,{once:!0})),r.then(h,f),e===Number.POSITIVE_INFINITY)return;const p=new Za;a=i.setTimeout.call(void 0,()=>{if(n){try{h(n())}catch(g){f(g)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?h():s instanceof Error?f(s):(p.message=s??`Promise timed out after ${e} milliseconds`,f(p))},e)}).finally(()=>{d.clear(),c&&o&&o.removeEventListener("abort",c)});return d.clear=()=>{i.clearTimeout.call(void 0,a),a=void 0},d}function rS(r,t,e){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;e(r[o],t)<=0?(n=++o,s-=i+1):s=i}return n}class sS{constructor(){ce(this,st,[])}enqueue(t,e){const{priority:n=0,id:s}=e??{},i={priority:n,id:s,run:t};if(this.size===0||D(this,st)[this.size-1].priority>=n){D(this,st).push(i);return}const o=rS(D(this,st),i,(a,c)=>c.priority-a.priority);D(this,st).splice(o,0,i)}setPriority(t,e){const n=D(this,st).findIndex(i=>i.id===t);if(n===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[s]=D(this,st).splice(n,1);this.enqueue(s.run,{priority:e,id:t})}dequeue(){const t=D(this,st).shift();return t==null?void 0:t.run}filter(t){return D(this,st).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return D(this,st).length}}st=new WeakMap;class iS extends tS{constructor(e){var n,s;super();ce(this,q);ce(this,fr);ce(this,ht);ce(this,Et,0);ce(this,gr);ce(this,mr,!1);ce(this,pr,!1);ce(this,en);ce(this,ls,0);ce(this,yr,0);ce(this,vt);ce(this,Mt);ce(this,Ie);ce(this,us);ce(this,qe,0);ce(this,xn);ce(this,Nt);ce(this,Qi,1n);ce(this,An,new Map);l(this,"timeout");if(e={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:sS,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=e.intervalCap)==null?void 0:n.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=e.interval)==null?void 0:s.toString())??""}\` (${typeof e.interval})`);if(ue(this,fr,e.carryoverIntervalCount??e.carryoverConcurrencyCount??!1),ue(this,ht,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),ue(this,gr,e.intervalCap),ue(this,en,e.interval),ue(this,Ie,new e.queueClass),ue(this,us,e.queueClass),this.concurrency=e.concurrency,e.timeout!==void 0&&!(Number.isFinite(e.timeout)&&e.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${e.timeout}\` (${typeof e.timeout})`);this.timeout=e.timeout,ue(this,Nt,e.autoStart===!1),z(this,q,$g).call(this)}get concurrency(){return D(this,xn)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);ue(this,xn,e),z(this,q,io).call(this)}setPriority(e,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);D(this,Ie).setPriority(e,n)}async add(e,n={}){return n.id??(n.id=(wr(this,Qi)._++).toString()),n={timeout:this.timeout,...n},new Promise((s,i)=>{const o=Symbol(`task-${n.id}`);D(this,Ie).enqueue(async()=>{var a;wr(this,qe)._++,D(this,An).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});try{try{(a=n.signal)==null||a.throwIfAborted()}catch(d){throw D(this,ht)||wr(this,Et)._--,D(this,An).delete(o),d}let c=e({signal:n.signal});n.timeout&&(c=nS(Promise.resolve(c),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${D(this,qe)} running, ${D(this,Ie).size} waiting)`})),n.signal&&(c=Promise.race([c,z(this,q,Bg).call(this,n.signal)]));const u=await c;s(u),this.emit("completed",u)}catch(c){i(c),this.emit("error",c)}finally{D(this,An).delete(o),queueMicrotask(()=>{z(this,q,Mg).call(this)})}},n),this.emit("add"),z(this,q,so).call(this)})}async addAll(e,n){return Promise.all(e.map(async s=>this.add(s,n)))}start(){return D(this,Nt)?(ue(this,Nt,!1),z(this,q,io).call(this),this):this}pause(){ue(this,Nt,!0)}clear(){ue(this,Ie,new(D(this,us))),z(this,q,Ic).call(this)}async onEmpty(){D(this,Ie).size!==0&&await z(this,q,Cn).call(this,"empty")}async onSizeLessThan(e){D(this,Ie).size<e||await z(this,q,Cn).call(this,"next",()=>D(this,Ie).size<e)}async onIdle(){D(this,qe)===0&&D(this,Ie).size===0||await z(this,q,Cn).call(this,"idle")}async onPendingZero(){D(this,qe)!==0&&await z(this,q,Cn).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await z(this,q,Cn).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await z(this,q,Cn).call(this,"rateLimitCleared")}async onError(){return new Promise((e,n)=>{const s=i=>{this.off("error",s),n(i)};this.on("error",s)})}get size(){return D(this,Ie).size}sizeBy(e){return D(this,Ie).filter(e).length}get pending(){return D(this,qe)}get isPaused(){return D(this,Nt)}get isRateLimited(){return D(this,mr)}get isSaturated(){return D(this,qe)===D(this,xn)&&D(this,Ie).size>0||this.isRateLimited&&D(this,Ie).size>0}get runningTasks(){return[...D(this,An).values()].map(e=>({...e}))}}fr=new WeakMap,ht=new WeakMap,Et=new WeakMap,gr=new WeakMap,mr=new WeakMap,pr=new WeakMap,en=new WeakMap,ls=new WeakMap,yr=new WeakMap,vt=new WeakMap,Mt=new WeakMap,Ie=new WeakMap,us=new WeakMap,qe=new WeakMap,xn=new WeakMap,Nt=new WeakMap,Qi=new WeakMap,An=new WeakMap,q=new WeakSet,Rg=function(){return D(this,ht)||D(this,Et)<D(this,gr)},kg=function(){return D(this,qe)<D(this,xn)},Mg=function(){wr(this,qe)._--,D(this,qe)===0&&this.emit("pendingZero"),z(this,q,so).call(this),this.emit("next")},Ng=function(){z(this,q,_c).call(this),z(this,q,Cc).call(this),ue(this,Mt,void 0)},Og=function(){const e=Date.now();if(D(this,vt)===void 0){const n=D(this,ls)-e;if(n<0){if(D(this,yr)>0){const s=e-D(this,yr);if(s<D(this,en))return z(this,q,xc).call(this,D(this,en)-s),!0}ue(this,Et,D(this,fr)?D(this,qe):0)}else return z(this,q,xc).call(this,n),!0}return!1},xc=function(e){D(this,Mt)===void 0&&ue(this,Mt,setTimeout(()=>{z(this,q,Ng).call(this)},e))},Ac=function(){D(this,vt)&&(clearInterval(D(this,vt)),ue(this,vt,void 0))},Fg=function(){D(this,Mt)&&(clearTimeout(D(this,Mt)),ue(this,Mt,void 0))},so=function(){if(D(this,Ie).size===0)return z(this,q,Ac).call(this),this.emit("empty"),D(this,qe)===0&&(z(this,q,Fg).call(this),this.emit("idle")),!1;let e=!1;if(!D(this,Nt)){const n=!D(this,q,Og);if(D(this,q,Rg)&&D(this,q,kg)){const s=D(this,Ie).dequeue();D(this,ht)||(wr(this,Et)._++,z(this,q,fs).call(this)),this.emit("active"),ue(this,yr,Date.now()),s(),n&&z(this,q,Cc).call(this),e=!0}}return e},Cc=function(){D(this,ht)||D(this,vt)!==void 0||(ue(this,vt,setInterval(()=>{z(this,q,_c).call(this)},D(this,en))),ue(this,ls,Date.now()+D(this,en)))},_c=function(){D(this,Et)===0&&D(this,qe)===0&&D(this,vt)&&z(this,q,Ac).call(this),ue(this,Et,D(this,fr)?D(this,qe):0),z(this,q,io).call(this),z(this,q,fs).call(this)},io=function(){for(;z(this,q,so).call(this););},Bg=async function(e){return new Promise((n,s)=>{e.addEventListener("abort",()=>{s(e.reason)},{once:!0})})},Cn=async function(e,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(e,i),s())};this.on(e,i)})},$g=function(){D(this,ht)||(this.on("add",()=>{D(this,Ie).size>0&&z(this,q,fs).call(this)}),this.on("next",()=>{z(this,q,fs).call(this)}))},fs=function(){D(this,ht)||D(this,pr)||(ue(this,pr,!0),queueMicrotask(()=>{ue(this,pr,!1),z(this,q,Ic).call(this)}))},Ic=function(){const e=D(this,mr),n=!D(this,ht)&&D(this,Et)>=D(this,gr)&&D(this,Ie).size>0;n!==e&&(ue(this,mr,n),this.emit(n?"rateLimit":"rateLimitCleared"))};function fh(r){const t=[Gt.A];return r==null?t:Array.isArray(r)?r.length===0?t:r:[r]}const gh=60;function mh(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(t=>({name:t.name,type:Gt[t.type]})),Answer:(r.Answer??r.answers??[]).map(t=>({name:t.name,type:Gt[t.type],TTL:t.TTL??t.ttl??gh,data:t.data instanceof Uint8Array?J(t.data):t.data}))}}const oS=4;function ph(r,t={}){const e=new iS({concurrency:t.queryConcurrency??oS});return async(n,s={})=>{var a;const i=new URLSearchParams;i.set("name",n),fh(s.types).forEach(c=>{i.append("type",Gt[c])}),(a=s.onProgress)==null||a.call(s,new ge("dns:query",n));const o=await e.add(async()=>{var d;const c=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const u=mh(await c.json());return(d=s.onProgress)==null||d.call(s,new ge("dns:response",u)),u},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function aS(){return[ph("https://cloudflare-dns.com/dns-query"),ph("https://dns.google/resolve")]}var cS=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,e=Object.create(null),n=Object.create(null);function s(i,o){e[i]=o,t++,t>=r&&(t=0,n=e,e=Object.create(null))}return{has:function(i){return e[i]!==void 0||n[i]!==void 0},remove:function(i){e[i]!==void 0&&(e[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=e[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){e[i]!==void 0?e[i]=o:s(i,o)},clear:function(){e=Object.create(null),n=Object.create(null)}}};const lS=_u(cS);class uS{constructor(t){l(this,"lru");this.lru=lS(t)}get(t,e){let n=!0;const s=[];for(const i of e){const o=this.getAnswers(t,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return mh({answers:s})}getAnswers(t,e){const n=`${t.toLowerCase()}-${e}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Gt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(t,e){const n=`${t.toLowerCase()}-${e.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(e.TTL??gh)*1e3,value:e}),this.lru.set(n,s)}remove(t,e){const n=`${t.toLowerCase()}-${e}`;this.lru.remove(n)}clear(){this.lru.clear()}}function dS(r){return new uS(r)}const hS=1e3;class fS{constructor(t){l(this,"resolvers");l(this,"cache");this.resolvers={},this.cache=dS(t.cacheSize??hS),Object.entries(t.resolvers??{}).forEach(([e,n])=>{Array.isArray(n)||(n=[n]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=n}),this.resolvers["."]==null&&(this.resolvers["."]=aS())}async query(t,e={}){var c,u,d;const n=fh(e.types),s=e.cached!==!1?this.cache.get(t,n):void 0;if(s!=null)return(c=e.onProgress)==null||c.call(e,new ge("dns:cache",s)),s;const i=`${t.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((u=e.signal)==null?void 0:u.aborted)===!0)break;try{const f=await h(t,{...e,types:n});for(const p of f.Answer)this.cache.add(t,p);return f}catch(f){a.push(f),(d=e.onProgress)==null||d.call(e,new ge("dns:error",f))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${t} ${n} failed`)}}var Gt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Gt||(Gt={}));function gS(r={}){return new fS(r)}class mS{constructor(){l(this,"dns")}canResolve(t){return t.getComponents().some(({name:e})=>e==="dnsaddr")}async resolve(t,e){var c,u;const n=(c=t.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[t];const i=await this.getDNS(e).query(`_dnsaddr.${n}`,{signal:e==null?void 0:e.signal,types:[Gt.TXT]}),o=(u=t.getComponents().find(d=>d.name==="p2p"))==null?void 0:u.value,a=[];for(const d of i.Answer){const h=d.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(Z(h)))}return a}getDNS(t){return t.dns!=null?t.dns:(this.dns==null&&(this.dns=gS()),this.dns)}}const yh=new mS;async function wh(r,t,e){const n=e.depth??0;if(n>(e.maxRecursiveDepth??Hv))throw new Iv("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(t))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,e);for(const c of a)i.push(...await wh(c,t,{...e,depth:n+1}))}return s===!1&&i.push(r),i}const rs={maxParallelDials:uh,maxDialQueueLength:lh,maxPeerAddrsToDial:ch,dialTimeout:oh,resolvers:{dnsaddr:yh}};class pS{constructor(t,e={}){l(this,"queue");l(this,"components");l(this,"addressSorter");l(this,"maxPeerAddrsToDial");l(this,"maxDialQueueLength");l(this,"dialTimeout");l(this,"shutDownController");l(this,"connections");l(this,"log");l(this,"resolvers");this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??rs.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??rs.maxDialQueueLength,this.dialTimeout=e.dialTimeout??rs.dialTimeout,this.connections=e.connections??new Un,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.resolvers=e.resolvers??rs.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new J0({concurrency:e.maxParallelDials??rs.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==ft.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var o,a,c;const{peerId:n,multiaddrs:s}=rh(t);if(n!=null&&e.force!==!0){const u=ih(n,this.connections.get(n),s);if(u!=null)return this.log("already connected to %a",u.remoteAddr),(o=e.onProgress)==null||o.call(e,new ge("dial-queue:already-connected")),u}const i=this.queue.queue.find(u=>{if((n==null?void 0:n.equals(u.options.peerId))===!0)return!0;const d=u.options.multiaddrs;if(d==null)return!1;for(const h of s)if(d.has(h.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const u of s)i.options.multiaddrs.add(u.toString());return(a=e.onProgress)==null||a.call(e,new ge("dial-queue:already-in-dial-queue")),i.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new Er("Dial queue is full");return this.log("creating dial target for %p",n,s.map(u=>u.toString())),(c=e.onProgress)==null||c.call(e,new ge("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var h;(h=u.onProgress)==null||h.call(u,new ge("dial-queue:start-dial"));const d=fn([this.shutDownController.signal,u.signal]);try{return await this.dialPeer(u,d)}finally{d.clear()}},{peerId:n,priority:e.priority??vh,multiaddrs:new Set(s.map(u=>u.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var d;const n=t.peerId,s=t.multiaddrs,i=new Set;let o=t.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const h=[],f=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...f]);const p=await this.calculateMultiaddrs(n,f,{...t,signal:e});for(const g of p){if(i.has(g.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",g.multiaddr,n);continue}h.push(g)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(g=>g.multiaddr.toString())),(d=t==null?void 0:t.onProgress)==null||d.call(t,new ge("dial-queue:calculated-addresses",h));for(const g of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new Er("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(g.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",g.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[Wv]:Y(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}return y}catch(y){if(this.log.error("dial failed to %a - %e",g.multiaddr,y),i.add(g.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[Vv]:Y(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}if(e.aborted)throw new qg(y.message);u.push(y)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,n={}){var h,f;const s=[...e].map(p=>({multiaddr:Z(p),isCertified:!1}));if(t!=null){if(this.components.peerId.equals(t))throw new Er("Tried to dial self");if(await((f=(h=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(h,t))===!0)throw new nh("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",t);try{const p=await this.components.peerStore.get(t);s.push(...p.addresses),this.log("loaded multiaddrs for %p",t,s.map(({multiaddr:g})=>g.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",t);try{const p=await this.components.peerRouting.findPeer(t,n);this.log("found multiaddrs for %p in the peer routing",t,s.map(({multiaddr:g})=>g.toString())),s.push(...p.multiaddrs.map(g=>({multiaddr:g,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,p)}}}let i=(await Promise.all(s.map(async p=>{const g=await wh(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return g.length===1&&g[0].equals(p.multiaddr)?p:g.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(t!=null){const p=`/p2p/${t.toString()}`;i=i.map(g=>{const y=g.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:g.multiaddr.encapsulate(p),isCertified:g.isCertified}:g})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const g=(y=p.multiaddr.getComponents().findLast(m=>m.code===H))==null?void 0:y.value;return t!=null&&g!=null?t.equals(g):!0}),a=new Map;for(const p of o){const g=p.multiaddr.toString(),y=a.get(g);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(g,p)}const c=[...a.values()];if(c.length===0)throw new xv("The dial request has no valid addresses");const u=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||u.push(p);const d=this.addressSorter==null?jv(u):u.sort(this.addressSorter);if(d.length===0)throw new nh("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const n=await this.calculateMultiaddrs(void 0,new Set(t.map(s=>s.toString())),e);return e.runOnLimitedConnection===!1?n.find(s=>!tr.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}const yS=Object.prototype.toString,wS=r=>yS.call(r)==="[object Error]",bS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function ES(r){if(!(r&&wS(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:e,stack:n}=r;return e==="Load failed"?n===void 0||"__sentry_captured__"in r:e.startsWith("error sending request for url")?!0:bS.has(e)}function vS(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function Di(r,t,{min:e=0,allowInfinity:n=!1}={}){if(t!==void 0){if(typeof t!="number"||Number.isNaN(t))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(t))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(t<e)throw new TypeError(`Expected \`${r}\` to be ≥ ${e}.`)}}class SS extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,{message:t}=t):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}function xS(r,t){const e=Math.max(1,r+1),n=t.randomize?Math.random()+1:1;let s=Math.round(n*t.minTimeout*t.factor**(e-1));return s=Math.min(s,t.maxTimeout),s}function bh(r,t){return Number.isFinite(t)?t-(performance.now()-r):t}async function AS({error:r,attemptNumber:t,retriesConsumed:e,startTime:n,options:s}){var p,g,y;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof SS)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-e):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:t,retriesLeft:o,retriesConsumed:e});if(await s.onFailedAttempt(c),bh(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(c),d=bh(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!ES(i)){if(u)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!u)return(g=s.signal)==null||g.throwIfAborted(),!1;const h=xS(e,s),f=Math.min(h,d);return f>0&&await new Promise((m,S)=>{var L,x;const v=()=>{var _;clearTimeout(E),(_=s.signal)==null||_.removeEventListener("abort",v),S(s.signal.reason)},E=setTimeout(()=>{var _;(_=s.signal)==null||_.removeEventListener("abort",v),m()},f);s.unref&&((L=E.unref)==null||L.call(E)),(x=s.signal)==null||x.addEventListener("abort",v,{once:!0})}),(y=s.signal)==null||y.throwIfAborted(),!0}async function CS(r,t={}){var i,o,a;if(t={...t},vS(t.retries),Object.hasOwn(t,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");t.retries??(t.retries=10),t.factor??(t.factor=2),t.minTimeout??(t.minTimeout=1e3),t.maxTimeout??(t.maxTimeout=Number.POSITIVE_INFINITY),t.maxRetryTime??(t.maxRetryTime=Number.POSITIVE_INFINITY),t.randomize??(t.randomize=!1),t.onFailedAttempt??(t.onFailedAttempt=()=>{}),t.shouldRetry??(t.shouldRetry=()=>!0),t.shouldConsumeRetry??(t.shouldConsumeRetry=()=>!0),Di("factor",t.factor,{min:0,allowInfinity:!1}),Di("minTimeout",t.minTimeout,{min:0,allowInfinity:!1}),Di("maxTimeout",t.maxTimeout,{min:0,allowInfinity:!0}),Di("maxRetryTime",t.maxRetryTime,{min:0,allowInfinity:!0}),t.factor>0||(t.factor=1),(i=t.signal)==null||i.throwIfAborted();let e=0,n=0;const s=performance.now();for(;!Number.isFinite(t.retries)||n<=t.retries;){e++;try{(o=t.signal)==null||o.throwIfAborted();const c=await r(e);return(a=t.signal)==null||a.throwIfAborted(),c}catch(c){await AS({error:c,attemptNumber:e,retriesConsumed:n,startTime:s,options:t})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class _S{constructor(t,e={}){l(this,"log");l(this,"queue");l(this,"started");l(this,"peerStore");l(this,"retries");l(this,"retryInterval");l(this,"backoffFactor");l(this,"connectionManager");l(this,"events");this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new Da({concurrency:e.maxParallelReconnects??Kv,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);Eh(e)&&(this.queue.has(t)||this.queue.add(async n=>{await CS(async s=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",t,n);const s={};[...e.tags.keys()].forEach(i=>{i.startsWith(po)&&(s[i]=void 0)}),await this.peerStore.merge(t,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>Eh(e)]});await Promise.all(t.map(async e=>{await this.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(t=>{this.log.error("error reconnect to peers after start - %e",t)})}stop(){this.started=!1,this.queue.abort()}}function Eh(r){for(const t of r.tags.keys())if(t.startsWith(po))return!0;return!1}const vh=50,Qa={maxConnections:Gv,inboundConnectionThreshold:zv,maxIncomingPendingConnections:qv};Xf=Symbol.toStringTag;class IS{constructor(t,e={}){l(this,"started");l(this,"connections");l(this,"allow");l(this,"deny");l(this,"maxIncomingPendingConnections");l(this,"incomingPendingConnections");l(this,"outboundPendingConnections");l(this,"maxConnections");l(this,"dialQueue");l(this,"reconnectQueue");l(this,"connectionPruner");l(this,"inboundConnectionRateLimiter");l(this,"peerStore");l(this,"metrics");l(this,"events");l(this,"log");l(this,"peerId");l(this,Xf,"@libp2p/connection-manager");var n;if(this.maxConnections=e.maxConnections??Qa.maxConnections,this.maxConnections<1)throw new G("Connection Manager maxConnections must be greater than 0");this.connections=new Un,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(s=>Xa(Z(s))),this.deny=(e.deny??[]).map(s=>Xa(Z(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??Qa.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new j0({points:e.inboundConnectionThreshold??Qa.inboundConnectionThreshold,duration:1}),this.connectionPruner=new $v({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{allow:(n=e.allow)==null?void 0:n.map(s=>Z(s))}),this.dialQueue=new pS(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??uh,maxDialQueueLength:e.maxDialQueueLength??lh,maxPeerAddrsToDial:e.maxPeerAddrsToDial??ch,dialTimeout:e.dialTimeout??oh,resolvers:e.resolvers??{dnsaddr:yh},connections:this.connections}),this.reconnectQueue=new _S({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,n;(t=this.metrics)==null||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(e=this.metrics)==null||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const u of a.streams){const d=`${u.direction} ${u.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[u,d]of Object.entries(c))s[u]=s[u]??[],s[u].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((u,d)=>u-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Nc(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Oc(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const n of e)t.push(Promise.all([Ue(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(t){if(this.maxConnections<1)throw new G("Connection Manager maxConnections must be greater than 0");let e=!1;t<this.maxConnections&&(e=!0),this.maxConnections=t,e&&this.connectionPruner.maybePruneConnections()}onConnect(t){this._onConnect(t).catch(e=>{this.log.error("could not connect - %e",e)})}async _onConnect(t){const{detail:e}=t;if(!this.started){await e.close();return}if(e.status!=="open")return;const n=e.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(e),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,n=e.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==e.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(t){if(t!=null)return this.connections.get(t)??[];let e=[];for(const n of this.connections.values())e=e.concat(n);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var n,s;if(!this.started)throw new br("Not started");this.outboundPendingConnections++;try{(n=e.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=rh(t);if(this.peerId.equals(i))throw new uo("Can not dial self");if(i!=null&&e.force!==!0){this.log("dial %p",i);const d=ih(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=e.onProgress)==null||s.call(e,new ge("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(t,{...e,priority:e.priority??vh});if(a.status!=="open")throw new ys("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let u=!1;for(const d of c)if(d.id===a.id&&(u=!0),e.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new ws("Duplicate multiaddr connection")),d;return u||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(t,e,n={}){return(await this.openConnection(t,n)).newStream(e,n)}async closeConnections(t,e={}){const n=this.connections.get(t)??[];await Promise.all(n.map(async s=>{try{await Promise.all([Ue(s,"close",e),s.close(e)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(t){if(this.deny.some(s=>{if(ct(t.remoteAddr)){const i=ye(t.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(s=>{if(ct(t.remoteAddr)){const i=ye(t.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(ct(t.remoteAddr)){const s=ye(t.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(n=>Z(n))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}const TS=1e4,LS="1.0.0",DS="ping",PS="ipfs",Sh=32,RS=!0;Qf=Symbol.toStringTag,Zf=St;class kS{constructor(t,e={}){l(this,"protocol");l(this,"components");l(this,"log");l(this,"heartbeatInterval");l(this,"pingIntervalMs");l(this,"abortController");l(this,"timeout");l(this,"abortConnectionOnPingFailure");l(this,Qf,"@libp2p/connection-monitor");l(this,Zf,["@libp2p/connection-monitor"]);this.components=t,this.protocol=`/${e.protocolPrefix??PS}/${DS}/${LS}`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??TS,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??RS,this.timeout=new Zb({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var n;let e=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await t.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=sd(i);e=Date.now(),await Promise.all([o.write(Ql(Sh),{signal:s}),o.read({bytes:Sh,signal:s})]),t.rtt=Date.now()-e,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;t.rtt=(Date.now()-e)/2}}).catch(e=>{this.log.error("error during heartbeat - %e",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;(t=this.abortController)==null||t.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}Jf=Symbol.toStringTag;class MS{constructor(t,e){l(this,"routers");l(this,"started");l(this,"components");l(this,Jf,"@libp2p/content-routing");var n,s,i,o,a;this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()}),getAttributesFromYieldedValue:(c,u)=>({...u,providers:[...Array.isArray(u.providers)?u.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:J(c,"base36")})}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:J(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(this.routers.length===0)throw new Ya("No content routers available");const n=this,s=new zn;for await(const i of Aa(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(t,e))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(t,e={}){if(this.routers.length===0)throw new Ya("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(t,e)}))}async cancelReprovide(t,e={}){if(this.routers.length===0)throw new Ya("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(t,e)}))}async put(t,e,n){if(!this.isStarted())throw new br;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(t,e,n)}))}async get(t,e){if(!this.isStarted())throw new br;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(t,e)))}}const Pi=globalThis.CustomEvent??Event;async function*NS(r,t={}){let e=t.concurrency??1/0;e<1&&(e=1/0);const n=t.ordered??!1,s=new EventTarget,i=[];let o=rt(),a=rt(),c=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of r){if(i.length===e&&(o=rt(),await o.promise),d)break;const y={done:!1};i.push(y),g().then(m=>{y.done=!0,y.ok=!0,y.value=m,s.dispatchEvent(new Pi("task-complete"))},m=>{y.done=!0,y.err=m,s.dispatchEvent(new Pi("task-complete"))})}c=!0,s.dispatchEvent(new Pi("task-complete"))}catch(g){u=g,s.dispatchEvent(new Pi("task-complete"))}});function h(){var g;return n?(g=i[0])==null?void 0:g.done:!!i.find(y=>y.done)}function*f(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw d=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;h();)for(let g=0;g<i.length;g++)if(i[g].done){const y=i[g];if(i.splice(g,1),g--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(h()||(a=rt(),await a.promise),u!=null||(n?yield*f():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}jf=Symbol.toStringTag;class OS{constructor(t,e={}){l(this,"log");l(this,"peerId");l(this,"peerStore");l(this,"routers");l(this,jf,"@libp2p/peer-routing");var n,s;this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:J(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(this.routers.length===0)throw new th("No peer routers available");if(t.toString()===this.peerId.toString())throw new wv("Should not try to find self");const n=this,s=Aa(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),i;throw new lo}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new th("No peer routers available");const n=this,s=Gr(1024);for await(const i of NS(async function*(){const o=Aa(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(t,e)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...e,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}class FS extends(tg=Ye,eg=Symbol.toStringTag,tg){constructor(e){super();l(this,"peerRouting");l(this,"log");l(this,"walking");l(this,"walkers");l(this,"shutdownController");l(this,"walkController");l(this,"needNext");l(this,eg,"@libp2p/random-walk");this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){var s,i;this.walking||this.startWalk(),this.walkers++;const n=fn([this.shutdownController.signal,e==null?void 0:e.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=rt(),yield(await Ue(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=fn([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Ql(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await wt(this.needNext.promise,e)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const xh=32,Ah=64;ng=Symbol.toStringTag;class BS{constructor(t){l(this,"log");l(this,"topologies");l(this,"handlers");l(this,"components");l(this,"middleware");l(this,ng,"@libp2p/registrar");var e;this.components=t,this.log=t.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(e=t.metrics)==null||e.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=Tt({name:"libp2p_registrar_protocol_handlers",metrics:t.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(e==null)throw new bv(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return e==null?[]:[...e.values()]}async handle(t,e,n){if(this.handlers.has(t)&&(n==null?void 0:n.force)!==!0)throw new Ev(`Handler already registered for protocol ${t}`);this.handlers.set(t,{handler:e,options:{maxInboundStreams:xh,maxOutboundStreams:Ah,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]},n)}async unhandle(t,e){(Array.isArray(t)?t:[t]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},e)}async register(t,e){if(e==null)throw new G("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(t);return s==null&&(s=new Map,this.topologies.set(t,s)),s.set(n,e),n}unregister(t){for(const[e,n]of this.topologies.entries())n.has(t)&&(n.delete(t),n.size===0&&this.topologies.delete(e))}use(t,e){this.middleware.set(t,e)}unuse(t){this.middleware.delete(t)}getMiddleware(t){return this.middleware.get(t)??[]}async _onDisconnect(t){const e=t.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(e,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e))!==!1&&((u=a.filter)==null||u.remove(e),await((d=a.onDisconnect)==null?void 0:d.call(a,e)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",e,s)}}async _onPeerUpdate(t){const{peer:e,previous:n}=t.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!e.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e.id))!==!1&&((u=a.filter)==null||u.remove(e.id),await((d=a.onDisconnect)==null?void 0:d.call(a,e.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",e.id,i)}}async _onPeerIdentify(t){const e=t.detail.protocols,n=t.detail.connection,s=t.detail.peerId;try{for(const i of e){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((u=a.filter)==null||u.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}rg=Symbol.toStringTag;class $S{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"transports");l(this,"listeners");l(this,"faultTolerance");l(this,"started");l(this,rg,"@libp2p/transport-manager");this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=Tt({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Tt({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??Ss.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(e==null)throw new G("Transport must have a valid tag");if(this.transports.has(e))throw new G(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,n]of this.listeners)for(this.log("closing listeners for %s",e);n.length>0;){const s=n.pop();s!=null&&t.push(s.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var s;const n=this.dialTransportForMultiaddr(t);if(n==null)throw new _v(`No transport available for address ${String(t)}`);return(s=e==null?void 0:e.onProgress)==null||s.call(e,new ge("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const n of e)t=[...t,...n.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values())if(e.dialFilter([t]).length>0)return e}listenTransportForMultiaddr(t){for(const e of this.transports.values())if(e.listenFilter([t]).length>0)return e}async listen(t){if(!this.isStarted())throw new br("Not started");if(t==null||t.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(i=>{e.errors.set(i.toString(),new vv)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(t);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(f=>f===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),Kd.matches(c)?e.ipv4.attempts++:Vd.matches(c)&&e.ipv6.attempts++,n.push(u.listen(c).then(()=>{e.errors.delete(c.toString()),Kd.matches(c)&&e.ipv4.success++,Vd.matches(c)&&e.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,h),e.errors.set(c.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(e)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Ss.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new Sv(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...e.errors.entries()].map(([i,o])=>`
  ${i}: ${`${US(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(t){if(t.ipv4.attempts===0||t.ipv6.attempts===0)return!1;const e=t.ipv4.attempts===t.ipv4.success,n=t.ipv6.success===0;return e&&n}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const n=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const s=e.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}function US(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const En="/multistream/1.0.0",Ch=1024,zS=Y(`
`);async function Ja(r,t){const n=(await r.read(t)).subarray();if(n.byteLength===0||n[n.length-1]!==zS[0])throw new it("Missing newline");return J(n).trimEnd()}async function ja(r,t,e={}){if(t=Array.isArray(t)?[...t]:[t],t.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=jr(r,{...e,maxDataLength:Ch});for(let i=0;i<t.length;i++){const o=t[i];let a;if(i===0){n.trace('write ["%s", "%s"]',En,o);const c=Y(`${En}
`),u=Y(`${o}
`);if(await s.writeV([c,u],e),n.trace("reading multistream-select header"),a=await Ja(s,e),n.trace('read "%s"',a),a!==En){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(Y(`${o}
`),e);if(n.trace("reading protocol response"),a=await Ja(s,e),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new Rc(`Protocol selection failed - could not negotiate ${t}`)}async function tc(r,t,e={}){t=Array.isArray(t)?t:[t];const n=r.log.newScope("mss:handle"),s=jr(r,{...e,maxDataLength:Ch,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await Ja(s,e);if(n.trace('read "%s"',i),i===En){n.trace('respond with "%s" for "%s"',En,i),await s.write(Y(`${En}
`),e),n.trace('responded with "%s" for "%s"',En,i);continue}if(t.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(Y(`${i}
`),e),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new Q(...t.map(a=>hi.single(Y(`${a}
`))),Y(`
`));n.trace('respond with "%s" for %s',t,i),await s.write(o,e),n.trace('responded with "%s" for %s',t,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(Y(`na
`),e),n('responded with "na" for "%s"',i)}}class qS extends(og=Ye,ig=Symbol.toStringTag,sg=de,og){constructor(e,n){super();l(this,"id");l(this,"remoteAddr");l(this,"remotePeer");l(this,"direction");l(this,"timeline");l(this,"direct");l(this,"multiplexer");l(this,"encryption");l(this,"limits");l(this,"log");l(this,"maConn");l(this,"muxer");l(this,"components");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"closeTimeout");l(this,ig,"Connection");l(this,sg,!0);l(this,"newStream",async(e,n={})=>{var i;if(this.muxer==null)throw new Ii("Connection is not multiplexed");if(this.muxer.status!=="open")throw new ys(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new ys(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new ho("Cannot open protocol stream on limited connection");Array.isArray(e)||(e=[e]),this.log.trace("starting new stream for protocols %s",e);const s=await this.muxer.createStream({...n,protocol:e.length===1?e[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,e);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const u=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:u}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",e),s.protocol=await ja(s,e,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=WS(s.protocol,this.components.registrar,n),a=_h(s.protocol,"outbound",this);if(a>o){const u=new fo(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(u),u}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,e,o),o}});this.components=e,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??Li,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??Li,this.closeTimeout=n.closeTimeout??ah,this.direct=sh(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===H)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new vs(s.local,s.error))})}get streams(){var e;return((e=this.muxer)==null?void 0:e.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(e){var i;const n=e.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await tc(n,h,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=VS(n.protocol,this.components.registrar);if(_h(n.protocol,"inbound",this)>o)throw new kc(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:u}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&u.runOnLimitedConnection!==!0)throw new ho("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(h,f,p)=>{await c(h,f),p(h,f)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(e,n,s){for(let i=0;i<s.length;i++){const o=s[i];e.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const u=o(e,n,(d,h)=>{e=d,n=h,a()});u instanceof Promise&&u.catch(c)}catch(u){c(u)}}),e.log.trace("ran middleware",i,o)}return e}async close(e={}){var n;if(this.log("closing connection to %a",this.remoteAddr),e.signal==null){const s=AbortSignal.timeout(this.closeTimeout);e={...e,signal:s}}await((n=this.muxer)==null?void 0:n.close(e)),await this.maConn.close(e)}abort(e){var n;(n=this.muxer)==null||n.abort(e),this.maConn.abort(e)}}function KS(r,t){return new qS(r,t)}function VS(r,t){try{const{options:e}=t.getHandler(r);if(e.maxInboundStreams!=null)return e.maxInboundStreams}catch(e){if(e.name!=="UnhandledProtocolError")throw e}return xh}function WS(r,t,e={}){try{const{options:n}=t.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return e.maxOutboundStreams??Ah}function _h(r,t,e){let n=0;return e.streams.forEach(s=>{s.direction===t&&s.protocol===r&&n++}),n}ag=Symbol.toStringTag;class HS{constructor(t,e){l(this,"components");l(this,"connectionEncrypters");l(this,"streamMuxers");l(this,"inboundUpgradeTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"events");l(this,"metrics");l(this,"connectionCloseTimeout");l(this,ag,"@libp2p/upgrader");var n,s,i,o;this.components=t,this.connectionEncrypters=Tt({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),e.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Tt({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),e.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??Uv,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??Li,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??Li,this.connectionCloseTimeout=e.connectionCloseTimeout??ah,this.events=t.events,this.metrics={dials:(n=t.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=t.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=t.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(t,...e){const n=this.components.connectionGater[t];if(n==null)return;if(await n.apply(this.components.connectionGater,e)===!0)throw new Av(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return fn([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(e.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(t),!n)throw new Cv("Connection denied");await wt(this.shouldBlockConnection("denyInboundConnection",t),s),await this._performUpgrade(t,"inbound",{...e,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=t.remoteAddr.getComponents().findLast(d=>d.code===H))==null?void 0:s.value;let c;a!=null&&(c=at(a),await wt(this.shouldBlockConnection("denyOutboundConnection",c,t),e.signal));let u="outbound";return e.initiator===!1&&(u="inbound"),await this._performUpgrade(t,u,e)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(t,e,n){var h,f,p,g;let s=t,i,o,a,c;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(t.log=t.log.newScope(`${e}:${u}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(t.log("protecting the %s connection",e),s=await y.protect(s,n))}try{if(GS(n)){if(n.remotePeer==null)throw new ws(`${e} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(f=t.remoteAddr.getComponents().findLast(S=>S.code===H))==null?void 0:f.value;let m;y!=null&&(m=at(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new ge(`upgrader:encrypt-${e}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(e==="inbound"?this._encryptInbound(s,{...n,remotePeer:m}):this._encryptOutbound(s,{...n,remotePeer:m}))}if(i.equals(this.components.peerId)){const y=new uo("Can not dial self");throw t.abort(y),y}await this.shouldBlockConnection(e==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,t),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((g=n==null?void 0:n.onProgress)==null||g.call(n,new ge(`upgrader:multiplex-${e}-connection`)),o=await(e==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw t.log.error("failed to upgrade %s connection %s %a - %e",e,e==="inbound"?"from":"to",t.remoteAddr,y),y}o!=null&&(t.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(e==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,t);const d=this._createConnection({id:u,cryptoProtocol:c,direction:e,maConn:t,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(t){const e=KS(this.components,{...t,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return e.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:e})}),this.events.safeDispatchEvent("connection:open",{detail:e}),e}async _encryptInbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{const s=await tc(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ti(`no crypto module found for ${s}`);return t.log("encrypting inbound connection using %s",s),{...await i.secureInbound(t,e),protocol:s}}catch(s){throw new Ti(s.message)}}async _encryptOutbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",n);const s=await ja(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ti(`no crypto module found for ${s}`);return t.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(t,e),protocol:s}}catch(s){throw new Ti(s.message)}}async _multiplexOutbound(t,e,n){const s=Array.from(e.keys());t.log("outbound selecting muxer %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await ja(t,s,n),o=e.get(i);if(o==null)throw new Ii(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing outbound connection - %e",i),new Ii(String(i))}}async _multiplexInbound(t,e,n){const s=Array.from(e.keys());t.log("inbound handling muxers %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await tc(t,s,n),o=e.get(i);if(o==null)throw new Ii(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function GS(r){return r.skipEncryption===!0}const Ih="3.0.6",Th="js-libp2p";function YS(r,t){return`${r??Th}/${t??Ih} browser/${globalThis.navigator.userAgent}`}class XS extends Ye{constructor(e){var d,h,f,p,g,y,m,S,v,E,L;super();ce(this,ds);l(this,"peerId");l(this,"peerStore");l(this,"contentRouting");l(this,"peerRouting");l(this,"metrics");l(this,"services");l(this,"logger");l(this,"status");l(this,"components");l(this,"log");this.status="stopped";const n=new Ye,s=n.dispatchEvent.bind(n);n.dispatchEvent=x=>{const _=s(x),O=this.dispatchEvent(new CustomEvent(x.type,{detail:x.detail}));return _||O},this.peerId=e.peerId,this.logger=e.logger??hu(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=e.nodeInfo)==null?void 0:d.name)??Th,o=((h=e.nodeInfo)==null?void 0:h.version)??Ih,a=this.components=Pv({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:o,userAgent:((f=e.nodeInfo)==null?void 0:f.userAgent)??YS(i,o)},logger:this.logger,events:n,datastore:e.datastore??new XE,connectionGater:Ov(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",qE(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),a.events.addEventListener("peer:update",x=>{if(x.detail.previous==null){const _={id:x.detail.peer.id,multiaddrs:x.detail.peer.addresses.map(O=>O.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:_})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(a)),this.components.upgrader=new HS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((x,_)=>this.configureComponent(`connection-encryption-${_}`,x(this.components))),streamMuxers:(e.streamMuxers??[]).map((x,_)=>this.configureComponent(`stream-muxers-${_}`,x(this.components))),inboundUpgradeTimeout:(p=e.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(g=e.connectionManager)==null?void 0:g.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=e.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=e.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new $S(this.components,e.transportManager)),this.configureComponent("connectionManager",new IS(this.components,e.connectionManager)),((S=e.connectionMonitor)==null?void 0:S.enabled)!==!1&&this.configureComponent("connectionMonitor",new kS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new BS(this.components)),this.configureComponent("addressManager",new mv(this.components,e.addresses));const c=(e.peerRouters??[]).map((x,_)=>this.configureComponent(`peer-router-${_}`,x(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new OS(this.components,{routers:c}));const u=(e.contentRouters??[]).map((x,_)=>this.configureComponent(`content-router-${_}`,x(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new MS(this.components,{routers:u})),this.configureComponent("randomWalk",new FS(this.components)),(e.peerDiscovery??[]).forEach((x,_)=>{this.configureComponent(`peer-discovery-${_}`,x(this.components)).addEventListener("peer",T=>{z(this,ds,Tc).call(this,T)})}),(v=e.transports)==null||v.forEach((x,_)=>{this.components.transportManager.add(this.configureComponent(`transport-${_}`,x(this.components)))}),e.services!=null)for(const x of Object.keys(e.services)){const _=e.services[x],O=_(this.components);if(O==null){this.log.error("service factory %s returned null or undefined instance",x);continue}this.services[x]=O,this.configureComponent(x,O),O[ve]!=null&&(this.log("registering service %s for content routing",x),u.push(O[ve])),O[Mc]!=null&&(this.log("registering service %s for peer routing",x),c.push(O[Mc])),O[go]!=null&&(this.log("registering service %s for peer discovery",x),(L=(E=O[go]).addEventListener)==null||L.call(E,"peer",T=>{z(this,ds,Tc).call(this,T)}))}Rv(a)}configureComponent(e,n){return n==null&&this.log.error("component %s was null or undefined",e),this.components[e]=n,n}async start(){var e,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(e=this.components).beforeStart)==null?void 0:n.call(e)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var e,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(e=this.components).beforeStop)==null?void 0:n.call(e)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new zn;for(const n of this.components.connectionManager.getConnections())e.add(n.remotePeer);return Array.from(e)}async dial(e,n={}){return this.components.connectionManager.openConnection(e,{priority:75,...n})}async dialProtocol(e,n,s={}){if(n==null)throw new G("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new G("no protocols were provided to open a stream");return this.components.connectionManager.openStream(e,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,n={}){var s;ui(e)&&(e=at(((s=e.getComponents().findLast(i=>i.code===H))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(e,n)}async getPublicKey(e,n={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const a=await this.peerStore.get(e,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=Ft([Y("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Ht(i);return await this.peerStore.patch(e,{publicKey:o},n),o}async handle(e,n,s){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(e,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(e,n,s){return this.components.registrar.register(e,n,s)}unregister(e){this.components.registrar.unregister(e)}use(e,n){this.components.registrar.use(e,Array.isArray(n)?n:[n])}unuse(e){this.components.registrar.unuse(e)}async isDialable(e,n={}){return this.components.connectionManager.isDialable(e,n)}}ds=new WeakSet,Tc=function(e){const{detail:n}=e;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function ZS(r={}){r.privateKey??(r.privateKey=await Lw());const t=new XS({...await Fw(r),peerId:Mw(r.privateKey)});return r.start!==!1&&await t.start(),t}var Ze;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let t;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(t||(t={})),function(n){n.codec=()=>kn(t)}(r.Flag||(r.Flag={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(Ze||(Ze={}));const QS=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const JS=2*1024*1024,Lh=16*1024;function jS(r=Lh){const t=Re(r-Re(r)),e=1+Re(Object.keys(Ze.Flag).length-1),n=1,s=r-t-e-n,i=Re(s);return t+e+n+i}const e1=jS(),t1=1e4,Dh="/webrtc",nc="/webrtc-signaling/0.0.1";var Ph=function(r,t,e){if(e||arguments.length===2)for(var n=0,s=t.length,i;n<s;n++)(i||!(n in t))&&(i||(i=Array.prototype.slice.call(t,0,n)),i[n]=t[n]);return r.concat(i||Array.prototype.slice.call(t))},n1=function(){function r(t,e,n){this.name=t,this.version=e,this.os=n,this.type="browser"}return r}(),r1=function(){function r(t){this.version=t,this.type="node",this.name="node",this.os=process.platform}return r}(),s1=function(){function r(t,e,n,s){this.name=t,this.version=e,this.os=n,this.bot=s,this.type="bot-device"}return r}(),i1=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),o1=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),a1=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,c1=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Rh=3,l1=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",a1]],kh=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function u1(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new o1:typeof navigator<"u"?h1(navigator.userAgent):g1()}function d1(r){return r!==""&&l1.reduce(function(t,e){var n=e[0],s=e[1];if(t)return t;var i=s.exec(r);return!!i&&[n,i]},!1)}function h1(r){var t=d1(r);if(!t)return null;var e=t[0],n=t[1];if(e==="searchbot")return new i1;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<Rh&&(s=Ph(Ph([],s,!0),m1(Rh-s.length),!0)):s=[];var i=s.join("."),o=f1(r),a=c1.exec(r);return a&&a[1]?new s1(e,i,o,a[1]):new n1(e,i,o)}function f1(r){for(var t=0,e=kh.length;t<e;t++){var n=kh[t],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function g1(){var r=typeof process<"u"&&process.version;return r?new r1(process.version.slice(1)):null}function m1(r){for(var t=[],e=0;e<r;e++)t.push("0");return t}const Mh=u1(),p1=Mh!=null&&Mh.name==="firefox";async function Nh(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??QS.map(t=>({urls:[t]})),r}class y1 extends Ou{constructor(e){super({...e,maxMessageSize:(e.maxMessageSize??Lh)-e1});l(this,"channel");l(this,"incomingData");l(this,"maxBufferedAmount");l(this,"receivedFinAck");l(this,"finAckTimeout");this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=si(),this.maxBufferedAmount=e.maxBufferedAmount??JS,this.finAckTimeout=e.finAckTimeout??t1,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=s=>{const i=s.error;this.log.trace("received datachannel error event - %e",i),this.abort(i)},this.channel.onmessage=async s=>{this.log("incoming message %d bytes",s.data.byteLength);const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const s of La(this.incomingData))this.processIncomingProtobuf(s)}).catch(s=>{this.log.error("error processing incoming data channel messages - %e",s)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),Ue(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(s=>{this.abort(s.error??s)}))}sendNewStream(){}_sendMessage(e){if(this.channel.readyState!=="open")throw new tn(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),p1){this.channel.send(e.subarray());return}for(const n of e)this.channel.send(n)}sendData(e){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(hi.single(Ze.encode({message:e.subarray()}))),{sentBytes:e.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(e){var n;try{this.log.error("sending reset - %e",e),this._sendFlag(Ze.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(e)}catch(s){this.log.error("failed to send reset - %e",s)}}async sendCloseWrite(e){var i;this._sendFlag(Ze.Flag.FIN),(i=e==null?void 0:e.signal)==null||i.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(e==null?void 0:e.signal)??AbortSignal.timeout(this.finAckTimeout),s=[Ue(this.channel,"close",{signal:n}),Ue(this.channel,"error",{signal:n})];await Promise.any([wt(this.receivedFinAck.promise,n),...s]).finally(()=>{s.forEach(o=>o.cancel())})}async sendCloseRead(e){var n;this._sendFlag(Ze.Flag.STOP_SENDING),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}processIncomingProtobuf(e){var s,i;const n=Ze.decode(e);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new Q(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===Ze.Flag.FIN&&(this._sendFlag(Ze.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===Ze.Flag.RESET&&((s=this.receivedFinAck)==null||s.reject(new ao("The stream was reset")),this.onRemoteReset()),n.flag===Ze.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===Ze.Flag.FIN_ACK&&((i=this.receivedFinAck)==null||i.resolve()))}_sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const n=Ze.encode({flag:e}),s=hi.single(n);try{return this._sendMessage(s),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}sendPause(){}sendResume(){}}function Oh(r){const{channel:t,direction:e,isHandshake:n}=r;return new y1({...r,id:`${t.id}`,log:r.log.newScope(`${n===!0?"handshake":e}:${t.id}`),protocol:""})}class Fh{constructor(t){l(this,"protocol");l(this,"peerConnection");l(this,"metrics");l(this,"dataChannelOptions");l(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Dh,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(t){this.earlyDataChannels.push(t.channel)}createStreamMuxer(t){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new w1(t,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class w1 extends Nu{constructor(e,n){super(e,{...n,name:"muxer"});l(this,"peerConnection");l(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??Dh,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:s})=>{this.onDataChannel(s)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(s=>{s.close()});return}n.earlyDataChannels.forEach(s=>{this.onDataChannel(s)})})}onDataChannel(e){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",e.id,e.protocol,e.readyState),e.label==="init"){this.log.trace("closing init channel %d",e.id),e.close();return}const n=Oh({...this.streamOptions,...this.dataChannelOptions,channel:e,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(e){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,e==null?void 0:e.protocol),Oh({...e,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class b1 extends Mu{constructor(e){super(e);l(this,"peerConnection");this.peerConnection=e.peerConnection;const n=e.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(e){return{sentBytes:e.byteLength,canSendMore:!0}}async sendClose(e){var n;this.peerConnection.close(),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const Bh=r=>new b1(r),$h=globalThis.RTCPeerConnection,Uh=globalThis.RTCSessionDescription,E1=globalThis.RTCIceCandidate;class v1 extends Error{constructor(t){super(`WebRTC transport error: ${t}`),this.name="WebRTCTransportError"}}class Yt extends v1{constructor(t="SDP handshake failed"){super(t),this.name="SDPHandshakeFailedError"}}var lt;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let t;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(t||(t={})),function(n){n.codec=()=>kn(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(lt||(lt={}));const zh=async(r,t,e)=>{var n,s,i,o;try{const a=Promise.withResolvers();for(S1(r,a);;){const c=await Promise.race([a.promise,t.read({signal:e.signal})]);if(c==null){(n=e.signal)==null||n.throwIfAborted();break}if(c.type!==lt.Type.ICE_CANDIDATE)throw new it("ICE candidate message expected");const u=JSON.parse(c.data??"null");if(u===""||u===null){(s=e.onProgress)==null||s.call(e,new ge("webrtc:end-of-ice-candidates")),e.log.trace("end-of-candidates received");continue}const d=new E1(u);e.log.trace("%s received new ICE candidate %o",e.direction,u);try{(i=e.onProgress)==null||i.call(e,new ge("webrtc:add-ice-candidate",d.candidate)),await r.addIceCandidate(d)}catch(h){e.log.error("%s bad candidate received %o - %e",e.direction,u,h)}}}catch(a){if(e.log.error("%s error parsing ICE candidate - %e",e.direction,a),((o=e.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function S1(r,t){if(r.connectionState==="connected"){t.resolve();return}r.onconnectionstatechange=e=>{switch(r.connectionState){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new Lc(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function qh(r){let t;for(const e of r.getComponents())e.name==="p2p"&&(t=at(e.value??""));if(t==null)throw new ws("Remote peerId must be present in multiaddr");return t}async function x1({rtcConfiguration:r,dataChannel:t,signal:e,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:d,targetPeer:h}=_1(s);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",d);const f=i.getConnections(h);let p;f.length===0?(u==null||u(new ge("webrtc:dial-relay")),p=await o.dial(d,{signal:e,onProgress:u})):(u==null||u(new ge("webrtc:reuse-relay-connection")),p=f[0]),u==null||u(new ge("webrtc:open-signaling-stream"));const g=await p.newStream(nc,{signal:e,runOnLimitedConnection:!0}),y=gn(g).pb(lt),m=new $h(r);m.addEventListener("connectionstatechange",()=>{switch(m.connectionState){case"closed":m.close();break}});const S=new Fh({peerConnection:m,dataChannelOptions:t});try{const v=m.createDataChannel("init");m.onicecandidate=({candidate:_})=>{if(m.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(_==null||(_==null?void 0:_.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const O=JSON.stringify((_==null?void 0:_.toJSON())??null);a.trace("initiator sending ICE candidate %o",_),y.write({type:lt.Type.ICE_CANDIDATE,data:O},{signal:e}).catch(T=>{a.error("error sending ICE candidate - %e",T)})},m.onicecandidateerror=_=>{a.error("initiator ICE candidate error",_)};const E=await m.createOffer().catch(_=>{throw a.error("could not execute createOffer - %e",_),new Yt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",E.sdp),u==null||u(new ge("webrtc:send-sdp-offer")),await y.write({type:lt.Type.SDP_OFFER,data:E.sdp},{signal:e}),await m.setLocalDescription(E).catch(_=>{throw a.error("could not execute setLocalDescription - %e",_),new Yt("Failed to set localDescription")}),u==null||u(new ge("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await y.read({signal:e});if(L.type!==lt.Type.SDP_ANSWER)throw new Yt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const x=new Uh({type:"answer",sdp:L.data});return await m.setRemoteDescription(x).catch(_=>{throw a.error("could not execute setRemoteDescription - %e",_),new Yt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u==null||u(new ge("webrtc:read-ice-candidates")),await zh(m,y,{direction:"initiator",signal:e,log:a,onProgress:u}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await Ue(v,"open",{signal:e})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await Ue(v,"close",{signal:e}),u==null||u(new ge("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:e}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:m,muxerFactory:S}}catch(v){throw a.error("outgoing signaling error - %e",v),m.close(),g.abort(v),v}finally{m.onicecandidate=null,m.onicecandidateerror=null}}const Kh=fe(Wa.matchers[0],he(Zn));class rc extends Ye{constructor(e,n){super();l(this,"transportManager");l(this,"shutdownController");l(this,"events");this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(s=>Kh.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof rc)).map(e=>e.getAddrs().filter(n=>Kh.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function A1(r,t,{peerConnection:e,signal:n,log:s}){s.trace("new inbound signaling stream");const i=gn(r).pb(lt);try{e.onicecandidate=({candidate:h})=>{if(e.connectionState==="connected"){s.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){s.trace("recipient detected end of ICE candidates");return}const f=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",f),i.write({type:lt.Type.ICE_CANDIDATE,data:f},{signal:n}).catch(p=>{s.error("error sending ICE candidate - %e",p)})},s.trace("recipient read SDP offer");const c=await i.read({signal:n});if(c.type!==lt.Type.SDP_OFFER)throw new Yt(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);s.trace("recipient received SDP offer %s",c.data);const u=new Uh({type:"offer",sdp:c.data});await e.setRemoteDescription(u).catch(h=>{throw s.error("could not execute setRemoteDescription - %e",h),new Yt("Failed to set remoteDescription")});const d=await e.createAnswer().catch(h=>{throw s.error("could not execute createAnswer - %e",h),new Yt("Failed to create answer")});s.trace("recipient send SDP answer %s",d.sdp),await i.write({type:lt.Type.SDP_ANSWER,data:d.sdp},{signal:n}),await e.setLocalDescription(d).catch(h=>{throw s.error("could not execute setLocalDescription - %e",h),new Yt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await zh(e,i,{direction:"recipient",signal:n,log:s})}catch(c){if(e.connectionState!=="connected")throw s.error("error while handling signaling stream from peer %a - %e",t.remoteAddr,c),e.close(),c;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",t.remoteAddr,c)}const o=qh(t.remoteAddr),a=Z(`/webrtc/p2p/${o}`);return s.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}dg=Fc,ug=Symbol.toStringTag,lg=St,cg=xs;class C1{constructor(t,e={}){l(this,"components");l(this,"init");l(this,"log");l(this,"_started",!1);l(this,"metrics");l(this,"shutdownController");l(this,dg,!0);l(this,ug,"@libp2p/webrtc");l(this,lg,["@libp2p/transport"]);l(this,cg,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=t,this.init=e,this.log=t.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(nc,(t,e)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(t,e,n).catch(s=>{this.log.error("failed to handle incoming connect from %p - %e",e.remotePeer,s)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(nc),this._started=!1}createListener(t){return new rc(this.components,{shutdownController:this.shutdownController})}listenFilter(t){return t.filter(Ha.exactMatch)}dialFilter(t){return this.listenFilter(t)}async dial(t,e){var c;this.log.trace("dialing address: %a",t);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await x1({rtcConfiguration:await Nh(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:t,dataChannelOptions:this.init.dataChannel,signal:e.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:e.onProgress}),o=Bh({peerConnection:s,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await e.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:qh(t),muxerFactory:i,onProgress:e.onProgress,signal:e.signal});return this._closeOnShutdown(s,o),a}async _onProtocol(t,e,n){var o;const s=new $h(await Nh(this.init.rtcConfiguration));s.addEventListener("connectionstatechange",()=>{switch(s.connectionState){case"closed":s.close();break}});const i=new Fh({peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await A1(t,e,{peerConnection:s,signal:n,log:this.log});await t.close({signal:n});const u=Bh({peerConnection:s,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(u,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:i,signal:n}),this._closeOnShutdown(s,u)}catch(a){throw this.log.error("incoming signaling error - %e",a),s.close(),t.abort(a),a}}_closeOnShutdown(t,e){const n=()=>{e.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",s)})};this.shutdownController.signal.addEventListener("abort",n),t.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function _1(r){const t=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(t==null)throw new G("Destination peer id was missing");return{circuitAddress:Z(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:at(t)}}const ss=65535,Vh=ss-16,is=!!((fg=(hg=globalThis.process)==null?void 0:hg.env)!=null&&fg.DUMP_SESSION_KEYS),Wh=16;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function I1(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function sc(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function ic(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function He(r,t,e=""){const n=I1(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Hh(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function T1(r,t){He(r,void 0,"output");const e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Xt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function nr(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function L1(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const D1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function P1(r,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(r,t)}function R1(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}const k1=(r,t)=>{function e(n,...s){if(He(n,void 0,"key"),!D1)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const d=s[0];He(d,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const i=r.tagLength;i&&s[1]!==void 0&&He(s[1],void 0,"AAD");const o=t(n,...s),a=(d,h)=>{if(h!==void 0){if(d!==2)throw new Error("cipher output not supported");He(h,void 0,"output")}};let c=!1;return{encrypt(d,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,He(d),a(o.encrypt.length,h),o.encrypt(d,h)},decrypt(d,h){if(He(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return a(o.decrypt.length,h),o.decrypt(d,h)}}}return Object.assign(e,r),e};function Gh(r,t,e=!0){if(t===void 0)return new Uint8Array(r);if(t.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+t.length);if(e&&!N1(t))throw new Error("invalid output, must be aligned");return t}function M1(r,t,e){sc(e);const n=new Uint8Array(16),s=L1(n);return s.setBigUint64(0,BigInt(t),e),s.setBigUint64(8,BigInt(r),e),n}function N1(r){return r.byteOffset%4===0}function Ri(r){return Uint8Array.from(r)}const Yh=r=>Uint8Array.from(r.split(""),t=>t.charCodeAt(0)),O1=Yh("expand 16-byte k"),F1=Yh("expand 32-byte k"),B1=Xt(O1),$1=Xt(F1);function te(r,t){return r<<t|r>>>32-t}function oc(r){return r.byteOffset%4===0}const ki=64,U1=16,Xh=2**32-1,Zh=Uint32Array.of();function z1(r,t,e,n,s,i,o,a){const c=s.length,u=new Uint8Array(ki),d=Xt(u),h=oc(s)&&oc(i),f=h?Xt(s):Zh,p=h?Xt(i):Zh;for(let g=0;g<c;o++){if(r(t,e,n,d,o,a),o>=Xh)throw new Error("arx: counter overflow");const y=Math.min(ki,c-g);if(h&&y===ki){const m=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let S=0,v;S<U1;S++)v=m+S,p[v]=f[v]^d[S];g+=ki;continue}for(let m=0,S;m<y;m++)S=g+m,i[S]=s[S]^u[m];g+=y}}function q1(r,t){const{allowShortKeys:e,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=P1({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof r!="function")throw new Error("core must be a function");return ic(s),ic(o),sc(i),sc(e),(a,c,u,d,h=0)=>{He(a,void 0,"key"),He(c,void 0,"nonce"),He(u,void 0,"data");const f=u.length;if(d===void 0&&(d=new Uint8Array(f)),He(d,void 0,"output"),ic(h),h<0||h>=Xh)throw new Error("arx: counter overflow");if(d.length<f)throw new Error(`arx: output (${d.length}) is shorter than data (${f})`);const p=[];let g=a.length,y,m;if(g===32)p.push(y=Ri(a)),m=$1;else if(g===16&&e)y=new Uint8Array(32),y.set(a),y.set(a,16),m=B1,p.push(y);else throw He(a,32,"arx key"),new Error("invalid key size");oc(c)||p.push(c=Ri(c));const S=Xt(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,S,Xt(c.subarray(0,16)),S),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const E=Xt(c);return z1(r,m,S,E,u,d,h,o),nr(...p),d}}function Me(r,t){return r[t++]&255|(r[t++]&255)<<8}class K1{constructor(t){l(this,"blockLen",16);l(this,"outputLen",16);l(this,"buffer",new Uint8Array(16));l(this,"r",new Uint16Array(10));l(this,"h",new Uint16Array(10));l(this,"pad",new Uint16Array(8));l(this,"pos",0);l(this,"finished",!1);t=Ri(He(t,32,"key"));const e=Me(t,0),n=Me(t,2),s=Me(t,4),i=Me(t,6),o=Me(t,8),a=Me(t,10),c=Me(t,12),u=Me(t,14);this.r[0]=e&8191,this.r[1]=(e>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=Me(t,16+2*d)}process(t,e,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],d=o[3],h=o[4],f=o[5],p=o[6],g=o[7],y=o[8],m=o[9],S=Me(t,e+0),v=Me(t,e+2),E=Me(t,e+4),L=Me(t,e+6),x=Me(t,e+8),_=Me(t,e+10),O=Me(t,e+12),T=Me(t,e+14);let I=i[0]+(S&8191),$=i[1]+((S>>>13|v<<3)&8191),U=i[2]+((v>>>10|E<<6)&8191),M=i[3]+((E>>>7|L<<9)&8191),N=i[4]+((L>>>4|x<<12)&8191),w=i[5]+(x>>>1&8191),b=i[6]+((x>>>14|_<<2)&8191),C=i[7]+((_>>>11|O<<5)&8191),P=i[8]+((O>>>8|T<<8)&8191),k=i[9]+(T>>>5|s),A=0,F=A+I*a+$*(5*m)+U*(5*y)+M*(5*g)+N*(5*p);A=F>>>13,F&=8191,F+=w*(5*f)+b*(5*h)+C*(5*d)+P*(5*u)+k*(5*c),A+=F>>>13,F&=8191;let R=A+I*c+$*a+U*(5*m)+M*(5*y)+N*(5*g);A=R>>>13,R&=8191,R+=w*(5*p)+b*(5*f)+C*(5*h)+P*(5*d)+k*(5*u),A+=R>>>13,R&=8191;let B=A+I*u+$*c+U*a+M*(5*m)+N*(5*y);A=B>>>13,B&=8191,B+=w*(5*g)+b*(5*p)+C*(5*f)+P*(5*h)+k*(5*d),A+=B>>>13,B&=8191;let K=A+I*d+$*u+U*c+M*a+N*(5*m);A=K>>>13,K&=8191,K+=w*(5*y)+b*(5*g)+C*(5*p)+P*(5*f)+k*(5*h),A+=K>>>13,K&=8191;let re=A+I*h+$*d+U*u+M*c+N*a;A=re>>>13,re&=8191,re+=w*(5*m)+b*(5*y)+C*(5*g)+P*(5*p)+k*(5*f),A+=re>>>13,re&=8191;let ee=A+I*f+$*h+U*d+M*u+N*c;A=ee>>>13,ee&=8191,ee+=w*a+b*(5*m)+C*(5*y)+P*(5*g)+k*(5*p),A+=ee>>>13,ee&=8191;let W=A+I*p+$*f+U*h+M*d+N*u;A=W>>>13,W&=8191,W+=w*c+b*a+C*(5*m)+P*(5*y)+k*(5*g),A+=W>>>13,W&=8191;let le=A+I*g+$*p+U*f+M*h+N*d;A=le>>>13,le&=8191,le+=w*u+b*c+C*a+P*(5*m)+k*(5*y),A+=le>>>13,le&=8191;let me=A+I*y+$*g+U*p+M*f+N*h;A=me>>>13,me&=8191,me+=w*d+b*u+C*c+P*a+k*(5*m),A+=me>>>13,me&=8191;let Ee=A+I*m+$*y+U*g+M*p+N*f;A=Ee>>>13,Ee&=8191,Ee+=w*h+b*d+C*u+P*c+k*a,A+=Ee>>>13,Ee&=8191,A=(A<<2)+A|0,A=A+F|0,F=A&8191,A=A>>>13,R+=A,i[0]=F,i[1]=R,i[2]=B,i[3]=K,i[4]=re,i[5]=ee,i[6]=W,i[7]=le,i[8]=me,i[9]=Ee}finalize(){const{h:t,pad:e}=this,n=new Uint16Array(10);let s=t[1]>>>13;t[1]&=8191;for(let a=2;a<10;a++)t[a]+=s,s=t[a]>>>13,t[a]&=8191;t[0]+=s*5,s=t[0]>>>13,t[0]&=8191,t[1]+=s,s=t[1]>>>13,t[1]&=8191,t[2]+=s,n[0]=t[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=t[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)t[a]=t[a]&i|n[a];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let o=t[0]+e[0];t[0]=o&65535;for(let a=1;a<8;a++)o=(t[a]+e[a]|0)+(o>>>16)|0,t[a]=o&65535;nr(n)}update(t){Hh(this),He(t),t=Ri(t);const{buffer:e,blockLen:n}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(t,i);continue}e.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(e,0,!1),this.pos=0)}return this}destroy(){nr(this.h,this.r,this.buffer,this.pad)}digestInto(t){Hh(this),T1(t,this),this.finished=!0;const{buffer:e,h:n}=this;let{pos:s}=this;if(s){for(e[s++]=1;s<16;s++)e[s]=0;this.process(e,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)t[i++]=n[o]>>>0,t[i++]=n[o]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}}function V1(r){const t=(n,s)=>r(s).update(n).digest(),e=r(new Uint8Array(32));return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=n=>r(n),t}const W1=V1(r=>new K1(r));function H1(r,t,e,n,s,i=20){let o=r[0],a=r[1],c=r[2],u=r[3],d=t[0],h=t[1],f=t[2],p=t[3],g=t[4],y=t[5],m=t[6],S=t[7],v=s,E=e[0],L=e[1],x=e[2],_=o,O=a,T=c,I=u,$=d,U=h,M=f,N=p,w=g,b=y,C=m,P=S,k=v,A=E,F=L,R=x;for(let K=0;K<i;K+=2)_=_+$|0,k=te(k^_,16),w=w+k|0,$=te($^w,12),_=_+$|0,k=te(k^_,8),w=w+k|0,$=te($^w,7),O=O+U|0,A=te(A^O,16),b=b+A|0,U=te(U^b,12),O=O+U|0,A=te(A^O,8),b=b+A|0,U=te(U^b,7),T=T+M|0,F=te(F^T,16),C=C+F|0,M=te(M^C,12),T=T+M|0,F=te(F^T,8),C=C+F|0,M=te(M^C,7),I=I+N|0,R=te(R^I,16),P=P+R|0,N=te(N^P,12),I=I+N|0,R=te(R^I,8),P=P+R|0,N=te(N^P,7),_=_+U|0,R=te(R^_,16),C=C+R|0,U=te(U^C,12),_=_+U|0,R=te(R^_,8),C=C+R|0,U=te(U^C,7),O=O+M|0,k=te(k^O,16),P=P+k|0,M=te(M^P,12),O=O+M|0,k=te(k^O,8),P=P+k|0,M=te(M^P,7),T=T+N|0,A=te(A^T,16),w=w+A|0,N=te(N^w,12),T=T+N|0,A=te(A^T,8),w=w+A|0,N=te(N^w,7),I=I+$|0,F=te(F^I,16),b=b+F|0,$=te($^b,12),I=I+$|0,F=te(F^I,8),b=b+F|0,$=te($^b,7);let B=0;n[B++]=o+_|0,n[B++]=a+O|0,n[B++]=c+T|0,n[B++]=u+I|0,n[B++]=d+$|0,n[B++]=h+U|0,n[B++]=f+M|0,n[B++]=p+N|0,n[B++]=g+w|0,n[B++]=y+b|0,n[B++]=m+C|0,n[B++]=S+P|0,n[B++]=v+k|0,n[B++]=E+A|0,n[B++]=L+F|0,n[B++]=x+R|0}const G1=q1(H1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Y1=new Uint8Array(16),Qh=(r,t)=>{r.update(t);const e=t.length%16;e&&r.update(Y1.subarray(e))},X1=new Uint8Array(32);function Jh(r,t,e,n,s){s!==void 0&&He(s,void 0,"AAD");const i=r(t,e,X1),o=M1(n.length,s?s.length:0,!0),a=W1.create(i);s&&Qh(a,s),Qh(a,n),a.update(o);const c=a.digest();return nr(i,o),c}const jh=k1({blockSize:64,nonceLength:12,tagLength:16},(r=>(t,e,n)=>({encrypt(i,o){const a=i.length;o=Gh(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(t,e,c,c,1);const u=Jh(r,t,e,c,n);return o.set(u,a),nr(u),o},decrypt(i,o){o=Gh(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Jh(r,t,e,a,n);if(!R1(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(t,e,o,o,1),nr(u),o}}))(G1));function Z1(r,t,e){return Ms(r),e===void 0&&(e=new Uint8Array(r.outputLen)),js(r,e,t)}const ac=Uint8Array.of(0),ef=Uint8Array.of();function Q1(r,t,e,n=32){Ms(r),Bt(n,"length");const s=r.outputLen;if(n>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(n/s);e===void 0?e=ef:X(e,void 0,"info");const o=new Uint8Array(i*s),a=js.create(r,t),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let d=0;d<i;d++)ac[0]=d+1,c.update(d===0?ef:u).update(e).update(ac).digestInto(u),o.set(u,s*d),a._cloneInto(c);return a.destroy(),c.destroy(),nn(u,ac),o.slice(0,n)}const J1={hashSHA256(r){return Rr(r.subarray())},getHKDF(r,t){const e=Z1(Rr,t,r),s=Q1(Rr,e,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=Ys.utils.randomSecretKey();return{publicKey:Ys.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:Ys.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,t){return Ys.getSharedSecret(r.subarray(),t.subarray())},chaCha20Poly1305Encrypt(r,t,e,n){return jh(n,t,e).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,t,e,n,s){return jh(n,t,e).decrypt(r.subarray(),s)}};function j1(r){return{generateKeypair:r.generateX25519KeyPair,dh:(t,e)=>r.generateX25519SharedKey(t.privateKey,e).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const Mi=r=>{const t=gt(2);return t[0]=r>>8,t[1]=r,t};Mi.bytes=2;const Ni=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let t=0;return t+=r[0]<<8,t+=r[1],t}return r.getUint16(0)};Ni.bytes=2;function ex(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function tf(r,t){!t.enabled||!is||(r?(t(`LOCAL_STATIC_PUBLIC_KEY ${J(r.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${J(r.privateKey,"hex")}`)):t("Missing local static keys."))}function nf(r,t){!t.enabled||!is||(r?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${J(r.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${J(r.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function tx(r,t){!t.enabled||!is||t(r?`REMOTE_STATIC_PUBLIC_KEY ${J(r.subarray(),"hex")}`:"Missing remote static public key.")}function rf(r,t){!t.enabled||!is||t(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${J(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function sf(r,t,e){!e.enabled||!is||(e(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&J(r.k,"hex")}`),e(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&J(t.k,"hex")}`))}const Ji=class Ji extends Error{constructor(e="Invalid crypto exchange"){super(e);l(this,"code");this.code=Ji.code}};l(Ji,"code","ERR_INVALID_CRYPTO_EXCHANGE");let os=Ji;const nx=0,rx=4294967295,sx="Cipherstate has reached maximum n, a new handshake must be performed";class ix{constructor(t=nx){l(this,"n");l(this,"bytes");l(this,"view");this.n=t,this.bytes=ae(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>rx)throw new Error(sx)}}const rr=ae(0);class Oi{constructor(t,e=void 0,n=0){l(this,"k");l(this,"n");l(this,"crypto");this.crypto=t,this.k=e,this.n=new ix(n)}hasKey(){return!!this.k}encryptWithAd(t,e){if(!this.hasKey())return e;this.n.assertValue();const n=this.crypto.encrypt(e,this.n.getBytes(),t,this.k);return this.n.increment(),n}decryptWithAd(t,e,n){if(!this.hasKey())return e;this.n.assertValue();const s=this.crypto.decrypt(e,this.n.getBytes(),t,this.k,n);return this.n.increment(),s}}class ox{constructor(t,e){l(this,"cs");l(this,"ck");l(this,"h");l(this,"crypto");this.crypto=t;const n=Y(e,"utf-8");this.h=cx(t,n),this.ck=this.h,this.cs=new Oi(t)}mixKey(t){const[e,n]=this.crypto.hkdf(this.ck,t);this.ck=e,this.cs=new Oi(this.crypto,n)}mixHash(t){this.h=this.crypto.hash(new Q(this.h,t))}encryptAndHash(t){const e=this.cs.encryptWithAd(this.h,t);return this.mixHash(e),e}decryptAndHash(t){const e=this.cs.decryptWithAd(this.h,t);return this.mixHash(t),e}split(){const[t,e]=this.crypto.hkdf(this.ck,rr);return[new Oi(this.crypto,t),new Oi(this.crypto,e)]}}class ax{constructor(t){l(this,"ss");l(this,"s");l(this,"e");l(this,"rs");l(this,"re");l(this,"initiator");l(this,"crypto");const{crypto:e,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=t;this.crypto=e,this.ss=new ox(e,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const t=this.crypto.generateKeypair();return this.ss.mixHash(t.publicKey),this.e=t,t.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(t,e=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(t.byteLength<e+32)throw new Error("message is not long enough");this.re=t.sublist(e,e+32),this.ss.mixHash(this.re)}readS(t,e=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(t.byteLength<e+n)throw new Error("message is not long enough");const s=t.sublist(e,e+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class of extends ax{writeMessageA(t){return new Q(this.writeE(),this.ss.encryptAndHash(t))}writeMessageB(t){const e=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new Q(e,n,this.ss.encryptAndHash(t))}writeMessageC(t){const e=this.writeS();return this.writeSE(),new Q(e,this.ss.encryptAndHash(t))}readMessageA(t){try{return this.readE(t),this.ss.decryptAndHash(t.sublist(32))}catch(e){throw new os(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(t){try{this.readE(t),this.readEE();const e=this.readS(t,32);return this.readES(),this.ss.decryptAndHash(t.sublist(32+e))}catch(e){throw new os(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(t){try{const e=this.readS(t);return this.readSE(),this.ss.decryptAndHash(t.sublist(e))}catch(e){throw new os(`handshake stage 2 validation fail: ${e.message}`)}}}function cx(r,t){if(t.length<=32){const e=ae(32);return e.set(t),e}else return r.hash(t)}var Fi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.webtransportCerthashes!=null)for(const i of e.webtransportCerthashes)n.uint32(10),n.bytes(i);if(e.streamMuxers!=null)for(const i of e.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new Ct('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(e.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new Ct('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(e.string());break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Fi||(Fi={}));var Bi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.identityKey!=null&&e.identityKey.byteLength>0&&(n.uint32(10),n.bytes(e.identityKey)),e.identitySig!=null&&e.identitySig.byteLength>0&&(n.uint32(18),n.bytes(e.identitySig)),e.extensions!=null&&(n.uint32(34),Fi.codec().encode(e.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={identityKey:ae(0),identitySig:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.identityKey=e.bytes();break}case 2:{i.identitySig=e.bytes();break}case 4:{i.extensions=Fi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Bi||(Bi={}));async function af(r,t,e){const n=await r.sign(lf(t));return Bi.encode({identityKey:It(r.publicKey),identitySig:n,extensions:e})}async function cf(r,t,e){try{const n=Bi.decode(r),s=Ht(n.identityKey);if((e==null?void 0:e.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${e}`);if(!t)throw new Error("Remote static does not exist");const i=lf(t);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new ps(n.message)}}function lf(r){const t=Y("noise-libp2p-static-key:");return r instanceof Uint8Array?Ft([t,r],t.length+r.length):(r.prepend(t),r)}class lx extends pa{constructor(e,n,s){super({log:e.log,inactivityTimeout:e.inactivityTimeout,maxReadBufferLength:e.maxReadBufferLength,direction:e.direction});l(this,"stream");l(this,"handshake");l(this,"metrics");l(this,"decoder");this.stream=e,this.handshake=n,this.metrics=s,this.decoder=new Y0({lengthDecoder:Ni,maxBufferSize:16*1024*1024,encodingLength:()=>2});const i=u=>{try{for(const d of this.decoder.decode(u.data))this.onData(this.decrypt(d))}catch(d){this.abort(d)}};this.stream.addEventListener("message",i);const o=u=>{u.error!=null?u.local===!0?this.abort(u.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(e){var s;const n=new Q;for(let i=0;i<e.byteLength;i+=Vh){let o=i+Vh;o>e.byteLength&&(o=e.byteLength);let a;e instanceof Uint8Array?a=this.handshake.encrypt(e.subarray(i,o)):a=this.handshake.encrypt(e.sublist(i,o)),(s=this.metrics)==null||s.encryptedPackets.increment(),n.append(Mi(a.byteLength)),n.append(a)}return n}decrypt(e){var s,i;const n=new Q;for(let o=0;o<e.byteLength;o+=ss){let a=o+ss;if(a>e.byteLength&&(a=e.byteLength),a-Wh<o)throw new Error("Invalid chunk");let c;e instanceof Uint8Array?c=e.subarray(o,a):c=e.sublist(o,a);const u=e.subarray(o,a-Wh);try{const d=this.handshake.decrypt(c,u);(s=this.metrics)==null||s.decryptedPackets.increment(),n.append(d)}catch(d){throw(i=this.metrics)==null||i.decryptErrors.increment(),d}}return n}close(e){return this.stream.close(e)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(e){this.stream.abort(e)}sendData(e){return{sentBytes:e.byteLength,canSendMore:this.stream.send(this.encrypt(e))}}}function uf(r,t,e){return new lx(r,t,e)}async function ux(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await af(i,a.publicKey,u),h=new of({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});tf(h.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(rr),t),e.trace("Stage 0 - Initiator finished sending first message."),nf(h.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=h.readMessageB(await n.read(t));e.trace("Stage 1 - Initiator received the message."),rf(h.re,e),tx(h.rs,e),e.trace("Initiator going to check remote's signature...");const p=await cf(f,h.rs,c);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(d),t),e.trace("Stage 2 - Initiator sent message with signed payload.");const[g,y]=h.ss.split();return sf(g,y,e),{payload:p,encrypt:m=>g.encryptWithAd(rr,m),decrypt:(m,S)=>y.decryptWithAd(rr,m,S)}}async function dx(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await af(i,a.publicKey,u),h=new of({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});tf(h.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),e.trace("Stage 0 - Responder received first message."),rf(h.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(d),t),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),nf(h.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const f=h.readMessageC(await n.read(t));e.trace("Stage 2 - Responder received the message, finished handshake.");const p=await cf(f,h.rs,c),[g,y]=h.ss.split();return sf(g,y,e),{payload:p,encrypt:m=>y.encryptWithAd(rr,m),decrypt:(m,S)=>g.decryptWithAd(rr,m,S)}}mg=Symbol.toStringTag,gg=St;class hx{constructor(t,e={}){l(this,"protocol","/noise");l(this,"crypto");l(this,"prologue");l(this,"staticKey");l(this,"extensions");l(this,"metrics");l(this,"components");l(this,"log");l(this,mg,"@chainsafe/libp2p-noise");l(this,gg,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=e,{metrics:a}=t;this.components=t,this.log=t.logger.forComponent("libp2p:noise");const c=i??J1;this.crypto=j1(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?ex(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ae(0)}async secureOutbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=jr(t,{lengthEncoder:Mi,lengthDecoder:Ni,maxDataLength:ss}),i=await this.performHandshakeInitiator(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Ht(i.payload.identityKey);return{connection:uf(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:zr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}getStreamMuxer(t){if(t==null||t.length===0)return;const e=this.components.upgrader.getStreamMuxers();if(e!=null)for(const n of t){const s=e.get(n);if(s!=null)return s}if(t.length)throw new zg("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=jr(t,{lengthEncoder:Mi,lengthDecoder:Ni,maxDataLength:ss}),i=await this.performHandshakeResponder(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Ht(i.payload.identityKey);return{connection:uf(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:zr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}async performHandshakeInitiator(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await ux({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}async performHandshakeResponder(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await dx({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}}function fx(r={}){return t=>new hx(t,r)}function gx(r){return t=>new C1(t,r)}var _e;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(_e||(_e={}));var oe;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(oe||(oe={})),Object.values(oe).filter(r=>typeof r!="string");const mx=0;var nt;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(nt||(nt={}));const vn=12;class as extends Error{constructor(e,n){super(e);l(this,"reason");this.name="ProtocolError",this.reason=n}}l(as,"name","ProtocolError");function px(r){return(r==null?void 0:r.reason)!==null}class Sn extends as{constructor(t="The frame was invalid"){super(t,nt.ProtocolError),this.name="InvalidFrameError"}}l(Sn,"name","InvalidFrameError");class df extends as{constructor(t="Un-requested ping error"){super(t,nt.ProtocolError),this.name="UnRequestedPingError"}}l(df,"name","UnRequestedPingError");class hf extends as{constructor(t="Not matching ping error"){super(t,nt.ProtocolError),this.name="NotMatchingPingError"}}l(hf,"name","NotMatchingPingError");class ff extends as{constructor(t="Receive window exceeded"){super(t,nt.ProtocolError),this.name="ReceiveWindowExceededError"}}l(ff,"name","ReceiveWindowExceededError");const gf=256*1024,yx=16*1024*1024,$i={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function wx(r){var t,e,n,s,i,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new G("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new G("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new G("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new G("MaxMessageSize must be greater than a kilobyte");if(((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)!=null&&((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)<gf)throw new G("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.initialStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new G("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new G("MaxStreamWindowSize must be less than equal MAX_UINT32")}function bx(r){return r.header.type===_e.Data&&r.data!==null}const mf=2**24;function Ex(r){if(r[0]!==mx)throw new Sn("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*mf+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*mf+(r[9]<<16)+(r[10]<<8)+r[11]}}class vx{constructor(){l(this,"buffer");this.buffer=new Q}*emitFrames(t){for(this.buffer.append(t);;){const e=this.readFrame();if(e===void 0)break;yield e}}readFrame(){let t=vn;if(this.buffer.byteLength<vn)return;const e=Ex(this.buffer.subarray(0,vn));if(e.type===_e.Data){if(t+=e.length,this.buffer.byteLength<t)return;const n=this.buffer.sublist(vn,t);return this.buffer.consume(t),{header:e,data:n}}return this.buffer.consume(t),{header:e}}}function pf(r){const t=new Uint8Array(vn);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var Qe;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(Qe||(Qe={}));class Sx extends Ou{constructor(e){const n=e.initialStreamWindowSize??gf;super({...e,maxMessageSize:n-vn});l(this,"streamId");l(this,"state");l(this,"sendWindowCapacity");l(this,"recvWindow");l(this,"recvWindowCapacity");l(this,"maxStreamWindowSize");l(this,"epochStart");l(this,"getRTT");l(this,"sendFrame");this.streamId=e.streamId,this.state=e.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=e.maxStreamWindowSize??yx,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame;const s=()=>{this.state=Qe.Finished};this.addEventListener("close",s)}sendData(e){var o,a;const n=e.byteLength;let s=0,i=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);e.byteLength>0;){if(this.sendWindowCapacity===0){i=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",s,n);break}const c=Math.min(this.sendWindowCapacity,e.byteLength),u=this.getSendFlags(),d=e.sublist(0,c);e.consume(c);const h=this.sendFrame({type:_e.Data,flag:u,streamID:this.streamId,length:c},d);if(this.sendWindowCapacity-=c,s+=c,!h){i=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",s,n);break}}return{sentBytes:s,canSendMore:i}}async sendReset(){this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|oe.FIN;this.sendFrame({type:_e.WindowUpdate,flag:e,streamID:this.streamId,length:0})}async sendCloseRead(e){var n;(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendPause(){this.state=Qe.Paused}sendResume(){this.state=Qe.Established,this.sendWindowUpdate()}handleWindowUpdate(e){var n;this.processFlags(e.header.flag),this.sendWindowCapacity+=e.header.length,this.maxMessageSize=this.sendWindowCapacity-vn,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",e.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(e){if(!bx(e))throw new Sn("Frame was not data frame");if(this.processFlags(e.header.flag),this.recvWindowCapacity<e.header.length)throw new ff("Receive window exceeded");this.recvWindowCapacity-=e.header.length,this.onData(e.data),this.sendWindowUpdate()}processFlags(e){(e&oe.ACK)===oe.ACK&&this.state===Qe.SYNSent&&(this.state=Qe.Established),(e&oe.FIN)===oe.FIN&&this.onRemoteCloseWrite(),(e&oe.RST)===oe.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case Qe.Init:return this.state=Qe.SYNSent,oe.SYN;case Qe.SYNReceived:return this.state=Qe.Established,oe.ACK;default:return 0}}sendWindowUpdate(){if(this.state===Qe.Paused){this.epochStart=Date.now();return}const e=this.getSendFlags(),n=Date.now(),s=this.getRTT();if(e===0&&s>-1&&n-this.epochStart<=s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:_e.WindowUpdate,flag:e,streamID:this.streamId,length:i})}}function yf(r){return{type:_e[r.type],flags:[(r.flag&oe.SYN)===oe.SYN?"SYN":void 0,(r.flag&oe.ACK)===oe.ACK?"ACK":void 0,(r.flag&oe.FIN)===oe.FIN?"FIN":void 0,(r.flag&oe.RST)===oe.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const wf="/yamux/1.0.0";yg=Symbol.toStringTag,pg=St;class xx{constructor(t={}){l(this,"protocol",wf);l(this,"_init");l(this,yg,"@chainsafe/libp2p-yamux");l(this,pg,["@libp2p/stream-multiplexing"]);this._init=t}createStreamMuxer(t){return new Ax(t,{...this._init})}}class Ax extends Nu{constructor(e,n={}){super(e,{...n,protocol:wf,name:"yamux"});l(this,"nextStreamID");l(this,"nextPingID");l(this,"activePing");l(this,"rtt");l(this,"client");l(this,"localGoAway");l(this,"remoteGoAway");l(this,"numInboundStreams");l(this,"numOutboundStreams");l(this,"decoder");l(this,"keepAlive");l(this,"enableKeepAlive");l(this,"keepAliveInterval");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");this.client=e.direction==="outbound",wx(n),this.enableKeepAlive=n.enableKeepAlive??$i.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??$i.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??$i.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??$i.maxOutboundStreams,this.decoder=new vx,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=tE(async s=>{try{await this.ping(s)}catch(i){this.log.error("ping error: %s",i)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(e){for(const n of this.decoder.emitFrames(e))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new _n("Muxer closed remotely");if(this.localGoAway!==void 0)throw new _n("Muxer closed locally");const e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new fo("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",e);const n=this._newStream(e,Qe.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(e){if(this.remoteGoAway!==void 0)throw new _n("Muxer closed remotely");if(this.localGoAway!==void 0)throw new _n("Muxer closed locally");if(this.activePing!=null)return wt(this.activePing.promise,e==null?void 0:e.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await wt(this.activePing.promise,e==null?void 0:e.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(e={}){var n;if(this.status==="open")try{const s=(e==null?void 0:e.reason)??nt.NormalTermination;this.log.trace("muxer close reason=%s",nt[s]),await super.close(e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}abort(e){var n;if(this.status==="open")try{super.abort(e);let s=nt.InternalError;px(e)&&(s=e.reason),this.log.error("muxer abort reason=%s error=%s",s,e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var e;try{super.onTransportClosed()}finally{(e=this.keepAlive)==null||e.stop()}}_newStream(e,n,s){if(this.streams.find(o=>o.streamId===e)!=null)throw new G("Stream already exists with that id");const i=new Sx({...this.streamOptions,id:`${e}`,streamId:e,state:n,direction:s,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${s}:${e}`),getRTT:this.getRTT.bind(this)});return i.addEventListener("close",()=>{this.closeStream(e)},{once:!0}),i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(e){const{streamID:n,type:s,length:i}=e.header;if(this.log.trace("received frame %o",yf(e.header)),n===0)switch(s){case _e.Ping:{this.handlePing(e.header);return}case _e.GoAway:{this.handleGoAway(i);return}default:throw new Sn("Invalid frame type")}else switch(e.header.type){case _e.Data:case _e.WindowUpdate:{this.handleStreamMessage(e);return}default:throw new Sn("Invalid frame type")}}handlePing(e){if(e.flag===oe.SYN)this.log.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,oe.ACK);else if(e.flag===oe.ACK)this.log.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new Sn("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new df("ping not requested");if(this.activePing.id!==e)throw new hf("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(e){this.log.trace("received GoAway reason=%s",nt[e]??"unknown"),this.remoteGoAway=e,e===nt.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(e){const{streamID:n,flag:s,type:i}=e.header;(s&oe.SYN)===oe.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(i){case _e.WindowUpdate:{o.handleWindowUpdate(e);return}case _e.Data:{o.handleData(e);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new G("Both endpoints are clients");if(this.streams.find(s=>s.streamId===e))return;if(this.log.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:e,length:0});return}const n=this._newStream(e,Qe.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(e,n){let s;if(e.type===_e.Data){if(n==null)throw new Sn("Invalid frame");s=new Q(pf(e),n)}else s=pf(e);return this.log.trace("sending frame %o",yf(e)),this.send(s)}sendPing(e,n=oe.SYN){n===oe.SYN?this.log.trace("sending ping request pingId=%s",e):this.log.trace("sending ping response pingId=%s",e),this.sendFrame({type:_e.Ping,flag:n,streamID:0,length:e})}sendGoAway(e=nt.NormalTermination){this.log("sending GoAway reason=%s",nt[e]),this.localGoAway=e,this.sendFrame({type:_e.GoAway,flag:0,streamID:0,length:e})}}function Cx(r={}){return()=>new xx(r)}const _x="0.1.0",Ix="id",Tx="1.0.0",Lx=1024*8;var Ui;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.protocolVersion!=null&&(n.uint32(42),n.string(e.protocolVersion)),e.agentVersion!=null&&(n.uint32(50),n.string(e.agentVersion)),e.publicKey!=null&&(n.uint32(10),n.bytes(e.publicKey)),e.listenAddrs!=null)for(const i of e.listenAddrs)n.uint32(18),n.bytes(i);if(e.observedAddr!=null&&(n.uint32(34),n.bytes(e.observedAddr)),e.protocols!=null)for(const i of e.protocols)n.uint32(26),n.string(i);e.signedPeerRecord!=null&&(n.uint32(66),n.bytes(e.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 5:{i.protocolVersion=e.string();break}case 6:{i.agentVersion=e.string();break}case 1:{i.publicKey=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new Ct('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(e.bytes());break}case 4:{i.observedAddr=e.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Ct('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 8:{i.signedPeerRecord=e.bytes();break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Ui||(Ui={}));const Pt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:Lx,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function Dx(r){if(r!=null&&r.length>0)try{return Z(r)}catch{}}async function Px(r,t,e,n,s){if(e("received identify from %p",n.remotePeer),s==null)throw new it("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:Z(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Ht(s.publicKey);if(!zr(c).equals(n.remotePeer))throw new it("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){e.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const u=await pn.openAndCertify(c,Lt.DOMAIN);let d=Lt.createFromProtobuf(u.payload);const h=Kr(u.publicKey.toCID());if(!d.peerId.equals(h))throw new it("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(d.peerId))throw new it("signing key does not match remote PeerId");let f;try{f=await r.get(d.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(f!=null&&(i.metadata=f.metadata,f.peerRecordEnvelope!=null)){const p=pn.createFromProtobuf(f.peerRecordEnvelope),g=Lt.createFromProtobuf(p.payload);g.seqNumber>=d.seqNumber&&(e("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,d.seqNumber),d=g,c=f.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=d.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:d.seqNumber,addresses:d.multiaddrs}}else e("%p did not send a signed peer record",n.remotePeer);if(e.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=Y(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=Y(s.protocolVersion)),e.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>Z(c)),observedAddr:s.observedAddr==null?void 0:Z(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}class Rx{constructor(t,e){l(this,"host");l(this,"components");l(this,"protocol");l(this,"started");l(this,"timeout");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");l(this,"maxMessageSize");l(this,"maxObservedAddresses");l(this,"runOnLimitedConnection");l(this,"log");this.protocol=e.protocol,this.started=!1,this.components=t,this.log=e.log,this.timeout=e.timeout??Pt.timeout,this.maxInboundStreams=e.maxInboundStreams??Pt.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??Pt.maxOutboundStreams,this.maxMessageSize=e.maxMessageSize??Pt.maxMessageSize,this.maxObservedAddresses=e.maxObservedAddresses??Pt.maxObservedAddresses,this.runOnLimitedConnection=e.runOnLimitedConnection??Pt.runOnLimitedConnection,this.host={protocolVersion:`${e.protocolPrefix??Pt.protocolPrefix}/${_x}`,agentVersion:t.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:Y(this.host.agentVersion),ProtocolVersion:Y(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}class kx extends(bg=Rx,wg=St,bg){constructor(e,n={}){super(e,{...n,protocol:`/${n.protocolPrefix??Pt.protocolPrefix}/${Ix}/${Tx}`,log:e.logger.forComponent("libp2p:identify")});l(this,wg,["@libp2p/identify"]);(n.runOnConnectionOpen??Pt.runOnConnectionOpen)&&e.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(()=>{})})}async _identify(e,n={}){let s,i;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",e.remoteAddr);try{s=await e.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),i=s.log.newScope("identify");const o=gn(s,{maxDataLength:this.maxMessageSize}).pb(Ui),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw i==null||i.error("identify failed - %e",o),s==null||s.abort(o),o}}async identify(e,n={}){const s=await this._identify(e,n),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new it("Public key was missing from identify message");const c=Ht(i),u=Kr(c.toCID());if(!e.remotePeer.equals(u))throw new it("Identified peer does not match the expected peer");if(this.components.peerId.equals(u))throw new it("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",u,o),Px(this.components.peerStore,this.components.events,this.log,e,s)}maybeAddObservedAddress(e){const n=Dx(e);if(n==null||(this.log.trace("our observed address was %a",n),Vn(n)))return;const s=n.getComponents();if((s[0].code===Gn||s[0].code===wa&&s[1].code===Gn)&&!Eb(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}xi.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(e,n){const s=e.log.newScope("identify");s("responding to identify");const i=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:i}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(H));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new Lt({peerId:this.components.peerId,multiaddrs:a});c=(await pn.seal(h,this.components.privateKey,{signal:i})).marshal().subarray()}let u=n.remoteAddr.bytes;jE.matches(n.remoteAddr)||(u=void 0);const d=gn(e).pb(Ui);s("send response"),await d.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:It(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:u,protocols:o.protocols},{signal:i}),s("close write"),await d.unwrap().unwrap().close({signal:i})}}function Mx(r={}){return t=>new kx(t,r)}const Nx=1,bf=5e3,Ox=100,zi=`${po}-circuit-relay`;BigInt(1<<17);const qi="/libp2p/circuit/relay/0.2.0/hop",Ef="/libp2p/circuit/relay/0.2.0/stop",vf=300,Fx=4096,Bx=.001;var sr;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(t||(t={})),function(n){n.codec=()=>kn(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),ir.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),Ki.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),or.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),Ge.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u,d;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const h=n.uint32();switch(h>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=ir.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.reservation=Ki.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.reservation});break}case 4:{o.limit=or.codec().decode(n,n.uint32(),{limits:(d=i.limits)==null?void 0:d.limit});break}case 5:{o.status=Ge.codec().decode(n);break}default:{n.skipType(h&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(sr||(sr={}));var Rt;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(t||(t={})),function(n){n.codec=()=>kn(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),ir.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),or.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),Ge.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const d=n.uint32();switch(d>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=ir.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.limit=or.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.limit});break}case 4:{o.status=Ge.codec().decode(n);break}default:{n.skipType(d&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(Rt||(Rt={}));var ir;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.id!=null&&e.id.byteLength>0&&(n.uint32(10),n.bytes(e.id)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={id:ae(0),addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Ct('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(ir||(ir={}));var Ki;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.expire!=null&&e.expire!==0n&&(n.uint32(8),n.uint64(e.expire)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);e.voucher!=null&&(n.uint32(26),Wi.codec().encode(e.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={expire:0n,addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.expire=e.uint64();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Ct('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}case 3:{i.voucher=Wi.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.voucher});break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Ki||(Ki={}));var or;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.duration!=null&&(n.uint32(8),n.uint32(e.duration)),e.data!=null&&(n.uint32(16),n.uint64(e.data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.duration=e.uint32();break}case 2:{i.data=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(or||(or={}));var Ge;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Ge||(Ge={}));var cc;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(cc||(cc={})),function(r){r.codec=()=>kn(cc)}(Ge||(Ge={}));var Vi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.relay!=null&&e.relay.byteLength>0&&(n.uint32(10),n.bytes(e.relay)),e.peer!=null&&e.peer.byteLength>0&&(n.uint32(18),n.bytes(e.peer)),e.expiration!=null&&e.expiration!==0n&&(n.uint32(24),n.uint64(e.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={relay:ae(0),peer:ae(0),expiration:0n},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.relay=e.bytes();break}case 2:{i.peer=e.bytes();break}case 3:{i.expiration=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Vi||(Vi={}));var Wi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&(n.uint32(26),Vi.codec().encode(e.payload,n)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={publicKey:ae(0),payloadType:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=Vi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.payload});break}case 5:{i.signature=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Wi||(Wi={}));class lc extends Error{constructor(){super(...arguments);l(this,"name","HadEnoughRelaysError")}}l(lc,"name","HadEnoughRelaysError");class Sf extends Error{constructor(){super(...arguments);l(this,"name","DoubleRelayError")}}l(Sf,"name","DoubleRelayError");class xf extends Error{constructor(){super(...arguments);l(this,"name","RelayQueueFullError")}}l(xf,"name","RelayQueueFullError");function Af(r){const t=r*BigInt(1e3),e=new Date().getTime();return Number(t-BigInt(e))}class Cf{constructor(t){l(this,"expires");l(this,"bytes");(t==null?void 0:t.duration)!=null&&(t==null?void 0:t.duration)!==0&&(this.expires=Date.now()+t.duration*1e3),this.bytes=t==null?void 0:t.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(t){this.bytes!=null&&(this.bytes-=BigInt(t.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const t={};if(this.bytes!=null){const e=this;Object.defineProperty(t,"bytes",{get(){return e.bytes}})}if(this.expires!=null){const e=this;Object.defineProperty(t,"seconds",{get(){return Math.round(((e.expires??0)-Date.now())/1e3)}})}return t}}const _f=fe(ie(Wa.matchers[0],he(Zn))),If=fe(he(Zn));class $x extends Ye{constructor(e,n={}){super();l(this,"components");l(this,"started");l(this,"running");l(this,"topologyId");l(this,"log");l(this,"discoveryController");l(this,"filter");l(this,"queue");this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=n.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(qi,{filter:this.filter,onConnect:e=>{var n,s;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,(n=this.queue)==null?void 0:n.size,(s=this.queue)==null?void 0:s.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var s;this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[i=>i.protocols.includes(qi)],orders:[()=>Math.random()<.5?1:-1,(i,o)=>{const a=Tf(i),c=Tf(o);return a>c?-1:c>a?1:0}]});for(const i of e)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",e.length);const n=this.queue=new Da({concurrency:5});this.log("start random walk");for await(const i of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",i.id),n.has(i.id)){this.log.trace("random peer %p was already in queue",i.id);continue}if(((s=this.components.connectionManager.getConnections(i.id))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",i.id);continue}if(!await this.components.connectionManager.isDialable(i.multiaddrs)){this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(o=>o.toString()));continue}n.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await n.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,n.size,n.running),n.add(this.dialPeer,{peerId:i.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",i.id,o)})}this.log("stop random walk"),await n.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",e)}))}stopDiscovery(){var e,n;this.log("stop discovery"),this.running=!1,(e=this.discoveryController)==null||e.abort(),(n=this.queue)==null||n.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p",e.detail.id),this.maybeDialPeer(e).catch(n=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,n)})}async maybeDialPeer(e){var i,o;if(this.queue==null)return;const n=e.detail.id,s=e.detail.multiaddrs;if(this.queue.has(n)){this.log.trace("random peer %p was already in queue",n);return}if(((i=this.components.connectionManager.getConnections(n))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",n);return}if(!await this.components.connectionManager.isDialable(s)){this.log.trace("random peer %p was not dialable",n);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",e.detail.id,a)})}async dialPeer({peerId:e,signal:n}){const s=fn([AbortSignal.timeout(5e3),n]);try{await this.components.connectionManager.openConnection(e,{signal:s})}finally{s.clear()}}}function Tf(r){const t=r.metadata.get("last-dial-success");return t==null?0:new Date(J(t)).getTime()}class Ux extends Ye{constructor(e,n={}){super();l(this,"connectionManager");l(this,"addressManager");l(this,"reservationStore");l(this,"listeningAddrs");l(this,"log");l(this,"listenTimeout");l(this,"reservationId");l(this,"relay");l(this,"_onRemoveRelayPeer",e=>{var n,s;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,(n=this.relay)==null?void 0:n.equals(e.detail.relay)),((s=this.relay)==null?void 0:s.equals(e.detail.relay))===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(i=>{this.addressManager.removeObservedAddr(i)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});l(this,"_onAddRelayPeer",e=>{const{details:n}=e.detail;n.type!=="configured"&&n.id===this.reservationId&&this.addedRelay(e.detail)});this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=n.listenTimeout??bf,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(If.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(_f.exactMatch(e)){this.log("listen on specific relay server %a",e);const n=AbortSignal.timeout(this.listenTimeout),s=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(s,{signal:n});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const o=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(o)}}else throw new bs(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(n=>Z(n).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(n=>{this.addressManager.confirmObservedAddr(n,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function zx(r){return new Ux(r)}const qx="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Kx=(r=21)=>{let t="",e=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)t+=qx[e[r]&63];return t};const Vx=60*1e3*10,Wx=60*1e3*5,Hx=30*1e3;class Gx extends Ye{constructor(e,n){super();ce(this,je);l(this,"peerId");l(this,"connectionManager");l(this,"peerStore");l(this,"events");l(this,"reserveQueue");l(this,"reservations");l(this,"pendingReservations");l(this,"maxReservationQueueLength");l(this,"reservationCompletionTimeout");l(this,"started");l(this,"log");l(this,"relayFilter");this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new Un,this.pendingReservations=[],this.maxReservationQueueLength=(n==null?void 0:n.maxReservationQueueLength)??Ox,this.reservationCompletionTimeout=(n==null?void 0:n.reservationCompletionTimeout)??bf,this.started=!1,this.relayFilter=Gr(100),this.reserveQueue=new Da({concurrency:(n==null?void 0:n.reservationConcurrency)??Nx,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",s=>{[...this.reservations.values()].find(o=>o.connection===s.detail.id)!=null&&z(this,je,gs).call(this,s.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",s.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[n=>n.tags.has(zi)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async n=>{await this.peerStore.merge(n.id,{tags:{[zi]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async n=>this.addRelay(n.id,"discovered"))),z(this,je,ms).call(this)}).catch(e=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=Kx();return this.pendingReservations.push(e),z(this,je,ms).call(this),e}async addRelay(e,n){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new bs("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new xf("The reservation queue is full");const s=this.reserveQueue.find(e);if(s!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),s.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new bs("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const o=this.reservations.get(e);if(o!=null){const y=this.connectionManager.getConnections(e);let m=!1;if(y.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),y.map(S=>S.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&Af(o.reservation.expire)>Vx)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:o};await z(this,je,gs).call(this,e)}if(n==="discovered"&&this.pendingReservations.length===0)throw new lc("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(e,{signal:a});if(tr.matches(c.remoteAddr))throw new Sf("not creating reservation over relayed connection");const u=await z(this,je,Ug).call(this,c,{signal:a}),d=Af(u.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+d).toString());const h=Math.min(Math.max(d-Wx,Hx),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,n).catch(async y=>{this.log.error("could not refresh reservation to relay %p - %e",e,y),await z(this,je,gs).call(this,e)}).catch(y=>{this.log.error("could not remove expired reservation to relay %p - %e",e,y)})},h);let p;if(n==="discovered"){const y=this.pendingReservations.pop();if(y==null)throw new lc("Made reservation on relay but did not need any more discovered relays");p={timeout:f,reservation:u,type:n,connection:c.id,id:y}}else p={timeout:f,reservation:u,type:n,connection:c.id};this.reservations.set(e,p),await this.peerStore.merge(e,{tags:{[zi]:{value:1,ttl:d}}}),z(this,je,ms).call(this);const g={relay:e,details:p};return this.safeDispatchEvent("relay:created-reservation",{detail:g}),g}catch(o){throw n==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),z(this,je,gs).call(this,e).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,a)}),o}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var n;return(n=this.reservations.get(e))==null?void 0:n.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((n,s)=>(s.type===e&&n++,n),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}je=new WeakSet,Ug=async function(e,n){var u;(u=n.signal)==null||u.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const s=await e.newStream(qi,n),o=gn(s).pb(sr);this.log.trace("send RESERVE to %p",e.remotePeer),await o.write({type:sr.Type.RESERVE},n);let a;try{this.log.trace("reading response from %p",e.remotePeer),a=await o.read(n)}catch(d){throw s.abort(d),d}finally{s.status!=="closed"&&await s.close(n)}if(this.log.trace("read response %s",a.status),a.status===Ge.OK&&a.reservation!=null){const d=new Set;d.add(e.remoteAddr.toString());for(const h of a.reservation.addrs){let f=Z(h);f.getComponents().find(p=>p.code===H)==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=Z(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),d.add(f.toString())}return a.reservation.addrs=[...d].map(h=>Z(h).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},gs=async function(e){const n=this.reservations.get(e);n!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(n.timeout),this.reservations.delete(e),n.type==="discovered"&&this.pendingReservations.push(n.id),await this.peerStore.merge(e,{tags:{[zi]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:n}}),z(this,je,ms).call(this))},ms=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Gr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class Yx extends Mu{constructor(e){super({...e,direction:e.stream.direction});l(this,"stream");l(this,"init");this.init=e,this.stream=e.stream,this.stream.addEventListener("close",n=>{this.onTransportClosed(n.error)}),this.stream.addEventListener("remoteCloseWrite",n=>{this.onRemoteCloseWrite(),this.close().catch(s=>{this.abort(s)})}),this.stream.addEventListener("message",n=>{var s;(s=e.onDataRead)==null||s.call(e,n.data),this.onData(n.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(e){var n,s;return(s=(n=this.init).onDataWrite)==null||s.call(n,e),{sentBytes:e.byteLength,canSendMore:this.stream.send(e)}}async sendClose(e){await this.stream.close(e)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function Lf(r){return new Yx(r)}const Xx=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(Z)}catch{return!1}return!0},Df={maxInboundStopStreams:vf,maxOutboundStopStreams:vf};class Zx{constructor(t,e={}){l(this,"components");l(this,"discovery");l(this,"reservationStore");l(this,"maxInboundStopStreams");l(this,"maxOutboundStopStreams");l(this,"started");l(this,"log");l(this,"shutdownController");l(this,xg,"@libp2p/circuit-relay-v2-transport");l(this,Sg,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);l(this,Eg,!0);this.components=t,this.log=t.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=e.maxInboundStopStreams??Df.maxInboundStopStreams,this.maxOutboundStopStreams=e.maxOutboundStopStreams??Df.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new $x(t,{filter:e.discoveryFilter??sE(Fx,Bx)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",n.detail,s)})}),this.reservationStore=new Gx(t,e),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var n;(n=this.discovery)==null||n.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var n;(n=this.discovery)==null||n.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[(xg=Symbol.toStringTag,Sg=St,vg=xs,Eg=Fc,vg)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(Ef,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Nc(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Oc(this.discovery,this.reservationStore),await this.components.registrar.unhandle(Ef),this.started=!1}async dial(t,e){var p,g,y,m,S,v,E,L;const n=t.toString().split("/p2p-circuit"),s=Z(n[0]),i=Z(n[n.length-1]),o=(p=s.getComponents().find(x=>x.code===H))==null?void 0:p.value,a=(g=i.getComponents().find(x=>x.code===H))==null?void 0:g.value;if(o==null||a==null){const x=`ircuit relay dial to ${t.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${x}`),new Er(`C${x}`)}const c=at(o),u=at(a);let h=this.components.connectionManager.getConnections(c)[0];h==null?(await this.components.peerStore.merge(c,{multiaddrs:[s]}),(y=e.onProgress)==null||y.call(e,new ge("circuit-relay:open-connection")),h=await this.components.connectionManager.openConnection(c,e)):(m=e.onProgress)==null||m.call(e,new ge("circuit-relay:reuse-connection"));let f;try{(S=e.onProgress)==null||S.call(e,new ge("circuit-relay:open-hop-stream")),f=await h.newStream(qi,e);const x=gn(f).pb(sr);(v=e.onProgress)==null||v.call(e,new ge("circuit-relay:write-connect-message")),await x.write({type:sr.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[Z(i).bytes]}},e),(E=e.onProgress)==null||E.call(e,new ge("circuit-relay:read-connect-response"));const _=await x.read(e);if(_.status!==Ge.OK)throw new it(`failed to connect via relay with status ${((L=_==null?void 0:_.status)==null?void 0:L.toString())??"undefined"}`);const O=new Cf(_.limit),T=Lf({stream:x.unwrap().unwrap(),remoteAddr:t,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:O.onData,onDataWrite:O.onData,log:f.log.newScope("circuit-relay:connection")}),I=await this.components.upgrader.upgradeOutbound(T,{...e,limits:O.getLimits()});return I.log("outbound relayed connection established to %p with limits %o, over connection %s",I.remotePeer,_.limit??"none",h.id),I}catch(x){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",u,c,x),f==null||f.abort(x),x}}createListener(t){return zx({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>_f.exactMatch(e)||If.exactMatch(e))}dialFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>tr.exactMatch(e))}async onStop(t,e){var s,i;const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(p){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",p)}const o=gn(t).pb(Rt),a=await o.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await o.write({type:Rt.Type.STATUS,status:Ge.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(a.type!==Rt.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:Rt.Type.STATUS,status:Ge.UNEXPECTED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(!Xx(a)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:Rt.Type.STATUS,status:Ge.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const c=qr(xr(a.peer.id));if(await((i=(s=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:i.call(s,e.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await o.write({type:Rt.Type.STATUS,status:Ge.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await o.write({type:Rt.Type.STATUS,status:Ge.OK},{signal:n});const u=new Cf(a.limit),d=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),h=this.components.addressManager.getAddresses()[0],f=Lf({stream:o.unwrap().unwrap(),remoteAddr:d,localAddr:h,onDataRead:u.onData,onDataWrite:u.onData,log:t.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(f,{limits:u.getLimits(),signal:n}),f.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",e.id)}finally{n==null||n.clear()}}}function Qx(r={}){return t=>new Zx(t,r)}const Jx="bootstrap",jx=50,e2=1e3;class Pf extends(Ig=Ye,_g=go,Cg=Symbol.toStringTag,Ag=St,Ig){constructor(e,n={list:[]}){if(n.list==null||n.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();l(this,"log");l(this,"timer");l(this,"list");l(this,"timeout");l(this,"components");l(this,"_init");l(this,_g,this);l(this,Cg,"@libp2p/bootstrap");l(this,Ag,["@libp2p/peer-discovery"]);this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=n.timeout??e2,this.list=n.list.map(s=>Z(s)).filter(s=>{var o;return Wa.matches(s)?((o=s.getComponents().findLast(a=>a.code===H))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",s),!1)}).map(s=>{var i;return{id:at(((i=s.getComponents().findLast(o=>o.code===H))==null?void 0:i.value)??""),multiaddrs:[s]}}),this._init=n}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error("failed to discover bootstrap peers - %e",e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??Jx]:{value:this._init.tagValue??jx,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not dial bootstrap peer %p - %e",e.id,n)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}l(Pf,"tag","bootstrap");function t2(r){return t=>new Pf(t,r)}const Rf=location.hostname.split(".")[0],n2=location.pathname==="/"||location.pathname===""?`${Rf}.github.io`:location.pathname.split("/")[1],ut=`${Rf}/${n2}`,uc=`https://api.github.com/repos/${ut}/contents/data/state.json`,Hi="gitchain_github_access_token",Gi=`https://api.github.com/repos/${ut}/issues`,kf="/gitchain/tx/1.0.0",Zt="data/server-peer.json",r2=5*60*1e3;let Qt=null,Yi=!1,Mf=null;function Nf(r,t,e,n){const s=`${r}${t}${e}${JSON.stringify(n)}`;return CryptoJS.SHA256(s).toString()}function s2(){const r=new Date().toISOString();return{index:0,previousHash:"0",timestamp:r,transactions:[],hash:Nf(0,"0",r,[])}}function Of(r){return JSON.stringify(r,Object.keys(r).sort())}function dc(r){const e=sha3.keccak256(r).match(/.{2}/g);if(!e)throw new Error("Failed to parse hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}function i2(r){const t=new Uint8Array(r.length/2);for(let e=0;e<r.length;e+=2)t[e/2]=parseInt(r.substr(e,2),16);return t}function cs(r){return Array.from(r,t=>t.toString(16).padStart(2,"0")).join("")}function hc(r){try{const t=dc(Of({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})),e=i2(r.signature);if(e.length!==65)return!1;const n=cs(e.slice(0,32)),s=cs(e.slice(32,64)),i=e[64]-27,o=new ec("secp256k1"),a=cs(t),c={r:n,s},u=o.recoverPubKey(a,c,i),d=dc(u.encode("array",!0).slice(1));return`0x${cs(d.slice(-20))}`.toLowerCase()===r.from.toLowerCase()}catch{return!1}}async function o2(r,t){const e=cs(dc(Of({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})));return hc(r)?(t.nonces[r.from]||0)+1!==r.nonce?{valid:!1,txid:e}:r.from.toLowerCase()!==ne.toLowerCase()&&(t.balances[r.from]||0)<r.amount?{valid:!1,txid:e}:!/^0x[a-fA-F0-9]{40}$/.test(r.from)||!/^0x[a-fA-F0-9]{40}$/.test(r.to)?{valid:!1,txid:e}:(t.pending.push(r),{valid:!0,txid:e}):{valid:!1,txid:e}}async function a2(r){if(r.pending.length===0)return null;const t=[],e={...r.balances},n={...r.nonces};for(const u of r.pending)hc(u)&&(n[u.from]||0)+1===u.nonce&&(u.from.toLowerCase()===ne.toLowerCase()||(e[u.from]||0)>=u.amount)&&(u.from.toLowerCase()!==ne.toLowerCase()&&(e[u.from]=(e[u.from]||0)-u.amount),e[u.to]=(e[u.to]||0)+u.amount,n[u.from]=u.nonce,t.push(u));if(t.length===0)return r.pending=[],null;const s=r.chain.length,i=r.chain.length>0?r.chain[r.chain.length-1].hash:"0",o=new Date().toISOString(),a=Nf(s,i,o,t),c={index:s,previousHash:i,timestamp:o,transactions:t,hash:a};return r.chain.push(c),r.pending=[],r.balances=e,r.nonces=n,s}function Jt(){var t;let r=localStorage.getItem(Hi);if(!r){if(r=(t=document.getElementById("githubAccessToken"))==null?void 0:t.value,!r)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(Hi,r)}return console.log("Retrieved GitHub access token"),r}async function Ff(r){console.log("Entering initP2P, isHost:",r),Yi=r;try{console.log("Creating libp2p node..."),Qt=await ZS({addresses:{listen:["/webrtc","/p2p-circuit"]},transports:[Qx({hop:{enabled:!1}}),gx({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncrypters:[fx()],streamMuxers:[Cx()],peerDiscovery:[t2({list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbX7TbXrHRQHh2","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqduuO5wL","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76C42gEOzRVzYVdigitaltA5dyxuEXsBC","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp"]})],services:{identify:Mx()},connectionGater:{denyDialMultiaddr:async()=>!1}}),console.log("Starting libp2p node..."),await Qt.start(),console.log("libp2p started, peerId:",Qt.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(e=>setTimeout(e,1e3)),Qt.addEventListener("peer:connect",e=>{console.log("Connected to peer:",e.detail.toString())}),console.log("Registering protocol handler for:",kf),await Qt.handle(kf,async({stream:e,connection:n})=>{console.log("Incoming TX stream from",n.remotePeer.toString());const s=await l2(e);try{const i=JSON.parse(s);if(hc(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:ut,txn:i}),a=await fetch(Gi,{method:"POST",headers:{Authorization:`token ${Jt()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}e.close()}),Yi&&(console.log("Host mode: Advertising peer info"),await Bf(),console.log("Setting interval for periodic peer advertising"),setInterval(Bf,r2),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await c2()})),console.log("initP2P completed successfully")}catch(t){console.error("Failed to initialize P2P:",t),Yi&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function Bf(r=3,t=1e3){if(console.log("Entering advertiseServerPeer, retries:",r),!Yi||!Qt)return console.log("Not in host mode or libp2p not initialized"),!1;const e=Qt.peerId.toString(),n=Qt.getMultiaddrs().map(a=>a.toString()),s={peerId:e,multiaddrs:n,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===Mf)return console.log("No change in peer info, skipping update"),!0;Mf=i;const o=Jt();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=r;a++){console.log(`Attempt ${a}/${r} to advertise peer info`);try{console.log("Fetching SHA for",Zt);const c=await $f(Zt);console.log("SHA:",c||"none (new file)");const u={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(u.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${ut}/contents/${Zt}`);const d=await fetch(`https://api.github.com/repos/${ut}/contents/${Zt}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(u)});if(d.ok)return console.log("Advertised peer info successfully"),!0;{const h=await d.text();if(console.error(`Attempt ${a}/${r} - Failed to advertise peer: ${d.status} ${h}`),(d.status===403||d.status===429)&&(console.log(`Retrying after ${t}ms due to ${d.status}`),a<r)){await new Promise(f=>setTimeout(f,t));continue}throw new Error(`HTTP ${d.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${r} - Error advertising peer:`,c),a===r)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(u=>setTimeout(u,t))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function c2(){console.log("Entering deleteServerPeerFile");const r=Jt();if(!r){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",Zt);const t=await $f(Zt);if(!t){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",Zt);const e=await fetch(`https://api.github.com/repos/${ut}/contents/${Zt}`,{method:"DELETE",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:t})});e.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",e.status,await e.text())}catch(t){console.error("Error deleting peer file:",t)}}async function $f(r){console.log("Entering getFileSha for",r);const t=Jt();if(!t)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${ut}/contents/${r}?ref=main`);const e=await fetch(`https://api.github.com/repos/${ut}/contents/${r}?ref=main`,{headers:{Authorization:`token ${t}`,Accept:"application/vnd.github.v3+json"}});if(e.ok){const n=await e.json();return console.log("SHA retrieved:",n.sha),n.sha}return e.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${r}: ${e.status} ${await e.text()}`),null)}catch(e){return console.error(`Error fetching SHA for ${r}:`,e),null}}async function l2(r){console.log("Reading stream to string");const t=[];for await(const s of r.source)t.push(s);const e=Ft(t),n=J(e);return console.log("Stream read complete, length:",n.length),n}function u2(){var t;console.log("Entering saveGithubAccessToken");const r=(t=document.getElementById("githubAccessToken"))==null?void 0:t.value;if(r)localStorage.setItem(Hi,r),console.log("PAT saved, initializing P2P as host"),Ff(!0);else throw console.error("No GitHub access token provided"),new Error("Enter a GitHub access token first.")}async function ar(){console.log("Entering fetchState");const r=Jt();if(!r)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",uc);const t=await fetch(`${uc}?ref=main`,{headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json"}});if(!t.ok){if(t.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",t.status,await t.text()),new Error(`Error fetching state: ${t.statusText}`)}const e=await t.json(),n=JSON.parse(atob(e.content));return console.log("State fetched, chain length:",n.chain.length),{content:n,sha:e.sha}}catch(t){return console.error("Error fetching state:",t),null}}async function Xi(r,t,e,n=3){console.log("Entering updateState, message:",e);const s=Jt();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(r,null,2));try{const o={message:e,content:i,branch:"main"};t&&(o.sha=t),console.log("Sending PUT request to update state");const a=await fetch(uc,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&n>0){console.log("Conflict detected, retrying...");const c=await ar();if(!c)throw new Error("Failed to refetch");return Xi(r,c.sha,e,n-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function Zi(r,t,e){console.log("Entering closeIssueWithComment, issue:",r);const n=Jt();if(!n){console.log("No PAT available for closing issue");return}const s=e&&t!==null?`Confirmed in block ${t}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${ut}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${ut})`;console.log("Creating comment for issue:",r),await fetch(`${Gi}/${r}/comments`,{method:"POST",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",r),await fetch(`${Gi}/${r}`,{method:"PATCH",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function Uf(){console.log("Entering processTxns");const r=document.getElementById("output"),t=document.getElementById("processingMessage");t.classList.add("visible");let e=await ar(),n=e==null?void 0:e.content;if(!n){if(console.log("No state found, initializing"),n={chain:[s2()],pending:[],balances:{[ne]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await Xi(n,null,"Initialize state")){console.log("Failed to initialize state"),r.textContent+=`
Failed to initialize.`,t.classList.remove("visible");return}e=await ar(),n=e.content}console.log("Fetching open issues");const i=await(await fetch(`${Gi}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${Jt()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=n.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(n.lastProcessedDate))continue;let c;try{const g=JSON.parse(a.body);if(g.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await Zi(a.number,null,!1);continue}if(g.repo!==ut){console.log("Skipping issue from wrong repo:",a.number),await Zi(a.number,null,!1);continue}c=g.txn}catch{console.log("Invalid issue body, closing:",a.number),await Zi(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:u,txid:d}=await o2(c,n);console.log(`Transaction ID: ${d}, valid: ${u}`);const h=u?await a2(n):null;if(await Zi(a.number,h,u),u&&h!==null?(console.log(`Transaction ID: ${d} settled in block ${h}`),r.textContent+=`
Processed txn ${d} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),r.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await Xi(n,e.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),r.textContent+=`
Failed to update state after issue #${a.number}`,t.classList.remove("visible");return}e=await ar(),n=e.content;const p=a.created_at;new Date(p)>new Date(o)&&(o=p)}o!==n.lastProcessedDate&&(console.log("Updating last processed date:",o),n.lastProcessedDate=o,await Xi(n,e.sha,"Update last processed date")),console.log("processTxns completed"),t.classList.remove("visible")}async function d2(){console.log("Entering viewChain");const r=document.getElementById("output"),t=await ar();if(!t||!t.content.chain||t.content.chain.length===0){console.log("No transactions in chain"),r.textContent="No transactions in the chain yet.";return}const e=t.content.chain,n=t.content.balances;let s=`Chain length: ${e.length}
Pending txns: ${t.content.pending.length}
Last processed: ${t.content.lastProcessedDate}
Balances:
`;for(const[i,o]of Object.entries(n))s+=` ${i}: ${o}
`;s+=`
`,e.forEach(i=>{s+=`Block ${i.index}:
 Hash: ${i.hash}
 Prev Hash: ${i.previousHash}
 Timestamp: ${i.timestamp}
 Transactions:
`+i.transactions.map(o=>` ${o.from} sends ${o.amount} to ${o.to} (nonce ${o.nonce})`).join(`
`)+`

`}),r.textContent=s,console.log("viewChain completed, chain length:",e.length)}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(Hi)?(console.log("PAT found, initializing P2P as host"),Ff(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{Uf()},15e3)}),window.gitchain={saveGithubAccessToken:u2,viewChain:d2,processTxns:Uf,fetchState:ar},window.dispatchEvent(new Event("gitchain:init"))})();
