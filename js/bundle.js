var XS=Object.defineProperty;var Nf=ee=>{throw TypeError(ee)};var ZS=(ee,ae,Ee)=>ae in ee?XS(ee,ae,{enumerable:!0,configurable:!0,writable:!0,value:Ee}):ee[ae]=Ee;var l=(ee,ae,Ee)=>ZS(ee,typeof ae!="symbol"?ae+"":ae,Ee),Za=(ee,ae,Ee)=>ae.has(ee)||Nf("Cannot "+Ee);var $=(ee,ae,Ee)=>(Za(ee,ae,"read from private field"),Ee?Ee.call(ee):ae.get(ee)),ge=(ee,ae,Ee)=>ae.has(ee)?Nf("Cannot add the same private member more than once"):ae instanceof WeakSet?ae.add(ee):ae.set(ee,Ee),me=(ee,ae,Ee,ct)=>(Za(ee,ae,"write to private field"),ct?ct.call(ee,Ee):ae.set(ee,Ee),Ee),ne=(ee,ae,Ee)=>(Za(ee,ae,"access private method"),Ee);var Hr=(ee,ae,Ee,ct)=>({set _(Gr){me(ee,ae,Gr,Ee)},get _(){return $(ee,ae,ct)}});(function(){"use strict";var za,Ka,qa,Va,Wa,Ha,mt,jh,Jh,ef,tf,nf,Ga,Ya,rf,at,qn,Vn,Xa,Xe,Di,ki,Ri,sf,Hn,Mi,of,et,Yn,Xn,Wt,Ur,Zn,zr,tt,Qn,We,Kr,nt,jn,_t,qr,Li,J,Of,Bf,Ff,$f,Uf,Ni,Qa,ja,Oi,zf,Bi,af,cf,lf,uf,df,hf,ff,gf,mf,pf,yf,wf,bf,Vr,Ja,Ef,vf,Sf,xf,Af,_f,Cf,If,Lf,Tf,Pf,Df;const ee="0x097efb2a92bc5205e1615db52338a118f1619f3f",ae=Symbol.for("@libp2p/connection"),Ee=Symbol.for("@libp2p/content-routing");let ct=(za=class extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}},l(za,"name","AbortError"),za);class Gr extends Error{constructor(e="Unexpected Peer"){super(e),this.name="UnexpectedPeerError"}}l(Gr,"name","UnexpectedPeerError");let Kf=(Ka=class extends Error{constructor(e="Invalid crypto exchange"){super(e),this.name="InvalidCryptoExchangeError"}},l(Ka,"name","InvalidCryptoExchangeError"),Ka),V=(qa=class extends Error{constructor(e="Invalid parameters"){super(e),this.name="InvalidParametersError"}},l(qa,"name","InvalidParametersError"),qa);class Fi extends Error{constructor(e="Invalid public key"){super(e),this.name="InvalidPublicKeyError"}}l(Fi,"name","InvalidPublicKeyError");class Yr extends Error{constructor(e="The connection is closed"){super(e),this.name="ConnectionClosedError"}}l(Yr,"name","ConnectionClosedError");class tc extends Error{constructor(e="Connection failed"){super(e),this.name="ConnectionFailedError"}}l(tc,"name","ConnectionFailedError");class gn extends Error{constructor(e="The muxer is closed"){super(e),this.name="MuxerClosedError"}}l(gn,"name","MuxerClosedError");class $i extends Error{constructor(e="The stream has been reset"){super(e),this.name="StreamResetError"}}l($i,"name","StreamResetError");class Ht extends Error{constructor(e="The stream is in an invalid state"){super(e),this.name="StreamStateError"}}l(Ht,"name","StreamStateError");class Ui extends Error{constructor(e="The stream buffer was full"){super(e),this.name="StreamBufferError"}}l(Ui,"name","StreamBufferError");let zi=(Va=class extends Error{constructor(e="Not found"){super(e),this.name="NotFoundError"}},l(Va,"name","NotFoundError"),Va);class Ki extends Error{constructor(e="Invalid PeerID"){super(e),this.name="InvalidPeerIdError"}}l(Ki,"name","InvalidPeerIdError");let Xr=(Wa=class extends Error{constructor(e="Invalid multiaddr"){super(e),this.name="InvalidMultiaddrError"}},l(Wa,"name","InvalidMultiaddrError"),Wa);class nc extends Error{constructor(e="Invalid CID"){super(e),this.name="InvalidCIDError"}}l(nc,"name","InvalidCIDError");class rc extends Error{constructor(e="Invalid Multihash"){super(e),this.name="InvalidMultihashError"}}l(rc,"name","InvalidMultihashError");class sc extends Error{constructor(e="Unsupported protocol error"){super(e),this.name="UnsupportedProtocolError"}}l(sc,"name","UnsupportedProtocolError");class lt extends Error{constructor(e="Invalid message"){super(e),this.name="InvalidMessageError"}}l(lt,"name","InvalidMessageError");let qf=(Ha=class extends Error{constructor(e="Timed out"){super(e),this.name="TimeoutError"}},l(Ha,"name","TimeoutError"),Ha);class Jn extends Error{constructor(e="Not started"){super(e),this.name="NotStartedError"}}l(Jn,"name","NotStartedError");class Zr extends Error{constructor(e="Dial error"){super(e),this.name="DialError"}}l(Zr,"name","DialError");class qi extends Error{constructor(e="Limited connection"){super(e),this.name="LimitedConnectionError"}}l(qi,"name","LimitedConnectionError");class ic extends Error{constructor(e="Too many inbound protocol streams"){super(e),this.name="TooManyInboundProtocolStreamsError"}}l(ic,"name","TooManyInboundProtocolStreamsError");class Vi extends Error{constructor(e="Too many outbound protocol streams"){super(e),this.name="TooManyOutboundProtocolStreamsError"}}l(Vi,"name","TooManyOutboundProtocolStreamsError");class Qr extends Error{constructor(e="Unsupported key type"){super(e),this.name="UnsupportedKeyTypeError"}}l(Qr,"name","UnsupportedKeyTypeError");class Vf extends Event{constructor(t,n){super("message",n);l(this,"data");this.data=t}}class jr extends Event{constructor(t,n,s){super("close",s);l(this,"error");l(this,"local");this.error=n,this.local=t}}class Wf extends jr{constructor(e,t){super(!0,e,t)}}class Hf extends jr{constructor(e,t){super(!1,e,t)}}const oc=Symbol.for("@libp2p/peer-discovery"),Wi=Symbol.for("@libp2p/peer-id");function er(r){return!!(r!=null&&r[Wi])}const ac=Symbol.for("@libp2p/peer-routing"),cc="keep-alive";function Hi(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Gf(...r){const e=[];for(const t of r)Hi(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStart!=null&&await t.beforeStart()})),await Promise.all(e.map(async t=>{await t.start()})),await Promise.all(e.map(async t=>{t.afterStart!=null&&await t.afterStart()}))}async function Yf(...r){const e=[];for(const t of r)Hi(t)&&e.push(t);await Promise.all(e.map(async t=>{t.beforeStop!=null&&await t.beforeStop()})),await Promise.all(e.map(async t=>{await t.stop()})),await Promise.all(e.map(async t=>{t.afterStop!=null&&await t.afterStop()}))}const Xf=Symbol.for("@libp2p/transport");var Jr;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Jr||(Jr={}));function QS(){}class ut extends EventTarget{constructor(){super();ge(this,mt,new Map)}listenerCount(t){const n=$(this,mt).get(t);return n==null?0:n.length}addEventListener(t,n,s){super.addEventListener(t,n,s);let i=$(this,mt).get(t);i==null&&(i=[],$(this,mt).set(t,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(t,n,s){super.removeEventListener(t.toString(),n??null,s);let i=$(this,mt).get(t);i!=null&&(i=i.filter(({callback:o})=>o!==n),$(this,mt).set(t,i))}dispatchEvent(t){const n=super.dispatchEvent(t);let s=$(this,mt).get(t.type);return s==null||(s=s.filter(({once:i})=>!i),$(this,mt).set(t.type,s)),n}safeDispatchEvent(t,n={}){return this.dispatchEvent(new CustomEvent(t,n))}}mt=new WeakMap;const Gt=Symbol.for("@libp2p/service-capabilities"),Gi=Symbol.for("@libp2p/service-dependencies");function Zf(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function es(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Qf(r){return new TextEncoder().encode(r)}function jf(r){return new TextDecoder().decode(r)}function Jf(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),n=0;n<t.length;n++)t[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function h(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var y=0,m=0,S=0,v=f.length;S!==v&&f[S]===0;)S++,y++;for(var E=(v-S)*d+1>>>0,T=new Uint8Array(E);S!==v;){for(var L=f[S],I=0,O=E-1;(L!==0||I<m)&&O!==-1;O--,I++)L+=256*T[O]>>>0,T[O]=L%a>>>0,L=L/a>>>0;if(L!==0)throw new Error("Non-zero carry");m=I,S++}for(var _=E-m;_!==E&&T[_]===0;)_++;for(var C=c.repeat(y);_<E;++_)C+=r.charAt(T[_]);return C}function g(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;var y=0;if(f[y]!==" "){for(var m=0,S=0;f[y]===c;)m++,y++;for(var v=(f.length-y)*u+1>>>0,E=new Uint8Array(v);f[y];){var T=t[f.charCodeAt(y)];if(T===255)return;for(var L=0,I=v-1;(T!==0||L<S)&&I!==-1;I--,L++)T+=a*E[I]>>>0,E[I]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");S=L,y++}if(f[y]!==" "){for(var O=v-S;O!==v&&E[O]===0;)O++;for(var _=new Uint8Array(m+(v-O)),C=m;O!==v;)_[C++]=E[O++];return _}}}function p(f){var y=g(f);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:g,decode:p}}var eg=Jf,tg=eg;class ng{constructor(e,t,n){l(this,"name");l(this,"prefix");l(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let rg=class{constructor(e,t,n){l(this,"name");l(this,"prefix");l(this,"baseDecode");l(this,"prefixCodePoint");this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return lc(this,e)}};class sg{constructor(e){l(this,"decoders");this.decoders=e}or(e){return lc(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n!=null)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function lc(r,e){return new sg({...r.decoders??{[r.prefix]:r},...e.decoders??{[e.prefix]:e}})}class ig{constructor(e,t,n,s){l(this,"name");l(this,"prefix");l(this,"baseEncode");l(this,"baseDecode");l(this,"encoder");l(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=s,this.encoder=new ng(e,t,n),this.decoder=new rg(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function ts({name:r,prefix:e,encode:t,decode:n}){return new ig(r,e,t,n)}function tr({name:r,prefix:e,alphabet:t}){const{encode:n,decode:s}=tg(t,r);return ts({prefix:e,name:r,encode:n,decode:i=>es(s(i))})}function og(r,e,t,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const d=e[r[u]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<t|d,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function ag(r,e,t){const n=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),n)for(;i.length*t&7;)i+="=";return i}function cg(r){const e={};for(let t=0;t<r.length;++t)e[r[t]]=t;return e}function _e({name:r,prefix:e,bitsPerChar:t,alphabet:n}){const s=cg(n);return ts({prefix:e,name:r,encode(i){return ag(i,n,t)},decode(i){return og(i,s,t,r)}})}const Ce=tr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),lg=tr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ug=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Ce,base58flickr:lg},Symbol.toStringTag,{value:"Module"})),Ct=_e({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),dg=_e({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),hg=_e({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),fg=_e({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),gg=_e({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mg=_e({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),pg=_e({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),yg=_e({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),wg=_e({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),bg=Object.freeze(Object.defineProperty({__proto__:null,base32:Ct,base32hex:gg,base32hexpad:pg,base32hexpadupper:yg,base32hexupper:mg,base32pad:hg,base32padupper:fg,base32upper:dg,base32z:wg},Symbol.toStringTag,{value:"Module"})),ns=tr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Eg=tr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),vg=Object.freeze(Object.defineProperty({__proto__:null,base36:ns,base36upper:Eg},Symbol.toStringTag,{value:"Module"}));var Sg=dc,uc=128,xg=-128,Ag=Math.pow(2,31);function dc(r,e,t){e=e||[],t=t||0;for(var n=t;r>=Ag;)e[t++]=r&255|uc,r/=128;for(;r&xg;)e[t++]=r&255|uc,r>>>=7;return e[t]=r|0,dc.bytes=t-n+1,e}var _g=Yi,Cg=128,hc=127;function Yi(r,n){var t=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Yi.bytes=0,new RangeError("Could not decode varint");o=r[i++],t+=s<28?(o&hc)<<s:(o&hc)*Math.pow(2,s),s+=7}while(o>=Cg);return Yi.bytes=i-n,t}var Ig=Math.pow(2,7),Lg=Math.pow(2,14),Tg=Math.pow(2,21),Pg=Math.pow(2,28),Dg=Math.pow(2,35),kg=Math.pow(2,42),Rg=Math.pow(2,49),Mg=Math.pow(2,56),Ng=Math.pow(2,63),Og=function(r){return r<Ig?1:r<Lg?2:r<Tg?3:r<Pg?4:r<Dg?5:r<kg?6:r<Rg?7:r<Mg?8:r<Ng?9:10},Bg={encode:Sg,decode:_g,encodingLength:Og},rs=Bg;function Xi(r,e=0){return[rs.decode(r,e),rs.decode.bytes]}function ss(r,e,t=0){return rs.encode(r,e,t),e}function is(r){return rs.encodingLength(r)}function os(r,e){const t=e.byteLength,n=is(r),s=n+is(t),i=new Uint8Array(s+t);return ss(r,i,0),ss(t,i,n),i.set(e,s),new Zi(r,t,e,i)}function as(r){const e=es(r),[t,n]=Xi(e),[s,i]=Xi(e.subarray(n)),o=e.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Zi(t,s,o,e)}function Fg(r,e){if(r===e)return!0;{const t=e;return r.code===t.code&&r.size===t.size&&t.bytes instanceof Uint8Array&&Zf(r.bytes,t.bytes)}}class Zi{constructor(e,t,n,s){l(this,"code");l(this,"size");l(this,"digest");l(this,"bytes");this.code=e,this.size=t,this.digest=n,this.bytes=s}}function fc(r,e){const{bytes:t,version:n}=r;switch(n){case 0:return Ug(t,Qi(r),e??Ce.encoder);default:return zg(t,Qi(r),e??Ct.encoder)}}const gc=new WeakMap;function Qi(r){const e=gc.get(r);if(e==null){const t=new Map;return gc.set(r,t),t}return e}class ue{constructor(e,t,n,s){l(this,"code");l(this,"version");l(this,"multihash");l(this,"bytes");l(this,"/");l(this,jh,"CID");this.code=t,this.version=e,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==nr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Kg)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ue.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=os(e,t);return ue.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return ue.equals(this,e)}static equals(e,t){const n=t;return n!=null&&e.code===n.code&&e.version===n.version&&Fg(e.multihash,n.multihash)}toString(e){return fc(this,e)}toJSON(){return{"/":fc(this)}}link(){return this}[(jh=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof ue)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:n,code:s,multihash:i,bytes:o}=t;return new ue(n,s,i,o??mc(n,s,i.bytes))}else if(t[qg]===!0){const{version:n,multihash:s,code:i}=t,o=as(s);return ue.create(n,i,o)}else return null}static create(e,t,n){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==nr)throw new Error(`Version 0 CID must use dag-pb (code: ${nr}) block encoding`);return new ue(e,t,n,n.bytes)}case 1:{const s=mc(e,t,n.bytes);return new ue(e,t,n,s)}default:throw new Error("Invalid version")}}static createV0(e){return ue.create(0,nr,e)}static createV1(e,t){return ue.create(1,e,t)}static decode(e){const[t,n]=ue.decodeFirst(e);if(n.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=ue.inspectBytes(e),n=t.size-t.multihashSize,s=es(e.subarray(n,n+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new Zi(t.multihashCode,t.digestSize,i,s);return[t.version===0?ue.createV0(o):ue.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[h,g]=Xi(e.subarray(t));return t+=g,h};let s=n(),i=nr;if(s===18?(s=0,t=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=n(),c=n(),u=t+c,d=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:u}}static parse(e,t){const[n,s]=$g(e,t),i=ue.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Qi(i).set(n,e),i}}function $g(r,e){switch(r[0]){case"Q":{const t=e??Ce;return[Ce.prefix,t.decode(`${Ce.prefix}${r}`)]}case Ce.prefix:{const t=e??Ce;return[Ce.prefix,t.decode(r)]}case Ct.prefix:{const t=e??Ct;return[Ct.prefix,t.decode(r)]}case ns.prefix:{const t=e??ns;return[ns.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}}function Ug(r,e,t){const{prefix:n}=t;if(n!==Ce.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(n);if(s==null){const i=t.encode(r).slice(1);return e.set(n,i),i}else return s}function zg(r,e,t){const{prefix:n}=t,s=e.get(n);if(s==null){const i=t.encode(r);return e.set(n,i),i}else return s}const nr=112,Kg=18;function mc(r,e,t){const n=is(r),s=n+is(e),i=new Uint8Array(s+t.byteLength);return ss(r,i,0),ss(e,i,n),i.set(t,s),i}const qg=Symbol.for("@ipld/js-cid/CID"),pc=0,Vg="identity",yc=es;function Wg(r,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==r.byteLength){if(e.truncate<0||e.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e.truncate)}return os(pc,yc(r))}const rr={code:pc,name:Vg,encode:yc,digest:Wg};function Fe(r,e){if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0}function ye(r=0){return new Uint8Array(r)}function dt(r=0){return new Uint8Array(r)}function jS(r){return r}function It(r,e){e==null&&(e=r.reduce((s,i)=>s+i.length,0));const t=dt(e);let n=0;for(const s of r)t.set(s,n),n+=s.length;return t}const wc=Symbol.for("@achingbrain/uint8arraylist");function bc(r,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const n of r){const s=t+n.byteLength;if(e<s)return{buf:n,index:e-t};t=s}throw new RangeError("index is out of bounds")}function cs(r){return!!(r!=null&&r[wc])}class Y{constructor(...e){l(this,"bufs");l(this,"length");l(this,Jh,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(Jh=wc,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const n of e)if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.push(n);else if(cs(n))t+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const n of e.reverse())if(n instanceof Uint8Array)t+=n.byteLength,this.bufs.unshift(n);else if(cs(n))t+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=bc(this.bufs,e);return t.buf[t.index]}set(e,t){const n=bc(this.bufs,e);n.buf[n.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let n=0;n<e.length;n++)this.set(t+n,e[n]);else if(cs(e))for(let n=0;n<e.length;n++)this.set(t+n,e.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:n,length:s}=this._subList(e,t);return It(n,s)}subarray(e,t){const{bufs:n,length:s}=this._subList(e,t);return n.length===1?n[0]:It(n,s)}sublist(e,t){const{bufs:n,length:s}=this._subList(e,t),i=new Y;return i.length=s,i.bufs=[...n],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const u=e>=a&&e<c,d=t>a&&t<=c;if(u&&d){if(e===a&&t===c){n.push(o);break}const h=e-a;n.push(o.subarray(h,h+(t-e)));break}if(u){if(e===0){n.push(o);continue}n.push(o.subarray(e-a));continue}if(d){if(t===c){n.push(o);break}n.push(o.subarray(0,t-a));break}n.push(o)}return{bufs:n,length:t-e}}indexOf(e,t=0){if(!cs(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,u=n.byteLength-1;let d;for(let h=t;h<=c;h+=d){d=0;for(let g=u;g>=0;g--){const p=this.get(h+g);if(n[g]!==p){d=Math.max(1,g-a[p]);break}}if(d===0)return h}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const n=dt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,t),this.write(n,e)}getInt16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,t)}setInt16(e,t,n){const s=ye(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,n),this.write(s,e)}getInt32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,t)}setInt32(e,t,n){const s=ye(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,n),this.write(s,e)}getBigInt64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,t)}setBigInt64(e,t,n){const s=ye(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,n),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const n=dt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,t),this.write(n,e)}getUint16(e,t){const n=this.subarray(e,e+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,t)}setUint16(e,t,n){const s=ye(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,n),this.write(s,e)}getUint32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,t)}setUint32(e,t,n){const s=ye(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,n),this.write(s,e)}getBigUint64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,t)}setBigUint64(e,t,n){const s=ye(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,n),this.write(s,e)}getFloat32(e,t){const n=this.subarray(e,e+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,t)}setFloat32(e,t,n){const s=ye(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,n),this.write(s,e)}getFloat64(e,t){const n=this.subarray(e,e+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,t)}setFloat64(e,t,n){const s=ye(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,n),this.write(s,e)}equals(e){if(e==null||!(e instanceof Y)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!Fe(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const n=new Y;return n.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),n.length=t,n}}const Hg=tr({prefix:"9",name:"base10",alphabet:"0123456789"}),Gg=Object.freeze(Object.defineProperty({__proto__:null,base10:Hg},Symbol.toStringTag,{value:"Module"})),Yg=_e({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Xg=_e({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Zg=Object.freeze(Object.defineProperty({__proto__:null,base16:Yg,base16upper:Xg},Symbol.toStringTag,{value:"Module"})),Qg=_e({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),jg=Object.freeze(Object.defineProperty({__proto__:null,base2:Qg},Symbol.toStringTag,{value:"Module"})),Ec=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Jg=Ec.reduce((r,e,t)=>(r[t]=e,r),[]),em=Ec.reduce((r,e,t)=>{const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);return r[n]=t,r},[]);function tm(r){return r.reduce((e,t)=>(e+=Jg[t],e),"")}function nm(r){const e=[];for(const t of r){const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);const s=em[n];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const rm=ts({prefix:"ðŸš€",name:"base256emoji",encode:tm,decode:nm}),sm=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:rm},Symbol.toStringTag,{value:"Module"})),vc=_e({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),im=_e({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Sc=_e({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),om=_e({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),am=Object.freeze(Object.defineProperty({__proto__:null,base64:vc,base64pad:im,base64url:Sc,base64urlpad:om},Symbol.toStringTag,{value:"Module"})),cm=_e({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),lm=Object.freeze(Object.defineProperty({__proto__:null,base8:cm},Symbol.toStringTag,{value:"Module"})),um=ts({prefix:"\0",name:"identity",encode:r=>jf(r),decode:r=>Qf(r)}),dm=Object.freeze(Object.defineProperty({__proto__:null,identity:um},Symbol.toStringTag,{value:"Module"}));new TextEncoder,new TextDecoder;const hm=20;function fm({name:r,code:e,encode:t,minDigestLength:n,maxDigestLength:s}){return new gm(r,e,t,n,s)}class gm{constructor(e,t,n,s,i){l(this,"name");l(this,"code");l(this,"encode");l(this,"minDigestLength");l(this,"maxDigestLength");this.name=e,this.code=t,this.encode=n,this.minDigestLength=s??hm,this.maxDigestLength=i}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const n=this.encode(e);return n instanceof Uint8Array?xc(n,this.code,t==null?void 0:t.truncate):n.then(s=>xc(s,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}}function xc(r,e,t){if(t!=null&&t!==r.byteLength){if(t>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t)}return os(e,r)}function mm(r){return async e=>new Uint8Array(await crypto.subtle.digest(r,e))}const Ac=fm({name:"sha2-256",code:18,encode:mm("SHA-256")}),ji={...dm,...jg,...lm,...Gg,...Zg,...bg,...vg,...ug,...am,...sm};function _c(r,e,t,n){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:n}}}const Cc=_c("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),Ji=_c("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=dt(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Ic={utf8:Cc,"utf-8":Cc,hex:ji.base16,latin1:Ji,ascii:Ji,binary:Ji,...ji};function H(r,e="utf8"){const t=Ic[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}function Q(r,e="utf8"){const t=Ic[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}const pm=parseInt("11111",2),eo=parseInt("10000000",2),ym=parseInt("01111111",2),Lc={0:ir,1:ir,2:wm,3:vm,4:Sm,5:Em,6:bm,16:ir,22:ir,48:ir};function ls(r,e={offset:0}){const t=r[e.offset]&pm;if(e.offset++,Lc[t]!=null)return Lc[t](r,e);throw new Error("No decoder for tag "+t)}function sr(r,e){let t=0;if((r[e.offset]&eo)===eo){const n=r[e.offset]&ym;let s="0x";e.offset++;for(let i=0;i<n;i++,e.offset++)s+=r[e.offset].toString(16).padStart(2,"0");t=parseInt(s,16)}else t=r[e.offset],e.offset++;return t}function ir(r,e){sr(r,e);const t=[];for(;!(e.offset>=r.byteLength);){const n=ls(r,e);if(n===null)break;t.push(n)}return t}function wm(r,e){const t=sr(r,e),n=e.offset,s=e.offset+t,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return e.offset+=t,Uint8Array.from(i)}function bm(r,e){const t=sr(r,e),n=e.offset+t,s=r[e.offset];e.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;e.offset<n;){const u=r[e.offset];if(e.offset++,c.push(u&127),u<128){c.reverse();let d=0;for(let h=0;h<c.length;h++)d+=c[h]<<h*7;a+=`.${d}`,c=[]}}return a}function Em(r,e){return e.offset++,null}function vm(r,e){const t=sr(r,e),n=r[e.offset];e.offset++;const s=r.subarray(e.offset,e.offset+t-1);if(e.offset+=t,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function Sm(r,e){const t=sr(r,e),n=r.subarray(e.offset,e.offset+t);return e.offset+=t,n}function xm(r){let e=r.toString(16);e.length%2===1&&(e="0"+e);const t=new Y;for(let n=0;n<e.length;n+=2)t.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return t}function to(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const e=xm(r.byteLength);return new Y(Uint8Array.from([e.byteLength|eo]),e)}function no(r){const e=new Y,t=128;return(r.subarray()[0]&t)===t&&e.append(Uint8Array.from([0])),e.append(r),new Y(Uint8Array.from([2]),to(e),e)}function Tc(r){const e=Uint8Array.from([0]),t=new Y(e,r);return new Y(Uint8Array.from([3]),to(t),t)}function or(r,e=48){const t=new Y;for(const n of r)t.append(n);return new Y(Uint8Array.from([e]),to(t),t)}async function Am(r,e,t,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,e,t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const _m=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Cm=Uint8Array.from([6,5,43,129,4,0,34]),Im=Uint8Array.from([6,5,43,129,4,0,35]),Lm={ext:!0,kty:"EC",crv:"P-256"},Tm={ext:!0,kty:"EC",crv:"P-384"},Pm={ext:!0,kty:"EC",crv:"P-521"},ro=32,so=48,io=66;function Pc(r){const e=ls(r);return Dm(e)}function Dm(r){const e=r[1][1][0],t=1;let n,s;if(e.byteLength===ro*2+1)return n=Q(e.subarray(t,t+ro),"base64url"),s=Q(e.subarray(t+ro),"base64url"),new oo({...Lm,key_ops:["verify"],x:n,y:s});if(e.byteLength===so*2+1)return n=Q(e.subarray(t,t+so),"base64url"),s=Q(e.subarray(t+so),"base64url"),new oo({...Tm,key_ops:["verify"],x:n,y:s});if(e.byteLength===io*2+1)return n=Q(e.subarray(t,t+io),"base64url"),s=Q(e.subarray(t+io),"base64url"),new oo({...Pm,key_ops:["verify"],x:n,y:s});throw new V(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}function km(r){return or([no(Uint8Array.from([1])),or([Rm(r.crv)],160),or([Tc(new Y(Uint8Array.from([4]),H(r.x??"","base64url"),H(r.y??"","base64url")))],161)]).subarray()}function Rm(r){if(r==="P-256")return _m;if(r==="P-384")return Cm;if(r==="P-521")return Im;throw new V(`Invalid curve ${r}`)}class oo{constructor(e){l(this,"type","ECDSA");l(this,"jwk");l(this,"_raw");this.jwk=e}get raw(){return this._raw==null&&(this._raw=km(this.jwk)),this._raw}toMultihash(){return rr.digest(bt(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Fe(this.raw,e.raw)}async verify(e,t,n){return Am(this.jwk,t,e,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function us(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Lt(r,e=""){if(!Number.isSafeInteger(r)||r<0){const t=e&&`"${e}" `;throw new Error(`${t}expected integer >= 0, got ${r}`)}}function G(r,e,t=""){const n=us(r),s=r==null?void 0:r.length,i=e!==void 0;if(!n||i&&s!==e){const o=t&&`"${t}" `,a=i?` of length ${e}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function ds(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Lt(r.outputLen),Lt(r.blockLen)}function hs(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function Mm(r,e){G(r,void 0,"digestInto() output");const t=e.outputLen;if(r.length<t)throw new Error('"digestInto() output" expected to be of length >='+t)}function Yt(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function ao(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function ht(r,e){return r<<32-e|r>>>e}const Dc=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Nm=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ar(r){if(G(r),Dc)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=Nm[r[t]];return e}const pt={_0:48,_9:57,A:65,F:70,a:97,f:102};function kc(r){if(r>=pt._0&&r<=pt._9)return r-pt._0;if(r>=pt.A&&r<=pt.F)return r-(pt.A-10);if(r>=pt.a&&r<=pt.f)return r-(pt.a-10)}function cr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Dc)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=kc(r.charCodeAt(i)),a=kc(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function ft(...r){let e=0;for(let n=0;n<r.length;n++){const s=r[n];G(s),e+=s.length}const t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){const i=r[n];t.set(i,s),s+=i.length}return t}function Rc(r,e={}){const t=(s,i)=>r(i).update(s).digest(),n=r(void 0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=s=>r(s),Object.assign(t,e),Object.freeze(t)}function lr(r=32){const e=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(e==null?void 0:e.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return e.getRandomValues(new Uint8Array(r))}const Mc=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Om(r,e,t){return r&e^~r&t}function Bm(r,e,t){return r&e^r&t^e&t}class Nc{constructor(e,t,n,s){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(e),this.view=ao(this.buffer)}update(e){hs(this),G(e);const{view:t,buffer:n,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=ao(e);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){hs(this),Mm(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,Yt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)t[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=ao(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,d[h],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const Tt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ke=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),fs=BigInt(2**32-1),Oc=BigInt(32);function Fm(r,e=!1){return e?{h:Number(r&fs),l:Number(r>>Oc&fs)}:{h:Number(r>>Oc&fs)|0,l:Number(r&fs)|0}}function $m(r,e=!1){const t=r.length;let n=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Fm(r[i],e);[n[i],s[i]]=[o,a]}return[n,s]}const Bc=(r,e,t)=>r>>>t,Fc=(r,e,t)=>r<<32-t|e>>>t,mn=(r,e,t)=>r>>>t|e<<32-t,pn=(r,e,t)=>r<<32-t|e>>>t,gs=(r,e,t)=>r<<64-t|e>>>t-32,ms=(r,e,t)=>r>>>t-32|e<<64-t;function yt(r,e,t,n){const s=(e>>>0)+(n>>>0);return{h:r+t+(s/2**32|0)|0,l:s|0}}const Um=(r,e,t)=>(r>>>0)+(e>>>0)+(t>>>0),zm=(r,e,t,n)=>e+t+n+(r/2**32|0)|0,Km=(r,e,t,n)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0),qm=(r,e,t,n,s)=>e+t+n+s+(r/2**32|0)|0,Vm=(r,e,t,n,s)=>(r>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(s>>>0),Wm=(r,e,t,n,s,i)=>e+t+n+s+i+(r/2**32|0)|0,Hm=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Pt=new Uint32Array(64);class Gm extends Nc{constructor(e){super(64,e,8,!1)}get(){const{A:e,B:t,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,n,s,i,o,a,c]}set(e,t,n,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let h=0;h<16;h++,t+=4)Pt[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const g=Pt[h-15],p=Pt[h-2],f=ht(g,7)^ht(g,18)^g>>>3,y=ht(p,17)^ht(p,19)^p>>>10;Pt[h]=y+Pt[h-7]+f+Pt[h-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let h=0;h<64;h++){const g=ht(a,6)^ht(a,11)^ht(a,25),p=d+g+Om(a,c,u)+Hm[h]+Pt[h]|0,y=(ht(n,2)^ht(n,13)^ht(n,22))+Bm(n,s,i)|0;d=u,u=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){Yt(Pt)}destroy(){this.set(0,0,0,0,0,0,0,0),Yt(this.buffer)}}class Ym extends Gm{constructor(){super(32);l(this,"A",Tt[0]|0);l(this,"B",Tt[1]|0);l(this,"C",Tt[2]|0);l(this,"D",Tt[3]|0);l(this,"E",Tt[4]|0);l(this,"F",Tt[5]|0);l(this,"G",Tt[6]|0);l(this,"H",Tt[7]|0)}}const $c=$m(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Xm=$c[0],Zm=$c[1],Dt=new Uint32Array(80),kt=new Uint32Array(80);class Qm extends Nc{constructor(e){super(128,e,16,!1)}get(){const{Ah:e,Al:t,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:d,Fh:h,Fl:g,Gh:p,Gl:f,Hh:y,Hl:m}=this;return[e,t,n,s,i,o,a,c,u,d,h,g,p,f,y,m]}set(e,t,n,s,i,o,a,c,u,d,h,g,p,f,y,m){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=d|0,this.Fh=h|0,this.Fl=g|0,this.Gh=p|0,this.Gl=f|0,this.Hh=y|0,this.Hl=m|0}process(e,t){for(let E=0;E<16;E++,t+=4)Dt[E]=e.getUint32(t),kt[E]=e.getUint32(t+=4);for(let E=16;E<80;E++){const T=Dt[E-15]|0,L=kt[E-15]|0,I=mn(T,L,1)^mn(T,L,8)^Bc(T,L,7),O=pn(T,L,1)^pn(T,L,8)^Fc(T,L,7),_=Dt[E-2]|0,C=kt[E-2]|0,F=mn(_,C,19)^gs(_,C,61)^Bc(_,C,6),U=pn(_,C,19)^ms(_,C,61)^Fc(_,C,6),R=Km(O,U,kt[E-7],kt[E-16]),M=qm(R,I,F,Dt[E-7],Dt[E-16]);Dt[E]=M|0,kt[E]=R|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:d,Eh:h,El:g,Fh:p,Fl:f,Gh:y,Gl:m,Hh:S,Hl:v}=this;for(let E=0;E<80;E++){const T=mn(h,g,14)^mn(h,g,18)^gs(h,g,41),L=pn(h,g,14)^pn(h,g,18)^ms(h,g,41),I=h&p^~h&y,O=g&f^~g&m,_=Vm(v,L,O,Zm[E],kt[E]),C=Wm(_,S,T,I,Xm[E],Dt[E]),F=_|0,U=mn(n,s,28)^gs(n,s,34)^gs(n,s,39),R=pn(n,s,28)^ms(n,s,34)^ms(n,s,39),M=n&i^n&a^i&a,w=s&o^s&c^o&c;S=y|0,v=m|0,y=p|0,m=f|0,p=h|0,f=g|0,{h,l:g}=yt(u|0,d|0,C|0,F|0),u=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=Um(F,R,w);n=zm(b,C,U,M),s=b|0}({h:n,l:s}=yt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=yt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=yt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:d}=yt(this.Dh|0,this.Dl|0,u|0,d|0),{h,l:g}=yt(this.Eh|0,this.El|0,h|0,g|0),{h:p,l:f}=yt(this.Fh|0,this.Fl|0,p|0,f|0),{h:y,l:m}=yt(this.Gh|0,this.Gl|0,y|0,m|0),{h:S,l:v}=yt(this.Hh|0,this.Hl|0,S|0,v|0),this.set(n,s,i,o,a,c,u,d,h,g,p,f,y,m,S,v)}roundClean(){Yt(Dt,kt)}destroy(){Yt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class jm extends Qm{constructor(){super(64);l(this,"Ah",ke[0]|0);l(this,"Al",ke[1]|0);l(this,"Bh",ke[2]|0);l(this,"Bl",ke[3]|0);l(this,"Ch",ke[4]|0);l(this,"Cl",ke[5]|0);l(this,"Dh",ke[6]|0);l(this,"Dl",ke[7]|0);l(this,"Eh",ke[8]|0);l(this,"El",ke[9]|0);l(this,"Fh",ke[10]|0);l(this,"Fl",ke[11]|0);l(this,"Gh",ke[12]|0);l(this,"Gl",ke[13]|0);l(this,"Hh",ke[14]|0);l(this,"Hl",ke[15]|0)}}const ur=Rc(()=>new Ym,Mc(1)),Jm=Rc(()=>new jm,Mc(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const co=BigInt(0),lo=BigInt(1);function Xt(r,e=""){if(typeof r!="boolean"){const t=e&&`"${e}" `;throw new Error(t+"expected boolean, got type="+typeof r)}return r}function Uc(r){if(typeof r=="bigint"){if(!ws(r))throw new Error("positive bigint expected, got "+r)}else Lt(r);return r}function ps(r){const e=Uc(r).toString(16);return e.length&1?"0"+e:e}function zc(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?co:BigInt("0x"+r)}function ys(r){return zc(ar(r))}function Zt(r){return zc(ar(dr(G(r)).reverse()))}function uo(r,e){Lt(e),r=Uc(r);const t=cr(r.toString(16).padStart(e*2,"0"));if(t.length!==e)throw new Error("number too large");return t}function ho(r,e){return uo(r,e).reverse()}function dr(r){return Uint8Array.from(r)}const ws=r=>typeof r=="bigint"&&co<=r;function ep(r,e,t){return ws(r)&&ws(e)&&ws(t)&&e<=r&&r<t}function hr(r,e,t,n){if(!ep(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function tp(r){let e;for(e=0;r>co;r>>=lo,e+=1);return e}const fo=r=>(lo<<BigInt(r))-lo;function np(r,e,t){if(Lt(r,"hashLen"),Lt(e,"qByteLen"),typeof t!="function")throw new Error("hmacFn must be a function");const n=m=>new Uint8Array(m),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),d=0;const h=()=>{c.fill(1),u.fill(0),d=0},g=(...m)=>t(u,ft(c,...m)),p=(m=s)=>{u=g(i,m),c=g(),m.length!==0&&(u=g(o,m),c=g())},f=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const S=[];for(;m<e;){c=g();const v=c.slice();S.push(v),m+=c.length}return ft(...S)};return(m,S)=>{h(),p(m);let v;for(;!(v=S(f()));)p();return h(),v}}function yn(r,e={},t={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(e,!1),s(t,!0)}function bs(r){const e=new WeakMap;return(t,...n)=>{const s=e.get(t);if(s!==void 0)return s;const i=r(t,...n);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const He=BigInt(0),Ie=BigInt(1),Qt=BigInt(2),Kc=BigInt(3),qc=BigInt(4),Vc=BigInt(5),rp=BigInt(7),Wc=BigInt(8),sp=BigInt(9),Hc=BigInt(16);function ve(r,e){const t=r%e;return t>=He?t:e+t}function we(r,e,t){let n=r;for(;e-- >He;)n*=n,n%=t;return n}function Gc(r,e){if(r===He)throw new Error("invert: expected non-zero number");if(e<=He)throw new Error("invert: expected positive modulus, got "+e);let t=ve(r,e),n=e,s=He,i=Ie;for(;t!==He;){const a=n/t,c=n%t,u=s-i*a;n=t,t=c,s=i,i=u}if(n!==Ie)throw new Error("invert: does not exist");return ve(s,e)}function go(r,e,t){if(!r.eql(r.sqr(e),t))throw new Error("Cannot find square root")}function Yc(r,e){const t=(r.ORDER+Ie)/qc,n=r.pow(e,t);return go(r,n,e),n}function ip(r,e){const t=(r.ORDER-Vc)/Wc,n=r.mul(e,Qt),s=r.pow(n,t),i=r.mul(e,s),o=r.mul(r.mul(i,Qt),s),a=r.mul(i,r.sub(o,r.ONE));return go(r,a,e),a}function op(r){const e=Es(r),t=Xc(r),n=t(e,e.neg(e.ONE)),s=t(e,n),i=t(e,e.neg(n)),o=(r+rp)/Hc;return(a,c)=>{let u=a.pow(c,o),d=a.mul(u,n);const h=a.mul(u,s),g=a.mul(u,i),p=a.eql(a.sqr(d),c),f=a.eql(a.sqr(h),c);u=a.cmov(u,d,p),d=a.cmov(g,h,f);const y=a.eql(a.sqr(d),c),m=a.cmov(u,d,y);return go(a,m,c),m}}function Xc(r){if(r<Kc)throw new Error("sqrt is not defined for small field");let e=r-Ie,t=0;for(;e%Qt===He;)e/=Qt,t++;let n=Qt;const s=Es(r);for(;Qc(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Yc;let i=s.pow(n,e);const o=(e+Ie)/Qt;return function(c,u){if(c.is0(u))return u;if(Qc(c,u)!==1)throw new Error("Cannot find square root");let d=t,h=c.mul(c.ONE,i),g=c.pow(u,e),p=c.pow(u,o);for(;!c.eql(g,c.ONE);){if(c.is0(g))return c.ZERO;let f=1,y=c.sqr(g);for(;!c.eql(y,c.ONE);)if(f++,y=c.sqr(y),f===d)throw new Error("Cannot find square root");const m=Ie<<BigInt(d-f-1),S=c.pow(h,m);d=f,h=c.sqr(S),g=c.mul(g,h),p=c.mul(p,S)}return p}}function ap(r){return r%qc===Kc?Yc:r%Wc===Vc?ip:r%Hc===sp?op(r):Xc(r)}const cp=(r,e)=>(ve(r,e)&Ie)===Ie,lp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function up(r){const e={ORDER:"bigint",BYTES:"number",BITS:"number"},t=lp.reduce((n,s)=>(n[s]="function",n),e);return yn(r,t),r}function dp(r,e,t){if(t<He)throw new Error("invalid exponent, negatives unsupported");if(t===He)return r.ONE;if(t===Ie)return e;let n=r.ONE,s=e;for(;t>He;)t&Ie&&(n=r.mul(n,s)),s=r.sqr(s),t>>=Ie;return n}function Zc(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),s=e.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return e.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function Qc(r,e){const t=(r.ORDER-Ie)/Qt,n=r.pow(e,t),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function hp(r,e){e!==void 0&&Lt(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}class fp{constructor(e,t={}){l(this,"ORDER");l(this,"BITS");l(this,"BYTES");l(this,"isLE");l(this,"ZERO",He);l(this,"ONE",Ie);l(this,"_lengths");l(this,"_sqrt");l(this,"_mod");var o;if(e<=He)throw new Error("invalid field: expected ORDER > 0, got "+e);let n;this.isLE=!1,t!=null&&typeof t=="object"&&(typeof t.BITS=="number"&&(n=t.BITS),typeof t.sqrt=="function"&&(this.sqrt=t.sqrt),typeof t.isLE=="boolean"&&(this.isLE=t.isLE),t.allowedLengths&&(this._lengths=(o=t.allowedLengths)==null?void 0:o.slice()),typeof t.modFromBytes=="boolean"&&(this._mod=t.modFromBytes));const{nBitLength:s,nByteLength:i}=hp(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=e,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(e){return ve(e,this.ORDER)}isValid(e){if(typeof e!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof e);return He<=e&&e<this.ORDER}is0(e){return e===He}isValidNot0(e){return!this.is0(e)&&this.isValid(e)}isOdd(e){return(e&Ie)===Ie}neg(e){return ve(-e,this.ORDER)}eql(e,t){return e===t}sqr(e){return ve(e*e,this.ORDER)}add(e,t){return ve(e+t,this.ORDER)}sub(e,t){return ve(e-t,this.ORDER)}mul(e,t){return ve(e*t,this.ORDER)}pow(e,t){return dp(this,e,t)}div(e,t){return ve(e*Gc(t,this.ORDER),this.ORDER)}sqrN(e){return e*e}addN(e,t){return e+t}subN(e,t){return e-t}mulN(e,t){return e*t}inv(e){return Gc(e,this.ORDER)}sqrt(e){return this._sqrt||(this._sqrt=ap(this.ORDER)),this._sqrt(this,e)}toBytes(e){return this.isLE?ho(e,this.BYTES):uo(e,this.BYTES)}fromBytes(e,t=!1){G(e);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(e.length)||e.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+e.length);const u=new Uint8Array(s);u.set(e,i?0:u.length-e.length),e=u}if(e.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+e.length);let c=i?Zt(e):ys(e);if(a&&(c=ve(c,o)),!t&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(e){return Zc(this,e)}cmov(e,t,n){return n?t:e}}function Es(r,e={}){return new fp(r,e)}function jc(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function Jc(r){const e=jc(r);return e+Math.ceil(e/2)}function gp(r,e,t=!1){G(r);const n=r.length,s=jc(e),i=Jc(e);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=t?Zt(r):ys(r),a=ve(o,e-Ie)+Ie;return t?ho(a,s):uo(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wn=BigInt(0),jt=BigInt(1);function vs(r,e){const t=e.negate();return r?t:e}function fr(r,e){const t=Zc(r.Fp,e.map(n=>n.Z));return e.map((n,s)=>r.fromAffine(n.toAffine(t[s])))}function el(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function mo(r,e){el(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),s=2**r,i=fo(r),o=BigInt(r);return{windows:t,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function tl(r,e,t){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=jt);const u=e*n,d=u+Math.abs(a)-1,h=a===0,g=a<0,p=e%2!==0;return{nextN:c,offset:d,isZero:h,isNeg:g,isNegF:p,offsetF:u}}const po=new WeakMap,nl=new WeakMap;function yo(r){return nl.get(r)||1}function rl(r){if(r!==wn)throw new Error("invalid wNAF")}class sl{constructor(e,t){l(this,"BASE");l(this,"ZERO");l(this,"Fn");l(this,"bits");this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,n=this.ZERO){let s=e;for(;t>wn;)t&jt&&(n=n.add(s)),s=s.double(),t>>=jt;return n}precomputeWindow(e,t){const{windows:n,windowSize:s}=mo(t,this.bits),i=[];let o=e,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(e,t,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=mo(e,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:g,offsetF:p}=tl(n,a,o);n=c,d?i=i.add(vs(g,t[p])):s=s.add(vs(h,t[u]))}return rl(n),{p:s,f:i}}wNAFUnsafe(e,t,n,s=this.ZERO){const i=mo(e,this.bits);for(let o=0;o<i.windows&&n!==wn;o++){const{nextN:a,offset:c,isZero:u,isNeg:d}=tl(n,o,i);if(n=a,!u){const h=t[c];s=s.add(d?h.negate():h)}}return rl(n),s}getPrecomputes(e,t,n){let s=po.get(t);return s||(s=this.precomputeWindow(t,e),e!==1&&(typeof n=="function"&&(s=n(s)),po.set(t,s))),s}cached(e,t,n){const s=yo(e);return this.wNAF(s,this.getPrecomputes(s,e,n),t)}unsafe(e,t,n,s){const i=yo(e);return i===1?this._unsafeLadder(e,t,s):this.wNAFUnsafe(i,this.getPrecomputes(i,e,n),t,s)}createCache(e,t){el(t,this.bits),nl.set(e,t),po.delete(e)}hasCache(e){return yo(e)!==1}}function mp(r,e,t,n){let s=e,i=r.ZERO,o=r.ZERO;for(;t>wn||n>wn;)t&jt&&(i=i.add(s)),n&jt&&(o=o.add(s)),s=s.double(),t>>=jt,n>>=jt;return{p1:i,p2:o}}function il(r,e,t){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return up(e),e}else return Es(r,{isLE:t})}function ol(r,e,t={},n){if(n===void 0&&(n=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=e[c];if(!(typeof u=="bigint"&&u>wn))throw new Error(`CURVE.${c} must be positive bigint`)}const s=il(e.p,t.Fp,n),i=il(e.n,t.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:s,Fn:i}}function wo(r,e){return function(n){const s=r(n);return{secretKey:s,publicKey:e(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rt=BigInt(0),Ae=BigInt(1),bo=BigInt(2),pp=BigInt(8);function yp(r,e,t,n){const s=r.sqr(t),i=r.sqr(n),o=r.add(r.mul(e.a,s),i),a=r.add(r.ONE,r.mul(e.d,r.mul(s,i)));return r.eql(o,a)}function wp(r,e={}){const t=ol("edwards",r,e,e.FpFnLE),{Fp:n,Fn:s}=t;let i=t.CURVE;const{h:o}=i;yn(e,{},{uvRatio:"function"});const a=bo<<BigInt(s.BYTES*8)-Ae,c=S=>n.create(S),u=e.uvRatio||((S,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(S,v))}}catch{return{isValid:!1,value:Rt}}});if(!yp(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(S,v,E=!1){const T=E?Ae:Rt;return hr("coordinate "+S,v,T,a),v}function h(S){if(!(S instanceof f))throw new Error("EdwardsPoint expected")}const g=bs((S,v)=>{const{X:E,Y:T,Z:L}=S,I=S.is0();v==null&&(v=I?pp:n.inv(L));const O=c(E*v),_=c(T*v),C=n.mul(L,v);if(I)return{x:Rt,y:Ae};if(C!==Ae)throw new Error("invZ was invalid");return{x:O,y:_}}),p=bs(S=>{const{a:v,d:E}=i;if(S.is0())throw new Error("bad point: ZERO");const{X:T,Y:L,Z:I,T:O}=S,_=c(T*T),C=c(L*L),F=c(I*I),U=c(F*F),R=c(_*v),M=c(F*c(R+C)),w=c(U+c(E*c(_*C)));if(M!==w)throw new Error("bad point: equation left != right (1)");const b=c(T*L),A=c(I*O);if(b!==A)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(v,E,T,L){l(this,"X");l(this,"Y");l(this,"Z");l(this,"T");this.X=d("x",v),this.Y=d("y",E),this.Z=d("z",T,!0),this.T=d("t",L),Object.freeze(this)}static CURVE(){return i}static fromAffine(v){if(v instanceof m)throw new Error("extended point not allowed");const{x:E,y:T}=v||{};return d("x",E),d("y",T),new m(E,T,Ae,c(E*T))}static fromBytes(v,E=!1){const T=n.BYTES,{a:L,d:I}=i;v=dr(G(v,T,"point")),Xt(E,"zip215");const O=dr(v),_=v[T-1];O[T-1]=_&-129;const C=Zt(O),F=E?a:n.ORDER;hr("point.y",C,Rt,F);const U=c(C*C),R=c(U-Ae),M=c(I*U-L);let{isValid:w,value:b}=u(R,M);if(!w)throw new Error("bad point: invalid y coordinate");const A=(b&Ae)===Ae,P=(_&128)!==0;if(!E&&b===Rt&&P)throw new Error("bad point: x=0 and x_0=1");return P!==A&&(b=c(-b)),m.fromAffine({x:b,y:C})}static fromHex(v,E=!1){return m.fromBytes(cr(v),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,E=!0){return y.createCache(this,v),E||this.multiply(bo),this}assertValidity(){p(this)}equals(v){h(v);const{X:E,Y:T,Z:L}=this,{X:I,Y:O,Z:_}=v,C=c(E*_),F=c(I*L),U=c(T*_),R=c(O*L);return C===F&&U===R}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=i,{X:E,Y:T,Z:L}=this,I=c(E*E),O=c(T*T),_=c(bo*c(L*L)),C=c(v*I),F=E+T,U=c(c(F*F)-I-O),R=C+O,M=R-_,w=C-O,b=c(U*M),A=c(R*w),P=c(U*w),k=c(M*R);return new m(b,A,k,P)}add(v){h(v);const{a:E,d:T}=i,{X:L,Y:I,Z:O,T:_}=this,{X:C,Y:F,Z:U,T:R}=v,M=c(L*C),w=c(I*F),b=c(_*T*R),A=c(O*U),P=c((L+I)*(C+F)-M-w),k=A-b,x=A+b,N=c(w-E*M),D=c(P*k),B=c(x*N),z=c(P*N),te=c(k*x);return new m(D,B,te,z)}subtract(v){return this.add(v.negate())}multiply(v){if(!s.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:T}=y.cached(this,v,L=>fr(m,L));return fr(m,[E,T])[0]}multiplyUnsafe(v,E=m.ZERO){if(!s.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===Rt?m.ZERO:this.is0()||v===Ae?this:y.unsafe(this,v,T=>fr(m,T),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(v){return g(this,v)}clearCofactor(){return o===Ae?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:E}=this.toAffine(),T=n.toBytes(E);return T[T.length-1]|=v&Ae?128:0,T}toHex(){return ar(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(m,"BASE",new m(i.Gx,i.Gy,Ae,c(i.Gx*i.Gy))),l(m,"ZERO",new m(Rt,Ae,Ae,Rt)),l(m,"Fp",n),l(m,"Fn",s);let f=m;const y=new sl(f,s.BITS);return f.BASE.precompute(8),f}function bp(r,e,t={}){if(typeof e!="function")throw new Error('"hash" function param is required');yn(t,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=t,{BASE:s,Fp:i,Fn:o}=r,a=t.randomBytes||lr,c=t.adjustScalarBytes||(_=>_),u=t.domain||((_,C,F)=>{if(Xt(F,"phflag"),C.length||F)throw new Error("Contexts/pre-hash are not supported");return _});function d(_){return o.create(Zt(_))}function h(_){const C=E.secretKey;G(_,E.secretKey,"secretKey");const F=G(e(_),2*C,"hashedSecretKey"),U=c(F.slice(0,C)),R=F.slice(C,2*C),M=d(U);return{head:U,prefix:R,scalar:M}}function g(_){const{head:C,prefix:F,scalar:U}=h(_),R=s.multiply(U),M=R.toBytes();return{head:C,prefix:F,scalar:U,point:R,pointBytes:M}}function p(_){return g(_).pointBytes}function f(_=Uint8Array.of(),...C){const F=ft(...C);return d(e(u(F,G(_,void 0,"context"),!!n)))}function y(_,C,F={}){_=G(_,void 0,"message"),n&&(_=n(_));const{prefix:U,scalar:R,pointBytes:M}=g(C),w=f(F.context,U,_),b=s.multiply(w).toBytes(),A=f(F.context,b,M,_),P=o.create(w+A*R);if(!o.isValid(P))throw new Error("sign failed: invalid s");const k=ft(b,o.toBytes(P));return G(k,E.signature,"result")}const m={zip215:!0};function S(_,C,F,U=m){const{context:R,zip215:M}=U,w=E.signature;_=G(_,w,"signature"),C=G(C,void 0,"message"),F=G(F,E.publicKey,"publicKey"),M!==void 0&&Xt(M,"zip215"),n&&(C=n(C));const b=w/2,A=_.subarray(0,b),P=Zt(_.subarray(b,w));let k,x,N;try{k=r.fromBytes(F,M),x=r.fromBytes(A,M),N=s.multiplyUnsafe(P)}catch{return!1}if(!M&&k.isSmallOrder())return!1;const D=f(R,x.toBytes(),k.toBytes(),C);return x.add(k.multiplyUnsafe(D)).subtract(N).clearCofactor().is0()}const v=i.BYTES,E={secretKey:v,publicKey:v,signature:2*v,seed:v};function T(_=a(E.seed)){return G(_,E.seed,"seed")}function L(_){return us(_)&&_.length===o.BYTES}function I(_,C){try{return!!r.fromBytes(_,C)}catch{return!1}}const O={getExtendedPublicKey:g,randomSecretKey:T,isValidSecretKey:L,isValidPublicKey:I,toMontgomery(_){const{y:C}=r.fromBytes(_),F=E.publicKey,U=F===32;if(!U&&F!==57)throw new Error("only defined for 25519 and 448");const R=U?i.div(Ae+C,Ae-C):i.div(C-Ae,C+Ae);return i.toBytes(R)},toMontgomerySecret(_){const C=E.secretKey;G(_,C);const F=e(_.subarray(0,C));return c(F).subarray(0,C)}};return Object.freeze({keygen:wo(T,p),getPublicKey:p,sign:y,verify:S,utils:O,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gr=BigInt(0),bn=BigInt(1),Ss=BigInt(2);function Ep(r){return yn(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function vp(r){const e=Ep(r),{P:t,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=e,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||lr,u=a?255:448,d=a?32:56,h=BigInt(a?9:5),g=BigInt(a?121665:39081),p=a?Ss**BigInt(254):Ss**BigInt(447),f=a?BigInt(8)*Ss**BigInt(251)-bn:BigInt(4)*Ss**BigInt(445)-bn,y=p+f+bn,m=w=>ve(w,t),S=v(h);function v(w){return ho(m(w),d)}function E(w){const b=dr(G(w,d,"uCoordinate"));return a&&(b[31]&=127),m(Zt(b))}function T(w){return Zt(s(dr(G(w,d,"scalar"))))}function L(w,b){const A=F(E(b),T(w));if(A===gr)throw new Error("invalid private or public key received");return v(A)}function I(w){return L(w,S)}const O=I,_=L;function C(w,b,A){const P=m(w*(b-A));return b=m(b-P),A=m(A+P),{x_2:b,x_3:A}}function F(w,b){hr("u",w,gr,t),hr("scalar",b,p,y);const A=b,P=w;let k=bn,x=gr,N=w,D=bn,B=gr;for(let te=BigInt(u-1);te>=gr;te--){const Z=A>>te&bn;B^=Z,{x_2:k,x_3:N}=C(B,k,N),{x_2:x,x_3:D}=C(B,x,D),B=Z;const q=k+x,oe=m(q*q),le=k-x,be=m(le*le),pe=oe-be,De=N+D,Pi=N-D,Wr=m(Pi*q),kf=m(De*le),Rf=Wr+kf,Mf=Wr-kf;N=m(Rf*Rf),D=m(P*m(Mf*Mf)),k=m(oe*be),x=m(pe*(oe+m(g*pe)))}({x_2:k,x_3:N}=C(B,k,N)),{x_2:x,x_3:D}=C(B,x,D);const z=i(x);return m(k*z)}const U={secretKey:d,publicKey:d,seed:d},R=(w=c(d))=>(G(w,U.seed,"seed"),w),M={randomSecretKey:R};return Object.freeze({keygen:wo(R,O),getSharedSecret:_,getPublicKey:O,scalarMult:L,scalarMultBase:I,utils:M,GuBytes:S.slice(),lengths:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Sp=BigInt(1),al=BigInt(2),xp=BigInt(3),Ap=BigInt(5),_p=BigInt(8),xs=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Cp={p:xs,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:_p,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function cl(r){const e=BigInt(10),t=BigInt(20),n=BigInt(40),s=BigInt(80),i=xs,a=r*r%i*r%i,c=we(a,al,i)*a%i,u=we(c,Sp,i)*r%i,d=we(u,Ap,i)*u%i,h=we(d,e,i)*d%i,g=we(h,t,i)*h%i,p=we(g,n,i)*g%i,f=we(p,s,i)*p%i,y=we(f,s,i)*p%i,m=we(y,e,i)*d%i;return{pow_p_5_8:we(m,al,i)*r%i,b2:a}}function ll(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const ul=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Ip(r,e){const t=xs,n=ve(e*e*e,t),s=ve(n*n*e,t),i=cl(r*s).pow_p_5_8;let o=ve(r*n*i,t);const a=ve(e*o*o,t),c=o,u=ve(o*ul,t),d=a===r,h=a===ve(-r,t),g=a===ve(-r*ul,t);return d&&(o=c),(h||g)&&(o=u),cp(o,t)&&(o=ve(-o,t)),{isValid:d||h,value:o}}const Lp=wp(Cp,{uvRatio:Ip});function Tp(r){return bp(Lp,Jm,Object.assign({adjustScalarBytes:ll},r))}const As=Tp({}),_s=(()=>{const r=xs;return vp({P:r,type:"x25519",powPminus2:e=>{const{pow_p_5_8:t,b2:n}=cl(e);return ve(we(t,xp,r)*n,r)},adjustScalarBytes:ll})})();class dl extends Error{constructor(e="An error occurred while verifying a message"){super(e),this.name="VerificationError"}}class Pp extends Error{constructor(e="Missing Web Crypto API"){super(e),this.name="WebCryptoMissingError"}}const Jt={get(r=globalThis){const e=r.crypto;if((e==null?void 0:e.subtle)==null)throw new Pp("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},hl=32,Eo=64,vo=32;let En;const fl=(async()=>{try{return await Jt.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Dp(){const r=As.utils.randomSecretKey(),e=As.getPublicKey(r);return{privateKey:Fp(r,e),publicKey:e}}async function kp(r,e){let t;r.length===Eo?t=r.subarray(0,32):t=r;const n={crv:"Ed25519",kty:"OKP",x:Q(r.subarray(32),"base64url"),d:Q(t,"base64url"),ext:!0,key_ops:["sign"]},s=await Jt.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await Jt.get().subtle.sign({name:"Ed25519"},s,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(i,0,i.byteLength)}function Rp(r,e){const t=r.subarray(0,vo);return As.sign(e instanceof Uint8Array?e:e.subarray(),t)}async function Mp(r,e){return En==null&&(En=await fl),En?kp(r,e):Rp(r,e)}async function Np(r,e,t){if(r.buffer instanceof ArrayBuffer){const n=await Jt.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await Jt.get().subtle.verify({name:"Ed25519"},n,e,t instanceof Uint8Array?t:t.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Op(r,e,t){return As.verify(e,t instanceof Uint8Array?t:t.subarray(),r)}async function Bp(r,e,t){return En==null&&(En=await fl),En?Np(r,e,t):Op(r,e,t)}function Fp(r,e){const t=new Uint8Array(Eo);for(let n=0;n<vo;n++)t[n]=r[n],t[vo+n]=e[n];return t}function So(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class gl{constructor(e){l(this,"type","Ed25519");l(this,"raw");this.raw=xo(e,hl)}toMultihash(){return rr.digest(bt(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Fe(this.raw,e.raw)}verify(e,t,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=Bp(this.raw,t,e);return So(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class $p{constructor(e,t){l(this,"type","Ed25519");l(this,"raw");l(this,"publicKey");this.raw=xo(e,Eo),this.publicKey=new gl(t)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Fe(this.raw,e.raw)}sign(e,t){var s,i;(s=t==null?void 0:t.signal)==null||s.throwIfAborted();const n=Mp(this.raw,e);return So(n)?n.then(o=>{var a;return(a=t==null?void 0:t.signal)==null||a.throwIfAborted(),o}):((i=t==null?void 0:t.signal)==null||i.throwIfAborted(),n)}}function ml(r){return r=xo(r,hl),new gl(r)}async function Up(){const{privateKey:r,publicKey:e}=Dp();return new $p(r,e)}function xo(r,e){if(r=Uint8Array.from(r??[]),r.length!==e)throw new V(`Key must be a Uint8Array of length ${e}, got ${r.length}`);return r}const zp=Math.pow(2,7),Kp=Math.pow(2,14),qp=Math.pow(2,21),Ao=Math.pow(2,28),_o=Math.pow(2,35),Co=Math.pow(2,42),Io=Math.pow(2,49),re=128,Re=127;function Le(r){if(r<zp)return 1;if(r<Kp)return 2;if(r<qp)return 3;if(r<Ao)return 4;if(r<_o)return 5;if(r<Co)return 6;if(r<Io)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Cs(r,e,t=0){switch(Le(r)){case 8:e[t++]=r&255|re,r/=128;case 7:e[t++]=r&255|re,r/=128;case 6:e[t++]=r&255|re,r/=128;case 5:e[t++]=r&255|re,r/=128;case 4:e[t++]=r&255|re,r>>>=7;case 3:e[t++]=r&255|re,r>>>=7;case 2:e[t++]=r&255|re,r>>>=7;case 1:{e[t++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return e}function Vp(r,e,t=0){switch(Le(r)){case 8:e.set(t++,r&255|re),r/=128;case 7:e.set(t++,r&255|re),r/=128;case 6:e.set(t++,r&255|re),r/=128;case 5:e.set(t++,r&255|re),r/=128;case 4:e.set(t++,r&255|re),r>>>=7;case 3:e.set(t++,r&255|re),r>>>=7;case 2:e.set(t++,r&255|re),r>>>=7;case 1:{e.set(t++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return e}function pl(r,e){let t=r[e],n=0;if(n+=t&Re,t<re||(t=r[e+1],n+=(t&Re)<<7,t<re)||(t=r[e+2],n+=(t&Re)<<14,t<re)||(t=r[e+3],n+=(t&Re)<<21,t<re)||(t=r[e+4],n+=(t&Re)*Ao,t<re)||(t=r[e+5],n+=(t&Re)*_o,t<re)||(t=r[e+6],n+=(t&Re)*Co,t<re)||(t=r[e+7],n+=(t&Re)*Io,t<re))return n;throw new RangeError("Could not decode varint")}function Wp(r,e){let t=r.get(e),n=0;if(n+=t&Re,t<re||(t=r.get(e+1),n+=(t&Re)<<7,t<re)||(t=r.get(e+2),n+=(t&Re)<<14,t<re)||(t=r.get(e+3),n+=(t&Re)<<21,t<re)||(t=r.get(e+4),n+=(t&Re)*Ao,t<re)||(t=r.get(e+5),n+=(t&Re)*_o,t<re)||(t=r.get(e+6),n+=(t&Re)*Co,t<re)||(t=r.get(e+7),n+=(t&Re)*Io,t<re))return n;throw new RangeError("Could not decode varint")}function mr(r,e,t=0){return e==null&&(e=dt(Le(r))),e instanceof Uint8Array?Cs(r,e,t):Vp(r,e,t)}function pr(r,e=0){return r instanceof Uint8Array?pl(r,e):Wp(r,e)}const Lo=new Float32Array([-0]),Mt=new Uint8Array(Lo.buffer);function Hp(r,e,t){Lo[0]=r,e[t]=Mt[0],e[t+1]=Mt[1],e[t+2]=Mt[2],e[t+3]=Mt[3]}function Gp(r,e){return Mt[0]=r[e],Mt[1]=r[e+1],Mt[2]=r[e+2],Mt[3]=r[e+3],Lo[0]}const To=new Float64Array([-0]),Me=new Uint8Array(To.buffer);function Yp(r,e,t){To[0]=r,e[t]=Me[0],e[t+1]=Me[1],e[t+2]=Me[2],e[t+3]=Me[3],e[t+4]=Me[4],e[t+5]=Me[5],e[t+6]=Me[6],e[t+7]=Me[7]}function Xp(r,e){return Me[0]=r[e],Me[1]=r[e+1],Me[2]=r[e+2],Me[3]=r[e+3],Me[4]=r[e+4],Me[5]=r[e+5],Me[6]=r[e+6],Me[7]=r[e+7],To[0]}const Zp=BigInt(Number.MAX_SAFE_INTEGER),Qp=BigInt(Number.MIN_SAFE_INTEGER);class Ne{constructor(e,t){l(this,"lo");l(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(t+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let n=~this.hi>>>0;return t===0&&(n=n+1>>>0),-(BigInt(t)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}static fromBigInt(e){if(e===0n)return en;if(e<Zp&&e>Qp)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let n=e>>32n,s=e-(n<<32n);return t&&(n=~n|0n,s=~s|0n,++s>yl&&(s=0n,++n>yl&&(n=0n))),new Ne(Number(s),Number(n))}static fromNumber(e){if(e===0)return en;const t=e<0;t&&(e=-e);let n=e>>>0,s=(e-n)/4294967296>>>0;return t&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Ne(n,s)}static from(e){return typeof e=="number"?Ne.fromNumber(e):typeof e=="bigint"?Ne.fromBigInt(e):typeof e=="string"?Ne.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Ne(e.low>>>0,e.high>>>0):en}}const en=new Ne(0,0);en.toBigInt=function(){return 0n},en.zzEncode=en.zzDecode=function(){return this},en.length=function(){return 1};const yl=4294967296n;function jp(r){let e=0,t=0;for(let n=0;n<r.length;++n)t=r.charCodeAt(n),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,e+=4):e+=3;return e}function Jp(r,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=r[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[e++]&63:a>239&&a<365?(a=((a&7)<<18|(r[e++]&63)<<12|(r[e++]&63)<<6|r[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[e++]&63)<<6|r[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function wl(r,e,t){const n=t;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-n}function rt(r,e){return RangeError(`index out of range: ${r.pos} + ${e??1} > ${r.len}`)}function Is(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}class ey{constructor(e){l(this,"buf");l(this,"pos");l(this,"len");l(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,rt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw rt(this,4);return Is(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw rt(this,4);return Is(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw rt(this,4);const e=Gp(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw rt(this,4);const e=Xp(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw rt(this,e);return this.pos+=e,t===n?new Uint8Array(0):this.buf.subarray(t,n)}string(){const e=this.bytes();return Jp(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw rt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw rt(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Ne(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw rt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw rt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw rt(this,8);const e=Is(this.buf,this.pos+=4),t=Is(this.buf,this.pos+=4);return new Ne(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=pl(this.buf,this.pos);return this.pos+=Le(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function ty(r){return new ey(r instanceof Uint8Array?r:r.subarray())}function $e(r,e,t){const n=ty(r);return e.decode(n,void 0,t)}function ny(r){let n,s=8192;return function(o){if(o<1||o>4096)return dt(o);s+o>8192&&(n=dt(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class yr{constructor(e,t,n){l(this,"fn");l(this,"len");l(this,"next");l(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=n}}function Po(){}class ry{constructor(e){l(this,"head");l(this,"tail");l(this,"len");l(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const sy=ny();function iy(r){return globalThis.Buffer!=null?dt(r):sy(r)}class Do{constructor(){l(this,"len");l(this,"head");l(this,"tail");l(this,"states");this.len=0,this.head=new yr(Po,0,0),this.tail=this.head,this.states=null}_push(e,t,n){return this.tail=this.tail.next=new yr(e,t,n),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new ay((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Ls,10,Ne.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Ne.fromBigInt(e);return this._push(Ls,t.length(),t)}uint64Number(e){return this._push(Cs,Le(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Ne.fromBigInt(e).zzEncode();return this._push(Ls,t.length(),t)}sint64Number(e){const t=Ne.fromNumber(e).zzEncode();return this._push(Ls,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(ko,1,e?1:0)}fixed32(e){return this._push(wr,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Ne.fromBigInt(e);return this._push(wr,4,t.lo)._push(wr,4,t.hi)}fixed64Number(e){const t=Ne.fromNumber(e);return this._push(wr,4,t.lo)._push(wr,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Hp,4,e)}double(e){return this._push(Yp,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(ko,1,0):this.uint32(t)._push(cy,t,e)}string(e){const t=jp(e);return t!==0?this.uint32(t)._push(wl,t,e):this._push(ko,1,0)}fork(){return this.states=new ry(this),this.head=this.tail=new yr(Po,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new yr(Po,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=e.next,this.tail=t,this.len+=n),this}finish(){let e=this.head.next;const t=iy(this.len);let n=0;for(;e!=null;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t}}function ko(r,e,t){e[t]=r&255}function oy(r,e,t){for(;r>127;)e[t++]=r&127|128,r>>>=7;e[t]=r}class ay extends yr{constructor(t,n){super(oy,t,n);l(this,"next");this.next=void 0}}function Ls(r,e,t){for(;r.hi!==0;)e[t++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[t++]=r.lo&127|128,r.lo=r.lo>>>7;e[t++]=r.lo}function wr(r,e,t){e[t]=r&255,e[t+1]=r>>>8&255,e[t+2]=r>>>16&255,e[t+3]=r>>>24}function cy(r,e,t){e.set(r,t)}globalThis.Buffer!=null&&(Do.prototype.bytes=function(r){const e=r.length>>>0;return this.uint32(e),e>0&&this._push(ly,e,r),this},Do.prototype.string=function(r){const e=globalThis.Buffer.byteLength(r);return this.uint32(e),e>0&&this._push(uy,e,r),this});function ly(r,e,t){e.set(r,t)}function uy(r,e,t){r.length<40?wl(r,e,t):e.utf8Write!=null?e.utf8Write(r,t):e.set(H(r),t)}function dy(){return new Do}function Ue(r,e){const t=dy();return e.encode(r,t,{lengthDelimited:!1}),t.finish()}var Ts;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Ts||(Ts={}));function bl(r,e,t,n){return{name:r,type:e,encode:t,decode:n}}function Ro(r){function e(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const t=function(i,o){const a=e(i);o.int32(a)},n=function(i){const o=i.int32();return e(o)};return bl("enum",Ts.VARINT,t,n)}function ze(r,e){return bl("message",Ts.LENGTH_DELIMITED,r,e)}class tn extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_LENGTH");l(this,"name","MaxLengthError")}}class El extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_SIZE");l(this,"name","MaxSizeError")}}var Te;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Te||(Te={}));var Mo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Mo||(Mo={})),function(r){r.codec=()=>Ro(Mo)}(Te||(Te={}));var vn;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(vn||(vn={}));var vl;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.Type!=null&&(n.uint32(8),Te.codec().encode(t.Type,n)),t.Data!=null&&(n.uint32(18),n.bytes(t.Data)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.Type=Te.codec().decode(t);break}case 2:{i.Data=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(vl||(vl={}));function Sl(r){if(isNaN(r)||r<=0)throw new V("random bytes length must be a Number bigger than 0");return lr(r)}class hy{constructor(e,t){l(this,"type","RSA");l(this,"jwk");l(this,"_raw");l(this,"_multihash");this.jwk=e,this._multihash=t}get raw(){return this._raw==null&&(this._raw=yy(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ue.createV1(114,this._multihash)}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Fe(this.raw,e.raw)}verify(e,t,n){return Ey(this.jwk,t,e,n)}}const fy=18,gy=1062,my=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function py(r){const e=ls(r[1],{offset:0});return{kty:"RSA",n:Q(e[0],"base64url"),e:Q(e[1],"base64url")}}function yy(r){if(r.n==null||r.e==null)throw new V("JWK was missing components");return or([my,Tc(or([no(H(r.n,"base64url")),no(H(r.e,"base64url"))]))]).subarray()}function wy(r,e){if(r.byteLength>=gy)throw new Fi("Key size is too large");const t=ls(r,{offset:0});return by(t,r,e)}function by(r,e,t){const n=py(r);if(t==null){const s=ur(vn.encode({Type:Te.RSA,Data:e}));t=os(fy,s)}return new hy(n,t)}async function Ey(r,e,t,n){var o,a;const s=await Jt.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await Jt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,e,t instanceof Uint8Array?t:t.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}class xl{constructor(e,t){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(ds(e),G(t,void 0,"key"),this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(t.length>n?e.create().update(t).digest():t);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=e.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),Yt(s)}update(e){return hs(this),this.iHash.update(e),this}digestInto(e){hs(this),G(e,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ps=(r,e,t)=>new xl(r,e).update(t).digest();Ps.create=(r,e)=>new xl(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Al=(r,e)=>(r+(r>=0?e:-e)/_l)/e;function vy(r,e,t){const[[n,s],[i,o]]=e,a=Al(o*r,t),c=Al(-s*r,t);let u=r-a*n-c*i,d=-a*s-c*o;const h=u<wt,g=d<wt;h&&(u=-u),g&&(d=-d);const p=fo(Math.ceil(tp(t)/2))+Sn;if(u<wt||u>=p||d<wt||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:g,k2:d}}function No(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function Oo(r,e){const t={};for(let n of Object.keys(e))t[n]=r[n]===void 0?e[n]:r[n];return Xt(t.lowS,"lowS"),Xt(t.prehash,"prehash"),t.format!==void 0&&No(t.format),t}class Sy extends Error{constructor(e=""){super(e)}}const Nt={Err:Sy,_tlv:{encode:(r,e)=>{const{Err:t}=Nt;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,s=ps(n);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=n>127?ps(s.length/2|128):"";return ps(r)+i+s+e},decode(r,e){const{Err:t}=Nt;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const s=e[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+c);if(u.length!==c)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const d of u)o=o<<8|d;if(n+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(n,n+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(n+o)}}},_int:{encode(r){const{Err:e}=Nt;if(r<wt)throw new e("integer: negative integers are not allowed");let t=ps(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Nt;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return ys(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Nt,s=G(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(r){const{_tlv:e,_int:t}=Nt,n=e.encode(2,t.encode(r.r)),s=e.encode(2,t.encode(r.s)),i=n+s;return e.encode(48,i)}},wt=BigInt(0),Sn=BigInt(1),_l=BigInt(2),Ds=BigInt(3),xy=BigInt(4);function Ay(r,e={}){const t=ol("weierstrass",r,e),{Fp:n,Fn:s}=t;let i=t.CURVE;const{h:o,n:a}=i;yn(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=e;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=Il(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(M,w,b){const{x:A,y:P}=w.toAffine(),k=n.toBytes(A);if(Xt(b,"isCompressed"),b){d();const x=!n.isOdd(P);return ft(Cl(x),k)}else return ft(Uint8Array.of(4),k,n.toBytes(P))}function g(M){G(M,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=u,A=M.length,P=M[0],k=M.subarray(1);if(A===w&&(P===2||P===3)){const x=n.fromBytes(k);if(!n.isValid(x))throw new Error("bad point: is not on curve, wrong x");const N=y(x);let D;try{D=n.sqrt(N)}catch(te){const Z=te instanceof Error?": "+te.message:"";throw new Error("bad point: is not on curve, sqrt error"+Z)}d();const B=n.isOdd(D);return(P&1)===1!==B&&(D=n.neg(D)),{x,y:D}}else if(A===b&&P===4){const x=n.BYTES,N=n.fromBytes(k.subarray(0,x)),D=n.fromBytes(k.subarray(x,x*2));if(!m(N,D))throw new Error("bad point: is not on curve");return{x:N,y:D}}else throw new Error(`bad point: got length ${A}, expected compressed=${w} or uncompressed=${b}`)}const p=e.toBytes||h,f=e.fromBytes||g;function y(M){const w=n.sqr(M),b=n.mul(w,M);return n.add(n.add(b,n.mul(M,i.a)),i.b)}function m(M,w){const b=n.sqr(w),A=y(M);return n.eql(b,A)}if(!m(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(i.a,Ds),xy),v=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(S,v)))throw new Error("bad curve params: a or b");function E(M,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${M}`);return w}function T(M){if(!(M instanceof C))throw new Error("Weierstrass Point expected")}function L(M){if(!c||!c.basises)throw new Error("no endo");return vy(M,c.basises,s.ORDER)}const I=bs((M,w)=>{const{X:b,Y:A,Z:P}=M;if(n.eql(P,n.ONE))return{x:b,y:A};const k=M.is0();w==null&&(w=k?n.ONE:n.inv(P));const x=n.mul(b,w),N=n.mul(A,w),D=n.mul(P,w);if(k)return{x:n.ZERO,y:n.ZERO};if(!n.eql(D,n.ONE))throw new Error("invZ was invalid");return{x,y:N}}),O=bs(M=>{if(M.is0()){if(e.allowInfinityPoint&&!n.is0(M.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=M.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!m(w,b))throw new Error("bad point: equation left != right");if(!M.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function _(M,w,b,A,P){return b=new C(n.mul(b.X,M),b.Y,b.Z),w=vs(A,w),b=vs(P,b),w.add(b)}const R=class R{constructor(w,b,A){l(this,"X");l(this,"Y");l(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",A),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:A}=w||{};if(!w||!n.isValid(b)||!n.isValid(A))throw new Error("invalid affine point");if(w instanceof R)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(A)?R.ZERO:new R(b,A,n.ONE)}static fromBytes(w){const b=R.fromAffine(f(G(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return R.fromBytes(cr(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return U.createCache(this,w),b||this.multiply(Ds),this}assertValidity(){O(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){T(w);const{X:b,Y:A,Z:P}=this,{X:k,Y:x,Z:N}=w,D=n.eql(n.mul(b,N),n.mul(k,P)),B=n.eql(n.mul(A,N),n.mul(x,P));return D&&B}negate(){return new R(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,A=n.mul(b,Ds),{X:P,Y:k,Z:x}=this;let N=n.ZERO,D=n.ZERO,B=n.ZERO,z=n.mul(P,P),te=n.mul(k,k),Z=n.mul(x,x),q=n.mul(P,k);return q=n.add(q,q),B=n.mul(P,x),B=n.add(B,B),N=n.mul(w,B),D=n.mul(A,Z),D=n.add(N,D),N=n.sub(te,D),D=n.add(te,D),D=n.mul(N,D),N=n.mul(q,N),B=n.mul(A,B),Z=n.mul(w,Z),q=n.sub(z,Z),q=n.mul(w,q),q=n.add(q,B),B=n.add(z,z),z=n.add(B,z),z=n.add(z,Z),z=n.mul(z,q),D=n.add(D,z),Z=n.mul(k,x),Z=n.add(Z,Z),z=n.mul(Z,q),N=n.sub(N,z),B=n.mul(Z,te),B=n.add(B,B),B=n.add(B,B),new R(N,D,B)}add(w){T(w);const{X:b,Y:A,Z:P}=this,{X:k,Y:x,Z:N}=w;let D=n.ZERO,B=n.ZERO,z=n.ZERO;const te=i.a,Z=n.mul(i.b,Ds);let q=n.mul(b,k),oe=n.mul(A,x),le=n.mul(P,N),be=n.add(b,A),pe=n.add(k,x);be=n.mul(be,pe),pe=n.add(q,oe),be=n.sub(be,pe),pe=n.add(b,P);let De=n.add(k,N);return pe=n.mul(pe,De),De=n.add(q,le),pe=n.sub(pe,De),De=n.add(A,P),D=n.add(x,N),De=n.mul(De,D),D=n.add(oe,le),De=n.sub(De,D),z=n.mul(te,pe),D=n.mul(Z,le),z=n.add(D,z),D=n.sub(oe,z),z=n.add(oe,z),B=n.mul(D,z),oe=n.add(q,q),oe=n.add(oe,q),le=n.mul(te,le),pe=n.mul(Z,pe),oe=n.add(oe,le),le=n.sub(q,le),le=n.mul(te,le),pe=n.add(pe,le),q=n.mul(oe,pe),B=n.add(B,q),q=n.mul(De,pe),D=n.mul(be,D),D=n.sub(D,q),q=n.mul(be,oe),z=n.mul(De,z),z=n.add(z,q),new R(D,B,z)}subtract(w){return this.add(w.negate())}is0(){return this.equals(R.ZERO)}multiply(w){const{endo:b}=e;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let A,P;const k=x=>U.cached(this,x,N=>fr(R,N));if(b){const{k1neg:x,k1:N,k2neg:D,k2:B}=L(w),{p:z,f:te}=k(N),{p:Z,f:q}=k(B);P=te.add(q),A=_(b.beta,z,Z,x,D)}else{const{p:x,f:N}=k(w);A=x,P=N}return fr(R,[A,P])[0]}multiplyUnsafe(w){const{endo:b}=e,A=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===wt||A.is0())return R.ZERO;if(w===Sn)return A;if(U.hasCache(this))return this.multiply(w);if(b){const{k1neg:P,k1:k,k2neg:x,k2:N}=L(w),{p1:D,p2:B}=mp(R,A,k,N);return _(b.beta,D,B,P,x)}else return U.unsafe(A,w)}toAffine(w){return I(this,w)}isTorsionFree(){const{isTorsionFree:w}=e;return o===Sn?!0:w?w(R,this):U.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=e;return o===Sn?this:w?w(R,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return Xt(w,"isCompressed"),this.assertValidity(),p(R,this,w)}toHex(w=!0){return ar(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(R,"BASE",new R(i.Gx,i.Gy,n.ONE)),l(R,"ZERO",new R(n.ZERO,n.ONE,n.ZERO)),l(R,"Fp",n),l(R,"Fn",s);let C=R;const F=s.BITS,U=new sl(C,e.endo?Math.ceil(F/2):F);return C.BASE.precompute(8),C}function Cl(r){return Uint8Array.of(r?2:3)}function Il(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function _y(r,e={}){const{Fn:t}=r,n=e.randomBytes||lr,s=Object.assign(Il(r.Fp,t),{seed:Jc(t.ORDER)});function i(p){try{const f=t.fromBytes(p);return t.isValidNot0(f)}catch{return!1}}function o(p,f){const{publicKey:y,publicKeyUncompressed:m}=s;try{const S=p.length;return f===!0&&S!==y||f===!1&&S!==m?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return gp(G(p,s.seed,"seed"),t.ORDER)}function c(p,f=!0){return r.BASE.multiply(t.fromBytes(p)).toBytes(f)}function u(p){const{secretKey:f,publicKey:y,publicKeyUncompressed:m}=s;if(!us(p)||"_lengths"in t&&t._lengths||f===y)return;const S=G(p,void 0,"key").length;return S===y||S===m}function d(p,f,y=!0){if(u(p)===!0)throw new Error("first arg must be private key");if(u(f)===!1)throw new Error("second arg must be public key");const m=t.fromBytes(p);return r.fromBytes(f).multiply(m).toBytes(y)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},g=wo(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:g,Point:r,utils:h,lengths:s})}function Cy(r,e,t={}){ds(e),yn(t,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),t=Object.assign({},t);const n=t.randomBytes||lr,s=t.hmac||((w,b)=>Ps(e,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:d,getSharedSecret:h,utils:g,lengths:p}=_y(r,t),f={prehash:!0,lowS:typeof t.lowS=="boolean"?t.lowS:!0,format:"compact",extraEntropy:!1},y=a*_l<i.ORDER;function m(w){const b=a>>Sn;return w>b}function S(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function v(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){No(b);const A=p.signature,P=b==="compact"?A:b==="recovered"?A+1:void 0;return G(w,P)}class T{constructor(b,A,P){l(this,"r");l(this,"s");l(this,"recovery");if(this.r=S("r",b),this.s=S("s",A),P!=null){if(v(),![0,1,2,3].includes(P))throw new Error("invalid recovery id");this.recovery=P}Object.freeze(this)}static fromBytes(b,A=f.format){E(b,A);let P;if(A==="der"){const{r:D,s:B}=Nt.toSig(G(b));return new T(D,B)}A==="recovered"&&(P=b[0],A="compact",b=b.subarray(1));const k=p.signature/2,x=b.subarray(0,k),N=b.subarray(k,k*2);return new T(o.fromBytes(x),o.fromBytes(N),P)}static fromHex(b,A){return this.fromBytes(cr(b),A)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new T(this.r,this.s,b)}recoverPublicKey(b){const{r:A,s:P}=this,k=this.assertRecovery(),x=k===2||k===3?A+a:A;if(!i.isValid(x))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const N=i.toBytes(x),D=r.fromBytes(ft(Cl((k&1)===0),N)),B=o.inv(x),z=I(G(b,void 0,"msgHash")),te=o.create(-z*B),Z=o.create(P*B),q=r.BASE.multiplyUnsafe(te).add(D.multiplyUnsafe(Z));if(q.is0())throw new Error("invalid recovery: point at infinify");return q.assertValidity(),q}hasHighS(){return m(this.s)}toBytes(b=f.format){if(No(b),b==="der")return cr(Nt.hexFromSig(this));const{r:A,s:P}=this,k=o.toBytes(A),x=o.toBytes(P);return b==="recovered"?(v(),ft(Uint8Array.of(this.assertRecovery()),k,x)):ft(k,x)}toHex(b){return ar(this.toBytes(b))}}const L=t.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const A=ys(b),P=b.length*8-c;return P>0?A>>BigInt(P):A},I=t.bits2int_modN||function(b){return o.create(L(b))},O=fo(c);function _(w){return hr("num < 2^"+c,w,wt,O),o.toBytes(w)}function C(w,b){return G(w,void 0,"message"),b?G(e(w),void 0,"prehashed message"):w}function F(w,b,A){const{lowS:P,prehash:k,extraEntropy:x}=Oo(A,f);w=C(w,k);const N=I(w),D=o.fromBytes(b);if(!o.isValidNot0(D))throw new Error("invalid private key");const B=[_(D),_(N)];if(x!=null&&x!==!1){const q=x===!0?n(p.secretKey):x;B.push(G(q,void 0,"extraEntropy"))}const z=ft(...B),te=N;function Z(q){const oe=L(q);if(!o.isValidNot0(oe))return;const le=o.inv(oe),be=r.BASE.multiply(oe).toAffine(),pe=o.create(be.x);if(pe===wt)return;const De=o.create(le*o.create(te+pe*D));if(De===wt)return;let Pi=(be.x===pe?0:2)|Number(be.y&Sn),Wr=De;return P&&m(De)&&(Wr=o.neg(De),Pi^=1),new T(pe,Wr,y?void 0:Pi)}return{seed:z,k2sig:Z}}function U(w,b,A={}){const{seed:P,k2sig:k}=F(w,b,A);return np(e.outputLen,o.BYTES,s)(P,k).toBytes(A.format)}function R(w,b,A,P={}){const{lowS:k,prehash:x,format:N}=Oo(P,f);if(A=G(A,void 0,"publicKey"),b=C(b,x),!us(w)){const D=w instanceof T?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+D)}E(w,N);try{const D=T.fromBytes(w,N),B=r.fromBytes(A);if(k&&D.hasHighS())return!1;const{r:z,s:te}=D,Z=I(b),q=o.inv(te),oe=o.create(Z*q),le=o.create(z*q),be=r.BASE.multiplyUnsafe(oe).add(B.multiplyUnsafe(le));return be.is0()?!1:o.create(be.x)===z}catch{return!1}}function M(w,b,A={}){const{prehash:P}=Oo(A,f);return b=C(b,P),T.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:h,utils:g,lengths:p,Point:r,sign:U,verify:R,recoverPublicKey:M,Signature:T,hash:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bo={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Iy={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Ll=BigInt(2);function Ly(r){const e=Bo.p,t=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%e,d=u*u*r%e,h=we(d,t,e)*d%e,g=we(h,t,e)*d%e,p=we(g,Ll,e)*u%e,f=we(p,s,e)*p%e,y=we(f,i,e)*f%e,m=we(y,a,e)*y%e,S=we(m,c,e)*m%e,v=we(S,a,e)*y%e,E=we(v,t,e)*d%e,T=we(E,o,e)*f%e,L=we(T,n,e)*u%e,I=we(L,Ll,e);if(!Fo.eql(Fo.sqr(I),r))throw new Error("Cannot find square root");return I}const Fo=Es(Bo.p,{sqrt:Ly}),ks=Cy(Ay(Bo,{Fp:Fo,endo:Iy}),ur);function Ty(r,e,t,n){var i;const s=Ac.digest(t instanceof Uint8Array?t:t.subarray());if(So(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),ks.verify(e,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new dl(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),ks.verify(e,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new dl(String(o))}}class Py{constructor(e){l(this,"type","secp256k1");l(this,"raw");l(this,"_key");this._key=ky(e),this.raw=Dy(this._key)}toMultihash(){return rr.digest(bt(this))}toCID(){return ue.createV1(114,this.toMultihash())}toString(){return Ce.encode(this.toMultihash().bytes).substring(1)}equals(e){return e==null||!(e.raw instanceof Uint8Array)?!1:Fe(this.raw,e.raw)}verify(e,t,n){return Ty(this._key,t,e,n)}}function Tl(r){return new Py(r)}function Dy(r){return ks.Point.fromBytes(r).toBytes()}function ky(r){try{return ks.Point.fromBytes(r),r}catch(e){throw new Fi(String(e))}}async function Ry(r,e){return Up()}function Ot(r,e){const{Type:t,Data:n}=vn.decode(r),s=n??new Uint8Array;switch(t){case Te.RSA:return wy(s,e);case Te.Ed25519:return ml(s);case Te.secp256k1:return Tl(s);case Te.ECDSA:return Pc(s);default:throw new Qr}}function My(r){const{Type:e,Data:t}=vn.decode(r.digest),n=t??new Uint8Array;switch(e){case Te.Ed25519:return ml(n);case Te.secp256k1:return Tl(n);case Te.ECDSA:return Pc(n);default:throw new Qr}}function bt(r){return vn.encode({Type:Te[r.type],Data:r.raw})}const Pl=Symbol.for("nodejs.util.inspect.custom"),Ny=114;class $o{constructor(e){l(this,"type");l(this,"multihash");l(this,"publicKey");l(this,"string");l(this,ef,!0);this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Ce.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ue.createV1(Ny,this.multihash)}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return Fe(this.multihash.bytes,e);if(typeof e=="string")return this.toString()===e;if(((t=e==null?void 0:e.toMultihash())==null?void 0:t.bytes)!=null)return Fe(this.multihash.bytes,e.toMultihash().bytes);throw new Error("not valid Id")}[(ef=Wi,Pl)](){return`PeerId(${this.toString()})`}}class Dl extends $o{constructor(t){super({...t,type:"RSA"});l(this,"type","RSA");l(this,"publicKey");this.publicKey=t.publicKey}}class kl extends $o{constructor(t){super({...t,type:"Ed25519"});l(this,"type","Ed25519");l(this,"publicKey");this.publicKey=t.publicKey}}class Rl extends $o{constructor(t){super({...t,type:"secp256k1"});l(this,"type","secp256k1");l(this,"publicKey");this.publicKey=t.publicKey}}const Oy=2336;class Ml{constructor(e){l(this,"type","url");l(this,"multihash");l(this,"publicKey");l(this,"url");l(this,tf,!0);this.url=e.toString(),this.multihash=rr.digest(H(this.url))}[(nf=Pl,tf=Wi,nf)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ue.createV1(Oy,this.toMultihash())}toJSON(){return this.toString()}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=Q(e)),e.toString()===this.toString())}}const By=114,Nl=2336;function Bt(r,e){let t;if(r.charAt(0)==="1"||r.charAt(0)==="Q")t=as(Ce.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return Er(ue.parse(r));throw new V('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return Rs(t)}function br(r){if(r.type==="Ed25519")return new kl({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new Rl({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new Dl({multihash:r.toCID().multihash,publicKey:r});throw new Qr}function Fy(r){return br(r.publicKey)}function Rs(r){if(Uy(r))return new Dl({multihash:r});if($y(r))try{const e=My(r);if(e.type==="Ed25519")return new kl({multihash:r,publicKey:e});if(e.type==="secp256k1")return new Rl({multihash:r,publicKey:e})}catch{const t=Q(r.digest);return new Ml(new URL(t))}throw new rc("Supplied PeerID Multihash is invalid")}function Er(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==By&&r.code!==Nl)throw new nc("Supplied PeerID CID is invalid");if(r.code===Nl){const e=Q(r.multihash.digest);return new Ml(new URL(e))}return Rs(r.multihash)}function $y(r){return r.code===rr.code}function Uy(r){return r.code===Ac.code}async function zy(r){var e,t;if(r.connectionProtector===null&&((t=(e=globalThis.process)==null?void 0:e.env)==null?void 0:t.LIBP2P_FORCE_PNET)!=null)throw new V("Private network is enforced, but no protector was provided");return r}const xn=1e3,An=xn*60,_n=An*60,nn=_n*24,vr=nn*7,Cn=nn*365.25,Sr=Cn/12;function Ky(r,e){if(typeof r=="string")return qy(r);if(typeof r=="number")return Hy(r,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var Ol=Ky;function qy(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(e!=null&&e.groups))return NaN;let{value:t,unit:n="ms"}=e.groups,s=parseFloat(t),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Cn;case"months":case"month":case"mo":return s*Sr;case"weeks":case"week":case"w":return s*vr;case"days":case"day":case"d":return s*nn;case"hours":case"hour":case"hrs":case"hr":case"h":return s*_n;case"minutes":case"minute":case"mins":case"min":case"m":return s*An;case"seconds":case"second":case"secs":case"sec":case"s":return s*xn;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Vy(r){let e=Math.abs(r);return e>=Cn?`${Math.round(r/Cn)}y`:e>=Sr?`${Math.round(r/Sr)}mo`:e>=vr?`${Math.round(r/vr)}w`:e>=nn?`${Math.round(r/nn)}d`:e>=_n?`${Math.round(r/_n)}h`:e>=An?`${Math.round(r/An)}m`:e>=xn?`${Math.round(r/xn)}s`:`${r}ms`}function Wy(r){let e=Math.abs(r);return e>=Cn?rn(r,e,Cn,"year"):e>=Sr?rn(r,e,Sr,"month"):e>=vr?rn(r,e,vr,"week"):e>=nn?rn(r,e,nn,"day"):e>=_n?rn(r,e,_n,"hour"):e>=An?rn(r,e,An,"minute"):e>=xn?rn(r,e,xn,"second"):`${r} ms`}function Hy(r,e){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return e!=null&&e.long?Wy(r):Vy(r)}function rn(r,e,t,n){let s=e>=t*1.5;return`${Math.round(r/t)} ${n}${s?"s":""}`}function Gy(r){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Ol,t.destroy=u,Object.keys(r).forEach(d=>{t[d]=r[d]}),t.names=[],t.skips=[],t.formatters={};function e(d){let h=0;for(let g=0;g<d.length;g++)h=(h<<5)-h+d.charCodeAt(g),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(d){let h,g=null,p,f;function y(...m){if(!y.enabled)return;const S=y,v=Number(new Date),E=v-(h||v);S.diff=E,S.prev=h,S.curr=v,h=v,m[0]=t.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let T=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(I,O)=>{if(I==="%%")return"%";T++;const _=t.formatters[O];if(typeof _=="function"){const C=m[T];I=_.call(S,C),m.splice(T,1),T--}return I}),t.formatArgs.call(S,m),(S.log||t.log).apply(S,m)}return y.namespace=d,y.useColors=t.useColors(),y.color=t.selectColor(d),y.extend=n,y.destroy=t.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(p!==t.namespaces&&(p=t.namespaces,f=t.enabled(d)),f),set:m=>{g=m}}),typeof t.init=="function"&&t.init(y),y}function n(d,h){const g=t(this.namespace+(typeof h>"u"?":":h)+d);return g.log=this.log,g}function s(d){t.save(d),t.namespaces=d,t.names=[],t.skips=[];let h;const g=(typeof d=="string"?d:"").split(/[\s,]+/),p=g.length;for(h=0;h<p;h++)g[h]&&(d=g[h].replace(/\*/g,".*?"),d[0]==="-"?t.skips.push(new RegExp("^"+d.substr(1)+"$")):t.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,g;for(h=0,g=t.skips.length;h<g;h++)if(t.skips[h].test(d))return!1;for(h=0,g=t.names.length;h<g;h++)if(t.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var Yy={};const gt=tw(),Xy=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Zy(){var r,e,t,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((t=(e=document.documentElement)==null?void 0:e.style)==null?void 0:t.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function Qy(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+Ol(this.diff),!this.useColors)return;const e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(n=t))}),r.splice(n,0,e)}const jy=console.debug??console.log??(()=>{});function Jy(r){try{r?gt==null||gt.setItem("debug",r):gt==null||gt.removeItem("debug")}catch{}}function ew(){let r;try{r=gt==null?void 0:gt.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Yy.DEBUG),r}function tw(){try{return localStorage}catch{}}function nw(r){r.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const Ze=Gy({formatArgs:Qy,save:Jy,load:ew,useColors:Zy,setupFormatters:nw,colors:Xy,storage:gt,log:jy});Ze.formatters.b=r=>r==null?"undefined":Ce.baseEncode(r),Ze.formatters.t=r=>r==null?"undefined":Ct.baseEncode(r),Ze.formatters.m=r=>r==null?"undefined":vc.baseEncode(r),Ze.formatters.p=r=>r==null?"undefined":r.toString(),Ze.formatters.c=r=>r==null?"undefined":r.toString(),Ze.formatters.k=r=>r==null?"undefined":r.toString(),Ze.formatters.a=r=>r==null?"undefined":r.toString(),Ze.formatters.e=r=>{if(r==null)return"undefined";const e=$l(r.message),t=$l(r.stack);return e!=null&&t!=null?t.includes(e)?t:`${e}
${t}`:t??e??r.toString()};function rw(r){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=r,e.destroy=()=>!0,e.extend=()=>e,e}function Bl(){return{forComponent(r){return Fl(r)}}}function Fl(r){let e=rw(`${r}:trace`);return Ze.enabled(`${r}:trace`)&&Ze.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=Ze(`${r}:trace`)),Object.assign(Ze(r),{error:Ze(`${r}:error`),trace:e,newScope:t=>Fl(`${r}:${t}`)})}function $l(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function xr(r,e){const t={[Symbol.iterator]:()=>t,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}function Uo(r){const e=as(Ce.decode(`z${r}`));return Rs(e)}class Ar{constructor(e){l(this,"map");if(this.map=new Map,e!=null)for(const[t,n]of e.entries())this.map.set(t.toString(),{key:t,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return xr(this.map.entries(),e=>[e[1].key,e[1].value])}forEach(e){this.map.forEach((t,n)=>{e(t.value,t.key,this)})}get(e){var t;return(t=this.map.get(e.toString()))==null?void 0:t.value}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),{key:e,value:t})}keys(){return xr(this.map.values(),e=>e.key)}values(){return xr(this.map.values(),e=>e.value)}get size(){return this.map.size}}class In{constructor(e){l(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return xr(this.set.entries(),e=>{const t=Uo(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const n=Uo(t);e(n,n,this)})}has(e){return this.set.has(e.toString())}values(){return xr(this.set.values(),e=>Uo(e))}intersection(e){const t=new In;for(const n of e)this.has(n)&&t.add(n);return t}difference(e){const t=new In;for(const n of this)e.has(n)||t.add(n);return t}union(e){const t=new In;for(const n of e)t.add(n);for(const n of this)t.add(n);return t}}const zo={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},Ul={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},zl=new globalThis.TextEncoder;function sw(r,e){const t=zo[e];let n=Ul[e];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(e,n*t);return n}function iw(r,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=zo[e];let s=Ul[e],i=r;for(;i.length>0;){const o=zl.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*n)}return s}function ow(r,{size:e=32,utf8Buffer:t}={}){if(!zo[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(t)return iw(r,e,t);r=zl.encode(r)}return sw(r,e)}const Ko={hash:r=>Number(ow(r,{size:32})),hashV:(r,e)=>aw(Ko.hash(r,e))};function aw(r){let e=r.toString(16);return e.length%2===1&&(e=`0${e}`),H(e,"base16")}const Kl=64;class sn{constructor(e,t,n,s=2){l(this,"fp");l(this,"h");l(this,"seed");if(s>Kl)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,n),o=ye(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return(e==null?void 0:e.fp)instanceof Uint8Array?Fe(this.fp,e.fp):!1}}function Ms(r,e){return Math.floor(Math.random()*(e-r))+r}class Ns{constructor(e){l(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof sn))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof sn))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof sn))throw new TypeError("Invalid Fingerprint");const t=Ms(0,this.contents.length-1),n=this.contents[t];return this.contents[t]=e,n}remove(e){if(!(e instanceof sn))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(n=>e.equals(n));return t>-1?(this.contents[t]=null,!0):!1}}const cw=500;class ql{constructor(e){l(this,"bucketSize");l(this,"filterSize");l(this,"fingerprintSize");l(this,"buckets");l(this,"count");l(this,"hash");l(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??Ko,this.seed=e.seed??Ms(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=H(e));const t=new sn(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=(n^t.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Ns(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Ns(this.bucketSize)),this.buckets[n].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[n,s];let o=i[Ms(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Ns(this.bucketSize));for(let a=0;a<cw;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Ns(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){var o,a;typeof e=="string"&&(e=H(e));const t=new sn(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(t))??!1;if(s)return s;const i=(n^t.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(t))??!1}remove(e){var a,c;typeof e=="string"&&(e=H(e));const t=new sn(e,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(e,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(t))??!1;if(s)return this.count--,s;const i=(n^t.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(t))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const lw={1:.5,2:.84,4:.95,8:.98};function uw(r=.001){return r>.002?2:r>1e-5?4:8}function dw(r,e=.001){const t=uw(e),n=lw[t],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),Kl);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class hw{constructor(e){l(this,"filterSize");l(this,"bucketSize");l(this,"fingerprintSize");l(this,"scale");l(this,"filterSeries");l(this,"hash");l(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??Ko,this.seed=e.seed??Ms(0,Math.pow(2,10)),this.filterSeries=[new ql({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=H(e)),this.has(e))return!0;let t=this.filterSeries.find(n=>n.reliable);if(t==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new ql({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=H(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=H(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Vl(r,e=.001,t){return new hw({...dw(r,e)})}function de(r){var s,i,o,a,c,u;const e=r.getComponents(),t={};let n=0;if(((s=e[n])==null?void 0:s.name)==="ip6zone"&&(t.zone=`${e[n].value}`,n++),e[n].name==="ip4"||e[n].name==="ip6"||e[n].name==="dns"||e[n].name==="dns4"||e[n].name==="dns6"?(t.type=e[n].name,t.host=e[n].value,n++):e[n].name==="dnsaddr"&&(t.type=e[n].name,t.host=`_dnsaddr.${e[n].value}`,n++),(((i=e[n])==null?void 0:i.name)==="tcp"||((o=e[n])==null?void 0:o.name)==="udp")&&(t.protocol=e[n].name==="tcp"?"tcp":"udp",t.port=parseInt(`${e[n].value}`),n++),((a=e[n])==null?void 0:a.name)==="ipcidr"&&(t.type==="ip4"?t.cidr=parseInt(`${e[n].value}`):t.type==="ip6"&&(t.cidr=`${e[n].value}`),n++),t.type==null||t.host==null)throw new V(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=e[n])==null?void 0:c.name)==="tls"&&((u=e[n+1])==null?void 0:u.name)==="sni"&&(t.sni=e[n+1].value,n+=2),t}class fw{constructor(){l(this,"index",0);l(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,n=e();return n===void 0&&(this.index=t),n}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,n){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return n()})}readNumber(e,t,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const g=Number.parseInt(h,e);if(!Number.isNaN(g))return g});if(d===void 0)break;if(i*=e,i+=d,i>u||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const n=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;e[t]=n}return e})}readIPv6Addr(){const e=t=>{for(let n=0;n<t.length/2;n++){const s=n*2;if(n<t.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[n,s]=e(t);if(n===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Wl=45,gw=15,Ln=new fw;function Hl(r){if(!(r.length>gw))return Ln.new(r).parseWith(()=>Ln.readIPv4Addr())}function Gl(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>Wl))return Ln.new(r).parseWith(()=>Ln.readIPv6Addr())}function qo(r,e=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>Wl)return;const t=Ln.new(r).parseWith(()=>Ln.readIPAddr());if(t)return e&&t.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,t[0],t[1],t[2],t[3]]):t}function mw(r,e,t){let n=0;for(const s of r)if(!(n<e)){if(n>t)break;if(s!==255)return!1;n++}return!0}function pw(r,e,t,n){let s=0;for(const i of r)if(!(s<t)){if(s>n)break;if(i!==e[s])return!1;s++}return!0}function yw(r){switch(r.length){case _r:return r.join(".");case Cr:{const e=[];for(let t=0;t<r.length;t++)t%2===0&&e.push(r[t].toString(16).padStart(2,"0")+r[t+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}function ww(r){let e=0;for(let[t,n]of r.entries()){if(n===255){e+=8;continue}for(;n&128;)e++,n=n<<1;if(n&128)return-1;for(let s=t+1;s<r.length;s++)if(r[s]!=0)return-1;break}return e}function bw(r){let e="0x";for(const t of r)e+=(t>>4).toString(16)+(t&15).toString(16);return e}const _r=4,Cr=16,Ew=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Yl(r,e){e.length===Cr&&r.length===_r&&mw(e,0,11)&&(e=e.slice(12)),e.length===_r&&r.length===Cr&&pw(r,Ew,0,11)&&(r=r.slice(12));const t=r.length;if(t!=e.length)throw new Error("Failed to mask ip");const n=new Uint8Array(t);for(let s=0;s<t;s++)n[s]=r[s]&e[s];return n}function vw(r,e){if(typeof e=="string"&&(e=qo(e)),e==null)throw new Error("Invalid ip");if(e.length!==r.network.length)return!1;for(let t=0;t<e.length;t++)if((r.network[t]&r.mask[t])!==(e[t]&r.mask[t]))return!1;return!0}function Sw(r){const[e,t]=r.split("/");if(!e||!t)throw new Error("Failed to parse given CIDR: "+r);let n=_r,s=Hl(e);if(s==null&&(n=Cr,s=Gl(e),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(t,10);if(Number.isNaN(i)||String(i).length!==t.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=Xl(i,8*n);return{network:Yl(s,o),mask:o}}function Xl(r,e){if(e!==8*_r&&e!==8*Cr)throw new Error("Invalid CIDR mask");if(r<0||r>e)throw new Error("Invalid CIDR mask");const t=e/8,n=new Uint8Array(t);for(let s=0;s<t;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class Zl{constructor(e,t){if(t==null)({network:this.network,mask:this.mask}=Sw(e));else{const n=qo(e);if(n==null)throw new Error("Failed to parse network");t=String(t);const s=parseInt(t,10);if(Number.isNaN(s)||String(s).length!==t.length||s<0||s>n.length*8){const i=qo(t);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=Xl(s,8*n.length);this.network=Yl(n,this.mask)}}contains(e){return vw({network:this.network,mask:this.mask},e)}toString(){const e=ww(this.mask),t=e!==-1?String(e):bw(this.mask);return yw(this.network)+"/"+t}}function xw(r,e){return new Zl(r).contains(e)}function Aw(r){try{const e=de(r);switch(e.type){case"ip6":return xw("2000::/3",e.host);default:return!1}}catch{return!1}}function _w(r){try{const e=de(r);switch(e.type){case"ip4":return e.host.startsWith("169.254.");case"ip6":return e.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function Cw(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function Vo(r){try{const e=de(r);switch(e.type){case"ip4":case"ip6":return Cw(e.host);default:return!1}}catch{return!1}}function st(r){try{return de(r),!0}catch{return!1}}function Tn(r){return!!Hl(r)}function Ql(r){return!!Gl(r)}var Iw=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function jl(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Jl;(function(){var r,e,t,n,s,i,o,a;a=function(c){var u,d,h,g;return u=(c&255<<24)>>>24,d=(c&255<<16)>>>16,h=(c&65280)>>>8,g=c&255,[u,d,h,g].join(".")},o=function(c){var u,d,h,g,p,f;for(u=[],h=g=0;g<=3&&c.length!==0;h=++g){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}f=e(c),p=f[0],d=f[1],c=c.substring(d),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},n=t("0"),i=t("a"),s=t("A"),e=function(c){var u,d,h,g,p;for(g=0,u=10,d="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,u=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<c.length;){if("0"<=c[h]&&c[h]<=d)g=g*u+(t(c[h])-n)>>>0;else if(u===16)if("a"<=c[h]&&c[h]<="f")g=g*u+(10+t(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")g=g*u+(10+t(c[h])-s)>>>0;else break;else break;if(g>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[g,h]},r=function(){function c(u,d){var h,g,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=g=32;g>=0;h=--g)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var d,h,g;for(g=o(this.first),h=o(this.last),d=0;g<=h;)u(a(g),g,d),d++,g++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Jl=r}).call(Iw);const Lw=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(r=>new Jl(r));function Wo(r){for(const e of Lw)if(e.contains(r))return!0;return!1}function Tw(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Pw(r){const e=r.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),n=e[e.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Wo(s)}function Dw(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function kw(r){const e=r.split(":"),t=e[e.length-1];return Wo(t)}function Rw(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function Ho(r){if(Tn(r))return Wo(r);if(Tw(r))return Pw(r);if(Dw(r))return kw(r);if(Ql(r))return Rw(r)}function Pn(r){try{const e=de(r);switch(e.type){case"ip4":case"ip6":return Ho(e.host)??!1;default:return e.host==="localhost"}}catch{return!1}}function Je(){const r={};return r.promise=new Promise((e,t)=>{r.resolve=e,r.reject=t}),r}class eu{constructor(e){l(this,"buffer");l(this,"mask");l(this,"top");l(this,"btm");l(this,"next");if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class Go{constructor(e={}){l(this,"size");l(this,"hwm");l(this,"head");l(this,"tail");this.hwm=e.splitLimit??16,this.head=new eu(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new eu(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let Mw=class extends Error{constructor(t,n){super(t??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function Os(r={}){return Nw(t=>{const n=t.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Nw(r,e){e=e??{};let t=e.onEnd,n=new Go,s,i,o,a=Je();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,S)=>{i=v=>{i=null,n.push(v);try{m(r(n))}catch(E){S(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=Je()})}},u=m=>i!=null?i(m):(n.push(m),s),d=m=>(n=new Go,i!=null?i({error:m}):(n.push({error:m}),s)),h=m=>{if(o)return s;if((e==null?void 0:e.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:m})},g=m=>o?s:(o=!0,m!=null?d(m):u({done:!0})),p=()=>(n=new Go,g(),{done:!0}),f=m=>(g(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:f,push:h,end:g,get readableLength(){return n.size},onEmpty:async m=>{const S=m==null?void 0:m.signal;if(S==null||S.throwIfAborted(),n.isEmpty())return;let v,E;S!=null&&(v=new Promise((T,L)=>{E=()=>{L(new Mw)},S.addEventListener("abort",E)}));try{await Promise.race([a.promise,v])}finally{E!=null&&S!=null&&(S==null||S.removeEventListener("abort",E))}}},t==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(m){return y.throw(m),t!=null&&(t(m),t=void 0),{done:!0}},return(){return y.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(m){return y.end(m),t!=null&&(t(m),t=void 0),s},get readableLength(){return y.readableLength},onEmpty:m=>y.onEmpty(m)},s}class tu extends Error{constructor(e){super(e),this.name="TimeoutError"}}let Ow=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const nu=r=>globalThis.DOMException===void 0?new Ow(r):new DOMException(r),ru=r=>{const e=r.reason===void 0?nu("This operation was aborted."):r.reason;return e instanceof Error?e:nu(e)};function su(r,e){const{milliseconds:t,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const u=new Promise((d,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:p}=e;p.aborted&&h(ru(p)),a=()=>{h(ru(p))},p.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){r.then(d,h);return}const g=new tu;o=i.setTimeout.call(void 0,()=>{if(n){try{d(n())}catch(p){h(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?d():s instanceof Error?h(s):(g.message=s??`Promise timed out after ${t} milliseconds`,h(g))},t),(async()=>{try{d(await r)}catch(p){h(p)}})()}).finally(()=>{u.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Bw=r=>{const e=r.addEventListener||r.on||r.addListener,t=r.removeEventListener||r.off||r.removeListener;if(!e||!t)throw new TypeError("Emitter is not compatible");return{addListener:e.bind(r),removeListener:t.bind(r)}};function Fw(r,e,t){let n;const s=new Promise((i,o)=>{var p;if(t={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...t},!(t.count>=0&&(t.count===Number.POSITIVE_INFINITY||Number.isInteger(t.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=t.signal)==null||p.throwIfAborted();const a=[e].flat(),c=[],{addListener:u,removeListener:d}=Bw(r),h=async(...f)=>{const y=t.multiArgs?f:f[0];if(t.filter)try{if(!await t.filter(y))return}catch(m){n(),o(m);return}c.push(y),t.count===c.length&&(n(),i(c))},g=(...f)=>{n(),o(t.rejectionMultiArgs?f:f[0])};n=()=>{for(const f of a)d(f,h);for(const f of t.rejectionEvents)a.includes(f)||d(f,g)};for(const f of a)u(f,h);for(const f of t.rejectionEvents)a.includes(f)||u(f,g);t.signal&&t.signal.addEventListener("abort",()=>{g(t.signal.reason)},{once:!0}),t.resolveImmediately&&i(c)});if(s.cancel=n,typeof t.timeout=="number"){const i=su(s,{milliseconds:t.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function Oe(r,e,t){typeof t=="function"&&(t={filter:t}),t={...t,count:1,resolveImmediately:!1};const n=Fw(r,e,t),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function Bs(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class $w extends Error{constructor(t="Rate limit exceeded",n){super(t);l(this,"remainingPoints");l(this,"msBeforeNext");l(this,"consumedPoints");l(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}let Uw=(Ga=class extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}},l(Ga,"name","QueueFullError"),Ga),Fs=(Ya=class extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError")}},l(Ya,"name","UnexpectedEOFError"),Ya);class iu extends Error{constructor(){super(...arguments);l(this,"name","MaxEarlyStreamsError")}}l(iu,"name","MaxEarlyStreamsError");class ou extends Error{constructor(){super(...arguments);l(this,"name","StreamClosedError")}}l(ou,"name","StreamClosedError");function zw(r){return r.reason}async function $s(r,e,t){if(e==null)return r;const n=zw;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}let Kw=class{constructor(e){l(this,"deferred");l(this,"signal");var t;this.signal=e,this.deferred=Je(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new ct)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}};function qw(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let Vw=class{constructor(e,t){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=qw(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var s;return t&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new ct),this.cleanup())}async join(e={}){var n;const t=new Kw(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await $s(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}},au=class extends ut{constructor(t={}){var n;super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"paused");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,t.metricName!=null&&((n=t.metrics)==null||n.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=t.sort,this.queue=[],this.emitEmpty=Bs(this.emitEmpty.bind(this),1),this.emitIdle=Bs(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Uw;const s=new Vw(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new ct)}),this.clear()}async onEmpty(t){this.size!==0&&await Oe(this,"empty",t)}async onSizeLessThan(t,n){this.size<t||await Oe(this,"next",{...n,filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Oe(this,"idle",t)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var u,d,h;(u=t==null?void 0:t.signal)==null||u.throwIfAborted();const n=Os({objectMode:!0}),s=g=>{g!=null?this.abort():this.clear(),n.end(g)},i=g=>{g.detail!=null&&n.push(g.detail)},o=g=>{s(g.detail.error)},a=()=>{s()},c=()=>{s(new ct("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),s()}}};const Ww=Math.pow(2,20)*4;class Yo extends ut{constructor(t){super();l(this,"status");l(this,"timeline");l(this,"inactivityTimeout");l(this,"maxReadBufferLength");l(this,"maxWriteBufferLength");l(this,"log");l(this,"direction");l(this,"maxMessageSize");l(this,"readStatus");l(this,"writeStatus");l(this,"remoteReadStatus");l(this,"remoteWriteStatus");l(this,"writableNeedsDrain");l(this,"readBuffer");l(this,"writeBuffer");l(this,"sendingData");l(this,"onDrainPromise");this.status="open",this.log=t.log,this.direction=t.direction??"outbound",this.inactivityTimeout=t.inactivityTimeout??12e4,this.maxReadBufferLength=t.maxReadBufferLength??Ww,this.maxWriteBufferLength=t.maxWriteBufferLength,this.maxMessageSize=t.maxMessageSize,this.readBuffer=new Y,this.writeBuffer=new Y,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new ou)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(t){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),$s(this.onDrainPromise.promise,t==null?void 0:t.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const t=Os(),n=o=>{t.push(o.data)};this.addEventListener("message",n);const s=o=>{t.end(o.error)};this.addEventListener("close",s);const i=()=>{t.end()};this.addEventListener("remoteCloseWrite",i);try{yield*t}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(t){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Ht(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",t.byteLength),this.writeBuffer.append(t),this.processSendQueue()}abort(t){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",t),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(t)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Wf(t))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Ht("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Ht("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Ht(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.append(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(t){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Ht(`Cannot push data onto a stream that is ${this.readStatus}`);if(t.byteLength!==0){if(this.readBuffer.prepend(t),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(t){if(t.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(t),this.dispatchReadBuffer()}}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const t=new $i;this.dispatchEvent(new Hf(t))}onTransportClosed(t){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),t!=null?this.abort(t):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new jr))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let t=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){t=!1;break}const o=this.writeBuffer.sublist(0,i),a=new Y(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(t=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!t)break}return t||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),t}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const t=this.readBuffer.sublist();this.readBuffer.consume(t.byteLength),this.dispatchEvent(new Vf(t))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new Ui(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new Ui(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Hw extends Yo{constructor(t){super(t);l(this,"remoteAddr");l(this,"metricPrefix");l(this,"metrics");this.metricPrefix=t.metricPrefix??"",this.metrics=t.metrics,this.remoteAddr=t.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(t){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Oe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Oe(this,"drain",{...t,rejectionEvents:["close"]})),await this.sendClose(t),this.onTransportClosed())}}function Gw(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class cu extends ut{constructor(t,n){super();l(this,"streams");l(this,"protocol");l(this,"status");l(this,"log");l(this,"maConn");l(this,"streamOptions");l(this,"earlyStreams");l(this,"maxEarlyStreams");l(this,"metrics");this.maConn=t,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=t.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(t){const n=this.maConn.send(t);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(t){this.status==="closed"||this.status==="closing"||(this.status="closing",await $s(Promise.all([...this.streams].map(async n=>{await n.close(t)})),t==null?void 0:t.signal),this.status="closed")}abort(t){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(t)}),this.status="closed")}onTransportClosed(t){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(t)})}catch(n){this.abort(n)}this.status="closed"}async createStream(t){if(this.status!=="open")throw new gn;let n=this.onCreateStream({...this.streamOptions,...t});return Gw(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(t){if(this.streams.push(t),this.cleanUpStream(t),this.listenerCount("stream")===0){this.earlyStreams.push(t),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new iu(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:t})}cleanUpStream(t){var s;const n=i=>{var a,c,u;const o=this.streams.findIndex(d=>d===t);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${t.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${t.direction}_stream_abort`]:!0}):(u=this.metrics)==null||u.increment({[`${t.direction}_stream_end`]:!0})};t.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${t.direction}_stream`]:!0})}addEventListener(...t){super.addEventListener.apply(this,t),t[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class lu extends Yo{constructor(t){super(t);l(this,"id");l(this,"protocol");this.id=t.id,this.protocol=t.protocol??""}async close(t){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Oe(this,"idle",{...t,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await Oe(this,"drain",{...t,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(t),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(t){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(t),this.readStatus="closed",this.log("closed readable end gracefully"))}}function Dn(r){const e=new globalThis.AbortController;function t(){e.abort();for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",t)}for(const i of r){if((i==null?void 0:i.aborted)===!0){t();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",t)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=n,s}class Xo{constructor(e){l(this,"movingAverage");l(this,"variance");l(this,"deviation");l(this,"forecast");l(this,"timeSpan");l(this,"previousTime");this.timeSpan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timeSpan)}push(e,t=Date.now()){if(this.previousTime!=null){const n=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=n*s;this.movingAverage=n*e+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=e;this.previousTime=t}}const Yw=1.2,Xw=2,Zw=5e3,Qw=6e4,jw=5e3;class Jw{constructor(e={}){l(this,"success");l(this,"failure");l(this,"next");l(this,"metric");l(this,"timeoutMultiplier");l(this,"failureMultiplier");l(this,"minTimeout");l(this,"maxTimeout");var n;const t=e.interval??jw;this.success=new Xo(t),this.failure=new Xo(t),this.next=new Xo(t),this.failureMultiplier=e.failureMultiplier??Xw,this.timeoutMultiplier=e.timeoutMultiplier??Yw,this.minTimeout=e.minTimeout??Zw,this.maxTimeout=e.maxTimeout??Qw,e.metricName!=null&&(this.metric=(n=e.metrics)==null?void 0:n.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){let t=Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier));t<this.minTimeout&&(t=this.minTimeout),t>this.maxTimeout&&(t=this.maxTimeout);const n=AbortSignal.timeout(t),s=Dn([e.signal,n]);return s.start=Date.now(),s.timeout=t,s}cleanUp(e){var n,s;const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}class Qe extends Error{constructor(){super(...arguments);l(this,"name","InvalidMultiaddrError")}}l(Qe,"name","InvalidMultiaddrError");class kn extends Error{constructor(){super(...arguments);l(this,"name","ValidationError")}}l(kn,"name","ValidationError");class uu extends Error{constructor(){super(...arguments);l(this,"name","InvalidParametersError")}}l(uu,"name","InvalidParametersError");class du extends Error{constructor(){super(...arguments);l(this,"name","UnknownProtocolError")}}l(du,"name","UnknownProtocolError");const Us=4,Rn=6,hu=273,eb=33,Mn=41,Zo=42,Qo=43,fu=53,gu=54,mu=55,pu=56,tb=132,nb=301,rb=302,yu=400,W=421,sb=444,ib=445,ob=446,ab=447,Nn=448,zs=449,cb=454,wu=460,bu=461,Eu=465,Ir=466,On=480,lb=481,jo=443,Jo=477,vu=478,ub=479,db=277,hb=275,fb=276,Su=280,Lr=281,Ks=290,xu=777;function Au(r){return e=>Q(e,r)}function _u(r){return e=>H(e,r)}function Tr(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Bn(r){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(e)}function gb(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=H(e[0],"base32"),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Bn(n);return It([t,s],t.length+s.length)}function mb(r){const e=r.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Ct.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Bn(n);return It([t,s],t.length+s.length)}function Cu(r){const e=r.subarray(0,r.length-2),t=r.subarray(r.length-2),n=Q(e,"base32"),s=Tr(t);return`${n}:${s}`}const Iu=function(r){r=r.toString().trim();const e=new Uint8Array(4);return r.split(/\./g).forEach((t,n)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new Qe("Invalid byte value in IP address");e[n]=s}),e},pb=function(r){let e=0;r=r.toString().trim();const t=r.split(":",8);let n;for(n=0;n<t.length;n++){const i=Tn(t[n]);let o;i&&(o=Iu(t[n]),t[n]=Q(o.subarray(0,2),"base16")),o!=null&&++n<8&&t.splice(n,0,Q(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(n=0;n<t.length&&t[n]!=="";n++);const i=[n,1];for(n=9-t.length;n>0;n--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(n=0;n<t.length;n++){t[n]===""&&(t[n]="0");const i=parseInt(t[n],16);if(isNaN(i)||i<0||i>65535)throw new Qe("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},yb=function(r){if(r.byteLength!==4)throw new Qe("IPv4 address was incorrect length");const e=[];for(let t=0;t<r.byteLength;t++)e.push(r[t]);return e.join(".")},wb=function(r){if(r.byteLength!==16)throw new Qe("IPv6 address was incorrect length");const e=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const n=new URL(`http://[${t}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new Qe(`Invalid IPv6 address "${t}"`)}};function bb(r){try{const e=new URL(`http://[${r}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new Qe(`Invalid IPv6 address "${r}"`)}}const ea=Object.values(ji).map(r=>r.decoder),Eb=function(){let r=ea[0].or(ea[1]);return ea.slice(2).forEach(e=>r=r.or(e)),r}();function vb(r){return Eb.decode(r)}function Sb(r){return e=>r.encoder.encode(e)}function xb(r){if(parseInt(r).toString()!==r)throw new kn("Value must be an integer")}function Ab(r){if(r<0)throw new kn("Value must be a positive integer, or zero")}function _b(r){return e=>{if(e>r)throw new kn(`Value must be smaller than or equal to ${r}`)}}function Cb(...r){return e=>{for(const t of r)t(e)}}const qs=Cb(xb,Ab,_b(65535)),Be=-1;class Ib{constructor(){l(this,"protocolsByCode",new Map);l(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new du(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(n=>{this.protocolsByName.set(n,e)})}removeProtocol(e){var n;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(n=t.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const Fn=new Ib;[{code:Us,name:"ip4",size:32,valueToBytes:Iu,bytesToValue:yb,validate:r=>{if(!Tn(r))throw new kn(`Invalid IPv4 address "${r}"`)}},{code:Rn,name:"tcp",size:16,valueToBytes:Bn,bytesToValue:Tr,validate:qs},{code:hu,name:"udp",size:16,valueToBytes:Bn,bytesToValue:Tr,validate:qs},{code:eb,name:"dccp",size:16,valueToBytes:Bn,bytesToValue:Tr,validate:qs},{code:Mn,name:"ip6",size:128,valueToBytes:pb,bytesToValue:wb,stringToValue:bb,validate:r=>{if(!Ql(r))throw new kn(`Invalid IPv6 address "${r}"`)}},{code:Zo,name:"ip6zone",size:Be},{code:Qo,name:"ipcidr",size:8,bytesToValue:Au("base10"),valueToBytes:_u("base10")},{code:fu,name:"dns",size:Be},{code:gu,name:"dns4",size:Be},{code:mu,name:"dns6",size:Be},{code:pu,name:"dnsaddr",size:Be},{code:tb,name:"sctp",size:16,valueToBytes:Bn,bytesToValue:Tr,validate:qs},{code:nb,name:"udt"},{code:rb,name:"utp"},{code:yu,name:"unix",size:Be,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:W,name:"p2p",aliases:["ipfs"],size:Be,bytesToValue:Au("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?_u("base58btc")(r):ue.parse(r).multihash.bytes},{code:sb,name:"onion",size:96,bytesToValue:Cu,valueToBytes:gb},{code:ib,name:"onion3",size:296,bytesToValue:Cu,valueToBytes:mb},{code:ob,name:"garlic64",size:Be},{code:ab,name:"garlic32",size:Be},{code:Nn,name:"tls"},{code:zs,name:"sni",size:Be},{code:cb,name:"noise"},{code:wu,name:"quic"},{code:bu,name:"quic-v1"},{code:Eu,name:"webtransport"},{code:Ir,name:"certhash",size:Be,bytesToValue:Sb(Sc),valueToBytes:vb},{code:On,name:"http"},{code:lb,name:"http-path",size:Be,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:jo,name:"https"},{code:Jo,name:"ws"},{code:vu,name:"wss"},{code:ub,name:"p2p-websocket-star"},{code:db,name:"p2p-stardust"},{code:hb,name:"p2p-webrtc-star"},{code:fb,name:"p2p-webrtc-direct"},{code:Su,name:"webrtc-direct"},{code:Lr,name:"webrtc"},{code:Ks,name:"p2p-circuit"},{code:xu,name:"memory",size:Be}].forEach(r=>{Fn.addProtocol(r)});function Lb(r){var n;const e=[];let t=0;for(;t<r.length;){const s=pr(r,t),i=Fn.getProtocol(s),o=Le(s),a=kb(i,r,t+o);let c=0;a>0&&i.size===Be&&(c=Le(a));const u=o+c+a,d={code:s,name:i.name,bytes:r.subarray(t,t+u)};if(a>0){const h=t+o+c,g=r.subarray(h,h+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,g))??Q(g)}e.push(d),t+=u}return e}function Tb(r){var n;let e=0;const t=[];for(const s of r){if(s.bytes==null){const i=Fn.getProtocol(s.code),o=Le(s.code);let a,c=0,u=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??H(s.value),c=a.byteLength,i.size===Be&&(u=Le(c)));const d=new Uint8Array(o+u+c);let h=0;Cs(s.code,d,h),h+=o,a!=null&&(i.size===Be&&(Cs(c,d,h),h+=u),d.set(a,h)),s.bytes=d}t.push(s.bytes),e+=s.bytes.byteLength}return It(t,e)}function Pb(r){var i;if(r.charAt(0)!=="/")throw new Qe('String multiaddr must start with "/"');const e=[];let t="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(t==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const u=Fn.getProtocol(s);if(t==="protocol"){if(u.size==null||u.size===0){e.push({code:u.code,name:u.name}),n="",s="",t="protocol";continue}else if(c)throw new Qe(`Component ${s} was missing value`);t="value"}else if(t==="value"){const d={code:u.code,name:u.name};if(u.size!=null&&u.size!==0){if(n==="")throw new Qe(`Component ${s} was missing value`);d.value=((i=u.stringToValue)==null?void 0:i.call(u,n))??n}e.push(d),n="",s="",t="protocol"}}}if(s!==""&&n!=="")throw new Qe("Incomplete multiaddr");return e}function Db(r){return`/${r.flatMap(e=>{var n;if(e.value==null)return e.name;const t=Fn.getProtocol(e.code);if(t==null)throw new Qe(`Unknown protocol code ${e.code}`);return[e.name,((n=t.valueToString)==null?void 0:n.call(t,e.value))??e.value]}).join("/")}`}function kb(r,e,t){return r.size==null||r.size===0?0:r.size>0?r.size/8:pr(e,t)}const Rb=Symbol.for("nodejs.util.inspect.custom"),Lu=Symbol.for("@multiformats/multiaddr");function Mb(r){if(r==null&&(r="/"),Vs(r))return r.getComponents();if(r instanceof Uint8Array)return Lb(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),Pb(r);if(Array.isArray(r))return r;throw new Qe("Must be a string, Uint8Array, Component[], or another Multiaddr")}const Wn=class Wn{constructor(e="/",t={}){l(this,rf,!0);ge(this,at);ge(this,qn);ge(this,Vn);me(this,at,Mb(e)),t.validate!==!1&&Nb(this)}get bytes(){return $(this,Vn)==null&&me(this,Vn,Tb($(this,at))),$(this,Vn)}toString(){return $(this,qn)==null&&me(this,qn,Db($(this,at))),$(this,qn)}toJSON(){return this.toString()}getComponents(){return[...$(this,at).map(e=>({...e}))]}encapsulate(e){const t=new Wn(e);return new Wn([...$(this,at),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),n=this.toString(),s=n.lastIndexOf(t);if(s<0)throw new uu(`Address ${this.toString()} does not contain subaddress: ${t}`);return new Wn(n.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let n=$(this,at).length-1;n>-1;n--)if($(this,at)[n].code===e){t=n;break}return new Wn($(this,at).slice(0,t),{validate:!1})}equals(e){return Fe(this.bytes,e.bytes)}[(rf=Lu,Rb)](){return`Multiaddr(${this.toString()})`}};at=new WeakMap,qn=new WeakMap,Vn=new WeakMap;let ta=Wn;function Nb(r){r.getComponents().forEach(e=>{var n;const t=Fn.getProtocol(e.code);e.value!=null&&((n=t.validate)==null||n.call(t,e.value))})}function Vs(r){return!!(r!=null&&r[Lu])}function ce(r){return new ta(r)}let Tu=class extends Error{constructor(t,n,s){super(t??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function Pu(r,e,t){if(e==null)return r;if(e.aborted)return r.catch(()=>{}),Promise.reject(new Tu(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let n;const s=new Tu(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},e.addEventListener("abort",n)})])}finally{n!=null&&e.removeEventListener("abort",n)}}class Ob{constructor(){l(this,"readNext");l(this,"haveNext");l(this,"ended");l(this,"nextResult");l(this,"error");this.ended=!1,this.readNext=Je(),this.haveNext=Je()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=Je(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=Je(),await Pu(this.readNext.promise,t==null?void 0:t.signal,t)}}function Bb(){return new Ob}function Fb(r){return r[Symbol.asyncIterator]!=null}async function $b(r,e,t){try{await Promise.all(r.map(async n=>{for await(const s of n)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(n){await e.end(n,{signal:t}).catch(()=>{})}}async function*Ub(r){const e=new AbortController,t=Bb();$b(r,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*zb(r){for(const e of r)yield*e}function na(...r){const e=[];for(const t of r)Fb(t)||e.push(t);return e.length===r.length?zb(e):Ub(r)}const Kb=4194304;class ra extends Error{constructor(){super(...arguments);l(this,"name","UnwrappedError")}}l(ra,"name","UnwrappedError");let Du=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}},qb=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}},Vb=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function Wb(r){return typeof(r==null?void 0:r.closeRead)=="function"}function Hb(r){return typeof(r==null?void 0:r.close)=="function"}function sa(r){return Wb(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:Hb(r)?r.status!=="open":!1}function Gb(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function ku(r,e){const t=(e==null?void 0:e.maxBufferSize)??Kb,n=new Y;let s,i=!1;if(!Gb(r))throw new V("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>t){const h=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${h} > ${t}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const u={readBuffer:n,async read(d){if(i===!0)throw new ra("Stream was unwrapped");if(sa(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new Fs(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await $s(s.promise,d==null?void 0:d.signal),sa(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const g=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<g){if(sa(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,g),new Fs(`Unexpected EOF - stream closed while reading ${n.byteLength}/${g} bytes`);return u.read(d)}const p=n.sublist(0,g);return n.consume(g),p},async write(d,h){if(i===!0)throw new ra("Stream was unwrapped");r.send(d)||await Oe(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function Pr(r,e={}){const t=ku(r,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=Le(e.maxDataLength));const n=(e==null?void 0:e.lengthDecoder)??pr,s=(e==null?void 0:e.lengthEncoder)??mr;return{async read(o){let a=-1;const c=new Y;for(;;){const d=await t.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new Du("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new Vb(`Message length length too long - ${c.byteLength} > ${e.maxLengthLength}`);if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new qb(`Message length too long - ${a} > ${e.maxDataLength}`);const u=await t.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new Fs(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new Fs(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await t.write(new Y(s(o.byteLength),o),a)},async writeV(o,a){const c=new Y(...o.flatMap(u=>[s(u.byteLength),u]));await t.write(c,a)},unwrap(){return t.unwrap()}}}function Ws(r,e){const t=Pr(r,e),n={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>t.unwrap()};return n}const Yb=1024*1024*4,Xb=1024*1024*4;class Zb{constructor(e={}){l(this,"buffer");l(this,"maxBufferSize");l(this,"lengthDecoder");l(this,"maxDataLength");l(this,"encodingLength");this.buffer=new Y,this.maxBufferSize=e.maxBufferSize??Yb,this.maxDataLength=e.maxDataLength??Xb,this.lengthDecoder=e.lengthDecoder??pr,this.encodingLength=e.encodingLength??Le}*decode(e){if(this.buffer.append(e),this.buffer.byteLength>this.maxBufferSize)throw new V(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let t;try{t=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(t<0||t>this.maxDataLength)throw new Du("Invalid message length");const n=this.encodingLength(t),s=n+t;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const Qb=8,ia=1024*1024*4;class jb extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}}class Ru extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}}class Jb extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class Mu extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError");l(this,"code","ERR_UNEXPECTED_EOF")}}function Nu(r){return r[Symbol.asyncIterator]!=null}function Ou(r,e){if(r.byteLength>e)throw new Ru("Message length too long")}const Hs=r=>{const e=Le(r),t=dt(e);return mr(r,t),Hs.bytes=e,t};Hs.bytes=0;function Gs(r,e){e=e??{};const t=e.lengthEncoder??Hs,n=(e==null?void 0:e.maxDataLength)??ia;function*s(i){Ou(i,n);const o=t(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Nu(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}Gs.single=(r,e)=>{e=e??{};const t=e.lengthEncoder??Hs,n=(e==null?void 0:e.maxDataLength)??ia;return Ou(r,n),new Y(t(r.byteLength),r)};var on;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(on||(on={}));const oa=r=>{const e=pr(r);return oa.bytes=Le(e),e};oa.bytes=0;function aa(r,e){const t=new Y;let n=on.LENGTH,s=-1;const i=(e==null?void 0:e.lengthDecoder)??oa,o=(e==null?void 0:e.maxLengthLength)??Qb,a=(e==null?void 0:e.maxDataLength)??ia;function*c(){for(;t.byteLength>0;){if(n===on.LENGTH)try{if(s=i(t),s<0)throw new jb("Invalid message length");if(s>a)throw new Ru("Message length too long");const u=i.bytes;t.consume(u),(e==null?void 0:e.onLength)!=null&&e.onLength(s),n=on.DATA}catch(u){if(u instanceof RangeError){if(t.byteLength>o)throw new Jb("Message length length too long");break}throw u}if(n===on.DATA){if(t.byteLength<s)break;const u=t.sublist(0,s);t.consume(s),(e==null?void 0:e.onData)!=null&&e.onData(u),yield u,n=on.LENGTH}}}return Nu(r)?async function*(){for await(const u of r)t.append(u),yield*c();if(t.byteLength>0)throw new Mu("Unexpected end of input")}():function*(){for(const u of r)t.append(u),yield*c();if(t.byteLength>0)throw new Mu("Unexpected end of input")}()}aa.fromReader=(r,e)=>{let t=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return aa(n,{...e??{},onLength:i=>{t=i}})};class e0 extends au{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}let t0=class extends au{constructor(e={}){super({...e,sort:(t,n)=>t.options.priority>n.options.priority?-1:t.options.priority<n.options.priority?1:0})}};class n0{constructor(e={}){l(this,"memoryStorage");l(this,"points");l(this,"duration");l(this,"blockDuration");l(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new r0}consume(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new $w("Rate limit exceeded",o);return o}penalty(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,n={}){const s=this.getKey(e),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const n=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(e,t,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return(e==null?void 0:e.customDuration)!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class r0{constructor(){l(this,"storage");this.storage=new Map}incrby(e,t,n){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,n)}return this.set(e,t,n)}set(e,t,n){const s=n*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function s0(r,e,t){let n,s,i=!1;function o(){const u={signal:s.signal};if((t==null?void 0:t.timeout)!=null){const d=Dn([s.signal,AbortSignal.timeout(t.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,e))})}const a=Bs(o,(t==null?void 0:t.debounce)??100);let c=!1;return{setInterval:u=>{e!==u&&(e=u,n!=null&&(clearTimeout(n),n=setTimeout(o,e)))},setTimeout:u=>{t??(t={}),t.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(t==null?void 0:t.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,e))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class i0 extends Map{constructor(t){super();l(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Et(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new i0({name:e,metrics:t}):n=new Map,n}class o0 extends Ar{constructor(t){super();l(this,"metric");const{name:n,metrics:s}=t;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(t,n){return super.set(t,n),this.updateComponentMetric(),this}delete(t){const n=super.delete(t);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function a0(r){const{name:e,metrics:t}=r;let n;return t!=null?n=new o0({name:e,metrics:t}):n=new Ar,n}var Ys;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(n.uint32(10),n.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(n.uint32(18),n.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(n.uint32(26),n.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(n.uint32(42),n.bytes(t.signature)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={publicKey:ye(0),payloadType:ye(0),payload:ye(0),signature:ye(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.publicKey=t.bytes();break}case 2:{i.payloadType=t.bytes();break}case 3:{i.payload=t.bytes();break}case 5:{i.signature=t.bytes();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Ys||(Ys={}));class c0 extends Error{constructor(e="Invalid signature"){super(e),this.name="InvalidSignatureError"}}const Vt=class Vt{constructor(e){l(this,"publicKey");l(this,"payloadType");l(this,"payload");l(this,"signature");l(this,"marshaled");const{publicKey:t,payloadType:n,payload:s,signature:i}=e;this.publicKey=t,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=Ys.encode({publicKey:bt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return e==null?!1:Fe(this.marshal(),e.marshal())}async validate(e,t){const n=Bu(e,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,t)}};l(Vt,"createFromProtobuf",e=>{const t=Ys.decode(e),n=Ot(t.publicKey);return new Vt({publicKey:n,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),l(Vt,"seal",async(e,t,n)=>{if(t==null)throw new Error("Missing private key");const s=e.domain,i=e.codec,o=e.marshal(),a=Bu(s,i,o),c=await t.sign(a.subarray(),n);return new Vt({publicKey:t.publicKey,payloadType:i,payload:o,signature:c})}),l(Vt,"openAndCertify",async(e,t,n)=>{const s=Vt.createFromProtobuf(e);if(!await s.validate(t,n))throw new c0("Envelope signature is not valid for the given domain");return s});let an=Vt;const Bu=(r,e,t)=>{const n=H(r),s=mr(n.byteLength),i=mr(e.length),o=mr(t.length);return new Y(s,n,i,e,o,t)},l0="libp2p-peer-record",u0=Uint8Array.from([3,1]);var Xs;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=ze((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ye(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),t.encode=s=>Ue(s,t.codec()),t.decode=(s,i)=>$e(s,t.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(n.uint32(10),n.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(n.uint32(16),n.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c;const i={peerId:ye(0),seq:0n,addresses:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const u=t.uint32();switch(u>>>3){case 1:{i.peerId=t.bytes();break}case 2:{i.seq=t.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new tn('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(t,t.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{t.skipType(u&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Xs||(Xs={}));function d0(r,e){const t=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==e.length?!1:(e.sort(t),r.sort(t).every((n,s)=>e[s].equals(n)))}const At=class At{constructor(e){l(this,"peerId");l(this,"multiaddrs");l(this,"seqNumber");l(this,"domain",At.DOMAIN);l(this,"codec",At.CODEC);l(this,"marshaled");const{peerId:t,multiaddrs:n,seqNumber:s}=e;this.peerId=t,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=Xs.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof At)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!d0(this.multiaddrs,e.multiaddrs))}};l(At,"createFromProtobuf",e=>{const t=Xs.decode(e),n=Rs(as(t.peerId)),s=(t.addresses??[]).map(o=>ce(o.multiaddr)),i=t.seq;return new At({peerId:n,multiaddrs:s,seqNumber:i})}),l(At,"DOMAIN",l0),l(At,"CODEC",u0);let vt=At;function h0(r){return r[Symbol.asyncIterator]!=null}function ca(r){if(h0(r))return(async()=>{const t=[];for await(const n of r)t.push(n);return t})();const e=[];for(const t of r)e.push(t);return e}let $n=(Xa=class extends Error{constructor(t="The operation was aborted",...n){super(t,...n);l(this,"name","AbortError")}},l(Xa,"name","AbortError"),Xa);async function la(r,e,t,n){const s=new $n(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(t==null?void 0:t.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){da(t,"abort",h),da(r,e,u),da(r,i,d)}const u=g=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,g))===!1)return}catch(f){c(),a(f);return}c(),o(g)},d=g=>{if(c(),g instanceof Error){a(g);return}a(g.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};ua(t,"abort",h),ua(r,e,u),ua(r,i,d)})}function ua(r,e,t){r!=null&&(Fu(r)?r.addEventListener(e,t):r.addListener(e,t))}function da(r,e,t){r!=null&&(Fu(r)?r.removeEventListener(e,t):r.removeListener(e,t))}function Fu(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class $u extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}l($u,"name","QueueFullError");class f0{constructor(e){l(this,"deferred");l(this,"signal");var t;this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new $n)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}}function g0(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class m0{constructor(e,t){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=g0(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,n)=>{var s;return t&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new $n),this.cleanup())}async join(e={}){var n;const t=new f0(e.signal);return this.recipients.push(t),(n=e.signal)==null||n.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Pu(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}}function Uu(r,e){let t;const n=function(){const s=function(){t=void 0,r()};clearTimeout(t),t=setTimeout(s,e)};return n.start=()=>{},n.stop=()=>{clearTimeout(t)},n}class zu extends ut{constructor(t={}){super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=Uu(this.emitEmpty.bind(this),1),this.emitIdle=Uu(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const n of this.queue)if(n.status==="queued"){t=n;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===t){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new $u;const s=new m0(t,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new $n)}),this.clear()}async onEmpty(t){this.size!==0&&await la(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,n){this.size<t||await la(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await la(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var u,d,h;(u=t==null?void 0:t.signal)==null||u.throwIfAborted();const n=Os({objectMode:!0}),s=g=>{g!=null?this.abort():this.clear(),n.end(g)},i=g=>{g.detail!=null&&n.push(g.detail.result)},o=g=>{s(g.detail.error)},a=()=>{s()},c=()=>{s(new $n("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=t==null?void 0:t.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),s()}}}const Ku="lock:worker:request-read",qu="lock:worker:abort-read-request",Vu="lock:worker:release-read",Wu="lock:master:grant-read",Hu="lock:master:error-read",Gu="lock:worker:request-write",Yu="lock:worker:abort-write-request",Xu="lock:worker:release-write",Zu="lock:master:grant-write",Qu="lock:master:error-write",ju="lock:worker:finalize",Ju="mortice",p0={singleProcess:!1},ed=(r,e,t,n,s,i,o,a,c)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(t,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{e.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(h=>{const g=p=>{if((p==null?void 0:p.data)==null)return;const f={type:p.data.type,name:p.data.name,identifier:p.data.identifier};f.type===a&&f.identifier===d.identifier&&(e.removeEventListener("message",g),h())};e.addEventListener("message",g)})},onError:h=>{e.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===ju&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},y0=(r=10)=>Math.random().toString().substring(2,r+2);class w0{constructor(e){l(this,"name");l(this,"channel");this.name=e,this.channel=new BroadcastChannel(Ju)}readLock(e){return this.sendRequest(Ku,qu,Wu,Hu,Vu,e)}writeLock(e){return this.sendRequest(Gu,Yu,Zu,Qu,Xu,e)}finalize(){this.channel.postMessage({type:ju,name:this.name}),this.channel.close()}async sendRequest(e,t,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=y0();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((u,d)=>{var p;const h=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",h,{once:!0});const g=f=>{var y,m,S,v;if(((y=f.data)==null?void 0:y.identifier)===a&&(((m=f.data)==null?void 0:m.type)===n&&(this.channel.removeEventListener("message",g),(S=o==null?void 0:o.signal)==null||S.removeEventListener("abort",h),u(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),f.data.type===s)){this.channel.removeEventListener("message",g),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const E=new Error;f.data.error!=null&&(E.message=f.data.error.message,E.name=f.data.error.name,E.stack=f.data.error.stack),d(E)}};this.channel.addEventListener("message",g)})}}const b0=r=>{if(r=Object.assign({},p0,r),!!globalThis.document||r.singleProcess){const t=new BroadcastChannel(Ju),n=new ut;return t.addEventListener("message",ed(n,t,"requestReadLock","abortReadLockRequest",Ku,qu,Hu,Vu,Wu)),t.addEventListener("message",ed(n,t,"requestWriteLock","abortWriteLockRequest",Gu,Yu,Qu,Xu,Zu)),n}return new w0(r.name)},cn=new Map;let Dr;function td(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function E0(r){if(Dr==null&&(Dr=b0(r),!td(Dr))){const e=Dr;e.addEventListener("requestReadLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=cn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const n=t.detail.name,s=t.detail.identifier,i=cn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const n=t.detail.name,s=cn.get(n);s!=null&&s.finalize()})}return Dr}async function ha(r,e){var o;let t,n;const s=new Promise((a,c)=>{t=a,n=c}),i=()=>{n(new $n)};return(o=e==null?void 0:e.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{t(()=>{var c;(c=e==null?void 0:e.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:e==null?void 0:e.signal}).catch(a=>{n(a)}),s}const v0=(r,e)=>{let t=cn.get(r);if(t!=null)return t;const n=E0(e);if(td(n))return t=n,cn.set(r,t),t;const s=new zu({concurrency:1});let i;return t={async readLock(o){if(i!=null)return ha(i,o);i=new zu({concurrency:e.concurrency,autoStart:!1});const a=i,c=ha(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,ha(s,o)},finalize:()=>{cn.delete(r)},queue:s},cn.set(r,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},S0={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function x0(r){const e=Object.assign({},S0,r);return v0(e.name,e)}const A0=36e5,_0=216e5;var ln;(function(r){(function(t){let n;t.codec=()=>(n==null&&(n=ze((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ye(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),t.encode=s=>Ue(s,t.codec()),t.decode=(s,i)=>$e(s,t.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(t){let n;t.codec=()=>(n==null&&(n=ze((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),Qs.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var u;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=Qs.codec().decode(s,s.uint32(),{limits:(u=o.limits)==null?void 0:u.value});break}default:{s.skipType(d&7);break}}}return a})),n),t.encode=s=>Ue(s,t.codec()),t.decode=(s,i)=>$e(s,t.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.addresses!=null)for(const i of t.addresses)n.uint32(10),Zs.codec().encode(i,n);if(t.protocols!=null)for(const i of t.protocols)n.uint32(18),n.string(i);if(t.publicKey!=null&&(n.uint32(34),n.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);t.updated!=null&&(n.uint32(64),n.uint64Number(t.updated)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c,u,d,h,g;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const p=t.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new tn('Decode error - map field "addresses" had too many elements');i.addresses.push(Zs.codec().decode(t,t.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((u=s.limits)==null?void 0:u.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new tn('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 4:{i.publicKey=t.bytes();break}case 5:{i.peerRecordEnvelope=t.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new El('Decode error - map field "metadata" had too many elements');const f=r.Peer$metadataEntry.codec().decode(t,t.uint32());i.metadata.set(f.key,f.value);break}case 7:{if(((h=s.limits)==null?void 0:h.tags)!=null&&i.tags.size===s.limits.tags)throw new El('Decode error - map field "tags" had too many elements');const f=r.Peer$tagsEntry.codec().decode(t,t.uint32(),{limits:{value:(g=s.limits)==null?void 0:g.tags$value}});i.tags.set(f.key,f.value);break}case 8:{i.updated=t.uint64Number();break}default:{t.skipType(p&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(ln||(ln={}));var Zs;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(t.multiaddr)),t.isCertified!=null&&(n.uint32(16),n.bool(t.isCertified)),t.observed!=null&&(n.uint32(24),n.uint64Number(t.observed)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={multiaddr:ye(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.multiaddr=t.bytes();break}case 2:{i.isCertified=t.bool();break}case 3:{i.observed=t.uint64Number();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Zs||(Zs={}));var Qs;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.value!=null&&t.value!==0&&(n.uint32(8),n.uint32(t.value)),t.expiry!=null&&(n.uint32(16),n.uint64(t.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{const i={value:0},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const a=t.uint32();switch(a>>>3){case 1:{i.value=t.uint32();break}case 2:{i.expiry=t.uint64();break}default:{t.skipType(a&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Qs||(Qs={}));function C0(r,e){if(r.publicKey!=null||e.publicKey==null)return r;let t;r.type==="RSA"&&(t=r.toMultihash());const n=Ot(e.publicKey,t);return br(n)}function I0(r,e,t){const n=ln.decode(e);return kr(r,n,t)}function kr(r,e,t){const n=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...e,id:C0(r,e),addresses:e.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-t).map(({multiaddr:i,isCertified:o})=>({multiaddr:ce(i),isCertified:o??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:n}}function L0(r,e){return T0(r.addresses,e.addresses)&&P0(r.protocols,e.protocols)&&D0(r.publicKey,e.publicKey)&&k0(r.peerRecordEnvelope,e.peerRecordEnvelope)&&R0(r.metadata,e.metadata)&&M0(r.tags,e.tags)}function T0(r,e){return rd(r,e,(t,n)=>!(t.isCertified!==n.isCertified||!Fe(t.multiaddr,n.multiaddr)))}function P0(r,e){return rd(r,e,(t,n)=>t===n)}function D0(r,e){return nd(r,e)}function k0(r,e){return nd(r,e)}function R0(r,e){return sd(r,e,(t,n)=>Fe(t,n))}function M0(r,e){return sd(r,e,(t,n)=>t.value===n.value&&t.expiry===n.expiry)}function nd(r,e){return r==null&&e==null?!0:r!=null&&e!=null?Fe(r,e):!1}function rd(r,e,t){if(r.length!==e.length)return!1;for(let n=0;n<r.length;n++)if(!t(r[n],e[n]))return!1;return!0}function sd(r,e,t){if(r.size!==e.size)return!1;for(const[n,s]of r.entries()){const i=e.get(n);if(i==null||!t(s,i))return!1}return!0}const St="/",id=new TextEncoder().encode(St),js=id[0];class Ke{constructor(e,t){l(this,"_buf");if(typeof e=="string")this._buf=H(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==js)throw new Error("Invalid key")}toString(e="utf8"){return Q(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Ke(e.join(St))}static random(){return new Ke(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Ke(e):typeof e.uint8Array=="function"?new Ke(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=id),this._buf[0]!==js){const e=new Uint8Array(this._buf.byteLength+1);e.fill(js,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===js;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let s=0;s<t.length;s++){if(n.length<s+1)return!1;const i=t[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return t.length<n.length}reverse(){return Ke.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(St).slice(1)}type(){return N0(this.baseNamespace())}name(){return O0(this.baseNamespace())}instance(e){return new Ke(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(St)||(e+=St),e+=this.type(),new Ke(e)}parent(){const e=this.list();return e.length===1?new Ke(St):new Ke(e.slice(0,-1).join(St))}child(e){return this.toString()===St?e:e.toString()===St?this:new Ke(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Ke.withNamespaces([...this.namespaces(),...B0(e.map(t=>t.namespaces()))])}}function N0(r){const e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function O0(r){const e=r.split(":");return e[e.length-1]}function B0(r){return[].concat(...r)}const od="/peers/";function Js(r){if(!er(r)||r.type==null)throw new V("Invalid PeerId");const e=r.toCID().toString();return new Ke(`${od}${e}`)}async function F0(r,e,t,n,s){const i=new Map;for(const o of t){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=ce(o.multiaddr)),!Vs(o.multiaddr))throw new V("Multiaddr was invalid");if(!await e(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var u;const c=(u=a.getComponents().find(d=>d.code===W))==null?void 0:u.value;return r.equals(c)&&(a=a.decapsulate(ce(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function fa(r,e,t,n){var g,p;if(e==null)throw new V("Invalid PeerData");if(e.publicKey!=null&&r.publicKey!=null&&!e.publicKey.equals(r.publicKey))throw new V("publicKey bytes do not match peer id publicKey bytes");const s=(g=n.existingPeer)==null?void 0:g.peer;if(s!=null&&!r.equals(s.id))throw new V("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,u=s==null?void 0:s.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=ei(f,{validate:ad})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=ei(f,{validate:cd,map:ld})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(f=>({isCertified:!1,multiaddr:f}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const f=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[y,m]of f)m==null?a.delete(y):a.set(y,m);a=ei([...a.entries()],{validate:ad})}if(e.tags!=null){const f=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),y=new Map(c);for(const[m,S]of f)S==null?y.delete(m):y.set(m,S);c=ei([...y.entries()],{validate:cd,map:ld})}e.peerRecordEnvelope!=null&&(u=e.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=bt(s.id.publicKey):e.publicKey!=null?d=bt(e.publicKey):r.publicKey!=null&&(d=bt(r.publicKey));const h={addresses:await F0(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((f,y)=>f.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(f=>{var y,m,S;f.observed=((S=(m=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:m.find(v=>Fe(v.multiaddr,v.multiaddr)))==null?void 0:S.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function ei(r,e){var n;const t=new Map;for(const[s,i]of r)i!=null&&e.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&t.set(s,((n=e.map)==null?void 0:n.call(e,s,i))??i);return t}function ad(r,e){if(typeof r!="string")throw new V("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new V("Metadata value must be a Uint8Array")}function cd(r,e){if(typeof r!="string")throw new V("Tag name must be a string");if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new V("Tag value must be an integer");if(e.value<0||e.value>100)throw new V("Tag value must be between 0-100")}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new V("Tag ttl must be an integer");if(e.ttl<0)throw new V("Tag ttl must be between greater than 0")}}function ld(r,e){let t;e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl)));const n={value:e.value??0};return t!=null&&(n.expiry=t),n}function ud(r){const e=r.toString().split("/")[2],t=ue.parse(e,Ct);return Er(t)}function ga(r,e,t){const n=ud(r);return I0(n,e,t)}function $0(r,e){return{prefix:od,filters:(r.filters??[]).map(t=>({key:n,value:s})=>t(ga(n,s,e))),orders:(r.orders??[]).map(t=>(n,s)=>t(ga(n.key,n.value,e),ga(s.key,s.value,e)))}}class U0{constructor(e,t={}){ge(this,Xe);l(this,"peerId");l(this,"datastore");l(this,"locks");l(this,"addressFilter");l(this,"log");l(this,"maxAddressAge");l(this,"maxPeerAge");this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.locks=a0({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=t.maxAddressAge??A0,this.maxPeerAge=t.maxPeerAge??_0}getLock(e){let t=this.locks.get(e);return t==null&&(t={refs:0,lock:x0({name:e.toString(),singleProcess:!0})},this.locks.set(e,t)),t.refs++,t}maybeRemoveLock(e,t){t.refs--,t.refs===0&&(t.lock.finalize(),this.locks.delete(e))}async getReadLock(e,t){const n=this.getLock(e);try{const s=await n.lock.readLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async getWriteLock(e,t){const n=this.getLock(e);try{const s=await n.lock.writeLock(t);return()=>{s(),this.maybeRemoveLock(e,n)}}catch(s){throw this.maybeRemoveLock(e,n),s}}async has(e,t){try{return await this.load(e,t),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(e,t){this.peerId.equals(e)||await this.datastore.delete(Js(e),t)}async load(e,t){const n=Js(e),s=await this.datastore.get(n,t),i=ln.decode(s);if(ne(this,Xe,Ri).call(this,e,i))throw await this.datastore.delete(n,t),new zi;return kr(e,i,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(e,t,n){const s=await ne(this,Xe,Di).call(this,e,n),i=await fa(e,t,"patch",{...n,addressFilter:this.addressFilter});return ne(this,Xe,ki).call(this,e,i,s)}async patch(e,t,n){const s=await ne(this,Xe,Di).call(this,e,n),i=await fa(e,t,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return ne(this,Xe,ki).call(this,e,i,s)}async merge(e,t,n){const s=await ne(this,Xe,Di).call(this,e,n),i=await fa(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return ne(this,Xe,ki).call(this,e,i,s)}async*all(e){for await(const{key:t,value:n}of this.datastore.query($0(e??{},this.maxAddressAge),e)){const s=ud(t);if(s.equals(this.peerId))continue;const i=ln.decode(n);if(ne(this,Xe,Ri).call(this,s,i)){await this.datastore.delete(t,e);continue}yield kr(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Xe=new WeakSet,Di=async function(e,t){try{const n=Js(e),s=await this.datastore.get(n,t),i=ln.decode(s);if(ne(this,Xe,Ri).call(this,e,i))throw await this.datastore.delete(n,t),new zi;return{peerPB:i,peer:kr(e,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},ki=async function(e,t,n,s){t.updated=Date.now();const i=ln.encode(t);return await this.datastore.put(Js(e),i,s),{peer:kr(e,t,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!L0(t,n.peerPB)}},Ri=function(e,t){if(t.updated==null)return!0;if(this.peerId.equals(e))return!1;const n=t.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=t.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0},sf=Symbol.toStringTag;class z0{constructor(e,t={}){ge(this,Hn);l(this,"store");l(this,"events");l(this,"peerId");l(this,"log");l(this,sf,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new U0(e,t)}async forEach(e,t){for await(const n of this.store.all(t))e(n)}async all(e){return ca(this.store.all(e))}async delete(e,t){const n=await this.store.getReadLock(e,t);try{await this.store.delete(e,t)}finally{n()}}async has(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.has(e,t)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(e,t){const n=await this.store.getReadLock(e,t);try{return await this.store.load(e,t)}finally{n==null||n()}}async getInfo(e,t){const n=await this.get(e,t);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.save(e,t,n);return ne(this,Hn,Mi).call(this,e,i),i.peer}finally{s==null||s()}}async patch(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.patch(e,t,n);return ne(this,Hn,Mi).call(this,e,i),i.peer}finally{s==null||s()}}async merge(e,t,n){const s=await this.store.getWriteLock(e,n);try{const i=await this.store.merge(e,t,n);return ne(this,Hn,Mi).call(this,e,i),i.peer}finally{s==null||s()}}async consumePeerRecord(e,t,n){const s=er(t)?t:er(t==null?void 0:t.expectedPeer)?t.expectedPeer:void 0,i=er(t)||t===void 0?n:t,o=await an.openAndCertify(e,vt.DOMAIN,i),a=Er(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=vt.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((u==null?void 0:u.peerRecordEnvelope)!=null){const d=an.createFromProtobuf(u.peerRecordEnvelope),h=vt.createFromProtobuf(d.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:e,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}Hn=new WeakSet,Mi=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function K0(r,e={}){return new z0(r,e)}const Gn=class Gn extends Error{constructor(t="Not Found"){super(t);l(this,"name",Gn.name);l(this,"code",Gn.code)}};l(Gn,"name","NotFoundError"),l(Gn,"code","ERR_NOT_FOUND");let ma=Gn;function q0(r){return r[Symbol.asyncIterator]!=null}function dd(r){if(q0(r))return(async()=>{for await(const e of r);})();for(const e of r);}function V0(r){const[e,t]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:e.next(),[t](){return this}}}function W0(r){return r[Symbol.asyncIterator]!=null}function Un(r,e){let t=0;if(W0(r))return async function*(){for await(const c of r)await e(c,t++)&&(yield c)}();const n=V0(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of n)a(c,t++)&&(yield c)}()}function H0(r){return r[Symbol.asyncIterator]!=null}function hd(r,e){return H0(r)?async function*(){yield*(await ca(r)).sort(e)}():function*(){yield*ca(r).sort(e)}()}function G0(r){return r[Symbol.asyncIterator]!=null}function fd(r,e){return G0(r)?async function*(){let t=0;if(!(e<1)){for await(const n of r)if(yield n,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const n of r)if(yield n,t++,t===e)return}}()}class Y0{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:n,value:s}of e)await this.put(n,s,t),yield n}async*getMany(e,t={}){for await(const n of e)yield{key:n,value:await this.get(n,t)}}async*deleteMany(e,t={}){for await(const n of e)await this.delete(n,t),yield n}batch(){let e=[],t=[];return{put(n,s){e.push({key:n,value:s})},delete(n){t.push(n)},commit:async n=>{await dd(this.putMany(e,n)),e=[],await dd(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(e.prefix!=null){const s=e.prefix;n=Un(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Un(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>hd(s,i),n)),e.offset!=null){let s=0;const i=e.offset;n=Un(n,()=>s++>=i)}return e.limit!=null&&(n=fd(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;n=Un(n,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(n=e.filters.reduce((s,i)=>Un(s,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((s,i)=>hd(s,i),n)),e.offset!=null){const s=e.offset;let i=0;n=Un(n,()=>i++>=s)}return e.limit!=null&&(n=fd(n,e.limit)),n}}class X0 extends Y0{constructor(){super();l(this,"data");this.data=new Map}put(t,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(t.toString(),n),t}get(t,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(t.toString());if(s==null)throw new ma;return s}has(t,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(t.toString())}delete(t,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(t.toString())}*_all(t,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new Ke(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(t,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new Ke(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const he=r=>({match:e=>{const t=e[0];return t==null||t.code!==r||t.value!=null?!1:e.slice(1)}}),K=(r,e)=>({match:t=>{const n=t[0];return(n==null?void 0:n.code)!==r||n.value==null||e!=null&&n.value!==e?!1:t.slice(1)}}),Z0=r=>({match:e=>r.match(e)===!1?e:!1}),X=r=>({match:e=>{const t=r.match(e);return t===!1?e:t}}),qe=(...r)=>({match:e=>{let t;for(const n of r){const s=n.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1}}),ie=(...r)=>({match:e=>{for(const t of r){const n=t.match(e);if(n===!1)return!1;e=n}return e}});function fe(...r){function e(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function n(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:r,matches:t,exactMatch:n}}const Q0=K(W),j0=fe(Q0),ti=K(gu),ni=K(mu),ri=K(pu),pa=K(fu);fe(ti,X(K(W))),fe(ni,X(K(W))),fe(ri,X(K(W))),fe(qe(pa,ri,ti,ni),X(K(W)));const gd=ie(K(Us),X(K(Qo))),md=ie(X(K(Zo)),K(Mn),X(K(Qo))),ya=qe(gd,md),un=qe(ya,pa,ti,ni,ri),J0=fe(qe(ya,ie(qe(pa,ri,ti,ni),X(K(W))))),pd=fe(gd),yd=fe(md);fe(ya);const wa=ie(un,K(Rn)),Rr=ie(un,K(hu)),si=fe(ie(wa,X(K(W))));fe(Rr);const ba=ie(Rr,he(wu),X(K(W))),ii=ie(Rr,he(bu),X(K(W))),eE=qe(ba,ii);fe(ba);const tE=fe(ii),Ea=qe(un,wa,Rr,ba,ii),wd=qe(ie(Ea,he(Jo),X(K(W)))),oi=fe(wd),bd=qe(ie(Ea,he(vu),X(K(W))),ie(Ea,he(Nn),X(K(zs)),he(Jo),X(K(W)))),va=fe(bd),Ed=ie(Rr,he(Su),X(K(Ir)),X(K(Ir)),X(K(W))),vd=fe(Ed),Sd=ie(ii,he(Eu),X(K(Ir)),X(K(Ir)),X(K(W))),xd=fe(Sd),ai=qe(wd,bd,ie(wa,X(K(W))),ie(eE,X(K(W))),ie(un,X(K(W))),Ed,Sd,K(W)),nE=fe(ai),rE=ie(X(ai),he(Ks),Z0(he(Lr)),X(K(W))),ci=fe(rE),sE=qe(ie(ai,he(Ks),he(Lr),X(K(W))),ie(ai,he(Lr),X(K(W))),ie(he(Lr),X(K(W)))),Sa=fe(sE),iE=qe(ie(un,K(Rn),he(On),X(K(W))),ie(un,he(On),X(K(W))));fe(iE);const oE=ie(un,qe(ie(K(Rn,"443"),he(On)),ie(K(Rn),he(jo)),ie(K(Rn),he(Nn),he(On)),ie(he(Nn),he(On)),he(Nn),he(jo)),X(K(W)));fe(oE);const aE=qe(ie(K(xu),X(K(W))));fe(aE);const cE=qe(ie(K(yu),X(K(W))));fe(cE);const Ad=864e13;class lE{constructor(e,t={}){l(this,"log");l(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Et({name:"libp2p_address_manager_dns_mappings",metrics:e.metrics})}has(e){const t=de(e);let n=t.host;(t.type==="ip4"||t.type==="ip6")&&t.sni!=null&&(n=t.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(e,t){t.forEach(n=>{this.log("add DNS mapping %s to %s",n,e);const s=Ho(n)===!0;this.mappings.set(n,{domain:e,verified:s,expires:s?Ad-Date.now():0,lastVerified:s?Ad-Date.now():void 0})})}remove(e){const t=de(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===t.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(e){const t=[];for(let n=0;n<e.length;n++){const s=e[n].multiaddr;if(!st(s))continue;const i=de(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(e.splice(n,1),n--,t.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return t}maybeAddSNIComponent(e,t){var s;const n=e.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===Nn&&((s=n[i+1])==null?void 0:s.code)!==zs)return n.splice(i+1,0,{name:"sni",code:zs,value:t}),ce(n)}confirm(e,t){const n=de(e);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+t,a.lastVerified=Date.now());return i}unconfirm(e,t){const n=de(e);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+t);return i}}class uE{constructor(e,t={}){l(this,"log");l(this,"mappings");this.log=e.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Et({name:"libp2p_address_manager_ip_mappings",metrics:e.metrics})}has(e){const t=de(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===t.host)return!0;return!1}add(e,t,n,s=t,i="tcp"){const o=`${e}-${t}-${i}`,a=this.mappings.get(o)??[],c={internalIp:e,internalPort:t,externalIp:n,externalPort:s,externalFamily:Tn(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(e){const t=de(e);if(t.type!=="ip4"&&t.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===t.host&&a.externalPort===t.port&&a.protocol===t.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,t.host,t.port,t.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(e){const t=[];for(const{multiaddr:n}of e){if(!st(n))continue;const s=de(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)t.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return t}maybeOverrideIp(e,t,n,s,i){const o=e.getComponents(),a=o.findIndex(u=>u.code===Us||u.code===Mn),c=o.findIndex(u=>u.name===s);return a>-1&&c>-1?(o[a].value=t,o[a].code=n===4?Us:Mn,o[c].value=`${i}`,ce(o)):e}confirm(e,t){if(!st(e))return!1;const n=de(e);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+t,o.lastVerified=Date.now());return s}unconfirm(e,t){if(!st(e))return!1;const n=de(e);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+t)}return s}}const dE={maxObservedAddresses:10};class hE{constructor(e,t={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Et({name:"libp2p_address_manager_observed_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??dE.maxObservedAddresses}has(e){return this.addresses.has(e.toString())}removePrefixed(e){for(const t of this.addresses.keys())t.toString().startsWith(e)&&this.addresses.delete(t)}add(e){this.addresses.size!==this.maxObservedAddresses&&(Pn(e)||_w(e)||(this.log("adding observed address %a",e),this.addresses.set(e.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([e,t])=>({multiaddr:ce(e),verified:t.verified,type:"observed",expires:t.expires,lastVerified:t.lastVerified}))}remove(e){var n;const t=((n=this.addresses.get(e.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(e.toString()),t}confirm(e,t){const n=e.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+t,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const fE={maxObservedAddresses:10};class gE{constructor(e,t={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=e.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Et({name:"libp2p_address_manager_transport_addresses",metrics:e.metrics}),this.maxObservedAddresses=t.maxObservedAddresses??fE.maxObservedAddresses}get(e,t){if(Pn(e))return{multiaddr:e,verified:!0,type:"transport",expires:Date.now()+t,lastVerified:Date.now()};const n=this.toKey(e);let s=this.addresses.get(n);return s==null&&(s={verified:!st(e),expires:0},this.addresses.set(n,s)),{multiaddr:e,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(e){const t=this.toKey(e);return this.addresses.has(t)}remove(e){var s;const t=this.toKey(e),n=((s=this.addresses.get(t))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",e),this.addresses.delete(t),n}confirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+t,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(e,t){const n=this.toKey(e),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+t,this.addresses.set(n,s),i}toKey(e){if(!st(e))return e.toString();const t=de(e);return`${t.host}-${t.port}-${t.protocol}`}}const _d=6e4,Cd={addressVerificationTTL:_d*10,addressVerificationRetry:_d*5},mE=r=>r;function xa(r,e){var n;const t=(n=r.getComponents().findLast(s=>s.code===W))==null?void 0:n.value;return t!=null&&Bt(t).equals(e)&&(r=r.decapsulate(ce(`/p2p/${e.toString()}`))),r}of=Symbol.toStringTag;class pE{constructor(e,t={}){l(this,"log");l(this,"components");l(this,"listen");l(this,"announce");l(this,"appendAnnounce");l(this,"announceFilter");l(this,"observed");l(this,"dnsMappings");l(this,"ipMappings");l(this,"transportAddresses");l(this,"observedAddressFilter");l(this,"addressVerificationTTL");l(this,"addressVerificationRetry");l(this,of,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new hE(e,t),this.dnsMappings=new lE(e,t),this.ipMappings=new uE(e,t),this.transportAddresses=new gE(e,t),this.announceFilter=t.announceFilter??mE,this.observedAddressFilter=Vl(1024),this.addressVerificationTTL=t.addressVerificationTTL??Cd.addressVerificationTTL,this.addressVerificationRetry=t.addressVerificationRetry??Cd.addressVerificationRetry,this._updatePeerStoreAddresses=Bs(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAddresses().map(t=>{var n;return((n=t.getComponents().findLast(s=>s.code===W))==null?void 0:n.value)===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t});this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses - %e",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>ce(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>ce(e))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(e=>ce(e))}getObservedAddrs(){return this.observed.getAll().map(e=>e.multiaddr)}addObservedAddr(e){const t=de(e);let n;switch(t.type){case"ip4":{n=`${t.host}:${t.port}`;break}case"ip6":{n=`[${t.host}]:${t.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),e=xa(e,this.components.peerId),!this.ipMappings.has(e)&&(this.dnsMappings.has(e)||this.observed.add(e)))}confirmObservedAddr(e,t){e=xa(e,this.components.peerId);let n=!0;((t==null?void 0:t.type)==="transport"||this.transportAddresses.has(e))&&!this.transportAddresses.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="dns-mapping"||this.dnsMappings.has(e))&&!this.dnsMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="ip-mapping"||this.ipMappings.has(e))&&!this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((t==null?void 0:t.type)==="observed"||this.observed.has(e))&&(this.maybeUpgradeToIPMapping(e)?(this.ipMappings.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(e,(t==null?void 0:t.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(e,t){e=xa(e,this.components.peerId),this.observed.has(e)&&this.observed.remove(e),this.transportAddresses.has(e)&&this.transportAddresses.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.dnsMappings.has(e)&&this.dnsMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry),this.ipMappings.has(e)&&this.ipMappings.unconfirm(e,(t==null?void 0:t.ttl)??this.addressVerificationRetry)}getAddresses(){const e=new Set,t=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return e.has(s)?!1:(e.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(t.map(n=>{const s=ce(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const e=this.getAnnounceAddrs();if(e.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(e)}),e.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let t=[];t=t.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),t=t.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),t=t.concat(this.observed.getAll()),t=t.concat(this.ipMappings.getAll(t)),t=t.concat(this.dnsMappings.getAll(t)),t}addDNSMapping(e,t){this.dnsMappings.add(e,t)}removeDNSMapping(e){this.dnsMappings.remove(ce(`/dns/${e}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.add(e,t,n,s,i),this.observed.removePrefixed(`/ip${Tn(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(e,t,n,s=t,i="tcp"){this.ipMappings.remove(ce(`/ip${Tn(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(e){if(this.ipMappings.has(e)||!st(e))return!1;const t=de(e);if(t.type!=="ip4"||Ho(t.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>oi.exactMatch(i)||va.exactMatch(i),i=>si.exactMatch(i),i=>tE.exactMatch(i)];for(const i of s){if(!i(e))continue;const o=n.filter(u=>u.getAddrs().filter(d=>de(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!Vo(u)).pop();if(a==null)continue;const c=de(a);return c.port==null?!1:(this.observed.remove(e),this.ipMappings.add(c.host,c.port,t.host,t.port,t.protocol),!0)}return!1}}var Id;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(Id||(Id={}));class yE extends Error{constructor(e="Missing service"){super(e),this.name="MissingServiceError"}}class wE extends Error{constructor(e="Unmet service dependencies"){super(e),this.name="UnmetServiceDependenciesError"}}class Aa extends Error{constructor(e="No content routers available"){super(e),this.name="NoContentRoutersError"}}class Ld extends Error{constructor(e="No peer routers available"){super(e),this.name="NoPeerRoutersError"}}class bE extends Error{constructor(e="Should not try to find self"){super(e),this.name="QueriedForSelfError"}}class EE extends Error{constructor(e="Unhandled protocol error"){super(e),this.name="UnhandledProtocolError"}}class vE extends Error{constructor(e="Duplicate protocol handler error"){super(e),this.name="DuplicateProtocolHandlerError"}}class Td extends Error{constructor(e="Dial denied error"){super(e),this.name="DialDeniedError"}}class SE extends Error{constructor(e="No transport was configured to listen on this address"){super(e),this.name="UnsupportedListenAddressError"}}class xE extends Error{constructor(e="Configured listen addresses could not be listened on"){super(e),this.name="UnsupportedListenAddressesError"}}class AE extends Error{constructor(e="No valid addresses"){super(e),this.name="NoValidAddressesError"}}class _E extends Error{constructor(e="Connection intercepted"){super(e),this.name="ConnectionInterceptedError"}}class CE extends Error{constructor(e="Connection denied"){super(e),this.name="ConnectionDeniedError"}}class li extends Error{constructor(e="Stream is not multiplexed"){super(e),this.name="MuxerUnavailableError"}}class ui extends Error{constructor(e="Encryption failed"){super(e),this.name="EncryptionFailedError"}}class IE extends Error{constructor(e="Transport unavailable"){super(e),this.name="TransportUnavailableError"}}class LE extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}class TE{constructor(e={}){l(this,"components",{});l(this,"_started",!1);this.components={};for(const[t,n]of Object.entries(e))this.components[t]=n;this.components.logger==null&&(this.components.logger=Bl())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>Hi(t)).map(async t=>{var n;await((n=t[e])==null?void 0:n.call(t))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const PE=["metrics","connectionProtector","dns"],DE=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function kE(r={}){const e=new TE(r);return new Proxy(e,{get(n,s,i){if(typeof s=="string"&&!DE.includes(s)){const o=e.components[s];if(o==null&&!PE.includes(s))throw new yE(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(n,s,i),!0}})}function RE(r){const e={};for(const t of Object.values(r.components))for(const n of ME(t))e[n]=!0;for(const t of Object.values(r.components))for(const n of NE(t))if(e[n]!==!0)throw new wE(`Service "${OE(t)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function ME(r){return Array.isArray(r==null?void 0:r[Gt])?r[Gt]:[]}function NE(r){return Array.isArray(r==null?void 0:r[Gi])?r[Gi]:[]}function OE(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function BE(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=e=>oi.matches(e)?!0:Pn(e)),r}class Se extends Event{constructor(t,n){super(t);l(this,"type");l(this,"detail");this.type=t,this.detail=n}}function Pd(r){var n;if(er(r))return{peerId:r,multiaddrs:[]};let e=Array.isArray(r)?r:[r],t;if(e.length>0){const s=(n=e[0].getComponents().findLast(i=>i.code===W))==null?void 0:n.value;t=s==null?void 0:Bt(s),e.forEach(i=>{var a;if(!Vs(i))throw new Xr("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===W))==null?void 0:a.value;if(o==null){if(t!=null)throw new V("Multiaddrs must all have the same peer id or have no peer id")}else{const c=Bt(o);if((t==null?void 0:t.equals(c))!==!0)throw new V("Multiaddrs must all have the same peer id or have no peer id")}})}return e=e.filter(s=>!j0.exactMatch(s)),{peerId:t,multiaddrs:e}}const FE=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function $E(r,e){var s;const t=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(e==null?void 0:e.closableProtocols)??FE;if(!(t.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(e))}catch(i){r==null||r.abort(i)}}function _a(r){const e=de(r);let t=e.cidr;if(e.type!=="ip4"&&e.type!=="ip6")throw new V(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(t==null)switch(e.type){case"ip4":{t=32;break}case"ip6":{t=128;break}default:throw new V(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new Zl(e.host,t)}function Dd(r){return!ci.exactMatch(r)}function kd(r,e,t){if(r==null||e==null)return;const n=e.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||t==null)return n;if(!t.some(i=>Dd(i)))return n}class UE{constructor(e,t={}){l(this,"connectionManager");l(this,"peerStore");l(this,"allow");l(this,"events");l(this,"log");this.allow=(t.allow??[]).map(n=>_a(n)),this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(e=>{this.log.error("error while pruning connections - %e",e)})}async _maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",t,n),t<=n)return;const s=new Ar;for(const c of e){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,g)=>h+g.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(e,s),o=Math.max(t-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(st(c.remoteAddr)){const h=de(c.remoteAddr);return d.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await $E(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(e,t){return e.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=t.get(n.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const Rd=1e4,Md=1e3,zE=1e4,di=1e4,Nd=25,KE=5,qE=10,VE=5,WE="last-dial-failure",HE="last-dial-success",Od=500,GE=32,YE=100,Bd=50;function XE(r,e){const t=si.exactMatch(r.multiaddr),n=si.exactMatch(e.multiaddr);if(t&&!n)return-1;if(!t&&n)return 1;const s=va.exactMatch(r.multiaddr),i=va.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=oi.exactMatch(r.multiaddr),a=oi.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=Sa.exactMatch(r.multiaddr),u=Sa.exactMatch(e.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const d=vd.exactMatch(r.multiaddr),h=vd.exactMatch(e.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const g=xd.exactMatch(r.multiaddr),p=xd.exactMatch(e.multiaddr);return g&&!p?-1:!g&&p?1:0}function ZE(r,e){const t=Vo(r.multiaddr),n=Vo(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function QE(r,e){const t=Pn(r.multiaddr),n=Pn(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function jE(r,e){return r.isCertified&&!e.isCertified?-1:!r.isCertified&&e.isCertified?1:0}function JE(r,e){const t=ci.exactMatch(r.multiaddr),n=ci.exactMatch(e.multiaddr);return t&&!n?1:!t&&n?-1:0}function ev(r){return r.sort(XE).sort(jE).sort(JE).sort(QE).sort(ZE)}var Fd={exports:{}};(function(r){var e=Object.prototype.hasOwnProperty,t="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(t=!1));function s(c,u,d){this.fn=c,this.context=u,this.once=d||!1}function i(c,u,d,h,g){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||c,g),f=t?t+u:u;return c._events[f]?c._events[f].fn?c._events[f]=[c._events[f],p]:c._events[f].push(p):(c._events[f]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)e.call(d,h)&&u.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=t?t+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var g=0,p=h.length,f=new Array(p);g<p;g++)f[g]=h[g].fn;return f},a.prototype.listenerCount=function(u){var d=t?t+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,g,p,f){var y=t?t+u:u;if(!this._events[y])return!1;var m=this._events[y],S=arguments.length,v,E;if(m.fn){switch(m.once&&this.removeListener(u,m.fn,void 0,!0),S){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,d),!0;case 3:return m.fn.call(m.context,d,h),!0;case 4:return m.fn.call(m.context,d,h,g),!0;case 5:return m.fn.call(m.context,d,h,g,p),!0;case 6:return m.fn.call(m.context,d,h,g,p,f),!0}for(E=1,v=new Array(S-1);E<S;E++)v[E-1]=arguments[E];m.fn.apply(m.context,v)}else{var T=m.length,L;for(E=0;E<T;E++)switch(m[E].once&&this.removeListener(u,m[E].fn,void 0,!0),S){case 1:m[E].fn.call(m[E].context);break;case 2:m[E].fn.call(m[E].context,d);break;case 3:m[E].fn.call(m[E].context,d,h);break;case 4:m[E].fn.call(m[E].context,d,h,g);break;default:if(!v)for(L=1,v=new Array(S-1);L<S;L++)v[L-1]=arguments[L];m[E].fn.apply(m[E].context,v)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,g){var p=t?t+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var f=this._events[p];if(f.fn)f.fn===d&&(!g||f.once)&&(!h||f.context===h)&&o(this,p);else{for(var y=0,m=[],S=f.length;y<S;y++)(f[y].fn!==d||g&&!f[y].once||h&&f[y].context!==h)&&m.push(f[y]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=t?t+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,r.exports=a})(Fd);var tv=Fd.exports;const nv=jl(tv);function rv(r,e,t){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;t(r[o],e)<=0?(n=++o,s-=i+1):s=i}return n}class sv{constructor(){ge(this,et,[])}enqueue(e,t){t={priority:0,...t};const n={priority:t.priority,id:t.id,run:e};if(this.size===0||$(this,et)[this.size-1].priority>=t.priority){$(this,et).push(n);return}const s=rv($(this,et),n,(i,o)=>o.priority-i.priority);$(this,et).splice(s,0,n)}setPriority(e,t){const n=$(this,et).findIndex(i=>i.id===e);if(n===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=$(this,et).splice(n,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){const e=$(this,et).shift();return e==null?void 0:e.run}filter(e){return $(this,et).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return $(this,et).length}}et=new WeakMap;class iv extends nv{constructor(t){var n,s;super();ge(this,J);ge(this,Yn);ge(this,Xn);ge(this,Wt,0);ge(this,Ur);ge(this,Zn);ge(this,zr,0);ge(this,tt);ge(this,Qn);ge(this,We);ge(this,Kr);ge(this,nt,0);ge(this,jn);ge(this,_t);ge(this,qr);ge(this,Li,1n);l(this,"timeout");if(t={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:sv,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=t.intervalCap)==null?void 0:n.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=t.interval)==null?void 0:s.toString())??""}\` (${typeof t.interval})`);me(this,Yn,t.carryoverConcurrencyCount),me(this,Xn,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),me(this,Ur,t.intervalCap),me(this,Zn,t.interval),me(this,We,new t.queueClass),me(this,Kr,t.queueClass),this.concurrency=t.concurrency,this.timeout=t.timeout,me(this,qr,t.throwOnTimeout===!0),me(this,_t,t.autoStart===!1)}get concurrency(){return $(this,jn)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);me(this,jn,t),ne(this,J,Oi).call(this)}setPriority(t,n){$(this,We).setPriority(t,n)}async add(t,n={}){return n.id??(n.id=(Hr(this,Li)._++).toString()),n={timeout:this.timeout,throwOnTimeout:$(this,qr),...n},new Promise((s,i)=>{$(this,We).enqueue(async()=>{var o;Hr(this,nt)._++;try{(o=n.signal)==null||o.throwIfAborted(),Hr(this,Wt)._++;let a=t({signal:n.signal});n.timeout&&(a=su(Promise.resolve(a),{milliseconds:n.timeout})),n.signal&&(a=Promise.race([a,ne(this,J,zf).call(this,n.signal)]));const c=await a;s(c),this.emit("completed",c)}catch(a){if(a instanceof tu&&!n.throwOnTimeout){s();return}i(a),this.emit("error",a)}finally{ne(this,J,Ff).call(this)}},n),this.emit("add"),ne(this,J,Ni).call(this)})}async addAll(t,n){return Promise.all(t.map(async s=>this.add(s,n)))}start(){return $(this,_t)?(me(this,_t,!1),ne(this,J,Oi).call(this),this):this}pause(){me(this,_t,!0)}clear(){me(this,We,new($(this,Kr)))}async onEmpty(){$(this,We).size!==0&&await ne(this,J,Bi).call(this,"empty")}async onSizeLessThan(t){$(this,We).size<t||await ne(this,J,Bi).call(this,"next",()=>$(this,We).size<t)}async onIdle(){$(this,nt)===0&&$(this,We).size===0||await ne(this,J,Bi).call(this,"idle")}get size(){return $(this,We).size}sizeBy(t){return $(this,We).filter(t).length}get pending(){return $(this,nt)}get isPaused(){return $(this,_t)}}Yn=new WeakMap,Xn=new WeakMap,Wt=new WeakMap,Ur=new WeakMap,Zn=new WeakMap,zr=new WeakMap,tt=new WeakMap,Qn=new WeakMap,We=new WeakMap,Kr=new WeakMap,nt=new WeakMap,jn=new WeakMap,_t=new WeakMap,qr=new WeakMap,Li=new WeakMap,J=new WeakSet,Of=function(){return $(this,Xn)||$(this,Wt)<$(this,Ur)},Bf=function(){return $(this,nt)<$(this,jn)},Ff=function(){Hr(this,nt)._--,ne(this,J,Ni).call(this),this.emit("next")},$f=function(){ne(this,J,ja).call(this),ne(this,J,Qa).call(this),me(this,Qn,void 0)},Uf=function(){const t=Date.now();if($(this,tt)===void 0){const n=$(this,zr)-t;if(n<0)me(this,Wt,$(this,Yn)?$(this,nt):0);else return $(this,Qn)===void 0&&me(this,Qn,setTimeout(()=>{ne(this,J,$f).call(this)},n)),!0}return!1},Ni=function(){if($(this,We).size===0)return $(this,tt)&&clearInterval($(this,tt)),me(this,tt,void 0),this.emit("empty"),$(this,nt)===0&&this.emit("idle"),!1;if(!$(this,_t)){const t=!$(this,J,Uf);if($(this,J,Of)&&$(this,J,Bf)){const n=$(this,We).dequeue();return n?(this.emit("active"),n(),t&&ne(this,J,Qa).call(this),!0):!1}}return!1},Qa=function(){$(this,Xn)||$(this,tt)!==void 0||(me(this,tt,setInterval(()=>{ne(this,J,ja).call(this)},$(this,Zn))),me(this,zr,Date.now()+$(this,Zn)))},ja=function(){$(this,Wt)===0&&$(this,nt)===0&&$(this,tt)&&(clearInterval($(this,tt)),me(this,tt,void 0)),me(this,Wt,$(this,Yn)?$(this,nt):0),ne(this,J,Oi).call(this)},Oi=function(){for(;ne(this,J,Ni).call(this););},zf=async function(t){return new Promise((n,s)=>{t.addEventListener("abort",()=>{s(t.reason)},{once:!0})})},Bi=async function(t,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(t,i),s())};this.on(t,i)})};function $d(r){const e=[Ft.A];return r==null?e:Array.isArray(r)?r.length===0?e:r:[r]}const Ud=60;function zd(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(e=>({name:e.name,type:Ft[e.type]})),Answer:(r.Answer??r.answers??[]).map(e=>({name:e.name,type:Ft[e.type],TTL:e.TTL??e.ttl??Ud,data:e.data instanceof Uint8Array?Q(e.data):e.data}))}}const ov=4;function Kd(r,e={}){const t=new iv({concurrency:e.queryConcurrency??ov});return async(n,s={})=>{var a;const i=new URLSearchParams;i.set("name",n),$d(s.types).forEach(c=>{i.append("type",Ft[c])}),(a=s.onProgress)==null||a.call(s,new Se("dns:query",n));const o=await t.add(async()=>{var d;const c=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const u=zd(await c.json());return(d=s.onProgress)==null||d.call(s,new Se("dns:response",u)),u},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function av(){return[Kd("https://cloudflare-dns.com/dns-query"),Kd("https://dns.google/resolve")]}var cv=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),n=Object.create(null);function s(i,o){t[i]=o,e++,e>=r&&(e=0,n=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||n[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),n=Object.create(null)}}};const lv=jl(cv);class uv{constructor(e){l(this,"lru");this.lru=lv(e)}get(e,t){let n=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return zd({answers:s})}getAnswers(e,t){const n=`${e.toLowerCase()}-${t}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Ft[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(e,t){const n=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(t.TTL??Ud)*1e3,value:t}),this.lru.set(n,s)}remove(e,t){const n=`${e.toLowerCase()}-${t}`;this.lru.remove(n)}clear(){this.lru.clear()}}function dv(r){return new uv(r)}const hv=1e3;class fv{constructor(e){l(this,"resolvers");l(this,"cache");this.resolvers={},this.cache=dv(e.cacheSize??hv),Object.entries(e.resolvers??{}).forEach(([t,n])=>{Array.isArray(n)||(n=[n]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=n}),this.resolvers["."]==null&&(this.resolvers["."]=av())}async query(e,t={}){var c,u,d;const n=$d(t.types),s=t.cached!==!1?this.cache.get(e,n):void 0;if(s!=null)return(c=t.onProgress)==null||c.call(t,new Se("dns:cache",s)),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((u=t.signal)==null?void 0:u.aborted)===!0)break;try{const g=await h(e,{...t,types:n});for(const p of g.Answer)this.cache.add(e,p);return g}catch(g){a.push(g),(d=t.onProgress)==null||d.call(t,new Se("dns:error",g))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${n} failed`)}}var Ft;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Ft||(Ft={}));function gv(r={}){return new fv(r)}class mv{constructor(){l(this,"dns")}canResolve(e){return e.getComponents().some(({name:t})=>t==="dnsaddr")}async resolve(e,t){var c,u;const n=(c=e.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[e];const i=await this.getDNS(t).query(`_dnsaddr.${n}`,{signal:t==null?void 0:t.signal,types:[Ft.TXT]}),o=(u=e.getComponents().find(d=>d.name==="p2p"))==null?void 0:u.value,a=[];for(const d of i.Answer){const h=d.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(ce(h)))}return a}getDNS(e){return e.dns!=null?e.dns:(this.dns==null&&(this.dns=gv()),this.dns)}}const qd=new mv;async function Vd(r,e,t){const n=t.depth??0;if(n>(t.maxRecursiveDepth??GE))throw new LE("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,t);for(const c of a)i.push(...await Vd(c,e,{...t,depth:n+1}))}return s===!1&&i.push(r),i}const Mr={maxParallelDials:Bd,maxDialQueueLength:Od,maxPeerAddrsToDial:Nd,dialTimeout:Rd,resolvers:{dnsaddr:qd}};class pv{constructor(e,t={}){l(this,"queue");l(this,"components");l(this,"addressSorter");l(this,"maxPeerAddrsToDial");l(this,"maxDialQueueLength");l(this,"dialTimeout");l(this,"shutDownController");l(this,"connections");l(this,"log");l(this,"resolvers");this.addressSorter=t.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??Mr.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??Mr.maxDialQueueLength,this.dialTimeout=t.dialTimeout??Mr.dialTimeout,this.connections=t.connections??new Ar,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.resolvers=t.resolvers??Mr.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new t0({concurrency:t.maxParallelDials??Mr.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==ct.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){var o,a,c;const{peerId:n,multiaddrs:s}=Pd(e);if(n!=null&&t.force!==!0){const u=kd(n,this.connections.get(n),s);if(u!=null)return this.log("already connected to %a",u.remoteAddr),(o=t.onProgress)==null||o.call(t,new Se("dial-queue:already-connected")),u}const i=this.queue.queue.find(u=>{if((n==null?void 0:n.equals(u.options.peerId))===!0)return!0;const d=u.options.multiaddrs;if(d==null)return!1;for(const h of s)if(d.has(h.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const u of s)i.options.multiaddrs.add(u.toString());return(a=t.onProgress)==null||a.call(t,new Se("dial-queue:already-in-dial-queue")),i.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new Zr("Dial queue is full");return this.log("creating dial target for %p",n,s.map(u=>u.toString())),(c=t.onProgress)==null||c.call(t,new Se("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var h;(h=u.onProgress)==null||h.call(u,new Se("dial-queue:start-dial"));const d=Dn([this.shutDownController.signal,u.signal]);try{return await this.dialPeer(u,d)}finally{d.clear()}},{peerId:n,priority:t.priority??Gd,multiaddrs:new Set(s.map(u=>u.toString())),signal:t.signal??AbortSignal.timeout(this.dialTimeout),onProgress:t.onProgress})}async dialPeer(e,t){var d;const n=e.peerId,s=e.multiaddrs,i=new Set;let o=e.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const h=[],g=new Set(e.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...g]);const p=await this.calculateMultiaddrs(n,g,{...e,signal:t});for(const f of p){if(i.has(f.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",f.multiaddr,n);continue}h.push(f)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(f=>f.multiaddr.toString())),(d=e==null?void 0:e.onProgress)==null||d.call(e,new Se("dial-queue:calculated-addresses",h));for(const f of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,e.peerId),new Zr("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(f.multiaddr,{...e,signal:t});this.log("dial to %a succeeded",f.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[HE]:H(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}return y}catch(y){if(this.log.error("dial failed to %a - %e",f.multiaddr,y),i.add(f.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[WE]:H(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}if(t.aborted)throw new qf(y.message);u.push(y)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(e,t=new Set,n={}){var h,g;const s=[...t].map(p=>({multiaddr:ce(p),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new Zr("Tried to dial self");if(await((g=(h=this.components.connectionGater).denyDialPeer)==null?void 0:g.call(h,e))===!0)throw new Td("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",e);try{const p=await this.components.peerStore.get(e);s.push(...p.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:f})=>f.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const p=await this.components.peerRouting.findPeer(e,n);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:f})=>f.toString())),s.push(...p.multiaddrs.map(f=>({multiaddr:f,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",e):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",e,p)}}}let i=(await Promise.all(s.map(async p=>{const f=await Vd(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return f.length===1&&f[0].equals(p.multiaddr)?p:f.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(e!=null){const p=`/p2p/${e.toString()}`;i=i.map(f=>{const y=f.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:f.multiaddr.encapsulate(p),isCertified:f.isCertified}:f})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const f=(y=p.multiaddr.getComponents().findLast(m=>m.code===W))==null?void 0:y.value;return e!=null&&f!=null?e.equals(f):!0}),a=new Map;for(const p of o){const f=p.multiaddr.toString(),y=a.get(f);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(f,p)}const c=[...a.values()];if(c.length===0)throw new AE("The dial request has no valid addresses");const u=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||u.push(p);const d=this.addressSorter==null?ev(u):u.sort(this.addressSorter);if(d.length===0)throw new Td("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const n=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnLimitedConnection===!1?n.find(s=>!ci.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}const yv=Object.prototype.toString,wv=r=>yv.call(r)==="[object Error]",bv=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function Ev(r){if(!(r&&wv(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:t,stack:n}=r;return t==="Load failed"?n===void 0||"__sentry_captured__"in r:t.startsWith("error sending request for url")?!0:bv.has(t)}function vv(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function hi(r,e,{min:t=0,allowInfinity:n=!1}={}){if(e!==void 0){if(typeof e!="number"||Number.isNaN(e))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(e))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(e<t)throw new TypeError(`Expected \`${r}\` to be â‰¥ ${t}.`)}}class Sv extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}function xv(r,e){const t=Math.max(1,r+1),n=e.randomize?Math.random()+1:1;let s=Math.round(n*e.minTimeout*e.factor**(t-1));return s=Math.min(s,e.maxTimeout),s}function Wd(r,e){return Number.isFinite(e)?e-(performance.now()-r):e}async function Av({error:r,attemptNumber:e,retriesConsumed:t,startTime:n,options:s}){var p,f,y;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof Sv)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-t):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:e,retriesLeft:o,retriesConsumed:t});if(await s.onFailedAttempt(c),Wd(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(c),d=Wd(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!Ev(i)){if(u)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!u)return(f=s.signal)==null||f.throwIfAborted(),!1;const h=xv(t,s),g=Math.min(h,d);return g>0&&await new Promise((m,S)=>{var T,L;const v=()=>{var I;clearTimeout(E),(I=s.signal)==null||I.removeEventListener("abort",v),S(s.signal.reason)},E=setTimeout(()=>{var I;(I=s.signal)==null||I.removeEventListener("abort",v),m()},g);s.unref&&((T=E.unref)==null||T.call(E)),(L=s.signal)==null||L.addEventListener("abort",v,{once:!0})}),(y=s.signal)==null||y.throwIfAborted(),!0}async function _v(r,e={}){var i,o,a;if(e={...e},vv(e.retries),Object.hasOwn(e,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");e.retries??(e.retries=10),e.factor??(e.factor=2),e.minTimeout??(e.minTimeout=1e3),e.maxTimeout??(e.maxTimeout=Number.POSITIVE_INFINITY),e.maxRetryTime??(e.maxRetryTime=Number.POSITIVE_INFINITY),e.randomize??(e.randomize=!1),e.onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.shouldConsumeRetry??(e.shouldConsumeRetry=()=>!0),hi("factor",e.factor,{min:0,allowInfinity:!1}),hi("minTimeout",e.minTimeout,{min:0,allowInfinity:!1}),hi("maxTimeout",e.maxTimeout,{min:0,allowInfinity:!0}),hi("maxRetryTime",e.maxRetryTime,{min:0,allowInfinity:!0}),e.factor>0||(e.factor=1),(i=e.signal)==null||i.throwIfAborted();let t=0,n=0;const s=performance.now();for(;!Number.isFinite(e.retries)||n<=e.retries;){t++;try{(o=e.signal)==null||o.throwIfAborted();const c=await r(t);return(a=e.signal)==null||a.throwIfAborted(),c}catch(c){await Av({error:c,attemptNumber:t,retriesConsumed:n,startTime:s,options:e})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class Cv{constructor(e,t={}){l(this,"log");l(this,"queue");l(this,"started");l(this,"peerStore");l(this,"retries");l(this,"retryInterval");l(this,"backoffFactor");l(this,"connectionManager");l(this,"events");this.log=e.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.queue=new e0({concurrency:t.maxParallelReconnects??VE,metricName:"libp2p_reconnect_queue",metrics:e.metrics}),this.started=!1,this.retries=t.retries??5,this.backoffFactor=t.backoffFactor,this.retryInterval=t.retryInterval,this.events=e.events,e.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(e){if(!this.started)return;const t=await this.peerStore.get(e);Hd(t)&&(this.queue.has(e)||this.queue.add(async n=>{await _v(async s=>{if(this.started)try{await this.connectionManager.openConnection(e,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",e,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:e}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",e,n);const s={};[...t.tags.keys()].forEach(i=>{i.startsWith(cc)&&(s[i]=void 0)}),await this.peerStore.merge(e,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:e})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",e,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>Hd(t)]});await Promise.all(e.map(async t=>{await this.connectionManager.openConnection(t.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(e=>{this.log.error("error reconnect to peers after start - %e",e)})}stop(){this.started=!1,this.queue.abort()}}function Hd(r){for(const e of r.tags.keys())if(e.startsWith(cc))return!0;return!1}const Gd=50,Ca={maxConnections:YE,inboundConnectionThreshold:KE,maxIncomingPendingConnections:qE};af=Symbol.toStringTag;class Iv{constructor(e,t={}){l(this,"started");l(this,"connections");l(this,"allow");l(this,"deny");l(this,"maxIncomingPendingConnections");l(this,"incomingPendingConnections");l(this,"outboundPendingConnections");l(this,"maxConnections");l(this,"dialQueue");l(this,"reconnectQueue");l(this,"connectionPruner");l(this,"inboundConnectionRateLimiter");l(this,"peerStore");l(this,"metrics");l(this,"events");l(this,"log");l(this,"peerId");l(this,af,"@libp2p/connection-manager");var n;if(this.maxConnections=t.maxConnections??Ca.maxConnections,this.maxConnections<1)throw new V("Connection Manager maxConnections must be greater than 0");this.connections=new Ar,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(t.allow??[]).map(s=>_a(ce(s))),this.deny=(t.deny??[]).map(s=>_a(ce(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Ca.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new n0({points:t.inboundConnectionThreshold??Ca.inboundConnectionThreshold,duration:1}),this.connectionPruner=new UE({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{allow:(n=t.allow)==null?void 0:n.map(s=>ce(s))}),this.dialQueue=new pv(e,{addressSorter:t.addressSorter,maxParallelDials:t.maxParallelDials??Bd,maxDialQueueLength:t.maxDialQueueLength??Od,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Nd,dialTimeout:t.dialTimeout??Rd,resolvers:t.resolvers??{dnsaddr:qd},connections:this.connections}),this.reconnectQueue=new Cv({events:e.events,peerStore:e.peerStore,logger:e.logger,connectionManager:this},{retries:t.reconnectRetries,retryInterval:t.reconnectRetryInterval,backoffFactor:t.reconnectBackoffFactor,maxParallelReconnects:t.maxParallelReconnects})}async start(){var e,t,n;(e=this.metrics)==null||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(t=this.metrics)==null||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const u of a.streams){const d=`${u.direction} ${u.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[u,d]of Object.entries(c))s[u]=s[u]??[],s[u].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((u,d)=>u-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Gf(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Yf(this.reconnectQueue,this.dialQueue,this.connectionPruner);const e=[];for(const t of this.connections.values())for(const n of t)e.push(Promise.all([Oe(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(e){if(this.maxConnections<1)throw new V("Connection Manager maxConnections must be greater than 0");let t=!1;e<this.maxConnections&&(t=!0),this.maxConnections=e,t&&this.connectionPruner.maybePruneConnections()}onConnect(e){this._onConnect(e).catch(t=>{this.log.error("could not connect - %e",t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}if(t.status!=="open")return;const n=t.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(t),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e,n=t.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==t.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const n of this.connections.values())t=t.concat(n);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){var n,s;if(!this.started)throw new Jn("Not started");this.outboundPendingConnections++;try{(n=t.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=Pd(e);if(this.peerId.equals(i))throw new Ki("Can not dial self");if(i!=null&&t.force!==!0){this.log("dial %p",i);const d=kd(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=t.onProgress)==null||s.call(t,new Se("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(e,{...t,priority:t.priority??Gd});if(a.status!=="open")throw new Yr("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let u=!1;for(const d of c)if(d.id===a.id&&(u=!0),t.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new Xr("Duplicate multiaddr connection")),d;return u||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(e,t,n={}){return(await this.openConnection(e,n)).newStream(t,n)}async closeConnections(e,t={}){const n=this.connections.get(e)??[];await Promise.all(n.map(async s=>{try{await Promise.all([Oe(s,"close",t),s.close(t)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(e){if(this.deny.some(s=>{if(st(e.remoteAddr)){const i=de(e.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>{if(st(e.remoteAddr)){const i=de(e.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(st(e.remoteAddr)){const s=de(e.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(n=>ce(n))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}const Lv=1e4,Tv="1.0.0",Pv="ping",Dv="ipfs",Yd=32,kv=!0;lf=Symbol.toStringTag,cf=Gt;class Rv{constructor(e,t={}){l(this,"protocol");l(this,"components");l(this,"log");l(this,"heartbeatInterval");l(this,"pingIntervalMs");l(this,"abortController");l(this,"timeout");l(this,"abortConnectionOnPingFailure");l(this,lf,"@libp2p/connection-monitor");l(this,cf,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??Dv}/${Pv}/${Tv}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??Lv,this.abortConnectionOnPingFailure=t.abortConnectionOnPingFailure??kv,this.timeout=new Jw({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{var n;let t=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await e.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=ku(i);t=Date.now(),await Promise.all([o.write(Sl(Yd),{signal:s}),o.read({bytes:Yd,signal:s})]),e.rtt=Date.now()-t,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat - %e",t),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),e.abort(t)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var e;(e=this.abortController)==null||e.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}uf=Symbol.toStringTag;class Mv{constructor(e,t){l(this,"routers");l(this,"started");l(this,"components");l(this,uf,"@libp2p/content-routing");var n,s,i,o,a;this.routers=t.routers??[],this.started=!1,this.components=e,this.findProviders=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()}),getAttributesFromYieldedValue:(c,u)=>({...u,providers:[...Array.isArray(u.providers)?u.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=e.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=e.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:Q(c,"base36")})}))??this.put,this.get=((a=e.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:Q(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new Aa("No content routers available");const n=this,s=new In;for await(const i of na(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new Aa("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(e,t)}))}async cancelReprovide(e,t={}){if(this.routers.length===0)throw new Aa("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(e,t)}))}async put(e,t,n){if(!this.isStarted())throw new Jn;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(e,t,n)}))}async get(e,t){if(!this.isStarted())throw new Jn;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(e,t)))}}const fi=globalThis.CustomEvent??Event;async function*Nv(r,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const n=e.ordered??!1,s=new EventTarget,i=[];let o=Je(),a=Je(),c=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const f of r){if(i.length===t&&(o=Je(),await o.promise),d)break;const y={done:!1};i.push(y),f().then(m=>{y.done=!0,y.ok=!0,y.value=m,s.dispatchEvent(new fi("task-complete"))},m=>{y.done=!0,y.err=m,s.dispatchEvent(new fi("task-complete"))})}c=!0,s.dispatchEvent(new fi("task-complete"))}catch(f){u=f,s.dispatchEvent(new fi("task-complete"))}});function h(){var f;return n?(f=i[0])==null?void 0:f.done:!!i.find(y=>y.done)}function*g(){for(;i.length>0&&i[0].done;){const f=i[0];if(i.shift(),f.ok)yield f.value;else throw d=!0,o.resolve(),f.err;o.resolve()}}function*p(){for(;h();)for(let f=0;f<i.length;f++)if(i[f].done){const y=i[f];if(i.splice(f,1),f--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(h()||(a=Je(),await a.promise),u!=null||(n?yield*g():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}df=Symbol.toStringTag;class Ov{constructor(e,t={}){l(this,"log");l(this,"peerId");l(this,"peerStore");l(this,"routers");l(this,df,"@libp2p/peer-routing");var n,s;this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[],this.findPeer=((n=e.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=e.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:Q(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(e,t){if(this.routers.length===0)throw new Ld("No peer routers available");if(e.toString()===this.peerId.toString())throw new bE("Should not try to find self");const n=this,s=na(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),i;throw new zi}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new Ld("No peer routers available");const n=this,s=Vl(1024);for await(const i of Nv(async function*(){const o=na(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...t,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},t),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}function Bv(r){return r.reason}async function Ia(r,e,t){if(e==null)return r;const n=Bv;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}class Fv extends(ff=ut,hf=Symbol.toStringTag,ff){constructor(t){super();l(this,"peerRouting");l(this,"log");l(this,"walking");l(this,"walkers");l(this,"shutdownController");l(this,"walkController");l(this,"needNext");l(this,hf,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(t){var s,i;this.walking||this.startWalk(),this.walkers++;const n=Dn([this.shutdownController.signal,t==null?void 0:t.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=Je(),yield(await Oe(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const t=Dn([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Sl(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Ia(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const Xd=32,Zd=64;gf=Symbol.toStringTag;class $v{constructor(e){l(this,"log");l(this,"topologies");l(this,"handlers");l(this,"components");l(this,"middleware");l(this,gf,"@libp2p/registrar");var t;this.components=e,this.log=e.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(t=e.metrics)==null||t.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=Et({name:"libp2p_registrar_protocol_handlers",metrics:e.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new EE(`No handler registered for protocol ${e}`);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,n){if(this.handlers.has(e)&&(n==null?void 0:n.force)!==!0)throw new vE(`Handler already registered for protocol ${e}`);this.handlers.set(e,{handler:t,options:{maxInboundStreams:Xd,maxOutboundStreams:Zd,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]},n)}async unhandle(e,t){(Array.isArray(e)?e:[e]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},t)}async register(e,t){if(t==null)throw new V("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(n,t),n}unregister(e){for(const[t,n]of this.topologies.entries())n.has(e)&&(n.delete(e),n.size===0&&this.topologies.delete(t))}use(e,t){this.middleware.set(e,t)}unuse(e){this.middleware.delete(e)}getMiddleware(e){return this.middleware.get(e)??[]}async _onDisconnect(e){const t=e.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(t,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(t))!==!1&&((u=a.filter)==null||u.remove(t),await((d=a.onDisconnect)==null?void 0:d.call(a,t)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",t,s)}}async _onPeerUpdate(e){const{peer:t,previous:n}=e.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!t.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(t.id))!==!1&&((u=a.filter)==null||u.remove(t.id),await((d=a.onDisconnect)==null?void 0:d.call(a,t.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",t.id,i)}}async _onPeerIdentify(e){const t=e.detail.protocols,n=e.detail.connection,s=e.detail.peerId;try{for(const i of t){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((u=a.filter)==null||u.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}mf=Symbol.toStringTag;class Uv{constructor(e,t={}){l(this,"log");l(this,"components");l(this,"transports");l(this,"listeners");l(this,"faultTolerance");l(this,"started");l(this,mf,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=Et({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Et({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Jr.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new V("Transport must have a valid tag");if(this.transports.has(t))throw new V(`There is already a transport with the tag ${t}`);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,n]of this.listeners)for(this.log("closing listeners for %s",t);n.length>0;){const s=n.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){var s;const n=this.dialTransportForMultiaddr(e);if(n==null)throw new IE(`No transport available for address ${String(e)}`);return(s=t==null?void 0:t.onProgress)==null||s.call(t,new Se("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(e,{...t,upgrader:this.components.upgrader})}getAddrs(){let e=[];for(const t of this.listeners.values())for(const n of t)e=[...e,...n.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new Jn("Not started");if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};e.forEach(i=>{t.errors.set(i.toString(),new SE)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(e);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(g=>g===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),pd.matches(c)?t.ipv4.attempts++:yd.matches(c)&&t.ipv6.attempts++,n.push(u.listen(c).then(()=>{t.errors.delete(c.toString()),pd.matches(c)&&t.ipv4.success++,yd.matches(c)&&t.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,h),t.errors.set(c.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(t)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Jr.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new xE(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...t.errors.entries()].map(([i,o])=>`
  ${i}: ${`${zv(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(e){if(e.ipv4.attempts===0||e.ipv6.attempts===0)return!1;const t=e.ipv4.attempts===e.ipv4.success,n=e.ipv6.success===0;return t&&n}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const n=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}function zv(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const dn="/multistream/1.0.0",Qd=1024,Kv=H(`
`);async function La(r,e){const n=(await r.read(e)).subarray();if(n.byteLength===0||n[n.length-1]!==Kv[0])throw new lt("Missing newline");return Q(n).trimEnd()}async function Ta(r,e,t={}){if(e=Array.isArray(e)?[...e]:[e],e.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=Pr(r,{...t,maxDataLength:Qd});for(let i=0;i<e.length;i++){const o=e[i];let a;if(i===0){n.trace('write ["%s", "%s"]',dn,o);const c=H(`${dn}
`),u=H(`${o}
`);if(await s.writeV([c,u],t),n.trace("reading multistream-select header"),a=await La(s,t),n.trace('read "%s"',a),a!==dn){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(H(`${o}
`),t);if(n.trace("reading protocol response"),a=await La(s,t),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new sc(`Protocol selection failed - could not negotiate ${e}`)}async function Pa(r,e,t={}){e=Array.isArray(e)?e:[e];const n=r.log.newScope("mss:handle"),s=Pr(r,{...t,maxDataLength:Qd,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await La(s,t);if(n.trace('read "%s"',i),i===dn){n.trace('respond with "%s" for "%s"',dn,i),await s.write(H(`${dn}
`),t),n.trace('responded with "%s" for "%s"',dn,i);continue}if(e.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(H(`${i}
`),t),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new Y(...e.map(a=>Gs.single(H(`${a}
`))),H(`
`));n.trace('respond with "%s" for %s',e,i),await s.write(o,t),n.trace('responded with "%s" for %s',e,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(H(`na
`),t),n('responded with "na" for "%s"',i)}}class qv extends(wf=ut,yf=Symbol.toStringTag,pf=ae,wf){constructor(t,n){super();l(this,"id");l(this,"remoteAddr");l(this,"remotePeer");l(this,"direction");l(this,"timeline");l(this,"direct");l(this,"multiplexer");l(this,"encryption");l(this,"limits");l(this,"log");l(this,"maConn");l(this,"muxer");l(this,"components");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"closeTimeout");l(this,yf,"Connection");l(this,pf,!0);l(this,"newStream",async(t,n={})=>{var i;if(this.muxer==null)throw new li("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Yr(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Yr(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new qi("Cannot open protocol stream on limited connection");Array.isArray(t)||(t=[t]),this.log.trace("starting new stream for protocols %s",t);const s=await this.muxer.createStream({...n,protocol:t.length===1?t[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,t);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",t);const u=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:u}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",t),s.protocol=await Ta(s,t,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=Hv(s.protocol,this.components.registrar,n),a=jd(s.protocol,"outbound",this);if(a>o){const u=new Vi(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(u),u}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,t,o),o}});this.components=t,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??di,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??di,this.closeTimeout=n.closeTimeout??Md,this.direct=Dd(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===W)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new jr(s.local,s.error))})}get streams(){var t;return((t=this.muxer)==null?void 0:t.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(t){var i;const n=t.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await Pa(n,h,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=Wv(n.protocol,this.components.registrar);if(jd(n.protocol,"inbound",this)>o)throw new ic(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:u}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&u.runOnLimitedConnection!==!0)throw new qi("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(h,g,p)=>{await c(h,g),p(h,g)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(t,n,s){for(let i=0;i<s.length;i++){const o=s[i];t.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const u=o(t,n,(d,h)=>{t=d,n=h,a()});u instanceof Promise&&u.catch(c)}catch(u){c(u)}}),t.log.trace("ran middleware",i,o)}return t}async close(t={}){var n;if(this.log("closing connection to %a",this.remoteAddr),t.signal==null){const s=AbortSignal.timeout(this.closeTimeout);t={...t,signal:s}}await((n=this.muxer)==null?void 0:n.close(t)),await this.maConn.close(t)}abort(t){var n;(n=this.muxer)==null||n.abort(t),this.maConn.abort(t)}}function Vv(r,e){return new qv(r,e)}function Wv(r,e){try{const{options:t}=e.getHandler(r);if(t.maxInboundStreams!=null)return t.maxInboundStreams}catch(t){if(t.name!=="UnhandledProtocolError")throw t}return Xd}function Hv(r,e,t={}){try{const{options:n}=e.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return t.maxOutboundStreams??Zd}function jd(r,e,t){let n=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===r&&n++}),n}bf=Symbol.toStringTag;class Gv{constructor(e,t){l(this,"components");l(this,"connectionEncrypters");l(this,"streamMuxers");l(this,"inboundUpgradeTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"events");l(this,"metrics");l(this,"connectionCloseTimeout");l(this,bf,"@libp2p/upgrader");var n,s,i,o;this.components=e,this.connectionEncrypters=Et({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),t.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Et({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),t.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??zE,this.inboundStreamProtocolNegotiationTimeout=t.inboundStreamProtocolNegotiationTimeout??di,this.outboundStreamProtocolNegotiationTimeout=t.outboundStreamProtocolNegotiationTimeout??di,this.connectionCloseTimeout=t.connectionCloseTimeout??Md,this.events=e.events,this.metrics={dials:(n=e.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=e.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=e.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=e.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(e,...t){const n=this.components.connectionGater[e];if(n==null)return;if(await n.apply(this.components.connectionGater,t)===!0)throw new _E(`The multiaddr connection is blocked by gater.${e}`)}createInboundAbortSignal(e){return Dn([AbortSignal.timeout(this.inboundUpgradeTimeout),e])}async upgradeInbound(e,t){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(t.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(e),!n)throw new CE("Connection denied");await Ia(this.shouldBlockConnection("denyInboundConnection",e),s),await this._performUpgrade(e,"inbound",{...t,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=e.remoteAddr.getComponents().findLast(d=>d.code===W))==null?void 0:s.value;let c;a!=null&&(c=Bt(a),await Ia(this.shouldBlockConnection("denyOutboundConnection",c,e),t.signal));let u="outbound";return t.initiator===!1&&(u="inbound"),await this._performUpgrade(e,u,t)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(e,t,n){var h,g,p,f;let s=e,i,o,a,c;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(e.log=e.log.newScope(`${t}:${u}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(e),e.log.trace("starting the %s connection upgrade",t),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(e.log("protecting the %s connection",t),s=await y.protect(s,n))}try{if(Yv(n)){if(n.remotePeer==null)throw new Xr(`${t} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(g=e.remoteAddr.getComponents().findLast(S=>S.code===W))==null?void 0:g.value;let m;y!=null&&(m=Bt(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new Se(`upgrader:encrypt-${t}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(t==="inbound"?this._encryptInbound(s,{...n,remotePeer:m}):this._encryptOutbound(s,{...n,remotePeer:m}))}if(i.equals(this.components.peerId)){const y=new Ki("Can not dial self");throw e.abort(y),y}await this.shouldBlockConnection(t==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,e),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((f=n==null?void 0:n.onProgress)==null||f.call(n,new Se(`upgrader:multiplex-${t}-connection`)),o=await(t==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw e.log.error("failed to upgrade %s connection %s %a - %e",t,t==="inbound"?"from":"to",e.remoteAddr,y),y}o!=null&&(e.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(t==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,e);const d=this._createConnection({id:u,cryptoProtocol:c,direction:t,maConn:e,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(e){const t=Vv(this.components,{...e,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return t.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:t})}),this.events.safeDispatchEvent("connection:open",{detail:t}),t}async _encryptInbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{const s=await Pa(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new ui(`no crypto module found for ${s}`);return e.log("encrypting inbound connection using %s",s),{...await i.secureInbound(e,t),protocol:s}}catch(s){throw new ui(s.message)}}async _encryptOutbound(e,t){const n=Array.from(this.connectionEncrypters.keys());try{e.log.trace("selecting encrypter from %s",n);const s=await Ta(e,n,t),i=this.connectionEncrypters.get(s);if(i==null)throw new ui(`no crypto module found for ${s}`);return e.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(e,t),protocol:s}}catch(s){throw new ui(s.message)}}async _multiplexOutbound(e,t,n){const s=Array.from(t.keys());e.log("outbound selecting muxer %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await Ta(e,s,n),o=t.get(i);if(o==null)throw new li(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing outbound connection - %e",i),new li(String(i))}}async _multiplexInbound(e,t,n){const s=Array.from(t.keys());e.log("inbound handling muxers %s",s);try{e.log.trace("selecting stream muxer from %s",s);const i=await Pa(e,s,n),o=t.get(i);if(o==null)throw new li(`No muxer configured for protocol "${i}"`);return e.log("selected %s as muxer protocol",i),o}catch(i){throw e.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function Yv(r){return r.skipEncryption===!0}const Jd="3.0.6",eh="js-libp2p";function Xv(r,e){return`${r??eh}/${e??Jd} browser/${globalThis.navigator.userAgent}`}class Zv extends ut{constructor(t){var d,h,g,p,f,y,m,S,v,E,T;super();ge(this,Vr);l(this,"peerId");l(this,"peerStore");l(this,"contentRouting");l(this,"peerRouting");l(this,"metrics");l(this,"services");l(this,"logger");l(this,"status");l(this,"components");l(this,"log");this.status="stopped";const n=new ut,s=n.dispatchEvent.bind(n);n.dispatchEvent=L=>{const I=s(L),O=this.dispatchEvent(new CustomEvent(L.type,{detail:L.detail}));return I||O},this.peerId=t.peerId,this.logger=t.logger??Bl(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=t.nodeInfo)==null?void 0:d.name)??eh,o=((h=t.nodeInfo)==null?void 0:h.version)??Jd,a=this.components=kE({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:i,version:o,userAgent:((g=t.nodeInfo)==null?void 0:g.userAgent)??Xv(i,o)},logger:this.logger,events:n,datastore:t.datastore??new X0,connectionGater:BE(t.connectionGater),dns:t.dns});t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",K0(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),a.events.addEventListener("peer:update",L=>{if(L.detail.previous==null){const I={id:L.detail.peer.id,multiaddrs:L.detail.peer.addresses.map(O=>O.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:I})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(a)),this.components.upgrader=new Gv(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((L,I)=>this.configureComponent(`connection-encryption-${I}`,L(this.components))),streamMuxers:(t.streamMuxers??[]).map((L,I)=>this.configureComponent(`stream-muxers-${I}`,L(this.components))),inboundUpgradeTimeout:(p=t.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(f=t.connectionManager)==null?void 0:f.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=t.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=t.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new Uv(this.components,t.transportManager)),this.configureComponent("connectionManager",new Iv(this.components,t.connectionManager)),((S=t.connectionMonitor)==null?void 0:S.enabled)!==!1&&this.configureComponent("connectionMonitor",new Rv(this.components,t.connectionMonitor)),this.configureComponent("registrar",new $v(this.components)),this.configureComponent("addressManager",new pE(this.components,t.addresses));const c=(t.peerRouters??[]).map((L,I)=>this.configureComponent(`peer-router-${I}`,L(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new Ov(this.components,{routers:c}));const u=(t.contentRouters??[]).map((L,I)=>this.configureComponent(`content-router-${I}`,L(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Mv(this.components,{routers:u})),this.configureComponent("randomWalk",new Fv(this.components)),(t.peerDiscovery??[]).forEach((L,I)=>{this.configureComponent(`peer-discovery-${I}`,L(this.components)).addEventListener("peer",_=>{ne(this,Vr,Ja).call(this,_)})}),(v=t.transports)==null||v.forEach((L,I)=>{this.components.transportManager.add(this.configureComponent(`transport-${I}`,L(this.components)))}),t.services!=null)for(const L of Object.keys(t.services)){const I=t.services[L],O=I(this.components);if(O==null){this.log.error("service factory %s returned null or undefined instance",L);continue}this.services[L]=O,this.configureComponent(L,O),O[Ee]!=null&&(this.log("registering service %s for content routing",L),u.push(O[Ee])),O[ac]!=null&&(this.log("registering service %s for peer routing",L),c.push(O[ac])),O[oc]!=null&&(this.log("registering service %s for peer discovery",L),(T=(E=O[oc]).addEventListener)==null||T.call(E,"peer",_=>{ne(this,Vr,Ja).call(this,_)}))}RE(a)}configureComponent(t,n){return n==null&&this.log.error("component %s was null or undefined",t),this.components[t]=n,n}async start(){var t,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(t=this.components).beforeStart)==null?void 0:n.call(t)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var t,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(t=this.components).beforeStop)==null?void 0:n.call(t)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new In;for(const n of this.components.connectionManager.getConnections())t.add(n.remotePeer);return Array.from(t)}async dial(t,n={}){return this.components.connectionManager.openConnection(t,{priority:75,...n})}async dialProtocol(t,n,s={}){if(n==null)throw new V("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new V("no protocols were provided to open a stream");return this.components.connectionManager.openStream(t,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,n={}){var s;Vs(t)&&(t=Bt(((s=t.getComponents().findLast(i=>i.code===W))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(t,n)}async getPublicKey(t,n={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const a=await this.peerStore.get(t,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=It([H("/pk/"),t.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Ot(i);return await this.peerStore.patch(t,{publicKey:o},n),o}async handle(t,n,s){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(t,n){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(t,n,s){return this.components.registrar.register(t,n,s)}unregister(t){this.components.registrar.unregister(t)}use(t,n){this.components.registrar.use(t,Array.isArray(n)?n:[n])}unuse(t){this.components.registrar.unuse(t)}async isDialable(t,n={}){return this.components.connectionManager.isDialable(t,n)}}Vr=new WeakSet,Ja=function(t){const{detail:n}=t;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function Qv(r={}){r.privateKey??(r.privateKey=await Ry());const e=new Zv({...await zy(r),peerId:Fy(r.privateKey)});return r.start!==!1&&await e.start(),e}var Ge;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let e;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(e||(e={})),function(n){n.codec=()=>Ro(e)}(r.Flag||(r.Flag={}));let t;r.codec=()=>(t==null&&(t=ze((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ue(n,r.codec()),r.decode=(n,s)=>$e(n,r.codec(),s)})(Ge||(Ge={}));const jv=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const Jv=2*1024*1024,th=16*1024;function e1(r=th){const e=Le(r-Le(r)),t=1+Le(Object.keys(Ge.Flag).length-1),n=1,s=r-e-t-n,i=Le(s);return e+t+n+i}const t1=e1(),n1=1e4,nh="/webrtc",Da="/webrtc-signaling/0.0.1";function r1(r){return r.reason}async function s1(r,e,t){if(e==null)return r;const n=r1;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}var rh=function(r,e,t){if(t||arguments.length===2)for(var n=0,s=e.length,i;n<s;n++)(i||!(n in e))&&(i||(i=Array.prototype.slice.call(e,0,n)),i[n]=e[n]);return r.concat(i||Array.prototype.slice.call(e))},i1=function(){function r(e,t,n){this.name=e,this.version=t,this.os=n,this.type="browser"}return r}(),o1=function(){function r(e){this.version=e,this.type="node",this.name="node",this.os=process.platform}return r}(),a1=function(){function r(e,t,n,s){this.name=e,this.version=t,this.os=n,this.bot=s,this.type="bot-device"}return r}(),c1=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),l1=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),u1=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,d1=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,sh=3,h1=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",u1]],ih=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function f1(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new l1:typeof navigator<"u"?m1(navigator.userAgent):y1()}function g1(r){return r!==""&&h1.reduce(function(e,t){var n=t[0],s=t[1];if(e)return e;var i=s.exec(r);return!!i&&[n,i]},!1)}function m1(r){var e=g1(r);if(!e)return null;var t=e[0],n=e[1];if(t==="searchbot")return new c1;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<sh&&(s=rh(rh([],s,!0),w1(sh-s.length),!0)):s=[];var i=s.join("."),o=p1(r),a=d1.exec(r);return a&&a[1]?new a1(t,i,o,a[1]):new i1(t,i,o)}function p1(r){for(var e=0,t=ih.length;e<t;e++){var n=ih[e],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function y1(){var r=typeof process<"u"&&process.version;return r?new o1(process.version.slice(1)):null}function w1(r){for(var e=[],t=0;t<r;t++)e.push("0");return e}const oh=f1(),b1=oh!=null&&oh.name==="firefox";async function ah(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??jv.map(e=>({urls:[e]})),r}class E1 extends lu{constructor(t){super({...t,maxMessageSize:(t.maxMessageSize??th)-t1});l(this,"channel");l(this,"incomingData");l(this,"maxBufferedAmount");l(this,"receivedFinAck");l(this,"finAckTimeout");this.channel=t.channel,this.channel.binaryType="arraybuffer",this.incomingData=Os(),this.maxBufferedAmount=t.maxBufferedAmount??Jv,this.finAckTimeout=t.finAckTimeout??n1,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=s=>{const i=s.error;this.log.trace("received datachannel error event - %e",i),this.abort(i)},this.channel.onmessage=async s=>{this.log("incoming message %d bytes",s.data.byteLength);const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const s of aa(this.incomingData))this.processIncomingProtobuf(s)}).catch(s=>{this.log.error("error processing incoming data channel messages - %e",s)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),Oe(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(s=>{this.abort(s.error??s)}))}sendNewStream(){}_sendMessage(t){if(this.channel.readyState!=="open")throw new Ht(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),b1){this.channel.send(t.subarray());return}for(const n of t)this.channel.send(n)}sendData(t){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(Gs.single(Ge.encode({message:t.subarray()}))),{sentBytes:t.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(t){var n;try{this.log.error("sending reset - %e",t),this._sendFlag(Ge.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(t)}catch(s){this.log.error("failed to send reset - %e",s)}}async sendCloseWrite(t){var i;this._sendFlag(Ge.Flag.FIN),(i=t==null?void 0:t.signal)==null||i.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(t==null?void 0:t.signal)??AbortSignal.timeout(this.finAckTimeout),s=[Oe(this.channel,"close",{signal:n}),Oe(this.channel,"error",{signal:n})];await Promise.any([s1(this.receivedFinAck.promise,n),...s]).finally(()=>{s.forEach(o=>o.cancel())})}async sendCloseRead(t){var n;this._sendFlag(Ge.Flag.STOP_SENDING),(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}processIncomingProtobuf(t){var s,i;const n=Ge.decode(t);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new Y(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===Ge.Flag.FIN&&(this._sendFlag(Ge.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===Ge.Flag.RESET&&((s=this.receivedFinAck)==null||s.reject(new $i("The stream was reset")),this.onRemoteReset()),n.flag===Ge.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===Ge.Flag.FIN_ACK&&((i=this.receivedFinAck)==null||i.resolve()))}_sendFlag(t){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',t.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",t.toString());const n=Ge.encode({flag:t}),s=Gs.single(n);try{return this._sendMessage(s),!0}catch(i){this.log.error("could not send flag %s - %e",t.toString(),i)}return!1}sendPause(){}sendResume(){}}function ch(r){const{channel:e,direction:t,isHandshake:n}=r;return new E1({...r,id:`${e.id}`,log:r.log.newScope(`${n===!0?"handshake":t}:${e.id}`),protocol:""})}class lh{constructor(e){l(this,"protocol");l(this,"peerConnection");l(this,"metrics");l(this,"dataChannelOptions");l(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=e.peerConnection,this.metrics=e.metrics,this.protocol=e.protocol??nh,this.dataChannelOptions=e.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(e){this.earlyDataChannels.push(e.channel)}createStreamMuxer(e){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new v1(e,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class v1 extends cu{constructor(t,n){super(t,{...n,name:"muxer"});l(this,"peerConnection");l(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??nh,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:s})=>{this.onDataChannel(s)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(s=>{s.close()});return}n.earlyDataChannels.forEach(s=>{this.onDataChannel(s)})})}onDataChannel(t){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",t.id,t.protocol,t.readyState),t.label==="init"){this.log.trace("closing init channel %d",t.id),t.close();return}const n=ch({...this.streamOptions,...this.dataChannelOptions,channel:t,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(t){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,t==null?void 0:t.protocol),ch({...t,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class S1 extends Hw{constructor(t){super(t);l(this,"peerConnection");this.peerConnection=t.peerConnection;const n=t.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(t){return{sentBytes:t.byteLength,canSendMore:!0}}async sendClose(t){var n;this.peerConnection.close(),(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const uh=r=>new S1(r),dh=globalThis.RTCPeerConnection,hh=globalThis.RTCSessionDescription,x1=globalThis.RTCIceCandidate;class A1 extends Error{constructor(e){super(`WebRTC transport error: ${e}`),this.name="WebRTCTransportError"}}class $t extends A1{constructor(e="SDP handshake failed"){super(e),this.name="SDPHandshakeFailedError"}}var it;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let e;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(e||(e={})),function(n){n.codec=()=>Ro(e)}(r.Type||(r.Type={}));let t;r.codec=()=>(t==null&&(t=ze((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),t),r.encode=n=>Ue(n,r.codec()),r.decode=(n,s)=>$e(n,r.codec(),s)})(it||(it={}));const fh=async(r,e,t)=>{var n,s,i,o;try{const a=Promise.withResolvers();for(_1(r,a);;){const c=await Promise.race([a.promise,e.read({signal:t.signal})]);if(c==null){(n=t.signal)==null||n.throwIfAborted();break}if(c.type!==it.Type.ICE_CANDIDATE)throw new lt("ICE candidate message expected");const u=JSON.parse(c.data??"null");if(u===""||u===null){(s=t.onProgress)==null||s.call(t,new Se("webrtc:end-of-ice-candidates")),t.log.trace("end-of-candidates received");continue}const d=new x1(u);t.log.trace("%s received new ICE candidate %o",t.direction,u);try{(i=t.onProgress)==null||i.call(t,new Se("webrtc:add-ice-candidate",d.candidate)),await r.addIceCandidate(d)}catch(h){t.log.error("%s bad candidate received %o - %e",t.direction,u,h)}}}catch(a){if(t.log.error("%s error parsing ICE candidate - %e",t.direction,a),((o=t.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function _1(r,e){if(r.connectionState==="connected"){e.resolve();return}r.onconnectionstatechange=t=>{switch(r.connectionState){case"connected":e.resolve();break;case"failed":case"disconnected":case"closed":e.reject(new tc(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function gh(r){let e;for(const t of r.getComponents())t.name==="p2p"&&(e=Bt(t.value??""));if(e==null)throw new Xr("Remote peerId must be present in multiaddr");return e}async function C1({rtcConfiguration:r,dataChannel:e,signal:t,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:d,targetPeer:h}=T1(s);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",d);const g=i.getConnections(h);let p;g.length===0?(u==null||u(new Se("webrtc:dial-relay")),p=await o.dial(d,{signal:t,onProgress:u})):(u==null||u(new Se("webrtc:reuse-relay-connection")),p=g[0]),u==null||u(new Se("webrtc:open-signaling-stream"));const f=await p.newStream(Da,{signal:t,runOnLimitedConnection:!0}),y=Ws(f).pb(it),m=new dh(r);m.addEventListener("connectionstatechange",()=>{switch(m.connectionState){case"closed":m.close();break}});const S=new lh({peerConnection:m,dataChannelOptions:e});try{const v=m.createDataChannel("init");m.onicecandidate=({candidate:I})=>{if(m.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(I==null||(I==null?void 0:I.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const O=JSON.stringify((I==null?void 0:I.toJSON())??null);a.trace("initiator sending ICE candidate %o",I),y.write({type:it.Type.ICE_CANDIDATE,data:O},{signal:t}).catch(_=>{a.error("error sending ICE candidate - %e",_)})},m.onicecandidateerror=I=>{a.error("initiator ICE candidate error",I)};const E=await m.createOffer().catch(I=>{throw a.error("could not execute createOffer - %e",I),new $t("Failed to set createOffer")});a.trace("initiator send SDP offer %s",E.sdp),u==null||u(new Se("webrtc:send-sdp-offer")),await y.write({type:it.Type.SDP_OFFER,data:E.sdp},{signal:t}),await m.setLocalDescription(E).catch(I=>{throw a.error("could not execute setLocalDescription - %e",I),new $t("Failed to set localDescription")}),u==null||u(new Se("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const T=await y.read({signal:t});if(T.type!==it.Type.SDP_ANSWER)throw new $t("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",T.data);const L=new hh({type:"answer",sdp:T.data});return await m.setRemoteDescription(L).catch(I=>{throw a.error("could not execute setRemoteDescription - %e",I),new $t("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u==null||u(new Se("webrtc:read-ice-candidates")),await fh(m,y,{direction:"initiator",signal:t,log:a,onProgress:u}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await Oe(v,"open",{signal:t})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await Oe(v,"close",{signal:t}),u==null||u(new Se("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await f.close({signal:t}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:m,muxerFactory:S}}catch(v){throw a.error("outgoing signaling error - %e",v),m.close(),f.abort(v),v}finally{m.onicecandidate=null,m.onicecandidateerror=null}}const mh=fe(nE.matchers[0],he(Ks));class ka extends ut{constructor(t,n){super();l(this,"transportManager");l(this,"shutdownController");l(this,"events");this.transportManager=t.transportManager,this.events=t.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(t){t.detail.getAddrs().filter(s=>mh.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(t=>!(t instanceof ka)).map(t=>t.getAddrs().filter(n=>mh.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function I1(r,e,{peerConnection:t,signal:n,log:s}){s.trace("new inbound signaling stream");const i=Ws(r).pb(it);try{t.onicecandidate=({candidate:h})=>{if(t.connectionState==="connected"){s.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){s.trace("recipient detected end of ICE candidates");return}const g=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",g),i.write({type:it.Type.ICE_CANDIDATE,data:g},{signal:n}).catch(p=>{s.error("error sending ICE candidate - %e",p)})},s.trace("recipient read SDP offer");const c=await i.read({signal:n});if(c.type!==it.Type.SDP_OFFER)throw new $t(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);s.trace("recipient received SDP offer %s",c.data);const u=new hh({type:"offer",sdp:c.data});await t.setRemoteDescription(u).catch(h=>{throw s.error("could not execute setRemoteDescription - %e",h),new $t("Failed to set remoteDescription")});const d=await t.createAnswer().catch(h=>{throw s.error("could not execute createAnswer - %e",h),new $t("Failed to create answer")});s.trace("recipient send SDP answer %s",d.sdp),await i.write({type:it.Type.SDP_ANSWER,data:d.sdp},{signal:n}),await t.setLocalDescription(d).catch(h=>{throw s.error("could not execute setLocalDescription - %e",h),new $t("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await fh(t,i,{direction:"recipient",signal:n,log:s})}catch(c){if(t.connectionState!=="connected")throw s.error("error while handling signaling stream from peer %a - %e",e.remoteAddr,c),t.close(),c;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",e.remoteAddr,c)}const o=gh(e.remoteAddr),a=ce(`/webrtc/p2p/${o}`);return s.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}xf=Xf,Sf=Symbol.toStringTag,vf=Gt,Ef=Gi;class L1{constructor(e,t={}){l(this,"components");l(this,"init");l(this,"log");l(this,"_started",!1);l(this,"metrics");l(this,"shutdownController");l(this,xf,!0);l(this,Sf,"@libp2p/webrtc");l(this,vf,["@libp2p/transport"]);l(this,Ef,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=e,this.init=t,this.log=e.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,e.metrics!=null&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:e.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(Da,(e,t)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(e,t,n).catch(s=>{this.log.error("failed to handle incoming connect from %p - %e",t.remotePeer,s)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Da),this._started=!1}createListener(e){return new ka(this.components,{shutdownController:this.shutdownController})}listenFilter(e){return e.filter(Sa.exactMatch)}dialFilter(e){return this.listenFilter(e)}async dial(e,t){var c;this.log.trace("dialing address: %a",e);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await C1({rtcConfiguration:await ah(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:e,dataChannelOptions:this.init.dataChannel,signal:t.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:t.onProgress}),o=uh({peerConnection:s,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await t.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:gh(e),muxerFactory:i,onProgress:t.onProgress,signal:t.signal});return this._closeOnShutdown(s,o),a}async _onProtocol(e,t,n){var o;const s=new dh(await ah(this.init.rtcConfiguration));s.addEventListener("connectionstatechange",()=>{switch(s.connectionState){case"closed":s.close();break}});const i=new lh({peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await I1(e,t,{peerConnection:s,signal:n,log:this.log});await e.close({signal:n});const u=uh({peerConnection:s,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(u,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:i,signal:n}),this._closeOnShutdown(s,u)}catch(a){throw this.log.error("incoming signaling error - %e",a),s.close(),e.abort(a),a}}_closeOnShutdown(e,t){const n=()=>{t.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",s)})};this.shutdownController.signal.addEventListener("abort",n),e.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function T1(r){const e=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(e==null)throw new V("Destination peer id was missing");return{circuitAddress:ce(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:Bt(e)}}const Nr=65535,ph=Nr-16,Or=!!((_f=(Af=globalThis.process)==null?void 0:Af.env)!=null&&_f.DUMP_SESSION_KEYS),yh=16;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function P1(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ra(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function Ma(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ve(r,e,t=""){const n=P1(r),s=r==null?void 0:r.length,i=e!==void 0;if(!n||i&&s!==e){const o=t&&`"${t}" `,a=i?` of length ${e}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function wh(r,e=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(e&&r.finished)throw new Error("Hash#digest() has already been called")}function D1(r,e){Ve(r,void 0,"output");const t=e.outputLen;if(r.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function Ut(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function zn(...r){for(let e=0;e<r.length;e++)r[e].fill(0)}function k1(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const R1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function M1(r,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(r,e)}function N1(r,e){if(r.length!==e.length)return!1;let t=0;for(let n=0;n<r.length;n++)t|=r[n]^e[n];return t===0}const O1=(r,e)=>{function t(n,...s){if(Ve(n,void 0,"key"),!R1)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const d=s[0];Ve(d,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const i=r.tagLength;i&&s[1]!==void 0&&Ve(s[1],void 0,"AAD");const o=e(n,...s),a=(d,h)=>{if(h!==void 0){if(d!==2)throw new Error("cipher output not supported");Ve(h,void 0,"output")}};let c=!1;return{encrypt(d,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ve(d),a(o.encrypt.length,h),o.encrypt(d,h)},decrypt(d,h){if(Ve(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return a(o.decrypt.length,h),o.decrypt(d,h)}}}return Object.assign(t,r),t};function bh(r,e,t=!0){if(e===void 0)return new Uint8Array(r);if(e.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+e.length);if(t&&!F1(e))throw new Error("invalid output, must be aligned");return e}function B1(r,e,t){Ra(t);const n=new Uint8Array(16),s=k1(n);return s.setBigUint64(0,BigInt(e),t),s.setBigUint64(8,BigInt(r),t),n}function F1(r){return r.byteOffset%4===0}function gi(r){return Uint8Array.from(r)}const Eh=r=>Uint8Array.from(r.split(""),e=>e.charCodeAt(0)),$1=Eh("expand 16-byte k"),U1=Eh("expand 32-byte k"),z1=Ut($1),K1=Ut(U1);function j(r,e){return r<<e|r>>>32-e}function Na(r){return r.byteOffset%4===0}const mi=64,q1=16,vh=2**32-1,Sh=Uint32Array.of();function V1(r,e,t,n,s,i,o,a){const c=s.length,u=new Uint8Array(mi),d=Ut(u),h=Na(s)&&Na(i),g=h?Ut(s):Sh,p=h?Ut(i):Sh;for(let f=0;f<c;o++){if(r(e,t,n,d,o,a),o>=vh)throw new Error("arx: counter overflow");const y=Math.min(mi,c-f);if(h&&y===mi){const m=f/4;if(f%4!==0)throw new Error("arx: invalid block position");for(let S=0,v;S<q1;S++)v=m+S,p[v]=g[v]^d[S];f+=mi;continue}for(let m=0,S;m<y;m++)S=f+m,i[S]=s[S]^u[m];f+=y}}function W1(r,e){const{allowShortKeys:t,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=M1({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof r!="function")throw new Error("core must be a function");return Ma(s),Ma(o),Ra(i),Ra(t),(a,c,u,d,h=0)=>{Ve(a,void 0,"key"),Ve(c,void 0,"nonce"),Ve(u,void 0,"data");const g=u.length;if(d===void 0&&(d=new Uint8Array(g)),Ve(d,void 0,"output"),Ma(h),h<0||h>=vh)throw new Error("arx: counter overflow");if(d.length<g)throw new Error(`arx: output (${d.length}) is shorter than data (${g})`);const p=[];let f=a.length,y,m;if(f===32)p.push(y=gi(a)),m=K1;else if(f===16&&t)y=new Uint8Array(32),y.set(a),y.set(a,16),m=z1,p.push(y);else throw Ve(a,32,"arx key"),new Error("invalid key size");Na(c)||p.push(c=gi(c));const S=Ut(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,S,Ut(c.subarray(0,16)),S),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const T=new Uint8Array(12);T.set(c,i?0:12-c.length),c=T,p.push(c)}const E=Ut(c);return V1(r,m,S,E,u,d,h,o),zn(...p),d}}function Pe(r,e){return r[e++]&255|(r[e++]&255)<<8}class H1{constructor(e){l(this,"blockLen",16);l(this,"outputLen",16);l(this,"buffer",new Uint8Array(16));l(this,"r",new Uint16Array(10));l(this,"h",new Uint16Array(10));l(this,"pad",new Uint16Array(8));l(this,"pos",0);l(this,"finished",!1);e=gi(Ve(e,32,"key"));const t=Pe(e,0),n=Pe(e,2),s=Pe(e,4),i=Pe(e,6),o=Pe(e,8),a=Pe(e,10),c=Pe(e,12),u=Pe(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=Pe(e,16+2*d)}process(e,t,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],d=o[3],h=o[4],g=o[5],p=o[6],f=o[7],y=o[8],m=o[9],S=Pe(e,t+0),v=Pe(e,t+2),E=Pe(e,t+4),T=Pe(e,t+6),L=Pe(e,t+8),I=Pe(e,t+10),O=Pe(e,t+12),_=Pe(e,t+14);let C=i[0]+(S&8191),F=i[1]+((S>>>13|v<<3)&8191),U=i[2]+((v>>>10|E<<6)&8191),R=i[3]+((E>>>7|T<<9)&8191),M=i[4]+((T>>>4|L<<12)&8191),w=i[5]+(L>>>1&8191),b=i[6]+((L>>>14|I<<2)&8191),A=i[7]+((I>>>11|O<<5)&8191),P=i[8]+((O>>>8|_<<8)&8191),k=i[9]+(_>>>5|s),x=0,N=x+C*a+F*(5*m)+U*(5*y)+R*(5*f)+M*(5*p);x=N>>>13,N&=8191,N+=w*(5*g)+b*(5*h)+A*(5*d)+P*(5*u)+k*(5*c),x+=N>>>13,N&=8191;let D=x+C*c+F*a+U*(5*m)+R*(5*y)+M*(5*f);x=D>>>13,D&=8191,D+=w*(5*p)+b*(5*g)+A*(5*h)+P*(5*d)+k*(5*u),x+=D>>>13,D&=8191;let B=x+C*u+F*c+U*a+R*(5*m)+M*(5*y);x=B>>>13,B&=8191,B+=w*(5*f)+b*(5*p)+A*(5*g)+P*(5*h)+k*(5*d),x+=B>>>13,B&=8191;let z=x+C*d+F*u+U*c+R*a+M*(5*m);x=z>>>13,z&=8191,z+=w*(5*y)+b*(5*f)+A*(5*p)+P*(5*g)+k*(5*h),x+=z>>>13,z&=8191;let te=x+C*h+F*d+U*u+R*c+M*a;x=te>>>13,te&=8191,te+=w*(5*m)+b*(5*y)+A*(5*f)+P*(5*p)+k*(5*g),x+=te>>>13,te&=8191;let Z=x+C*g+F*h+U*d+R*u+M*c;x=Z>>>13,Z&=8191,Z+=w*a+b*(5*m)+A*(5*y)+P*(5*f)+k*(5*p),x+=Z>>>13,Z&=8191;let q=x+C*p+F*g+U*h+R*d+M*u;x=q>>>13,q&=8191,q+=w*c+b*a+A*(5*m)+P*(5*y)+k*(5*f),x+=q>>>13,q&=8191;let oe=x+C*f+F*p+U*g+R*h+M*d;x=oe>>>13,oe&=8191,oe+=w*u+b*c+A*a+P*(5*m)+k*(5*y),x+=oe>>>13,oe&=8191;let le=x+C*y+F*f+U*p+R*g+M*h;x=le>>>13,le&=8191,le+=w*d+b*u+A*c+P*a+k*(5*m),x+=le>>>13,le&=8191;let be=x+C*m+F*y+U*f+R*p+M*g;x=be>>>13,be&=8191,be+=w*h+b*d+A*u+P*c+k*a,x+=be>>>13,be&=8191,x=(x<<2)+x|0,x=x+N|0,N=x&8191,x=x>>>13,D+=x,i[0]=N,i[1]=D,i[2]=B,i[3]=z,i[4]=te,i[5]=Z,i[6]=q,i[7]=oe,i[8]=le,i[9]=be}finalize(){const{h:e,pad:t}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=e[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|n[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535;zn(n)}update(e){wh(this),Ve(e),e=gi(e);const{buffer:t,blockLen:n}=this,s=e.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){zn(this.h,this.r,this.buffer,this.pad)}digestInto(e){wh(this),D1(e,this),this.finished=!0;const{buffer:t,h:n}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=n[o]>>>0,e[i++]=n[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}}function G1(r){const e=(n,s)=>r(s).update(n).digest(),t=r(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=n=>r(n),e}const Y1=G1(r=>new H1(r));function X1(r,e,t,n,s,i=20){let o=r[0],a=r[1],c=r[2],u=r[3],d=e[0],h=e[1],g=e[2],p=e[3],f=e[4],y=e[5],m=e[6],S=e[7],v=s,E=t[0],T=t[1],L=t[2],I=o,O=a,_=c,C=u,F=d,U=h,R=g,M=p,w=f,b=y,A=m,P=S,k=v,x=E,N=T,D=L;for(let z=0;z<i;z+=2)I=I+F|0,k=j(k^I,16),w=w+k|0,F=j(F^w,12),I=I+F|0,k=j(k^I,8),w=w+k|0,F=j(F^w,7),O=O+U|0,x=j(x^O,16),b=b+x|0,U=j(U^b,12),O=O+U|0,x=j(x^O,8),b=b+x|0,U=j(U^b,7),_=_+R|0,N=j(N^_,16),A=A+N|0,R=j(R^A,12),_=_+R|0,N=j(N^_,8),A=A+N|0,R=j(R^A,7),C=C+M|0,D=j(D^C,16),P=P+D|0,M=j(M^P,12),C=C+M|0,D=j(D^C,8),P=P+D|0,M=j(M^P,7),I=I+U|0,D=j(D^I,16),A=A+D|0,U=j(U^A,12),I=I+U|0,D=j(D^I,8),A=A+D|0,U=j(U^A,7),O=O+R|0,k=j(k^O,16),P=P+k|0,R=j(R^P,12),O=O+R|0,k=j(k^O,8),P=P+k|0,R=j(R^P,7),_=_+M|0,x=j(x^_,16),w=w+x|0,M=j(M^w,12),_=_+M|0,x=j(x^_,8),w=w+x|0,M=j(M^w,7),C=C+F|0,N=j(N^C,16),b=b+N|0,F=j(F^b,12),C=C+F|0,N=j(N^C,8),b=b+N|0,F=j(F^b,7);let B=0;n[B++]=o+I|0,n[B++]=a+O|0,n[B++]=c+_|0,n[B++]=u+C|0,n[B++]=d+F|0,n[B++]=h+U|0,n[B++]=g+R|0,n[B++]=p+M|0,n[B++]=f+w|0,n[B++]=y+b|0,n[B++]=m+A|0,n[B++]=S+P|0,n[B++]=v+k|0,n[B++]=E+x|0,n[B++]=T+N|0,n[B++]=L+D|0}const Z1=W1(X1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Q1=new Uint8Array(16),xh=(r,e)=>{r.update(e);const t=e.length%16;t&&r.update(Q1.subarray(t))},j1=new Uint8Array(32);function Ah(r,e,t,n,s){s!==void 0&&Ve(s,void 0,"AAD");const i=r(e,t,j1),o=B1(n.length,s?s.length:0,!0),a=Y1.create(i);s&&xh(a,s),xh(a,n),a.update(o);const c=a.digest();return zn(i,o),c}const _h=O1({blockSize:64,nonceLength:12,tagLength:16},(r=>(e,t,n)=>({encrypt(i,o){const a=i.length;o=bh(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(e,t,c,c,1);const u=Ah(r,e,t,c,n);return o.set(u,a),zn(u),o},decrypt(i,o){o=bh(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Ah(r,e,t,a,n);if(!N1(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(e,t,o,o,1),zn(u),o}}))(Z1));function J1(r,e,t){return ds(r),t===void 0&&(t=new Uint8Array(r.outputLen)),Ps(r,t,e)}const Oa=Uint8Array.of(0),Ch=Uint8Array.of();function eS(r,e,t,n=32){ds(r),Lt(n,"length");const s=r.outputLen;if(n>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(n/s);t===void 0?t=Ch:G(t,void 0,"info");const o=new Uint8Array(i*s),a=Ps.create(r,e),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let d=0;d<i;d++)Oa[0]=d+1,c.update(d===0?Ch:u).update(t).update(Oa).digestInto(u),o.set(u,s*d),a._cloneInto(c);return a.destroy(),c.destroy(),Yt(u,Oa),o.slice(0,n)}const tS={hashSHA256(r){return ur(r.subarray())},getHKDF(r,e){const t=J1(ur,e,r),s=eS(ur,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=_s.utils.randomSecretKey();return{publicKey:_s.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:_s.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,e){return _s.getSharedSecret(r.subarray(),e.subarray())},chaCha20Poly1305Encrypt(r,e,t,n){return _h(n,e,t).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,e,t,n,s){return _h(n,e,t).decrypt(r.subarray(),s)}};function nS(r){return{generateKeypair:r.generateX25519KeyPair,dh:(e,t)=>r.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const pi=r=>{const e=dt(2);return e[0]=r>>8,e[1]=r,e};pi.bytes=2;const yi=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let e=0;return e+=r[0]<<8,e+=r[1],e}return r.getUint16(0)};yi.bytes=2;function rS(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Ih(r,e){!e.enabled||!Or||(r?(e(`LOCAL_STATIC_PUBLIC_KEY ${Q(r.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${Q(r.privateKey,"hex")}`)):e("Missing local static keys."))}function Lh(r,e){!e.enabled||!Or||(r?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Q(r.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Q(r.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function sS(r,e){!e.enabled||!Or||e(r?`REMOTE_STATIC_PUBLIC_KEY ${Q(r.subarray(),"hex")}`:"Missing remote static public key.")}function Th(r,e){!e.enabled||!Or||e(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Q(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Ph(r,e,t){!t.enabled||!Or||(t(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&Q(r.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&Q(e.k,"hex")}`))}const Ti=class Ti extends Error{constructor(t="Invalid crypto exchange"){super(t);l(this,"code");this.code=Ti.code}};l(Ti,"code","ERR_INVALID_CRYPTO_EXCHANGE");let Br=Ti;const iS=0,oS=4294967295,aS="Cipherstate has reached maximum n, a new handshake must be performed";class cS{constructor(e=iS){l(this,"n");l(this,"bytes");l(this,"view");this.n=e,this.bytes=ye(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>oS)throw new Error(aS)}}const Kn=ye(0);class wi{constructor(e,t=void 0,n=0){l(this,"k");l(this,"n");l(this,"crypto");this.crypto=e,this.k=t,this.n=new cS(n)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const n=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),n}decryptWithAd(e,t,n){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,n);return this.n.increment(),s}}class lS{constructor(e,t){l(this,"cs");l(this,"ck");l(this,"h");l(this,"crypto");this.crypto=e;const n=H(t,"utf-8");this.h=dS(e,n),this.ck=this.h,this.cs=new wi(e)}mixKey(e){const[t,n]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new wi(this.crypto,n)}mixHash(e){this.h=this.crypto.hash(new Y(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,Kn);return[new wi(this.crypto,e),new wi(this.crypto,t)]}}class uS{constructor(e){l(this,"ss");l(this,"s");l(this,"e");l(this,"rs");l(this,"re");l(this,"initiator");l(this,"crypto");const{crypto:t,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=e;this.crypto=t,this.ss=new lS(t,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+n)throw new Error("message is not long enough");const s=e.sublist(t,t+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class Dh extends uS{writeMessageA(e){return new Y(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new Y(t,n,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new Y(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new Br(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new Br(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new Br(`handshake stage 2 validation fail: ${t.message}`)}}}function dS(r,e){if(e.length<=32){const t=ye(32);return t.set(e),t}else return r.hash(e)}var bi;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)n.uint32(10),n.bytes(i);if(t.streamMuxers!=null)for(const i of t.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const u=t.uint32();switch(u>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new tn('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(t.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new tn('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(t.string());break}default:{t.skipType(u&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(bi||(bi={}));var Ei;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(n.uint32(10),n.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(n.uint32(18),n.bytes(t.identitySig)),t.extensions!=null&&(n.uint32(34),bi.codec().encode(t.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a;const i={identityKey:ye(0),identitySig:ye(0)},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const c=t.uint32();switch(c>>>3){case 1:{i.identityKey=t.bytes();break}case 2:{i.identitySig=t.bytes();break}case 4:{i.extensions=bi.codec().decode(t,t.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{t.skipType(c&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Ei||(Ei={}));async function kh(r,e,t){const n=await r.sign(Mh(e));return Ei.encode({identityKey:bt(r.publicKey),identitySig:n,extensions:t})}async function Rh(r,e,t){try{const n=Ei.decode(r),s=Ot(n.identityKey);if((t==null?void 0:t.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${t}`);if(!e)throw new Error("Remote static does not exist");const i=Mh(e);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new Gr(n.message)}}function Mh(r){const e=H("noise-libp2p-static-key:");return r instanceof Uint8Array?It([e,r],e.length+r.length):(r.prepend(e),r)}class hS extends Yo{constructor(t,n,s){super({log:t.log,inactivityTimeout:t.inactivityTimeout,maxReadBufferLength:t.maxReadBufferLength,direction:t.direction});l(this,"stream");l(this,"handshake");l(this,"metrics");l(this,"decoder");this.stream=t,this.handshake=n,this.metrics=s,this.decoder=new Zb({lengthDecoder:yi,maxBufferSize:16*1024*1024,encodingLength:()=>2});const i=u=>{try{for(const d of this.decoder.decode(u.data))this.onData(this.decrypt(d))}catch(d){this.abort(d)}};this.stream.addEventListener("message",i);const o=u=>{u.error!=null?u.local===!0?this.abort(u.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(t){var s;const n=new Y;for(let i=0;i<t.byteLength;i+=ph){let o=i+ph;o>t.byteLength&&(o=t.byteLength);let a;t instanceof Uint8Array?a=this.handshake.encrypt(t.subarray(i,o)):a=this.handshake.encrypt(t.sublist(i,o)),(s=this.metrics)==null||s.encryptedPackets.increment(),n.append(pi(a.byteLength)),n.append(a)}return n}decrypt(t){var s,i;const n=new Y;for(let o=0;o<t.byteLength;o+=Nr){let a=o+Nr;if(a>t.byteLength&&(a=t.byteLength),a-yh<o)throw new Error("Invalid chunk");let c;t instanceof Uint8Array?c=t.subarray(o,a):c=t.sublist(o,a);const u=t.subarray(o,a-yh);try{const d=this.handshake.decrypt(c,u);(s=this.metrics)==null||s.decryptedPackets.increment(),n.append(d)}catch(d){throw(i=this.metrics)==null||i.decryptErrors.increment(),d}}return n}close(t){return this.stream.close(t)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(t){this.stream.abort(t)}sendData(t){return{sentBytes:t.byteLength,canSendMore:this.stream.send(this.encrypt(t))}}}function Nh(r,e,t){return new hS(r,e,t)}async function fS(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await kh(i,a.publicKey,u),h=new Dh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Ih(h.s,t),t.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(Kn),e),t.trace("Stage 0 - Initiator finished sending first message."),Lh(h.e,t),t.trace("Stage 1 - Initiator waiting to receive first message from responder...");const g=h.readMessageB(await n.read(e));t.trace("Stage 1 - Initiator received the message."),Th(h.re,t),sS(h.rs,t),t.trace("Initiator going to check remote's signature...");const p=await Rh(g,h.rs,c);t.trace("All good with the signature!"),t.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(d),e),t.trace("Stage 2 - Initiator sent message with signed payload.");const[f,y]=h.ss.split();return Ph(f,y,t),{payload:p,encrypt:m=>f.encryptWithAd(Kn,m),decrypt:(m,S)=>y.decryptWithAd(Kn,m,S)}}async function gS(r,e){const{log:t,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await kh(i,a.publicKey,u),h=new Dh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Ih(h.s,t),t.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(e)),t.trace("Stage 0 - Responder received first message."),Th(h.re,t),t.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(d),e),t.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Lh(h.e,t),t.trace("Stage 2 - Responder waiting for third handshake message...");const g=h.readMessageC(await n.read(e));t.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Rh(g,h.rs,c),[f,y]=h.ss.split();return Ph(f,y,t),{payload:p,encrypt:m=>y.encryptWithAd(Kn,m),decrypt:(m,S)=>f.decryptWithAd(Kn,m,S)}}If=Symbol.toStringTag,Cf=Gt;class mS{constructor(e,t={}){l(this,"protocol","/noise");l(this,"crypto");l(this,"prologue");l(this,"staticKey");l(this,"extensions");l(this,"metrics");l(this,"components");l(this,"log");l(this,If,"@chainsafe/libp2p-noise");l(this,Cf,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e,this.log=e.logger.forComponent("libp2p:noise");const c=i??tS;this.crypto=nS(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?rS(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ye(0)}async secureOutbound(e,t){var a,c,u;const n=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,s=Pr(e,{lengthEncoder:pi,lengthDecoder:yi,maxDataLength:Nr}),i=await this.performHandshakeInitiator(s,this.components.privateKey,n,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=Ot(i.payload.identityKey);return{connection:Nh(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:br(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}getStreamMuxer(e){if(e==null||e.length===0)return;const t=this.components.upgrader.getStreamMuxers();if(t!=null)for(const n of e){const s=t.get(n);if(s!=null)return s}if(e.length)throw new Kf("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(e,t){var a,c,u;const n=((a=e.log)==null?void 0:a.newScope("noise"))??this.log,s=Pr(e,{lengthEncoder:pi,lengthDecoder:yi,maxDataLength:Nr}),i=await this.performHandshakeResponder(s,this.components.privateKey,n,(c=t==null?void 0:t.remotePeer)==null?void 0:c.publicKey,t),o=Ot(i.payload.identityKey);return{connection:Nh(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:br(o),streamMuxer:(t==null?void 0:t.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}async performHandshakeInitiator(e,t,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await fS({connection:e,privateKey:t,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}async performHandshakeResponder(e,t,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await gS({connection:e,privateKey:t,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}}function pS(r={}){return e=>new mS(e,r)}function yS(r){return e=>new L1(e,r)}function wS(r){return r.reason}async function Oh(r,e,t){if(e==null)return r;const n=wS;if(e.aborted)return r.catch(()=>{}),Promise.reject(n(e));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(e))},e.addEventListener("abort",s)})])}finally{s!=null&&e.removeEventListener("abort",s)}}var xe;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(xe||(xe={}));var se;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(se||(se={})),Object.values(se).filter(r=>typeof r!="string");const bS=0;var je;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(je||(je={}));const hn=12;class Fr extends Error{constructor(t,n){super(t);l(this,"reason");this.name="ProtocolError",this.reason=n}}l(Fr,"name","ProtocolError");function ES(r){return(r==null?void 0:r.reason)!==null}class fn extends Fr{constructor(e="The frame was invalid"){super(e,je.ProtocolError),this.name="InvalidFrameError"}}l(fn,"name","InvalidFrameError");class Bh extends Fr{constructor(e="Un-requested ping error"){super(e,je.ProtocolError),this.name="UnRequestedPingError"}}l(Bh,"name","UnRequestedPingError");class Fh extends Fr{constructor(e="Not matching ping error"){super(e,je.ProtocolError),this.name="NotMatchingPingError"}}l(Fh,"name","NotMatchingPingError");class $h extends Fr{constructor(e="Receive window exceeded"){super(e,je.ProtocolError),this.name="ReceiveWindowExceededError"}}l($h,"name","ReceiveWindowExceededError");const Uh=256*1024,vS=16*1024*1024,vi={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function SS(r){var e,t,n,s,i,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new V("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new V("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new V("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new V("MaxMessageSize must be greater than a kilobyte");if(((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)!=null&&((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)<Uh)throw new V("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.initialStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new V("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new V("MaxStreamWindowSize must be less than equal MAX_UINT32")}function xS(r){return r.header.type===xe.Data&&r.data!==null}const zh=2**24;function AS(r){if(r[0]!==bS)throw new fn("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*zh+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*zh+(r[9]<<16)+(r[10]<<8)+r[11]}}class _S{constructor(){l(this,"buffer");this.buffer=new Y}*emitFrames(e){for(this.buffer.append(e);;){const t=this.readFrame();if(t===void 0)break;yield t}}readFrame(){let e=hn;if(this.buffer.byteLength<hn)return;const t=AS(this.buffer.subarray(0,hn));if(t.type===xe.Data){if(e+=t.length,this.buffer.byteLength<e)return;const n=this.buffer.sublist(hn,e);return this.buffer.consume(e),{header:t,data:n}}return this.buffer.consume(e),{header:t}}}function Kh(r){const e=new Uint8Array(hn);return e[1]=r.type,e[2]=r.flag>>>8,e[3]=r.flag,e[4]=r.streamID>>>24,e[5]=r.streamID>>>16,e[6]=r.streamID>>>8,e[7]=r.streamID,e[8]=r.length>>>24,e[9]=r.length>>>16,e[10]=r.length>>>8,e[11]=r.length,e}var Ye;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(Ye||(Ye={}));class CS extends lu{constructor(t){const n=t.initialStreamWindowSize??Uh;super({...t,maxMessageSize:n-hn});l(this,"streamId");l(this,"state");l(this,"sendWindowCapacity");l(this,"recvWindow");l(this,"recvWindowCapacity");l(this,"maxStreamWindowSize");l(this,"epochStart");l(this,"getRTT");l(this,"sendFrame");this.streamId=t.streamId,this.state=t.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=t.maxStreamWindowSize??vS,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame;const s=()=>{this.state=Ye.Finished};this.addEventListener("close",s)}sendData(t){var o,a;const n=t.byteLength;let s=0,i=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);t.byteLength>0;){if(this.sendWindowCapacity===0){i=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",s,n);break}const c=Math.min(this.sendWindowCapacity,t.byteLength),u=this.getSendFlags(),d=t.sublist(0,c);t.consume(c);const h=this.sendFrame({type:xe.Data,flag:u,streamID:this.streamId,length:c},d);if(this.sendWindowCapacity-=c,s+=c,!h){i=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",s,n);break}}return{sentBytes:s,canSendMore:i}}async sendReset(){this.sendFrame({type:xe.WindowUpdate,flag:se.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const t=this.getSendFlags()|se.FIN;this.sendFrame({type:xe.WindowUpdate,flag:t,streamID:this.streamId,length:0})}async sendCloseRead(t){var n;(n=t==null?void 0:t.signal)==null||n.throwIfAborted()}sendPause(){this.state=Ye.Paused}sendResume(){this.state=Ye.Established,this.sendWindowUpdate()}handleWindowUpdate(t){var n;this.processFlags(t.header.flag),this.sendWindowCapacity+=t.header.length,this.maxMessageSize=this.sendWindowCapacity-hn,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",t.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(t){if(!xS(t))throw new fn("Frame was not data frame");if(this.processFlags(t.header.flag),this.recvWindowCapacity<t.header.length)throw new $h("Receive window exceeded");this.recvWindowCapacity-=t.header.length,this.onData(t.data),this.sendWindowUpdate()}processFlags(t){(t&se.ACK)===se.ACK&&this.state===Ye.SYNSent&&(this.state=Ye.Established),(t&se.FIN)===se.FIN&&this.onRemoteCloseWrite(),(t&se.RST)===se.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case Ye.Init:return this.state=Ye.SYNSent,se.SYN;case Ye.SYNReceived:return this.state=Ye.Established,se.ACK;default:return 0}}sendWindowUpdate(){if(this.state===Ye.Paused){this.epochStart=Date.now();return}const t=this.getSendFlags(),n=Date.now(),s=this.getRTT();if(t===0&&s>-1&&n-this.epochStart<=s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:xe.WindowUpdate,flag:t,streamID:this.streamId,length:i})}}function qh(r){return{type:xe[r.type],flags:[(r.flag&se.SYN)===se.SYN?"SYN":void 0,(r.flag&se.ACK)===se.ACK?"ACK":void 0,(r.flag&se.FIN)===se.FIN?"FIN":void 0,(r.flag&se.RST)===se.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const Vh="/yamux/1.0.0";Tf=Symbol.toStringTag,Lf=Gt;class IS{constructor(e={}){l(this,"protocol",Vh);l(this,"_init");l(this,Tf,"@chainsafe/libp2p-yamux");l(this,Lf,["@libp2p/stream-multiplexing"]);this._init=e}createStreamMuxer(e){return new LS(e,{...this._init})}}class LS extends cu{constructor(t,n={}){super(t,{...n,protocol:Vh,name:"yamux"});l(this,"nextStreamID");l(this,"nextPingID");l(this,"activePing");l(this,"rtt");l(this,"client");l(this,"localGoAway");l(this,"remoteGoAway");l(this,"numInboundStreams");l(this,"numOutboundStreams");l(this,"decoder");l(this,"keepAlive");l(this,"enableKeepAlive");l(this,"keepAliveInterval");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");this.client=t.direction==="outbound",SS(n),this.enableKeepAlive=n.enableKeepAlive??vi.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??vi.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??vi.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??vi.maxOutboundStreams,this.decoder=new _S,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=s0(async s=>{try{await this.ping(s)}catch(i){this.log.error("ping error: %s",i)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(t){for(const n of this.decoder.emitFrames(t))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new gn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new gn("Muxer closed locally");const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new Vi("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",t);const n=this._newStream(t,Ye.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(t){if(this.remoteGoAway!==void 0)throw new gn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new gn("Muxer closed locally");if(this.activePing!=null)return Oh(this.activePing.promise,t==null?void 0:t.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await Oh(this.activePing.promise,t==null?void 0:t.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(t={}){var n;if(this.status==="open")try{const s=(t==null?void 0:t.reason)??je.NormalTermination;this.log.trace("muxer close reason=%s",je[s]),await super.close(t),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}abort(t){var n;if(this.status==="open")try{super.abort(t);let s=je.InternalError;ES(t)&&(s=t.reason),this.log.error("muxer abort reason=%s error=%s",s,t),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var t;try{super.onTransportClosed()}finally{(t=this.keepAlive)==null||t.stop()}}_newStream(t,n,s){if(this.streams.find(o=>o.streamId===t)!=null)throw new V("Stream already exists with that id");const i=new CS({...this.streamOptions,id:`${t}`,streamId:t,state:n,direction:s,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${s}:${t}`),getRTT:this.getRTT.bind(this)});return i.addEventListener("close",()=>{this.closeStream(t)},{once:!0}),i}closeStream(t){this.client===(t%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(t){const{streamID:n,type:s,length:i}=t.header;if(this.log.trace("received frame %o",qh(t.header)),n===0)switch(s){case xe.Ping:{this.handlePing(t.header);return}case xe.GoAway:{this.handleGoAway(i);return}default:throw new fn("Invalid frame type")}else switch(t.header.type){case xe.Data:case xe.WindowUpdate:{this.handleStreamMessage(t);return}default:throw new fn("Invalid frame type")}}handlePing(t){if(t.flag===se.SYN)this.log.trace("received ping request pingId=%s",t.length),this.sendPing(t.length,se.ACK);else if(t.flag===se.ACK)this.log.trace("received ping response pingId=%s",t.length),this.handlePingResponse(t.length);else throw new fn("Invalid frame flag")}handlePingResponse(t){if(this.activePing===void 0)throw new Bh("ping not requested");if(this.activePing.id!==t)throw new Fh("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(t){this.log.trace("received GoAway reason=%s",je[t]??"unknown"),this.remoteGoAway=t,t===je.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(t){const{streamID:n,flag:s,type:i}=t.header;(s&se.SYN)===se.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(i){case xe.WindowUpdate:{o.handleWindowUpdate(t);return}case xe.Data:{o.handleData(t);return}default:throw new Error("unreachable")}}incomingStream(t){if(this.client!==(t%2===0))throw new V("Both endpoints are clients");if(this.streams.find(s=>s.streamId===t))return;if(this.log.trace("new incoming stream id=%s",t),this.localGoAway!==void 0){this.sendFrame({type:xe.WindowUpdate,flag:se.RST,streamID:t,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:xe.WindowUpdate,flag:se.RST,streamID:t,length:0});return}const n=this._newStream(t,Ye.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(t,n){let s;if(t.type===xe.Data){if(n==null)throw new fn("Invalid frame");s=new Y(Kh(t),n)}else s=Kh(t);return this.log.trace("sending frame %o",qh(t)),this.send(s)}sendPing(t,n=se.SYN){n===se.SYN?this.log.trace("sending ping request pingId=%s",t):this.log.trace("sending ping response pingId=%s",t),this.sendFrame({type:xe.Ping,flag:n,streamID:0,length:t})}sendGoAway(t=je.NormalTermination){this.log("sending GoAway reason=%s",je[t]),this.localGoAway=t,this.sendFrame({type:xe.GoAway,flag:0,streamID:0,length:t})}}function TS(r={}){return()=>new IS(r)}const PS="0.1.0",DS="id",kS="1.0.0",RS=1024*8;var Si;(function(r){let e;r.codec=()=>(e==null&&(e=ze((t,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),t.protocolVersion!=null&&(n.uint32(42),n.string(t.protocolVersion)),t.agentVersion!=null&&(n.uint32(50),n.string(t.agentVersion)),t.publicKey!=null&&(n.uint32(10),n.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)n.uint32(18),n.bytes(i);if(t.observedAddr!=null&&(n.uint32(34),n.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)n.uint32(26),n.string(i);t.signedPeerRecord!=null&&(n.uint32(66),n.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(t,n,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=n==null?t.len:t.pos+n;for(;t.pos<o;){const u=t.uint32();switch(u>>>3){case 5:{i.protocolVersion=t.string();break}case 6:{i.agentVersion=t.string();break}case 1:{i.publicKey=t.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new tn('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(t.bytes());break}case 4:{i.observedAddr=t.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new tn('Decode error - map field "protocols" had too many elements');i.protocols.push(t.string());break}case 8:{i.signedPeerRecord=t.bytes();break}default:{t.skipType(u&7);break}}}return i})),e),r.encode=t=>Ue(t,r.codec()),r.decode=(t,n)=>$e(t,r.codec(),n)})(Si||(Si={}));const xt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:RS,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function MS(r){if(r!=null&&r.length>0)try{return ce(r)}catch{}}async function NS(r,e,t,n,s){if(t("received identify from %p",n.remotePeer),s==null)throw new lt("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:ce(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Ot(s.publicKey);if(!br(c).equals(n.remotePeer))throw new lt("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){t.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const u=await an.openAndCertify(c,vt.DOMAIN);let d=vt.createFromProtobuf(u.payload);const h=Er(u.publicKey.toCID());if(!d.peerId.equals(h))throw new lt("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(d.peerId))throw new lt("signing key does not match remote PeerId");let g;try{g=await r.get(d.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(g!=null&&(i.metadata=g.metadata,g.peerRecordEnvelope!=null)){const p=an.createFromProtobuf(g.peerRecordEnvelope),f=vt.createFromProtobuf(p.payload);f.seqNumber>=d.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",f.seqNumber,d.seqNumber),d=f,c=g.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=d.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:d.seqNumber,addresses:d.multiaddrs}}else t("%p did not send a signed peer record",n.remotePeer);if(t.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=H(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=H(s.protocolVersion)),t.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>ce(c)),observedAddr:s.observedAddr==null?void 0:ce(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class OS{constructor(e,t){l(this,"host");l(this,"components");l(this,"protocol");l(this,"started");l(this,"timeout");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");l(this,"maxMessageSize");l(this,"maxObservedAddresses");l(this,"runOnLimitedConnection");l(this,"log");this.protocol=t.protocol,this.started=!1,this.components=e,this.log=t.log,this.timeout=t.timeout??xt.timeout,this.maxInboundStreams=t.maxInboundStreams??xt.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??xt.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??xt.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??xt.maxObservedAddresses,this.runOnLimitedConnection=t.runOnLimitedConnection??xt.runOnLimitedConnection,this.host={protocolVersion:`${t.protocolPrefix??xt.protocolPrefix}/${PS}`,agentVersion:e.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:H(this.host.agentVersion),ProtocolVersion:H(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}class BS extends(Df=OS,Pf=Gt,Df){constructor(t,n={}){super(t,{...n,protocol:`/${n.protocolPrefix??xt.protocolPrefix}/${DS}/${kS}`,log:t.logger.forComponent("libp2p:identify")});l(this,Pf,["@libp2p/identify"]);(n.runOnConnectionOpen??xt.runOnConnectionOpen)&&t.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(()=>{})})}async _identify(t,n={}){let s,i;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",t.remoteAddr);try{s=await t.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),i=s.log.newScope("identify");const o=Ws(s,{maxDataLength:this.maxMessageSize}).pb(Si),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw i==null||i.error("identify failed - %e",o),s==null||s.abort(o),o}}async identify(t,n={}){const s=await this._identify(t,n),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new lt("Public key was missing from identify message");const c=Ot(i),u=Er(c.toCID());if(!t.remotePeer.equals(u))throw new lt("Identified peer does not match the expected peer");if(this.components.peerId.equals(u))throw new lt("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",u,o),NS(this.components.peerStore,this.components.events,this.log,t,s)}maybeAddObservedAddress(t){const n=MS(t);if(n==null||(this.log.trace("our observed address was %a",n),Pn(n)))return;const s=n.getComponents();if((s[0].code===Mn||s[0].code===Zo&&s[1].code===Mn)&&!Aw(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}si.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(t,n){const s=t.log.newScope("identify");s("responding to identify");const i=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:i}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(W));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new vt({peerId:this.components.peerId,multiaddrs:a});c=(await an.seal(h,this.components.privateKey,{signal:i})).marshal().subarray()}let u=n.remoteAddr.bytes;J0.matches(n.remoteAddr)||(u=void 0);const d=Ws(t).pb(Si);s("send response"),await d.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:bt(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:u,protocols:o.protocols},{signal:i}),s("close write"),await d.unwrap().unwrap().close({signal:i})}}function FS(r={}){return e=>new BS(e,r)}const Wh=location.hostname.split(".")[0],$S=location.pathname==="/"||location.pathname===""?`${Wh}.github.io`:location.pathname.split("/")[1],ot=`${Wh}/${$S}`,Ba=`https://api.github.com/repos/${ot}/contents/data/state.json`,Fa="gitchain_github_access_token",xi=`https://api.github.com/repos/${ot}/issues`,Hh="/gitchain/tx/1.0.0",zt="data/server-peer.json",US=5*60*1e3;let Kt=null,Ai=!1,Gh=null;function Yh(r,e,t,n){const s=`${r}${e}${t}${JSON.stringify(n)}`;return CryptoJS.SHA256(s).toString()}function zS(){const r=new Date().toISOString();return{index:0,previousHash:"0",timestamp:r,transactions:[],hash:Yh(0,"0",r,[])}}function Xh(r){return JSON.stringify(r,Object.keys(r).sort())}function $a(r){const t=sha3.keccak256(r).match(/.{2}/g);if(!t)throw new Error("Failed to parse hex string");return new Uint8Array(t.map(n=>parseInt(n,16)))}function KS(r){const e=new Uint8Array(r.length/2);for(let t=0;t<r.length;t+=2)e[t/2]=parseInt(r.substr(t,2),16);return e}function $r(r){return Array.from(r,e=>e.toString(16).padStart(2,"0")).join("")}function Ua(r){try{const e=$a(Xh({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})),t=KS(r.signature);if(t.length!==65)return!1;const n=$r(t.slice(0,32)),s=$r(t.slice(32,64)),i=t[64]-27,o=new ec("secp256k1"),a=$r(e),c={r:n,s},u=o.recoverPubKey(a,c,i),d=$a(u.encode("array",!0).slice(1));return`0x${$r(d.slice(-20))}`.toLowerCase()===r.from.toLowerCase()}catch{return!1}}async function qS(r,e){const t=$r($a(Xh({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})));return Ua(r)?(e.nonces[r.from]||0)+1!==r.nonce?{valid:!1,txid:t}:r.from.toLowerCase()!==ee.toLowerCase()&&(e.balances[r.from]||0)<r.amount?{valid:!1,txid:t}:!/^0x[a-fA-F0-9]{40}$/.test(r.from)||!/^0x[a-fA-F0-9]{40}$/.test(r.to)?{valid:!1,txid:t}:(e.pending.push(r),{valid:!0,txid:t}):{valid:!1,txid:t}}async function VS(r){if(r.pending.length===0)return null;const e=[],t={...r.balances},n={...r.nonces};for(const u of r.pending)Ua(u)&&(n[u.from]||0)+1===u.nonce&&(u.from.toLowerCase()===ee.toLowerCase()||(t[u.from]||0)>=u.amount)&&(u.from.toLowerCase()!==ee.toLowerCase()&&(t[u.from]=(t[u.from]||0)-u.amount),t[u.to]=(t[u.to]||0)+u.amount,n[u.from]=u.nonce,e.push(u));if(e.length===0)return r.pending=[],null;const s=r.chain.length,i=r.chain.length>0?r.chain[r.chain.length-1].hash:"0",o=new Date().toISOString(),a=Yh(s,i,o,e),c={index:s,previousHash:i,timestamp:o,transactions:e,hash:a};return r.chain.push(c),r.pending=[],r.balances=t,r.nonces=n,s}function qt(){var e;let r=localStorage.getItem(Fa);if(!r){if(r=(e=document.getElementById("githubAccessToken"))==null?void 0:e.value,!r)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(Fa,r)}return console.log("Retrieved GitHub access token"),r}async function WS(r){console.log("Entering initP2P, isHost:",r),Ai=r;try{console.log("Creating libp2p node..."),Kt=await Qv({transports:[yS({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncrypters:[pS()],streamMuxers:[TS()],services:{identify:FS()},addresses:{listen:["/webrtc"]}}),console.log("Starting libp2p node..."),await Kt.start(),console.log("libp2p started, peerId:",Kt.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(t=>setTimeout(t,1e3)),Kt.addEventListener("peer:connect",t=>{console.log("Connected to peer:",t.detail.toString())}),console.log("Registering protocol handler for:",Hh),await Kt.handle(Hh,async({stream:t,connection:n})=>{console.log("Incoming TX stream from",n.remotePeer.toString());const s=await GS(t);try{const i=JSON.parse(s);if(Ua(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:ot,txn:i}),a=await fetch(xi,{method:"POST",headers:{Authorization:`token ${qt()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}t.close()}),Ai&&(console.log("Host mode: Advertising peer info"),await Zh(),console.log("Setting interval for periodic peer advertising"),setInterval(Zh,US),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await HS()})),console.log("initP2P completed successfully")}catch(e){console.error("Failed to initialize P2P:",e),Ai&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function Zh(r=3,e=1e3){if(console.log("Entering advertiseServerPeer, retries:",r),!Ai||!Kt)return console.log("Not in host mode or libp2p not initialized"),!1;const t=Kt.peerId.toString(),n=Kt.getMultiaddrs().map(a=>a.toString()),s={peerId:t,multiaddrs:n,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===Gh)return console.log("No change in peer info, skipping update"),!0;Gh=i;const o=qt();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=r;a++){console.log(`Attempt ${a}/${r} to advertise peer info`);try{console.log("Fetching SHA for",zt);const c=await Qh(zt);console.log("SHA:",c||"none (new file)");const u={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(u.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${ot}/contents/${zt}`);const d=await fetch(`https://api.github.com/repos/${ot}/contents/${zt}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(u)});if(d.ok)return console.log("Advertised peer info successfully"),!0;{const h=await d.text();if(console.error(`Attempt ${a}/${r} - Failed to advertise peer: ${d.status} ${h}`),(d.status===403||d.status===429)&&(console.log(`Retrying after ${e}ms due to ${d.status}`),a<r)){await new Promise(g=>setTimeout(g,e));continue}throw new Error(`HTTP ${d.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${r} - Error advertising peer:`,c),a===r)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(u=>setTimeout(u,e))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function HS(){console.log("Entering deleteServerPeerFile");const r=qt();if(!r){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",zt);const e=await Qh(zt);if(!e){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",zt);const t=await fetch(`https://api.github.com/repos/${ot}/contents/${zt}`,{method:"DELETE",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:e})});t.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",t.status,await t.text())}catch(e){console.error("Error deleting peer file:",e)}}async function Qh(r){console.log("Entering getFileSha for",r);const e=qt();if(!e)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${ot}/contents/${r}?ref=main`);const t=await fetch(`https://api.github.com/repos/${ot}/contents/${r}?ref=main`,{headers:{Authorization:`token ${e}`,Accept:"application/vnd.github.v3+json"}});if(t.ok){const n=await t.json();return console.log("SHA retrieved:",n.sha),n.sha}return t.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${r}: ${t.status} ${await t.text()}`),null)}catch(t){return console.error(`Error fetching SHA for ${r}:`,t),null}}async function GS(r){console.log("Reading stream to string");const e=[];for await(const s of r.source)e.push(s);const t=It(e),n=Q(t);return console.log("Stream read complete, length:",n.length),n}async function _i(){console.log("Entering fetchState");const r=qt();if(!r)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",Ba);const e=await fetch(`${Ba}?ref=main`,{headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json"}});if(!e.ok){if(e.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",e.status,await e.text()),new Error(`Error fetching state: ${e.statusText}`)}const t=await e.json(),n=JSON.parse(atob(t.content));return console.log("State fetched, chain length:",n.chain.length),{content:n,sha:t.sha}}catch(e){return console.error("Error fetching state:",e),null}}async function Ci(r,e,t,n=3){console.log("Entering updateState, message:",t);const s=qt();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(r,null,2));try{const o={message:t,content:i,branch:"main"};e&&(o.sha=e),console.log("Sending PUT request to update state");const a=await fetch(Ba,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&n>0){console.log("Conflict detected, retrying...");const c=await _i();if(!c)throw new Error("Failed to refetch");return Ci(r,c.sha,t,n-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function Ii(r,e,t){console.log("Entering closeIssueWithComment, issue:",r);const n=qt();if(!n){console.log("No PAT available for closing issue");return}const s=t&&e!==null?`Confirmed in block ${e}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${ot}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${ot})`;console.log("Creating comment for issue:",r),await fetch(`${xi}/${r}/comments`,{method:"POST",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",r),await fetch(`${xi}/${r}`,{method:"PATCH",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function YS(){console.log("Entering processTxns");const r=document.getElementById("output"),e=document.getElementById("processingMessage");e.style.display="block";let t=await _i(),n=t==null?void 0:t.content;if(!n){if(console.log("No state found, initializing"),n={chain:[zS()],pending:[],balances:{[ee]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await Ci(n,null,"Initialize state")){console.log("Failed to initialize state"),r.textContent+=`
Failed to initialize.`,e.style.display="none";return}t=await _i(),n=t.content}console.log("Fetching open issues");const i=await(await fetch(`${xi}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${qt()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=n.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(n.lastProcessedDate))continue;let c;try{const f=JSON.parse(a.body);if(f.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await Ii(a.number,null,!1);continue}if(f.repo!==ot){console.log("Skipping issue from wrong repo:",a.number),await Ii(a.number,null,!1);continue}c=f.txn}catch{console.log("Invalid issue body, closing:",a.number),await Ii(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:u,txid:d}=await qS(c,n);console.log(`Transaction ID: ${d}, valid: ${u}`);const h=u?await VS(n):null;if(await Ii(a.number,h,u),u&&h!==null?(console.log(`Transaction ID: ${d} settled in block ${h}`),r.textContent+=`
Processed txn ${d} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),r.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await Ci(n,t.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),r.textContent+=`
Failed to update state after issue #${a.number}`,e.style.display="none";return}t=await _i(),n=t.content;const p=a.created_at;new Date(p)>new Date(o)&&(o=p)}o!==n.lastProcessedDate&&(console.log("Updating last processed date:",o),n.lastProcessedDate=o,await Ci(n,t.sha,"Update last processed date")),console.log("processTxns completed"),e.style.display="none"}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(Fa)?(console.log("PAT found, initializing P2P as host"),WS(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{YS()},15e3)})})();
