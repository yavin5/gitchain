var Z_=Object.defineProperty;var ag=ee=>{throw TypeError(ee)};var Q_=(ee,oe,me)=>oe in ee?Z_(ee,oe,{enumerable:!0,configurable:!0,writable:!0,value:me}):ee[oe]=me;var f=(ee,oe,me)=>Q_(ee,typeof oe!="symbol"?oe+"":oe,me),cc=(ee,oe,me)=>oe.has(ee)||ag("Cannot "+me);var D=(ee,oe,me)=>(cc(ee,oe,"read from private field"),me?me.call(ee):oe.get(ee)),ue=(ee,oe,me)=>oe.has(ee)?ag("Cannot add the same private member more than once"):oe instanceof WeakSet?oe.add(ee):oe.set(ee,me),he=(ee,oe,me,bn)=>(cc(ee,oe,"write to private field"),bn?bn.call(ee,me):oe.set(ee,me),me),ie=(ee,oe,me)=>(cc(ee,oe,"access private method"),me);var Rs=(ee,oe,me,bn)=>({set _(Tr){he(ee,oe,Tr,me)},get _(){return D(ee,oe,bn)}});(function(){"use strict";var Yt,Lt,Bd,Od,Pd,Ud,Md,Fd,Vd,de,Er,vr,ac,Dt,Bt,Yi,ji,$d,Ar,Xi,Hd,ft,Kd,Sr,xr,wn,vs,Rr,_s,dt,Ir,We,As,gt,kr,Xt,Ss,qi,J,cg,lg,ug,hg,fg,Zi,lc,uc,Qi,dg,Ji,zd,qd,Gd,Wd,Yd,jd,Xd,Zd,Qd,Jd,eg,tg,xs,hc,ng,rg,sg,ig;const ee="0x097efb2a92bc5205e1615db52338a118f1619f3f",oe=Symbol.for("@libp2p/connection"),me=Symbol.for("@libp2p/content-routing"),bn=Symbol.for("@libp2p/peer-discovery"),Tr=Symbol.for("@libp2p/peer-id");function fc(n){return n!=null&&!!n[Tr]}const dc=Symbol.for("@libp2p/peer-routing"),gg="keep-alive";var Vn;(function(n){n[n.FATAL_ALL=0]="FATAL_ALL",n[n.NO_FATAL=1]="NO_FATAL"})(Vn||(Vn={}));let eo=(Yt=class extends Error{constructor(t="The operation was aborted"){super(t);f(this,"code");f(this,"type");this.name="AbortError",this.code=Yt.code,this.type=Yt.type}},f(Yt,"code","ABORT_ERR"),f(Yt,"type","aborted"),Yt),R=class extends Error{constructor(t,r,s){super(t);f(this,"code");f(this,"props");this.code=r,this.name=(s==null?void 0:s.name)??"CodeError",this.props=s??{}}};class pg extends AggregateError{constructor(t,r,s,i){super(t,r);f(this,"code");f(this,"props");this.code=s,this.name=(i==null?void 0:i.name)??"AggregateCodeError",this.props=i??{}}}const gc="ERR_TIMEOUT";function J_(){}const Se=(n,...e)=>{try{[...e]}catch{}};let Is=(Bd=class extends EventTarget{constructor(){super();ue(this,Lt,new Map);Se(1/0,this)}listenerCount(t){const r=D(this,Lt).get(t);return r==null?0:r.length}addEventListener(t,r,s){super.addEventListener(t,r,s);let i=D(this,Lt).get(t);i==null&&(i=[],D(this,Lt).set(t,i)),i.push({callback:r,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(t,r,s){super.removeEventListener(t.toString(),r??null,s);let i=D(this,Lt).get(t);i!=null&&(i=i.filter(({callback:o})=>o!==r),D(this,Lt).set(t,i))}dispatchEvent(t){const r=super.dispatchEvent(t);let s=D(this,Lt).get(t.type);return s==null||(s=s.filter(({once:i})=>!i),D(this,Lt).set(t.type,s)),r}safeDispatchEvent(t,r={}){return this.dispatchEvent(new pc(t,r))}},Lt=new WeakMap,Bd);const pc=globalThis.CustomEvent;function yg(n){return n!=null&&typeof n.start=="function"&&typeof n.stop=="function"}const ks=Symbol.for("@libp2p/service-capabilities"),yc=Symbol.for("@libp2p/service-dependencies");function mg(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function Ts(n){if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")}function wg(n){return new TextEncoder().encode(n)}function bg(n){return new TextDecoder().decode(n)}function Eg(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var s=0;s<n.length;s++){var i=n.charAt(s),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=s}var a=n.length,c=n.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(m){if(m instanceof Uint8Array||(ArrayBuffer.isView(m)?m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength):Array.isArray(m)&&(m=Uint8Array.from(m))),!(m instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(m.length===0)return"";for(var d=0,p=0,b=0,v=m.length;b!==v&&m[b]===0;)b++,d++;for(var w=(v-b)*u+1>>>0,E=new Uint8Array(w);b!==v;){for(var A=m[b],S=0,k=w-1;(A!==0||S<p)&&k!==-1;k--,S++)A+=256*E[k]>>>0,E[k]=A%a>>>0,A=A/a>>>0;if(A!==0)throw new Error("Non-zero carry");p=S,b++}for(var C=w-p;C!==w&&E[C]===0;)C++;for(var _=c.repeat(d);C<w;++C)_+=n.charAt(E[C]);return _}function g(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return new Uint8Array;var d=0;if(m[d]!==" "){for(var p=0,b=0;m[d]===c;)p++,d++;for(var v=(m.length-d)*l+1>>>0,w=new Uint8Array(v);m[d];){var E=t[m.charCodeAt(d)];if(E===255)return;for(var A=0,S=v-1;(E!==0||A<b)&&S!==-1;S--,A++)E+=a*w[S]>>>0,w[S]=E%256>>>0,E=E/256>>>0;if(E!==0)throw new Error("Non-zero carry");b=A,d++}if(m[d]!==" "){for(var k=v-b;k!==v&&w[k]===0;)k++;for(var C=new Uint8Array(p+(v-k)),_=p;k!==v;)C[_++]=w[k++];return C}}}function y(m){var d=g(m);if(d)return d;throw new Error(`Non-${e} character`)}return{encode:h,decodeUnsafe:g,decode:y}}var vg=Eg,_g=vg;class Ag{constructor(e,t,r){f(this,"name");f(this,"prefix");f(this,"baseEncode");this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}let Sg=class{constructor(e,t,r){f(this,"name");f(this,"prefix");f(this,"baseDecode");f(this,"prefixCodePoint");this.name=e,this.prefix=t;const s=t.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return mc(this,e)}};class xg{constructor(e){f(this,"decoders");this.decoders=e}or(e){return mc(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r!=null)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function mc(n,e){return new xg({...n.decoders??{[n.prefix]:n},...e.decoders??{[e.prefix]:e}})}class Rg{constructor(e,t,r,s){f(this,"name");f(this,"prefix");f(this,"baseEncode");f(this,"baseDecode");f(this,"encoder");f(this,"decoder");this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=s,this.encoder=new Ag(e,t,r),this.decoder=new Sg(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}function Cs({name:n,prefix:e,encode:t,decode:r}){return new Rg(n,e,t,r)}function Cr({name:n,prefix:e,alphabet:t}){const{encode:r,decode:s}=_g(t,n);return Cs({prefix:e,name:n,encode:r,decode:i=>Ts(s(i))})}function Ig(n,e,t,r){let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*t/8|0);let o=0,a=0,c=0;for(let l=0;l<s;++l){const u=e[n[l]];if(u===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<t|u,o+=t,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=t||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function kg(n,e,t){const r=e[e.length-1]==="=",s=(1<<t)-1;let i="",o=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],o+=8;o>t;)o-=t,i+=e[s&a>>o];if(o!==0&&(i+=e[s&a<<t-o]),r)for(;i.length*t&7;)i+="=";return i}function Tg(n){const e={};for(let t=0;t<n.length;++t)e[n[t]]=t;return e}function Ce({name:n,prefix:e,bitsPerChar:t,alphabet:r}){const s=Tg(r);return Cs({prefix:e,name:n,encode(i){return kg(i,r,t)},decode(i){return Ig(i,s,t,n)}})}const Ve=Cr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Cg=Cr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Ng=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Ve,base58flickr:Cg},Symbol.toStringTag,{value:"Module"}));var Lg=bc,wc=128,Dg=-128,Bg=Math.pow(2,31);function bc(n,e,t){e=e||[],t=t||0;for(var r=t;n>=Bg;)e[t++]=n&255|wc,n/=128;for(;n&Dg;)e[t++]=n&255|wc,n>>>=7;return e[t]=n|0,bc.bytes=t-r+1,e}var Og=to,Pg=128,Ec=127;function to(n,r){var t=0,r=r||0,s=0,i=r,o,a=n.length;do{if(i>=a)throw to.bytes=0,new RangeError("Could not decode varint");o=n[i++],t+=s<28?(o&Ec)<<s:(o&Ec)*Math.pow(2,s),s+=7}while(o>=Pg);return to.bytes=i-r,t}var Ug=Math.pow(2,7),Mg=Math.pow(2,14),Fg=Math.pow(2,21),Vg=Math.pow(2,28),$g=Math.pow(2,35),Hg=Math.pow(2,42),Kg=Math.pow(2,49),zg=Math.pow(2,56),qg=Math.pow(2,63),Gg=function(n){return n<Ug?1:n<Mg?2:n<Fg?3:n<Vg?4:n<$g?5:n<Hg?6:n<Kg?7:n<zg?8:n<qg?9:10},Wg={encode:Lg,decode:Og,encodingLength:Gg},Ns=Wg;function no(n,e=0){return[Ns.decode(n,e),Ns.decode.bytes]}function Ls(n,e,t=0){return Ns.encode(n,e,t),e}function Ds(n){return Ns.encodingLength(n)}function Nr(n,e){const t=e.byteLength,r=Ds(n),s=r+Ds(t),i=new Uint8Array(s+t);return Ls(n,i,0),Ls(t,i,r),i.set(e,s),new so(n,t,e,i)}function ro(n){const e=Ts(n),[t,r]=no(e),[s,i]=no(e.subarray(r)),o=e.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new so(t,s,o,e)}function Yg(n,e){if(n===e)return!0;{const t=e;return n.code===t.code&&n.size===t.size&&t.bytes instanceof Uint8Array&&mg(n.bytes,t.bytes)}}class so{constructor(e,t,r,s){f(this,"code");f(this,"size");f(this,"digest");f(this,"bytes");this.code=e,this.size=t,this.digest=r,this.bytes=s}}const vc=0,jg="identity",_c=Ts;function Xg(n,e){if((e==null?void 0:e.truncate)!=null&&e.truncate!==n.byteLength){if(e.truncate<0||e.truncate>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,e.truncate)}return Nr(vc,_c(n))}const $n={code:vc,name:jg,encode:_c,digest:Xg},Zg=20;function Qg({name:n,code:e,encode:t,minDigestLength:r,maxDigestLength:s}){return new Jg(n,e,t,r,s)}class Jg{constructor(e,t,r,s,i){f(this,"name");f(this,"code");f(this,"encode");f(this,"minDigestLength");f(this,"maxDigestLength");this.name=e,this.code=t,this.encode=r,this.minDigestLength=s??Zg,this.maxDigestLength=i}digest(e,t){if((t==null?void 0:t.truncate)!=null){if(t.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&t.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?Ac(r,this.code,t==null?void 0:t.truncate):r.then(s=>Ac(s,this.code,t==null?void 0:t.truncate))}else throw Error("Unknown type, must be binary type")}}function Ac(n,e,t){if(t!=null&&t!==n.byteLength){if(t>n.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${n.byteLength}`);n=n.subarray(0,t)}return Nr(e,n)}function ep(n){return async e=>new Uint8Array(await crypto.subtle.digest(n,e))}const pt=Qg({name:"sha2-256",code:18,encode:ep("SHA-256")});function $e(n,e){if(n===e)return!0;if(n.byteLength!==e.byteLength)return!1;for(let t=0;t<n.byteLength;t++)if(n[t]!==e[t])return!1;return!0}function He(n=0){return new Uint8Array(n)}function vt(n=0){return new Uint8Array(n)}function eA(n){return n}function Pt(n,e){e==null&&(e=n.reduce((s,i)=>s+i.length,0));const t=vt(e);let r=0;for(const s of n)t.set(s,r),r+=s.length;return t}const tp=Cr({prefix:"9",name:"base10",alphabet:"0123456789"}),np=Object.freeze(Object.defineProperty({__proto__:null,base10:tp},Symbol.toStringTag,{value:"Module"})),rp=Ce({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),sp=Ce({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),ip=Object.freeze(Object.defineProperty({__proto__:null,base16:rp,base16upper:sp},Symbol.toStringTag,{value:"Module"})),op=Ce({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ap=Object.freeze(Object.defineProperty({__proto__:null,base2:op},Symbol.toStringTag,{value:"Module"})),Sc=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),cp=Sc.reduce((n,e,t)=>(n[t]=e,n),[]),lp=Sc.reduce((n,e,t)=>{const r=e.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${e}`);return n[r]=t,n},[]);function up(n){return n.reduce((e,t)=>(e+=cp[t],e),"")}function hp(n){const e=[];for(const t of n){const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);const s=lp[r];if(s==null)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const fp=Cs({prefix:"🚀",name:"base256emoji",encode:up,decode:hp}),dp=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:fp},Symbol.toStringTag,{value:"Module"})),Qt=Ce({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),gp=Ce({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),pp=Ce({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),yp=Ce({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),mp=Ce({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),wp=Ce({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),bp=Ce({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Ep=Ce({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),vp=Ce({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),_p=Object.freeze(Object.defineProperty({__proto__:null,base32:Qt,base32hex:mp,base32hexpad:bp,base32hexpadupper:Ep,base32hexupper:wp,base32pad:pp,base32padupper:yp,base32upper:gp,base32z:vp},Symbol.toStringTag,{value:"Module"})),Bs=Cr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ap=Cr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Sp=Object.freeze(Object.defineProperty({__proto__:null,base36:Bs,base36upper:Ap},Symbol.toStringTag,{value:"Module"})),io=Ce({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),xp=Ce({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),oo=Ce({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Rp=Ce({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Ip=Object.freeze(Object.defineProperty({__proto__:null,base64:io,base64pad:xp,base64url:oo,base64urlpad:Rp},Symbol.toStringTag,{value:"Module"})),kp=Ce({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Tp=Object.freeze(Object.defineProperty({__proto__:null,base8:kp},Symbol.toStringTag,{value:"Module"})),Cp=Cs({prefix:"\0",name:"identity",encode:n=>bg(n),decode:n=>wg(n)}),Np=Object.freeze(Object.defineProperty({__proto__:null,identity:Cp},Symbol.toStringTag,{value:"Module"}));new TextEncoder,new TextDecoder;function xc(n,e){const{bytes:t,version:r}=n;switch(r){case 0:return Dp(t,ao(n),e??Ve.encoder);default:return Bp(t,ao(n),e??Qt.encoder)}}const Rc=new WeakMap;function ao(n){const e=Rc.get(n);if(e==null){const t=new Map;return Rc.set(n,t),t}return e}class _e{constructor(e,t,r,s){f(this,"code");f(this,"version");f(this,"multihash");f(this,"bytes");f(this,"/");f(this,Od,"CID");this.code=t,this.version=e,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Lr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Op)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return _e.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Nr(e,t);return _e.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return _e.equals(this,e)}static equals(e,t){const r=t;return r!=null&&e.code===r.code&&e.version===r.version&&Yg(e.multihash,r.multihash)}toString(e){return xc(this,e)}toJSON(){return{"/":xc(this)}}link(){return this}[(Od=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof _e)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:s,multihash:i,bytes:o}=t;return new _e(r,s,i,o??Ic(r,s,i.bytes))}else if(t[Pp]===!0){const{version:r,multihash:s,code:i}=t,o=ro(s);return _e.create(r,i,o)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==Lr)throw new Error(`Version 0 CID must use dag-pb (code: ${Lr}) block encoding`);return new _e(e,t,r,r.bytes)}case 1:{const s=Ic(e,t,r.bytes);return new _e(e,t,r,s)}default:throw new Error("Invalid version")}}static createV0(e){return _e.create(0,Lr,e)}static createV1(e,t){return _e.create(1,e,t)}static decode(e){const[t,r]=_e.decodeFirst(e);if(r.length!==0)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=_e.inspectBytes(e),r=t.size-t.multihashSize,s=Ts(e.subarray(r,r+t.multihashSize));if(s.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=s.subarray(t.multihashSize-t.digestSize),o=new so(t.multihashCode,t.digestSize,i,s);return[t.version===0?_e.createV0(o):_e.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[h,g]=no(e.subarray(t));return t+=g,h};let s=r(),i=Lr;if(s===18?(s=0,t=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=t,a=r(),c=r(),l=t+c,u=l-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,s]=Lp(e,t),i=_e.decode(s);if(i.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ao(i).set(r,e),i}}function Lp(n,e){switch(n[0]){case"Q":{const t=e??Ve;return[Ve.prefix,t.decode(`${Ve.prefix}${n}`)]}case Ve.prefix:{const t=e??Ve;return[Ve.prefix,t.decode(n)]}case Qt.prefix:{const t=e??Qt;return[Qt.prefix,t.decode(n)]}case Bs.prefix:{const t=e??Bs;return[Bs.prefix,t.decode(n)]}default:{if(e==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[n[0],e.decode(n)]}}}function Dp(n,e,t){const{prefix:r}=t;if(r!==Ve.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const s=e.get(r);if(s==null){const i=t.encode(n).slice(1);return e.set(r,i),i}else return s}function Bp(n,e,t){const{prefix:r}=t,s=e.get(r);if(s==null){const i=t.encode(n);return e.set(r,i),i}else return s}const Lr=112,Op=18;function Ic(n,e,t){const r=Ds(n),s=r+Ds(e),i=new Uint8Array(s+t.byteLength);return Ls(n,i,0),Ls(e,i,r),i.set(t,s),i}const Pp=Symbol.for("@ipld/js-cid/CID"),Dr={...Np,...ap,...Tp,...np,...ip,..._p,...Sp,...Ng,...Ip,...dp};function kc(n,e,t,r){return{name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:r}}}const Tc=kc("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),co=kc("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=vt(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),Cc={utf8:Tc,"utf-8":Tc,hex:Dr.base16,latin1:co,ascii:co,binary:co,...Dr};function z(n,e="utf8"){const t=Cc[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${n}`)}function Jt(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}const Hn=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Up(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function En(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function Kn(n,...e){if(!Up(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error("Uint8Array expected of length "+e+", got length="+n.length)}function Os(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");En(n.outputLen),En(n.blockLen)}function Ps(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function Mp(n,e){Kn(n);const t=e.outputLen;if(n.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}function en(...n){for(let e=0;e<n.length;e++)n[e].fill(0)}function Us(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function _t(n,e){return n<<32-e|n>>>e}const Fp=async()=>{};async function Vp(n,e,t){let r=Date.now();for(let s=0;s<n;s++){t(s);const i=Date.now()-r;i>=0&&i<e||(await Fp(),r+=i)}}function Nc(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function Br(n){return typeof n=="string"&&(n=Nc(n)),Kn(n),n}function Lc(n){return typeof n=="string"&&(n=Nc(n)),Kn(n),n}function $p(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];Kn(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}function Hp(n,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(n,e)}class Dc{}function Bc(n){const e=r=>n().update(Br(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function Ms(n=32){if(Hn&&typeof Hn.getRandomValues=="function")return Hn.getRandomValues(new Uint8Array(n));if(Hn&&typeof Hn.randomBytes=="function")return Uint8Array.from(Hn.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function Kp(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=r?4:0,l=r?0:4;n.setUint32(e+c,o,r),n.setUint32(e+l,a,r)}function zp(n,e,t){return n&e^~n&t}function qp(n,e,t){return n&e^n&t^e&t}class Oc extends Dc{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=Us(this.buffer)}update(e){Ps(this),e=Br(e),Kn(e);const{view:t,buffer:r,blockLen:s}=this,i=e.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=Us(e);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Ps(this),Mp(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;t[o++]=128,en(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let h=o;h<s;h++)t[h]=0;Kp(r,s-8,BigInt(this.length*8),i),this.process(r,0);const a=Us(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)a.setUint32(4*h,u[h],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return e.destroyed=o,e.finished=i,e.length=s,e.pos=a,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const tn=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),De=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Fs=BigInt(2**32-1),Pc=BigInt(32);function Gp(n,e=!1){return e?{h:Number(n&Fs),l:Number(n>>Pc&Fs)}:{h:Number(n>>Pc&Fs)|0,l:Number(n&Fs)|0}}function Wp(n,e=!1){const t=n.length;let r=new Uint32Array(t),s=new Uint32Array(t);for(let i=0;i<t;i++){const{h:o,l:a}=Gp(n[i],e);[r[i],s[i]]=[o,a]}return[r,s]}const Uc=(n,e,t)=>n>>>t,Mc=(n,e,t)=>n<<32-t|e>>>t,zn=(n,e,t)=>n>>>t|e<<32-t,qn=(n,e,t)=>n<<32-t|e>>>t,Vs=(n,e,t)=>n<<64-t|e>>>t-32,$s=(n,e,t)=>n>>>t-32|e<<64-t;function Ut(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Yp=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),jp=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,Xp=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Zp=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,Qp=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),Jp=(n,e,t,r,s,i)=>e+t+r+s+i+(n/2**32|0)|0,ey=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nn=new Uint32Array(64);class ty extends Oc{constructor(e=32){super(64,e,8,!1),this.A=tn[0]|0,this.B=tn[1]|0,this.C=tn[2]|0,this.D=tn[3]|0,this.E=tn[4]|0,this.F=tn[5]|0,this.G=tn[6]|0,this.H=tn[7]|0}get(){const{A:e,B:t,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[e,t,r,s,i,o,a,c]}set(e,t,r,s,i,o,a,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(e,t){for(let h=0;h<16;h++,t+=4)nn[h]=e.getUint32(t,!1);for(let h=16;h<64;h++){const g=nn[h-15],y=nn[h-2],m=_t(g,7)^_t(g,18)^g>>>3,d=_t(y,17)^_t(y,19)^y>>>10;nn[h]=d+nn[h-7]+m+nn[h-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:l,H:u}=this;for(let h=0;h<64;h++){const g=_t(a,6)^_t(a,11)^_t(a,25),y=u+g+zp(a,c,l)+ey[h]+nn[h]|0,d=(_t(r,2)^_t(r,13)^_t(r,22))+qp(r,s,i)|0;u=l,l=c,c=a,a=o+y|0,o=i,i=s,s=r,r=y+d|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,l=l+this.G|0,u=u+this.H|0,this.set(r,s,i,o,a,c,l,u)}roundClean(){en(nn)}destroy(){this.set(0,0,0,0,0,0,0,0),en(this.buffer)}}const Fc=Wp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),ny=Fc[0],ry=Fc[1],rn=new Uint32Array(80),sn=new Uint32Array(80);class sy extends Oc{constructor(e=64){super(128,e,16,!1),this.Ah=De[0]|0,this.Al=De[1]|0,this.Bh=De[2]|0,this.Bl=De[3]|0,this.Ch=De[4]|0,this.Cl=De[5]|0,this.Dh=De[6]|0,this.Dl=De[7]|0,this.Eh=De[8]|0,this.El=De[9]|0,this.Fh=De[10]|0,this.Fl=De[11]|0,this.Gh=De[12]|0,this.Gl=De[13]|0,this.Hh=De[14]|0,this.Hl=De[15]|0}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:l,El:u,Fh:h,Fl:g,Gh:y,Gl:m,Hh:d,Hl:p}=this;return[e,t,r,s,i,o,a,c,l,u,h,g,y,m,d,p]}set(e,t,r,s,i,o,a,c,l,u,h,g,y,m,d,p){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=h|0,this.Fl=g|0,this.Gh=y|0,this.Gl=m|0,this.Hh=d|0,this.Hl=p|0}process(e,t){for(let w=0;w<16;w++,t+=4)rn[w]=e.getUint32(t),sn[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const E=rn[w-15]|0,A=sn[w-15]|0,S=zn(E,A,1)^zn(E,A,8)^Uc(E,A,7),k=qn(E,A,1)^qn(E,A,8)^Mc(E,A,7),C=rn[w-2]|0,_=sn[w-2]|0,U=zn(C,_,19)^Vs(C,_,61)^Uc(C,_,6),V=qn(C,_,19)^$s(C,_,61)^Mc(C,_,6),P=Xp(k,V,sn[w-7],sn[w-16]),K=Zp(P,S,U,rn[w-7],rn[w-16]);rn[w]=K|0,sn[w]=P|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:l,Dl:u,Eh:h,El:g,Fh:y,Fl:m,Gh:d,Gl:p,Hh:b,Hl:v}=this;for(let w=0;w<80;w++){const E=zn(h,g,14)^zn(h,g,18)^Vs(h,g,41),A=qn(h,g,14)^qn(h,g,18)^$s(h,g,41),S=h&y^~h&d,k=g&m^~g&p,C=Qp(v,A,k,ry[w],sn[w]),_=Jp(C,b,E,S,ny[w],rn[w]),U=C|0,V=zn(r,s,28)^Vs(r,s,34)^Vs(r,s,39),P=qn(r,s,28)^$s(r,s,34)^$s(r,s,39),K=r&i^r&a^i&a,L=s&o^s&c^o&c;b=d|0,v=p|0,d=y|0,p=m|0,y=h|0,m=g|0,{h,l:g}=Ut(l|0,u|0,_|0,U|0),l=a|0,u=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const T=Yp(U,P,L);r=jp(T,_,V,K),s=T|0}({h:r,l:s}=Ut(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=Ut(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=Ut(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=Ut(this.Dh|0,this.Dl|0,l|0,u|0),{h,l:g}=Ut(this.Eh|0,this.El|0,h|0,g|0),{h:y,l:m}=Ut(this.Fh|0,this.Fl|0,y|0,m|0),{h:d,l:p}=Ut(this.Gh|0,this.Gl|0,d|0,p|0),{h:b,l:v}=Ut(this.Hh|0,this.Hl|0,b|0,v|0),this.set(r,s,i,o,a,c,l,u,h,g,y,m,d,p,b,v)}roundClean(){en(rn,sn)}destroy(){en(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Vc=Bc(()=>new ty),$c=Bc(()=>new sy);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const lo=BigInt(0),uo=BigInt(1);function Gn(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function ho(n){if(!Gn(n))throw new Error("Uint8Array expected")}function on(n,e){if(typeof e!="boolean")throw new Error(n+" boolean expected, got "+e)}function Hs(n){const e=n.toString(16);return e.length&1?"0"+e:e}function Hc(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?lo:BigInt("0x"+n)}const Kc=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",iy=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function Wn(n){if(ho(n),Kc)return n.toHex();let e="";for(let t=0;t<n.length;t++)e+=iy[n[t]];return e}const Mt={_0:48,_9:57,A:65,F:70,a:97,f:102};function zc(n){if(n>=Mt._0&&n<=Mt._9)return n-Mt._0;if(n>=Mt.A&&n<=Mt.F)return n-(Mt.A-10);if(n>=Mt.a&&n<=Mt.f)return n-(Mt.a-10)}function Ks(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(Kc)return Uint8Array.fromHex(n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,i=0;s<t;s++,i+=2){const o=zc(n.charCodeAt(i)),a=zc(n.charCodeAt(i+1));if(o===void 0||a===void 0){const c=n[i]+n[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function vn(n){return Hc(Wn(n))}function _n(n){return ho(n),Hc(Wn(Uint8Array.from(n).reverse()))}function Or(n,e){return Ks(n.toString(16).padStart(e*2,"0"))}function Pr(n,e){return Or(n,e).reverse()}function we(n,e,t){let r;if(typeof e=="string")try{r=Ks(e)}catch(i){throw new Error(n+" must be hex string or Uint8Array, cause: "+i)}else if(Gn(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(n+" of length "+t+" expected, got "+s);return r}function Yn(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];ho(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const i=n[r];t.set(i,s),s+=i.length}return t}const fo=n=>typeof n=="bigint"&&lo<=n;function go(n,e,t){return fo(n)&&fo(e)&&fo(t)&&e<=n&&n<t}function Qe(n,e,t,r){if(!go(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function oy(n){let e;for(e=0;n>lo;n>>=uo,e+=1);return e}const zs=n=>(uo<<BigInt(n))-uo,po=n=>new Uint8Array(n),qc=n=>Uint8Array.from(n);function ay(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=po(n),s=po(n),i=0;const o=()=>{r.fill(1),s.fill(0),i=0},a=(...h)=>t(s,r,...h),c=(h=po(0))=>{s=a(qc([0]),h),r=a(),h.length!==0&&(s=a(qc([1]),h),r=a())},l=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const g=[];for(;h<e;){r=a();const y=r.slice();g.push(y),h+=r.length}return Yn(...g)};return(h,g)=>{o(),c(h);let y;for(;!(y=g(l()));)c();return o(),y}}const cy={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||Gn(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function jn(n,e,t={}){const r=(s,i,o)=>{const a=cy[i];if(typeof a!="function")throw new Error("invalid validator function");const c=n[s];if(!(o&&c===void 0)&&!a(c,n))throw new Error("param "+String(s)+" is invalid. Expected "+i+", got "+c)};for(const[s,i]of Object.entries(e))r(s,i,!1);for(const[s,i]of Object.entries(t))r(s,i,!0);return n}function qs(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const i=n(t,...r);return e.set(t,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ye=BigInt(0),Ie=BigInt(1),An=BigInt(2),ly=BigInt(3),yo=BigInt(4),Gc=BigInt(5),Wc=BigInt(8);function le(n,e){const t=n%e;return t>=Ye?t:e+t}function pe(n,e,t){let r=n;for(;e-- >Ye;)r*=r,r%=t;return r}function mo(n,e){if(n===Ye)throw new Error("invert: expected non-zero number");if(e<=Ye)throw new Error("invert: expected positive modulus, got "+e);let t=le(n,e),r=e,s=Ye,i=Ie;for(;t!==Ye;){const a=r/t,c=r%t,l=s-i*a;r=t,t=c,s=i,i=l}if(r!==Ie)throw new Error("invert: does not exist");return le(s,e)}function uy(n){let e=n-Ie,t=0;for(;e%An===Ye;)e/=An,t++;let r=An;const s=Xn(n);for(;r<n&&Yc(s,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1){const o=(n+Ie)/yo;return function(c,l){const u=c.pow(l,o);if(!c.eql(c.sqr(u),l))throw new Error("Cannot find square root");return u}}const i=(e+Ie)/An;return function(a,c){if(!Yc(a,c))throw new Error("Cannot find square root");let l=t,u=a.pow(a.mul(a.ONE,r),e),h=a.pow(c,i),g=a.pow(c,e);for(;!a.eql(g,a.ONE);){if(a.eql(g,a.ZERO))return a.ZERO;let y=1;for(let d=a.sqr(g);y<l&&!a.eql(d,a.ONE);y++)d=a.sqr(d);const m=a.pow(u,Ie<<BigInt(l-y-1));u=a.sqr(m),h=a.mul(h,m),g=a.mul(g,u),l=y}return h}}function hy(n){return n%yo===ly?function(t,r){const s=(n+Ie)/yo,i=t.pow(r,s);if(!t.eql(t.sqr(i),r))throw new Error("Cannot find square root");return i}:n%Wc===Gc?function(t,r){const s=t.mul(r,An),i=(n-Gc)/Wc,o=t.pow(s,i),a=t.mul(r,o),c=t.mul(t.mul(a,An),o),l=t.mul(a,t.sub(c,t.ONE));if(!t.eql(t.sqr(l),r))throw new Error("Cannot find square root");return l}:uy(n)}const fy=(n,e)=>(le(n,e)&Ie)===Ie,dy=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function gy(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=dy.reduce((r,s)=>(r[s]="function",r),e);return jn(n,t)}function py(n,e,t){if(t<Ye)throw new Error("invalid exponent, negatives unsupported");if(t===Ye)return n.ONE;if(t===Ie)return e;let r=n.ONE,s=e;for(;t>Ye;)t&Ie&&(r=n.mul(r,s)),s=n.sqr(s),t>>=Ie;return r}function wo(n,e,t=!1){const r=new Array(e.length).fill(t?n.ZERO:void 0),s=e.reduce((o,a,c)=>n.is0(a)?o:(r[c]=o,n.mul(o,a)),n.ONE),i=n.inv(s);return e.reduceRight((o,a,c)=>n.is0(a)?o:(r[c]=n.mul(o,r[c]),n.mul(o,a)),i),r}function yy(n,e){const t=(n.ORDER-Ie)/An,r=n.pow(e,t),s=n.eql(r,n.ONE),i=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!s&&!i&&!o)throw new Error("Cannot find square root: probably non-prime P");return s?1:i?0:-1}function Yc(n,e){const t=yy(n,e);return t===0||t===1}function jc(n,e){e!==void 0&&En(e);const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Xn(n,e,t=!1,r={}){if(n<=Ye)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:s,nByteLength:i}=jc(n,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:n,isLE:t,BITS:s,BYTES:i,MASK:zs(s),ZERO:Ye,ONE:Ie,create:c=>le(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof c);return Ye<=c&&c<n},is0:c=>c===Ye,isOdd:c=>(c&Ie)===Ie,neg:c=>le(-c,n),eql:(c,l)=>c===l,sqr:c=>le(c*c,n),add:(c,l)=>le(c+l,n),sub:(c,l)=>le(c-l,n),mul:(c,l)=>le(c*l,n),pow:(c,l)=>py(a,c,l),div:(c,l)=>le(c*mo(l,n),n),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>mo(c,n),sqrt:r.sqrt||(c=>(o||(o=hy(n)),o(a,c))),toBytes:c=>t?Pr(c,i):Or(c,i),fromBytes:c=>{if(c.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+c.length);return t?_n(c):vn(c)},invertBatch:c=>wo(a,c),cmov:(c,l,u)=>u?l:c});return Object.freeze(a)}function Xc(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Zc(n){const e=Xc(n);return e+Math.ceil(e/2)}function my(n,e,t=!1){const r=n.length,s=Xc(e),i=Zc(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=t?_n(n):vn(n),a=le(o,e-Ie)+Ie;return t?Pr(a,s):Or(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qc=BigInt(0),bo=BigInt(1);function Eo(n,e){const t=e.negate();return n?t:e}function Jc(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function vo(n,e){Jc(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1),s=2**n,i=zs(n),o=BigInt(n);return{windows:t,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function el(n,e,t){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=t;let a=Number(n&s),c=n>>o;a>r&&(a-=i,c+=bo);const l=e*r,u=l+Math.abs(a)-1,h=a===0,g=a<0,y=e%2!==0;return{nextN:c,offset:u,isZero:h,isNeg:g,isNegF:y,offsetF:l}}function wy(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function by(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const _o=new WeakMap,tl=new WeakMap;function Ao(n){return tl.get(n)||1}function nl(n,e){return{constTimeNegate:Eo,hasPrecomputes(t){return Ao(t)!==1},unsafeLadder(t,r,s=n.ZERO){let i=t;for(;r>Qc;)r&bo&&(s=s.add(i)),i=i.double(),r>>=bo;return s},precomputeWindow(t,r){const{windows:s,windowSize:i}=vo(r,e),o=[];let a=t,c=a;for(let l=0;l<s;l++){c=a,o.push(c);for(let u=1;u<i;u++)c=c.add(a),o.push(c);a=c.double()}return o},wNAF(t,r,s){let i=n.ZERO,o=n.BASE;const a=vo(t,e);for(let c=0;c<a.windows;c++){const{nextN:l,offset:u,isZero:h,isNeg:g,isNegF:y,offsetF:m}=el(s,c,a);s=l,h?o=o.add(Eo(y,r[m])):i=i.add(Eo(g,r[u]))}return{p:i,f:o}},wNAFUnsafe(t,r,s,i=n.ZERO){const o=vo(t,e);for(let a=0;a<o.windows&&s!==Qc;a++){const{nextN:c,offset:l,isZero:u,isNeg:h}=el(s,a,o);if(s=c,!u){const g=r[l];i=i.add(h?g.negate():g)}}return i},getPrecomputes(t,r,s){let i=_o.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&_o.set(r,s(i))),i},wNAFCached(t,r,s){const i=Ao(t);return this.wNAF(i,this.getPrecomputes(i,t,s),r)},wNAFCachedUnsafe(t,r,s,i){const o=Ao(t);return o===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,t,s),r,i)},setWindowSize(t,r){Jc(r,e),tl.set(t,r),_o.delete(t)}}}function rl(n,e,t,r){if(wy(t,n),by(r,e),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=n.ZERO,i=oy(BigInt(t.length)),o=i>12?i-3:i>4?i-2:i?2:1,a=zs(o),c=new Array(Number(a)+1).fill(s),l=Math.floor((e.BITS-1)/o)*o;let u=s;for(let h=l;h>=0;h-=o){c.fill(s);for(let y=0;y<r.length;y++){const m=r[y],d=Number(m>>BigInt(h)&a);c[d]=c[d].add(t[y])}let g=s;for(let y=c.length-1,m=s;y>0;y--)m=m.add(c[y]),g=g.add(m);if(u=u.add(g),h!==0)for(let y=0;y<o;y++)u=u.double()}return u}function So(n){return gy(n.Fp),jn(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jc(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const At=BigInt(0),Ke=BigInt(1),sl=BigInt(2),Ey=BigInt(8),vy={zip215:!0};function _y(n){const e=So(n);return jn(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function Ay(n){const e=_y(n),{Fp:t,n:r,prehash:s,hash:i,randomBytes:o,nByteLength:a,h:c}=e,l=sl<<BigInt(a*8)-Ke,u=t.create,h=Xn(e.n,e.nBitLength),g=e.uvRatio||((N,x)=>{try{return{isValid:!0,value:t.sqrt(N*t.inv(x))}}catch{return{isValid:!1,value:At}}}),y=e.adjustScalarBytes||(N=>N),m=e.domain||((N,x,I)=>{if(on("phflag",I),x.length||I)throw new Error("Contexts/pre-hash are not supported");return N});function d(N,x,I=!1){const B=I?Ke:At;Qe("coordinate "+N,x,B,l)}function p(N){if(!(N instanceof w))throw new Error("ExtendedPoint expected")}const b=qs((N,x)=>{const{ex:I,ey:B,ez:M}=N,$=N.is0();x==null&&(x=$?Ey:t.inv(M));const q=u(I*x),G=u(B*x),W=u(M*x);if($)return{x:At,y:Ke};if(W!==Ke)throw new Error("invZ was invalid");return{x:q,y:G}}),v=qs(N=>{const{a:x,d:I}=e;if(N.is0())throw new Error("bad point: ZERO");const{ex:B,ey:M,ez:$,et:q}=N,G=u(B*B),W=u(M*M),Y=u($*$),ce=u(Y*Y),se=u(G*x),ge=u(Y*u(se+W)),Ze=u(ce+u(I*u(G*W)));if(ge!==Ze)throw new Error("bad point: equation left != right (1)");const Te=u(B*M),Fe=u($*q);if(Te!==Fe)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(x,I,B,M){d("x",x),d("y",I),d("z",B,!0),d("t",M),this.ex=x,this.ey=I,this.ez=B,this.et=M,Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(x){if(x instanceof w)throw new Error("extended point not allowed");const{x:I,y:B}=x||{};return d("x",I),d("y",B),new w(I,B,Ke,u(I*B))}static normalizeZ(x){const I=wo(t,x.map(B=>B.ez));return x.map((B,M)=>B.toAffine(I[M])).map(w.fromAffine)}static msm(x,I){return rl(w,h,x,I)}_setWindowSize(x){S.setWindowSize(this,x)}assertValidity(){v(this)}equals(x){p(x);const{ex:I,ey:B,ez:M}=this,{ex:$,ey:q,ez:G}=x,W=u(I*G),Y=u($*M),ce=u(B*G),se=u(q*M);return W===Y&&ce===se}is0(){return this.equals(w.ZERO)}negate(){return new w(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:x}=e,{ex:I,ey:B,ez:M}=this,$=u(I*I),q=u(B*B),G=u(sl*u(M*M)),W=u(x*$),Y=I+B,ce=u(u(Y*Y)-$-q),se=W+q,ge=se-G,Ze=W-q,Te=u(ce*ge),Fe=u(se*Ze),lt=u(ce*Ze),Ot=u(ge*se);return new w(Te,Fe,Ot,lt)}add(x){p(x);const{a:I,d:B}=e,{ex:M,ey:$,ez:q,et:G}=this,{ex:W,ey:Y,ez:ce,et:se}=x,ge=u(M*W),Ze=u($*Y),Te=u(G*B*se),Fe=u(q*ce),lt=u((M+$)*(W+Y)-ge-Ze),Ot=Fe-Te,Zt=Fe+Te,og=u(Ze-I*ge),W_=u(lt*Ot),Y_=u(Zt*og),j_=u(lt*og),X_=u(Ot*Zt);return new w(W_,Y_,X_,j_)}subtract(x){return this.add(x.negate())}wNAF(x){return S.wNAFCached(this,x,w.normalizeZ)}multiply(x){const I=x;Qe("scalar",I,Ke,r);const{p:B,f:M}=this.wNAF(I);return w.normalizeZ([B,M])[0]}multiplyUnsafe(x,I=w.ZERO){const B=x;return Qe("scalar",B,At,r),B===At?A:this.is0()||B===Ke?this:S.wNAFCachedUnsafe(this,B,w.normalizeZ,I)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return S.unsafeLadder(this,r).is0()}toAffine(x){return b(this,x)}clearCofactor(){const{h:x}=e;return x===Ke?this:this.multiplyUnsafe(x)}static fromHex(x,I=!1){const{d:B,a:M}=e,$=t.BYTES;x=we("pointHex",x,$),on("zip215",I);const q=x.slice(),G=x[$-1];q[$-1]=G&-129;const W=_n(q),Y=I?l:t.ORDER;Qe("pointHex.y",W,At,Y);const ce=u(W*W),se=u(ce-Ke),ge=u(B*ce-M);let{isValid:Ze,value:Te}=g(se,ge);if(!Ze)throw new Error("Point.fromHex: invalid y coordinate");const Fe=(Te&Ke)===Ke,lt=(G&128)!==0;if(!I&&Te===At&&lt)throw new Error("Point.fromHex: x=0 and x_0=1");return lt!==Fe&&(Te=u(-Te)),w.fromAffine({x:Te,y:W})}static fromPrivateKey(x){const{scalar:I}=_(x);return E.multiply(I)}toRawBytes(){const{x,y:I}=this.toAffine(),B=Pr(I,t.BYTES);return B[B.length-1]|=x&Ke?128:0,B}toHex(){return Wn(this.toRawBytes())}}w.BASE=new w(e.Gx,e.Gy,Ke,u(e.Gx*e.Gy)),w.ZERO=new w(At,Ke,Ke,At);const{BASE:E,ZERO:A}=w,S=nl(w,a*8);function k(N){return le(N,r)}function C(N){return k(_n(N))}function _(N){const x=t.BYTES;N=we("private key",N,x);const I=we("hashed private key",i(N),2*x),B=y(I.slice(0,x)),M=I.slice(x,2*x),$=C(B);return{head:B,prefix:M,scalar:$}}function U(N){const{head:x,prefix:I,scalar:B}=_(N),M=E.multiply(B),$=M.toRawBytes();return{head:x,prefix:I,scalar:B,point:M,pointBytes:$}}function V(N){return U(N).pointBytes}function P(N=Uint8Array.of(),...x){const I=Yn(...x);return C(i(m(I,we("context",N),!!s)))}function K(N,x,I={}){N=we("message",N),s&&(N=s(N));const{prefix:B,scalar:M,pointBytes:$}=U(x),q=P(I.context,B,N),G=E.multiply(q).toRawBytes(),W=P(I.context,G,$,N),Y=k(q+W*M);Qe("signature.s",Y,At,r);const ce=Yn(G,Pr(Y,t.BYTES));return we("result",ce,t.BYTES*2)}const L=vy;function T(N,x,I,B=L){const{context:M,zip215:$}=B,q=t.BYTES;N=we("signature",N,2*q),x=we("message",x),I=we("publicKey",I,q),$!==void 0&&on("zip215",$),s&&(x=s(x));const G=_n(N.slice(q,2*q));let W,Y,ce;try{W=w.fromHex(I,$),Y=w.fromHex(N.slice(0,q),$),ce=E.multiplyUnsafe(G)}catch{return!1}if(!$&&W.isSmallOrder())return!1;const se=P(M,Y.toRawBytes(),W.toRawBytes(),x);return Y.add(W.multiplyUnsafe(se)).subtract(ce).clearCofactor().equals(w.ZERO)}return E._setWindowSize(8),{CURVE:e,getPublicKey:V,sign:K,verify:T,ExtendedPoint:w,utils:{getExtendedPublicKey:U,randomPrivateKey:()=>o(t.BYTES),precompute(N=8,x=w.BASE){return x._setWindowSize(N),x.multiply(BigInt(3)),x}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zn=BigInt(0),xo=BigInt(1);function Sy(n){return jn(n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...n})}function xy(n){const e=Sy(n),{P:t}=e,r=Xn(t),s=w=>le(w,t),i=e.montgomeryBits,o=Math.ceil(i/8),a=e.nByteLength,c=e.adjustScalarBytes||(w=>w),l=e.powPminus2||(w=>r.pow(w,t-BigInt(2)));function u(w,E,A){const S=s(w*(E-A));return E=s(E-S),A=s(A+S),[E,A]}const h=(e.a-BigInt(2))/BigInt(4);function g(w,E){Qe("u",w,Zn,t),Qe("scalar",E,Zn,t);const A=E,S=w;let k=xo,C=Zn,_=w,U=xo,V=Zn,P;for(let L=BigInt(i-1);L>=Zn;L--){const T=A>>L&xo;V^=T,P=u(V,k,_),k=P[0],_=P[1],P=u(V,C,U),C=P[0],U=P[1],V=T;const O=k+C,N=s(O*O),x=k-C,I=s(x*x),B=N-I,M=_+U,$=_-U,q=s($*O),G=s(M*x),W=q+G,Y=q-G;_=s(W*W),U=s(S*s(Y*Y)),k=s(N*I),C=s(B*(N+s(h*B)))}P=u(V,k,_),k=P[0],_=P[1],P=u(V,C,U),C=P[0],U=P[1];const K=l(C);return s(k*K)}function y(w){return Pr(s(w),o)}function m(w){const E=we("u coordinate",w,o);return a===32&&(E[31]&=127),_n(E)}function d(w){const E=we("scalar",w),A=E.length;if(A!==o&&A!==a){let S=""+o+" or "+a;throw new Error("invalid scalar, expected "+S+" bytes, got "+A)}return _n(c(E))}function p(w,E){const A=m(E),S=d(w),k=g(A,S);if(k===Zn)throw new Error("invalid private or public key received");return y(k)}const b=y(e.Gu);function v(w){return p(w,b)}return{scalarMult:p,scalarMultBase:v,getSharedSecret:(w,E)=>p(w,E),getPublicKey:w=>v(w),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ur=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),il=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Ry=BigInt(1),ol=BigInt(2),Iy=BigInt(3),ky=BigInt(5),Ty=BigInt(8);function al(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),i=Ur,a=n*n%i*n%i,c=pe(a,ol,i)*a%i,l=pe(c,Ry,i)*n%i,u=pe(l,ky,i)*l%i,h=pe(u,e,i)*u%i,g=pe(h,t,i)*h%i,y=pe(g,r,i)*g%i,m=pe(y,s,i)*y%i,d=pe(m,s,i)*y%i,p=pe(d,e,i)*u%i;return{pow_p_5_8:pe(p,ol,i)*n%i,b2:a}}function cl(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function Cy(n,e){const t=Ur,r=le(e*e*e,t),s=le(r*r*e,t),i=al(n*s).pow_p_5_8;let o=le(n*r*i,t);const a=le(e*o*o,t),c=o,l=le(o*il,t),u=a===n,h=a===le(-n,t),g=a===le(-n*il,t);return u&&(o=c),(h||g)&&(o=l),fy(o,t)&&(o=le(-o,t)),{isValid:u||h,value:o}}const ll=Xn(Ur,void 0,!0),Ny={a:ll.create(BigInt(-1)),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ll,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ty,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:$c,randomBytes:Ms,adjustScalarBytes:cl,uvRatio:Cy},Mr=Ay(Ny),Gs=xy({P:Ur,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:n=>{const e=Ur,{pow_p_5_8:t,b2:r}=al(n);return le(pe(t,Iy,e)*r,e)},adjustScalarBytes:cl,randomBytes:Ms}),Fr=32,an=64,Ws=32;function Ly(){const n=Mr.utils.randomPrivateKey(),e=Mr.getPublicKey(n);return{privateKey:ul(n,e),publicKey:e}}function Dy(n){if(n.length!==Ws)throw new TypeError('"seed" must be 32 bytes in length.');if(!(n instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const e=n,t=Mr.getPublicKey(e);return{privateKey:ul(e,t),publicKey:t}}function By(n,e){const t=n.subarray(0,Ws);return Mr.sign(e instanceof Uint8Array?e:e.subarray(),t)}function Oy(n,e,t){return Mr.verify(e,t instanceof Uint8Array?t:t.subarray(),n)}function ul(n,e){const t=new Uint8Array(an);for(let r=0;r<Ws;r++)t[r]=n[r],t[Ws+r]=e[r];return t}const yt={get(n=globalThis){const e=n.crypto;if((e==null?void 0:e.subtle)==null)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return e}},Ro={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function Py(n){const e="AES-GCM";let t=16;const r=12,s="SHA-256",i=16,o=32767,a=yt.get();t*=8;async function c(h,g){const y=a.getRandomValues(new Uint8Array(i)),m=a.getRandomValues(new Uint8Array(r)),d={name:e,iv:m};typeof g=="string"&&(g=z(g));let p;if(g.length===0){p=await a.subtle.importKey("jwk",Ro,{name:"AES-GCM"},!0,["encrypt"]);try{const v={name:"PBKDF2",salt:y,iterations:o,hash:{name:s}},w=await a.subtle.importKey("raw",g,{name:"PBKDF2"},!1,["deriveKey"]);p=await a.subtle.deriveKey(v,w,{name:e,length:t},!0,["encrypt"])}catch{p=await a.subtle.importKey("jwk",Ro,{name:"AES-GCM"},!0,["encrypt"])}}else{const v={name:"PBKDF2",salt:y,iterations:o,hash:{name:s}},w=await a.subtle.importKey("raw",g,{name:"PBKDF2"},!1,["deriveKey"]);p=await a.subtle.deriveKey(v,w,{name:e,length:t},!0,["encrypt"])}const b=await a.subtle.encrypt(d,p,h);return Pt([y,d.iv,new Uint8Array(b)])}async function l(h,g){const y=h.subarray(0,i),m=h.subarray(i,i+r),d=h.subarray(i+r),p={name:e,iv:m};typeof g=="string"&&(g=z(g));let b;if(g.length===0)try{const w={name:"PBKDF2",salt:y,iterations:o,hash:{name:s}},E=await a.subtle.importKey("raw",g,{name:"PBKDF2"},!1,["deriveKey"]);b=await a.subtle.deriveKey(w,E,{name:e,length:t},!0,["decrypt"])}catch{b=await a.subtle.importKey("jwk",Ro,{name:"AES-GCM"},!0,["decrypt"])}else{const w={name:"PBKDF2",salt:y,iterations:o,hash:{name:s}},E=await a.subtle.importKey("raw",g,{name:"PBKDF2"},!1,["deriveKey"]);b=await a.subtle.deriveKey(w,E,{name:e,length:t},!0,["decrypt"])}const v=await a.subtle.decrypt(p,b,d);return new Uint8Array(v)}return{encrypt:c,decrypt:l}}async function Io(n,e){const r=await Py().encrypt(n,e);return io.encode(r)}const Uy=Math.pow(2,7),My=Math.pow(2,14),Fy=Math.pow(2,21),ko=Math.pow(2,28),To=Math.pow(2,35),Co=Math.pow(2,42),No=Math.pow(2,49),ne=128,Be=127;function ut(n){if(n<Uy)return 1;if(n<My)return 2;if(n<Fy)return 3;if(n<ko)return 4;if(n<To)return 5;if(n<Co)return 6;if(n<No)return 7;if(Number.MAX_SAFE_INTEGER!=null&&n>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Ys(n,e,t=0){switch(ut(n)){case 8:e[t++]=n&255|ne,n/=128;case 7:e[t++]=n&255|ne,n/=128;case 6:e[t++]=n&255|ne,n/=128;case 5:e[t++]=n&255|ne,n/=128;case 4:e[t++]=n&255|ne,n>>>=7;case 3:e[t++]=n&255|ne,n>>>=7;case 2:e[t++]=n&255|ne,n>>>=7;case 1:{e[t++]=n&255,n>>>=7;break}default:throw new Error("unreachable")}return e}function Vy(n,e,t=0){switch(ut(n)){case 8:e.set(t++,n&255|ne),n/=128;case 7:e.set(t++,n&255|ne),n/=128;case 6:e.set(t++,n&255|ne),n/=128;case 5:e.set(t++,n&255|ne),n/=128;case 4:e.set(t++,n&255|ne),n>>>=7;case 3:e.set(t++,n&255|ne),n>>>=7;case 2:e.set(t++,n&255|ne),n>>>=7;case 1:{e.set(t++,n&255),n>>>=7;break}default:throw new Error("unreachable")}return e}function hl(n,e){let t=n[e],r=0;if(r+=t&Be,t<ne||(t=n[e+1],r+=(t&Be)<<7,t<ne)||(t=n[e+2],r+=(t&Be)<<14,t<ne)||(t=n[e+3],r+=(t&Be)<<21,t<ne)||(t=n[e+4],r+=(t&Be)*ko,t<ne)||(t=n[e+5],r+=(t&Be)*To,t<ne)||(t=n[e+6],r+=(t&Be)*Co,t<ne)||(t=n[e+7],r+=(t&Be)*No,t<ne))return r;throw new RangeError("Could not decode varint")}function $y(n,e){let t=n.get(e),r=0;if(r+=t&Be,t<ne||(t=n.get(e+1),r+=(t&Be)<<7,t<ne)||(t=n.get(e+2),r+=(t&Be)<<14,t<ne)||(t=n.get(e+3),r+=(t&Be)<<21,t<ne)||(t=n.get(e+4),r+=(t&Be)*ko,t<ne)||(t=n.get(e+5),r+=(t&Be)*To,t<ne)||(t=n.get(e+6),r+=(t&Be)*Co,t<ne)||(t=n.get(e+7),r+=(t&Be)*No,t<ne))return r;throw new RangeError("Could not decode varint")}function Qn(n,e,t=0){return e==null&&(e=vt(ut(n))),e instanceof Uint8Array?Ys(n,e,t):Vy(n,e,t)}function js(n,e=0){return n instanceof Uint8Array?hl(n,e):$y(n,e)}const Lo=new Float32Array([-0]),cn=new Uint8Array(Lo.buffer);function Hy(n,e,t){Lo[0]=n,e[t]=cn[0],e[t+1]=cn[1],e[t+2]=cn[2],e[t+3]=cn[3]}function Ky(n,e){return cn[0]=n[e],cn[1]=n[e+1],cn[2]=n[e+2],cn[3]=n[e+3],Lo[0]}const Do=new Float64Array([-0]),Oe=new Uint8Array(Do.buffer);function zy(n,e,t){Do[0]=n,e[t]=Oe[0],e[t+1]=Oe[1],e[t+2]=Oe[2],e[t+3]=Oe[3],e[t+4]=Oe[4],e[t+5]=Oe[5],e[t+6]=Oe[6],e[t+7]=Oe[7]}function qy(n,e){return Oe[0]=n[e],Oe[1]=n[e+1],Oe[2]=n[e+2],Oe[3]=n[e+3],Oe[4]=n[e+4],Oe[5]=n[e+5],Oe[6]=n[e+6],Oe[7]=n[e+7],Do[0]}const Gy=BigInt(Number.MAX_SAFE_INTEGER),Wy=BigInt(Number.MIN_SAFE_INTEGER);class Pe{constructor(e,t){f(this,"lo");f(this,"hi");this.lo=e|0,this.hi=t|0}toNumber(e=!1){if(!e&&this.hi>>>31>0){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(t+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(e=!1){if(e)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const t=~this.lo+1>>>0;let r=~this.hi>>>0;return t===0&&(r=r+1>>>0),-(BigInt(t)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(e=!1){return this.toBigInt(e).toString()}zzEncode(){const e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this}zzDecode(){const e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this}length(){const e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?t===0?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}static fromBigInt(e){if(e===0n)return Sn;if(e<Gy&&e>Wy)return this.fromNumber(Number(e));const t=e<0n;t&&(e=-e);let r=e>>32n,s=e-(r<<32n);return t&&(r=~r|0n,s=~s|0n,++s>fl&&(s=0n,++r>fl&&(r=0n))),new Pe(Number(s),Number(r))}static fromNumber(e){if(e===0)return Sn;const t=e<0;t&&(e=-e);let r=e>>>0,s=(e-r)/4294967296>>>0;return t&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new Pe(r,s)}static from(e){return typeof e=="number"?Pe.fromNumber(e):typeof e=="bigint"?Pe.fromBigInt(e):typeof e=="string"?Pe.fromBigInt(BigInt(e)):e.low!=null||e.high!=null?new Pe(e.low>>>0,e.high>>>0):Sn}}const Sn=new Pe(0,0);Sn.toBigInt=function(){return 0n},Sn.zzEncode=Sn.zzDecode=function(){return this},Sn.length=function(){return 1};const fl=4294967296n;function Yy(n){let e=0,t=0;for(let r=0;r<n.length;++r)t=n.charCodeAt(r),t<128?e+=1:t<2048?e+=2:(t&64512)===55296&&(n.charCodeAt(r+1)&64512)===56320?(++r,e+=4):e+=3;return e}function jy(n,e,t){if(t-e<1)return"";let s;const i=[];let o=0,a;for(;e<t;)a=n[e++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|n[e++]&63:a>239&&a<365?(a=((a&7)<<18|(n[e++]&63)<<12|(n[e++]&63)<<6|n[e++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(n[e++]&63)<<6|n[e++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function dl(n,e,t){const r=t;let s,i;for(let o=0;o<n.length;++o)s=n.charCodeAt(o),s<128?e[t++]=s:s<2048?(e[t++]=s>>6|192,e[t++]=s&63|128):(s&64512)===55296&&((i=n.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,e[t++]=s>>18|240,e[t++]=s>>12&63|128,e[t++]=s>>6&63|128,e[t++]=s&63|128):(e[t++]=s>>12|224,e[t++]=s>>6&63|128,e[t++]=s&63|128);return t-r}function mt(n,e){return RangeError(`index out of range: ${n.pos} + ${e??1} > ${n.len}`)}function Xs(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}class Xy{constructor(e){f(this,"buf");f(this,"pos");f(this,"len");f(this,"_slice",Uint8Array.prototype.subarray);this.buf=e,this.pos=0,this.len=e.length}uint32(){let e=4294967295;if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,mt(this,10);return e}int32(){return this.uint32()|0}sint32(){const e=this.uint32();return e>>>1^-(e&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw mt(this,4);return Xs(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw mt(this,4);return Xs(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw mt(this,4);const e=Ky(this.buf,this.pos);return this.pos+=4,e}double(){if(this.pos+8>this.len)throw mt(this,4);const e=qy(this.buf,this.pos);return this.pos+=8,e}bytes(){const e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw mt(this,e);return this.pos+=e,t===r?new Uint8Array(0):this.buf.subarray(t,r)}string(){const e=this.bytes();return jy(e,0,e.length)}skip(e){if(typeof e=="number"){if(this.pos+e>this.len)throw mt(this,e);this.pos+=e}else do if(this.pos>=this.len)throw mt(this);while(this.buf[this.pos++]&128);return this}skipType(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(e=this.uint32()&7)!==4;)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${e} at offset ${this.pos}`)}return this}readLongVarint(){const e=new Pe(0,0);let t=0;if(this.len-this.pos>4){for(;t<4;++t)if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(this.buf[this.pos]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return e;t=0}else{for(;t<3;++t){if(this.pos>=this.len)throw mt(this);if(e.lo=(e.lo|(this.buf[this.pos]&127)<<t*7)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(this.buf[this.pos++]&127)<<t*7)>>>0,e}if(this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw mt(this);if(e.hi=(e.hi|(this.buf[this.pos]&127)<<t*7+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw mt(this,8);const e=Xs(this.buf,this.pos+=4),t=Xs(this.buf,this.pos+=4);return new Pe(e,t)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const e=hl(this.buf,this.pos);return this.pos+=ut(e),e}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Zy(n){return new Xy(n instanceof Uint8Array?n:n.subarray())}function Je(n,e,t){const r=Zy(n);return e.decode(r,void 0,t)}function Qy(n){let r,s=8192;return function(o){if(o<1||o>4096)return vt(o);s+o>8192&&(r=vt(8192),s=0);const a=r.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class Vr{constructor(e,t,r){f(this,"fn");f(this,"len");f(this,"next");f(this,"val");this.fn=e,this.len=t,this.next=void 0,this.val=r}}function Bo(){}class Jy{constructor(e){f(this,"head");f(this,"tail");f(this,"len");f(this,"next");this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}}const em=Qy();function tm(n){return globalThis.Buffer!=null?vt(n):em(n)}class Oo{constructor(){f(this,"len");f(this,"head");f(this,"tail");f(this,"states");this.len=0,this.head=new Vr(Bo,0,0),this.tail=this.head,this.states=null}_push(e,t,r){return this.tail=this.tail.next=new Vr(e,t,r),this.len+=t,this}uint32(e){return this.len+=(this.tail=this.tail.next=new rm((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this}int32(e){return e<0?this._push(Zs,10,Pe.fromNumber(e)):this.uint32(e)}sint32(e){return this.uint32((e<<1^e>>31)>>>0)}uint64(e){const t=Pe.fromBigInt(e);return this._push(Zs,t.length(),t)}uint64Number(e){return this._push(Ys,ut(e),e)}uint64String(e){return this.uint64(BigInt(e))}int64(e){return this.uint64(e)}int64Number(e){return this.uint64Number(e)}int64String(e){return this.uint64String(e)}sint64(e){const t=Pe.fromBigInt(e).zzEncode();return this._push(Zs,t.length(),t)}sint64Number(e){const t=Pe.fromNumber(e).zzEncode();return this._push(Zs,t.length(),t)}sint64String(e){return this.sint64(BigInt(e))}bool(e){return this._push(Po,1,e?1:0)}fixed32(e){return this._push($r,4,e>>>0)}sfixed32(e){return this.fixed32(e)}fixed64(e){const t=Pe.fromBigInt(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64Number(e){const t=Pe.fromNumber(e);return this._push($r,4,t.lo)._push($r,4,t.hi)}fixed64String(e){return this.fixed64(BigInt(e))}sfixed64(e){return this.fixed64(e)}sfixed64Number(e){return this.fixed64Number(e)}sfixed64String(e){return this.fixed64String(e)}float(e){return this._push(Hy,4,e)}double(e){return this._push(zy,8,e)}bytes(e){const t=e.length>>>0;return t===0?this._push(Po,1,0):this.uint32(t)._push(sm,t,e)}string(e){const t=Yy(e);return t!==0?this.uint32(t)._push(dl,t,e):this._push(Po,1,0)}fork(){return this.states=new Jy(this),this.head=this.tail=new Vr(Bo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Vr(Bo,0,0),this.len=0),this}ldelim(){const e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=e.next,this.tail=t,this.len+=r),this}finish(){let e=this.head.next;const t=tm(this.len);let r=0;for(;e!=null;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t}}function Po(n,e,t){e[t]=n&255}function nm(n,e,t){for(;n>127;)e[t++]=n&127|128,n>>>=7;e[t]=n}class rm extends Vr{constructor(t,r){super(nm,t,r);f(this,"next");this.next=void 0}}function Zs(n,e,t){for(;n.hi!==0;)e[t++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[t++]=n.lo&127|128,n.lo=n.lo>>>7;e[t++]=n.lo}function $r(n,e,t){e[t]=n&255,e[t+1]=n>>>8&255,e[t+2]=n>>>16&255,e[t+3]=n>>>24}function sm(n,e,t){e.set(n,t)}globalThis.Buffer!=null&&(Oo.prototype.bytes=function(n){const e=n.length>>>0;return this.uint32(e),e>0&&this._push(im,e,n),this},Oo.prototype.string=function(n){const e=globalThis.Buffer.byteLength(n);return this.uint32(e),e>0&&this._push(om,e,n),this});function im(n,e,t){e.set(n,t)}function om(n,e,t){n.length<40?dl(n,e,t):e.utf8Write!=null?e.utf8Write(n,t):e.set(z(n),t)}function am(){return new Oo}function et(n,e){const t=am();return e.encode(n,t,{lengthDelimited:!1}),t.finish()}var Qs;(function(n){n[n.VARINT=0]="VARINT",n[n.BIT64=1]="BIT64",n[n.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",n[n.START_GROUP=3]="START_GROUP",n[n.END_GROUP=4]="END_GROUP",n[n.BIT32=5]="BIT32"})(Qs||(Qs={}));function gl(n,e,t,r){return{name:n,type:e,encode:t,decode:r}}function cm(n){function e(s){if(n[s.toString()]==null)throw new Error("Invalid enum value");return n[s]}const t=function(i,o){const a=e(i);o.int32(a)},r=function(i){const o=i.int32();return e(o)};return gl("enum",Qs.VARINT,t,r)}function tt(n,e){return gl("message",Qs.LENGTH_DELIMITED,n,e)}var Ae;(function(n){n.RSA="RSA",n.Ed25519="Ed25519",n.Secp256k1="Secp256k1"})(Ae||(Ae={}));var Uo;(function(n){n[n.RSA=0]="RSA",n[n.Ed25519=1]="Ed25519",n[n.Secp256k1=2]="Secp256k1"})(Uo||(Uo={})),function(n){n.codec=()=>cm(Uo)}(Ae||(Ae={}));var Jn;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),Ae.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.Type=Ae.codec().decode(t);break;case 2:s.Data=t.bytes();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(Jn||(Jn={}));var er;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.Type!=null&&(r.uint32(8),Ae.codec().encode(t.Type,r)),t.Data!=null&&(r.uint32(18),r.bytes(t.Data)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.Type=Ae.codec().decode(t);break;case 2:s.Data=t.bytes();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(er||(er={}));class Mo{constructor(e){f(this,"_key");this._key=tr(e,Fr)}verify(e,t){return Oy(this._key,t,e)}marshal(){return this._key}get bytes(){return Jn.encode({Type:Ae.Ed25519,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}hash(){const e=pt.digest(this.bytes);return Jt(e)?e.then(({bytes:t})=>t):e.bytes}}class Hr{constructor(e,t){f(this,"_key");f(this,"_publicKey");this._key=tr(e,an),this._publicKey=tr(t,Fr)}sign(e){return By(this._key,e)}get public(){return new Mo(this._publicKey)}marshal(){return this._key}get bytes(){return er.encode({Type:Ae.Ed25519,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}async hash(){const e=pt.digest(this.bytes);let t;return Jt(e)?{bytes:t}=await e:t=e.bytes,t}async id(){const e=$n.digest(this.public.bytes);return Ve.encode(e.bytes).substring(1)}async export(e,t="libp2p-key"){if(t==="libp2p-key")return Io(this.bytes,e);throw new R(`export format '${t}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function lm(n){if(n.length>an){n=tr(n,an+Fr);const r=n.subarray(0,an),s=n.subarray(an,n.length);return new Hr(r,s)}n=tr(n,an);const e=n.subarray(0,an),t=n.subarray(Fr);return new Hr(e,t)}function um(n){return n=tr(n,Fr),new Mo(n)}async function hm(){const{privateKey:n,publicKey:e}=Ly();return new Hr(n,e)}async function fm(n){const{privateKey:e,publicKey:t}=Dy(n);return new Hr(e,t)}function tr(n,e){if(n=Uint8Array.from(n??[]),n.length!==e)throw new R(`Key must be a Uint8Array of length ${e}, got ${n.length}`,"ERR_INVALID_KEY_TYPE");return n}const dm=Object.freeze(Object.defineProperty({__proto__:null,Ed25519PrivateKey:Hr,Ed25519PublicKey:Mo,generateKeyPair:hm,generateKeyPairFromSeed:fm,unmarshalEd25519PrivateKey:lm,unmarshalEd25519PublicKey:um},Symbol.toStringTag,{value:"Module"}));function j(n,e="utf8"){const t=Cc[e];if(t==null)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(n).substring(1)}function Kr(n){if(isNaN(n)||n<=0)throw new R("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return Ms(n)}class pl extends Dc{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,Os(e);const r=Br(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),en(i)}update(e){return Ps(this),this.iHash.update(e),this}digestInto(e){Ps(this),Kn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return e=e,e.finished=s,e.destroyed=i,e.blockLen=o,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const zr=(n,e,t)=>new pl(n,e).update(t).digest();zr.create=(n,e)=>new pl(n,e);function gm(n,e,t,r){Os(n);const s=Hp({dkLen:32,asyncTick:10},r),{c:i,dkLen:o,asyncTick:a}=s;if(En(i),En(o),En(a),i<1)throw new Error("iterations (c) should be >= 1");const c=Lc(e),l=Lc(t),u=new Uint8Array(o),h=zr.create(n,c),g=h._cloneInto().update(l);return{c:i,dkLen:o,asyncTick:a,DK:u,PRF:h,PRFSalt:g}}function pm(n,e,t,r,s){return n.destroy(),e.destroy(),r&&r.destroy(),en(s),t}async function ym(n,e,t,r){const{c:s,dkLen:i,asyncTick:o,DK:a,PRF:c,PRFSalt:l}=gm(n,e,t,r);let u;const h=new Uint8Array(4),g=Us(h),y=new Uint8Array(c.outputLen);for(let m=1,d=0;d<i;m++,d+=c.outputLen){const p=a.subarray(d,d+c.outputLen);g.setInt32(0,m,!1),(u=l._cloneInto(u)).update(h).digestInto(y),p.set(y.subarray(0,p.length)),await Vp(s-1,o,()=>{c._cloneInto(u).update(y).digestInto(y);for(let b=0;b<p.length;b++)p[b]^=y[b]})}return pm(c,l,a,u,y)}const mm=$c;/*!
 * MIT License
 * 
 * Copyright (c) 2017-2024 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */const wm="[object ArrayBuffer]";class ae{static isArrayBuffer(e){return Object.prototype.toString.call(e)===wm}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||e.byteOffset===0&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=ae.toUint8Array(e),s=ae.toUint8Array(t);if(r.length!==s.byteLength)return!1;for(let i=0;i<r.length;i++)if(r[i]!==s[i])return!1;return!0}static concat(...e){let t;Array.isArray(e[0])&&!(e[1]instanceof Function)||Array.isArray(e[0])&&e[1]instanceof Function?t=e[0]:e[e.length-1]instanceof Function?t=e.slice(0,e.length-1):t=e;let r=0;for(const o of t)r+=o.byteLength;const s=new Uint8Array(r);let i=0;for(const o of t){const a=this.toUint8Array(o);s.set(a,i),i+=a.length}return e[e.length-1]instanceof Function?this.toView(s,e[e.length-1]):s.buffer}}const Fo="string",bm=/^[0-9a-f\s]+$/i,Em=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,vm=/^[a-zA-Z0-9-_]+$/;class yl{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return r.buffer}static toString(e){const t=ae.toUint8Array(e);let r="";for(let i=0;i<t.length;i++)r+=String.fromCharCode(t[i]);return decodeURIComponent(escape(r))}}class St{static toString(e,t=!1){const r=ae.toArrayBuffer(e),s=new DataView(r);let i="";for(let o=0;o<r.byteLength;o+=2){const a=s.getUint16(o,t);i+=String.fromCharCode(a)}return i}static fromString(e,t=!1){const r=new ArrayBuffer(e.length*2),s=new DataView(r);for(let i=0;i<e.length;i++)s.setUint16(i*2,e.charCodeAt(i),t);return r}}class be{static isHex(e){return typeof e===Fo&&bm.test(e)}static isBase64(e){return typeof e===Fo&&Em.test(e)}static isBase64Url(e){return typeof e===Fo&&vm.test(e)}static ToString(e,t="utf8"){const r=ae.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return St.toString(r,!0);case"utf16":case"utf16be":return St.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return St.fromString(e,!0);case"utf16":case"utf16be":return St.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=ae.toUint8Array(e);if(typeof btoa<"u"){const r=this.ToString(t,"binary");return btoa(r)}else return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!be.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return typeof atob<"u"?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!be.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=be.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return yl.fromString(e);case"utf16":case"utf16be":return St.fromString(e);case"utf16le":case"usc2":return St.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=be.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return yl.toString(e);case"utf16":case"utf16be":return St.toString(e);case"utf16le":case"usc2":return St.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const t=ae.toUint8Array(e);let r="";for(let s=0;s<t.length;s++)r+=String.fromCharCode(t[s]);return r}static ToHex(e){const t=ae.toUint8Array(e);let r="";const s=t.length;for(let i=0;i<s;i++){const o=t[i];o<16&&(r+="0"),r+=o.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!be.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let s=0;s<t.length;s=s+2){const i=t.slice(s,s+2);r[s/2]=parseInt(i,16)}return r.buffer}static ToUtf16String(e,t=!1){return St.toString(e,t)}static FromUtf16String(e,t=!1){return St.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(e==null?void 0:e.replace(/[\n\r\t ]/g,""))||""}}be.DEFAULT_UTF8_ENCODING="utf8";/*!
 Copyright (c) Peculiar Ventures, LLC
*/function nr(n,e){let t=0;if(n.length===1)return n[0];for(let r=n.length-1;r>=0;r--)t+=n[n.length-1-r]*Math.pow(2,e*r);return t}function xn(n,e,t=-1){const r=t;let s=n,i=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(n<o){let c;if(r<0)c=new ArrayBuffer(a),i=a;else{if(r<a)return new ArrayBuffer(0);c=new ArrayBuffer(r),i=r}const l=new Uint8Array(c);for(let u=a-1;u>=0;u--){const h=Math.pow(2,u*e);l[i-u-1]=Math.floor(s/h),s-=l[i-u-1]*h}return c}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Vo(...n){let e=0,t=0;for(const i of n)e+=i.length;const r=new ArrayBuffer(e),s=new Uint8Array(r);for(const i of n)s.set(i,t),t+=i.length;return s}function ml(){const n=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const a=n[0]===255&&n[1]&128,c=n[0]===0&&(n[1]&128)===0;(a||c)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),t=new Uint8Array(e);for(let a=0;a<this.valueHex.byteLength;a++)t[a]=0;t[0]=n[0]&128;const r=nr(t,8),s=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(s);for(let a=0;a<this.valueHex.byteLength;a++)i[a]=n[a];return i[0]&=127,nr(i,8)-r}function _m(n){const e=n<0?n*-1:n;let t=128;for(let r=1;r<8;r++){if(e<=t){if(n<0){const o=t-e,a=xn(o,8,r),c=new Uint8Array(a);return c[0]|=128,a}let s=xn(e,8,r),i=new Uint8Array(s);if(i[0]&128){const o=s.slice(0),a=new Uint8Array(o);s=new ArrayBuffer(s.byteLength+1),i=new Uint8Array(s);for(let c=0;c<o.byteLength;c++)i[c+1]=a[c];i[0]=0}return s}t*=Math.pow(2,8)}return new ArrayBuffer(0)}function Am(n,e){if(n.byteLength!==e.byteLength)return!1;const t=new Uint8Array(n),r=new Uint8Array(e);for(let s=0;s<t.length;s++)if(t[s]!==r[s])return!1;return!0}function nt(n,e){const t=n.toString(10);if(e<t.length)return"";const r=e-t.length,s=new Array(r);for(let o=0;o<r;o++)s[o]="0";return s.join("").concat(t)}/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function Js(){if(typeof BigInt>"u")throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function $o(n){let e=0,t=0;for(let s=0;s<n.length;s++){const i=n[s];e+=i.byteLength}const r=new Uint8Array(e);for(let s=0;s<n.length;s++){const i=n[s];r.set(new Uint8Array(i),t),t+=i.byteLength}return r.buffer}function Ft(n,e,t,r){return e instanceof Uint8Array?e.byteLength?t<0?(n.error="Wrong parameter: inputOffset less than zero",!1):r<0?(n.error="Wrong parameter: inputLength less than zero",!1):e.byteLength-t-r<0?(n.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):!0:(n.error="Wrong parameter: inputBuffer has zero length",!1):(n.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class Ho{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return $o(this.items)}}const qr=[new Uint8Array([1])],wl="0123456789",rr="",wt=new ArrayBuffer(0),Ko=new Uint8Array(0),Gr="EndOfContent",bl="OCTET STRING",El="BIT STRING";function Vt(n){var e;return e=class extends n{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(r){this.valueHexView=new Uint8Array(r)}constructor(...r){var s;super(...r);const i=r[0]||{};this.isHexOnly=(s=i.isHexOnly)!==null&&s!==void 0?s:!1,this.valueHexView=i.valueHex?ae.toUint8Array(i.valueHex):Ko}fromBER(r,s,i){const o=r instanceof ArrayBuffer?new Uint8Array(r):r;if(!Ft(this,o,s,i))return-1;const a=s+i;return this.valueHexView=o.subarray(s,a),this.valueHexView.length?(this.blockLength=i,a):(this.warnings.push("Zero buffer length"),s)}toBER(r=!1){return this.isHexOnly?r?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",wt)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:be.ToHex(this.valueHexView)}}},e.NAME="hexBlock",e}class Rn{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t=rr,warnings:r=[],valueBeforeDecode:s=Ko}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=ae.toUint8Array(s)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:be.ToHex(this.valueBeforeDecodeView)}}}Rn.NAME="baseBlock";class je extends Rn{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}je.NAME="valueBlock";class vl extends Vt(Rn){constructor({idBlock:e={}}={}){var t,r,s,i;super(),e?(this.isHexOnly=(t=e.isHexOnly)!==null&&t!==void 0?t:!1,this.valueHexView=e.valueHex?ae.toUint8Array(e.valueHex):Ko,this.tagClass=(r=e.tagClass)!==null&&r!==void 0?r:-1,this.tagNumber=(s=e.tagNumber)!==null&&s!==void 0?s:-1,this.isConstructed=(i=e.isConstructed)!==null&&i!==void 0?i:!1):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",wt}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const s=new Uint8Array(1);if(!e){let i=this.tagNumber;i&=31,t|=i,s[0]=t}return s.buffer}if(!this.isHexOnly){const s=xn(this.tagNumber,7),i=new Uint8Array(s),o=s.byteLength,a=new Uint8Array(o+1);if(a[0]=t|31,!e){for(let c=0;c<o-1;c++)a[c+1]=i[c]|128;a[o]=i[o-1]}return a.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=t|31,!e){const s=this.valueHexView;for(let i=0;i<s.length-1;i++)r[i+1]=s[i]|128;r[this.valueHexView.byteLength]=s[s.length-1]}return r.buffer}fromBER(e,t,r){const s=ae.toUint8Array(e);if(!Ft(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(i.length===0)return this.error="Zero buffer length",-1;switch(i[0]&192){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=(i[0]&32)===32,this.isHexOnly=!1;const a=i[0]&31;if(a!==31)this.tagNumber=a,this.blockLength=1;else{let c=1,l=this.valueHexView=new Uint8Array(255),u=255;for(;i[c]&128;){if(l[c-1]=i[c]&127,c++,c>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(c===u){u+=255;const g=new Uint8Array(u);for(let y=0;y<l.length;y++)g[y]=l[y];l=this.valueHexView=new Uint8Array(u)}}this.blockLength=c+1,l[c-1]=i[c]&127;const h=new Uint8Array(c);for(let g=0;g<c;g++)h[g]=l[g];l=this.valueHexView=new Uint8Array(c),l.set(h),this.blockLength<=9?this.tagNumber=nr(l,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(this.tagClass===1&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}vl.NAME="identificationBlock";class _l extends Rn{constructor({lenBlock:e={}}={}){var t,r,s;super(),this.isIndefiniteForm=(t=e.isIndefiniteForm)!==null&&t!==void 0?t:!1,this.longFormUsed=(r=e.longFormUsed)!==null&&r!==void 0?r:!1,this.length=(s=e.length)!==null&&s!==void 0?s:0}fromBER(e,t,r){const s=ae.toUint8Array(e);if(!Ft(this,s,t,r))return-1;const i=s.subarray(t,t+r);if(i.length===0)return this.error="Zero buffer length",-1;if(i[0]===255)return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=i[0]===128,this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(i[0]&128),this.longFormUsed===!1)return this.length=i[0],this.blockLength=1,t+this.blockLength;const o=i[0]&127;if(o>8)return this.error="Too big integer",-1;if(o+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const a=t+1,c=s.subarray(a,a+o);return c[o-1]===0&&this.warnings.push("Needlessly long encoded length"),this.length=nr(c,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=o+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const s=xn(this.length,8);if(s.byteLength>127)return this.error="Too big length",wt;if(t=new ArrayBuffer(s.byteLength+1),e)return t;const i=new Uint8Array(s);r=new Uint8Array(t),r[0]=s.byteLength|128;for(let o=0;o<s.byteLength;o++)r[o+1]=i[o];return t}return t=new ArrayBuffer(1),e===!1&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}_l.NAME="lengthBlock";const F={};class ze extends Rn{constructor({name:e=rr,optional:t=!1,primitiveSchema:r,...s}={},i){super(s),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new vl(s),this.lenBlock=new _l(s),this.valueBlock=i?new i(s):new je(s)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){const r=t||new Ho;t||Al(this);const s=this.idBlock.toBER(e);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const i=this.valueBlock.toBER(e);this.lenBlock.length=i.byteLength;const o=this.lenBlock.toBER(e);r.write(o),r.write(i)}return t?wt:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return e==="ascii"?this.onAsciiEncoding():be.ToHex(this.toBER())}onAsciiEncoding(){const e=this.constructor.NAME,t=be.ToHex(this.valueBlock.valueBeforeDecodeView);return`${e} : ${t}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;const t=this.toBER(),r=e.toBER();return Am(t,r)}}ze.NAME="BaseBlock";function Al(n){var e;if(n instanceof F.Constructed)for(const t of n.valueBlock.value)Al(t)&&(n.lenBlock.isIndefiniteForm=!0);return!!(!((e=n.lenBlock)===null||e===void 0)&&e.isIndefiniteForm)}class Sl extends ze{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e=rr,...t}={},r){super(t,r),e&&this.fromString(e)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}Sl.NAME="BaseStringBlock";class xl extends Vt(je){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}xl.NAME="PrimitiveValueBlock";var Rl;class Il extends ze{constructor(e={}){super(e,xl),this.idBlock.isConstructed=!1}}Rl=Il,F.Primitive=Rl,Il.NAME="PRIMITIVE";function Sm(n,e){if(n instanceof e)return n;const t=new e;return t.idBlock=n.idBlock,t.lenBlock=n.lenBlock,t.warnings=n.warnings,t.valueBeforeDecodeView=n.valueBeforeDecodeView,t}function ei(n,e=0,t=n.length){const r=e;let s=new ze({},je);const i=new Rn;if(!Ft(i,n,e,t))return s.error=i.error,{offset:-1,result:s};if(!n.subarray(e,e+t).length)return s.error="Zero buffer length",{offset:-1,result:s};let a=s.idBlock.fromBER(n,e,t);if(s.idBlock.warnings.length&&s.warnings.concat(s.idBlock.warnings),a===-1)return s.error=s.idBlock.error,{offset:-1,result:s};if(e=a,t-=s.idBlock.blockLength,a=s.lenBlock.fromBER(n,e,t),s.lenBlock.warnings.length&&s.warnings.concat(s.lenBlock.warnings),a===-1)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=a,t-=s.lenBlock.blockLength,!s.idBlock.isConstructed&&s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let c=ze;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&s.idBlock.isHexOnly===!1)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};c=F.EndOfContent;break;case 1:c=F.Boolean;break;case 2:c=F.Integer;break;case 3:c=F.BitString;break;case 4:c=F.OctetString;break;case 5:c=F.Null;break;case 6:c=F.ObjectIdentifier;break;case 10:c=F.Enumerated;break;case 12:c=F.Utf8String;break;case 13:c=F.RelativeObjectIdentifier;break;case 14:c=F.TIME;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:c=F.Sequence;break;case 17:c=F.Set;break;case 18:c=F.NumericString;break;case 19:c=F.PrintableString;break;case 20:c=F.TeletexString;break;case 21:c=F.VideotexString;break;case 22:c=F.IA5String;break;case 23:c=F.UTCTime;break;case 24:c=F.GeneralizedTime;break;case 25:c=F.GraphicString;break;case 26:c=F.VisibleString;break;case 27:c=F.GeneralString;break;case 28:c=F.UniversalString;break;case 29:c=F.CharacterString;break;case 30:c=F.BmpString;break;case 31:c=F.DATE;break;case 32:c=F.TimeOfDay;break;case 33:c=F.DateTime;break;case 34:c=F.Duration;break;default:{const l=s.idBlock.isConstructed?new F.Constructed:new F.Primitive;l.idBlock=s.idBlock,l.lenBlock=s.lenBlock,l.warnings=s.warnings,s=l}}break;case 2:case 3:case 4:default:c=s.idBlock.isConstructed?F.Constructed:F.Primitive}return s=Sm(s,c),a=s.fromBER(n,e,s.lenBlock.isIndefiniteForm?t:s.lenBlock.length),s.valueBeforeDecodeView=n.subarray(r,r+s.blockLength),{offset:a,result:s}}function kl(n){if(!n.byteLength){const e=new ze({},je);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ei(ae.toUint8Array(n).slice(),0,n.byteLength)}function xm(n,e){return n?1:e}class ln extends je{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const s=ae.toUint8Array(e);if(!Ft(this,s,t,r))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+r),this.valueBeforeDecodeView.length===0)return this.warnings.push("Zero buffer length"),t;let i=t;for(;xm(this.isIndefiniteForm,r)>0;){const o=ei(s,i,r);if(o.offset===-1)return this.error=o.result.error,this.warnings.concat(o.result.warnings),-1;if(i=o.offset,this.blockLength+=o.result.blockLength,r-=o.result.blockLength,this.value.push(o.result),this.isIndefiniteForm&&o.result.constructor.NAME===Gr)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===Gr?this.value.pop():this.warnings.push("No EndOfContent block encoded")),i}toBER(e,t){const r=t||new Ho;for(let s=0;s<this.value.length;s++)this.value[s].toBER(e,r);return t?wt:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}ln.NAME="ConstructedValueBlock";var Tl;class sr extends ze{constructor(e={}){super(e,ln),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return s===-1?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const e=[];for(const r of this.valueBlock.value)e.push(r.toString("ascii").split(`
`).map(s=>`  ${s}`).join(`
`));const t=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :
${e.join(`
`)}`:`${t} :`}}Tl=sr,F.Constructed=Tl,sr.NAME="CONSTRUCTED";class Cl extends je{fromBER(e,t,r){return t}toBER(e){return wt}}Cl.override="EndOfContentValueBlock";var Nl;class Ll extends ze{constructor(e={}){super(e,Cl),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}Nl=Ll,F.EndOfContent=Nl,Ll.NAME=Gr;var Dl;class Wr extends ze{constructor(e={}){super(e,je),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const s=new Uint8Array(r);s[0]=5,s[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}Dl=Wr,F.Null=Dl,Wr.NAME="NULL";class Bl extends Vt(je){get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=ae.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,r){const s=ae.toUint8Array(e);return Ft(this,s,t,r)?(this.valueHexView=s.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,ml.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}Bl.NAME="BooleanValueBlock";var Ol;let Pl=class extends ze{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,Bl),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}};Ol=Pl,F.Boolean=Ol,Pl.NAME="BOOLEAN";class Ul extends Vt(ln){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=ln.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(let i=0;i<this.value.length;i++){const o=this.value[i].constructor.NAME;if(o===Gr){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(o!==bl)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e,t){return this.isConstructed?ln.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}Ul.NAME="OctetStringValueBlock";var zo;class ir extends ze{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Ul),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,r===0)return this.idBlock.error.length===0&&(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length===0&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const i=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(i.byteLength){const o=ei(i,0,i.byteLength);o.offset!==-1&&o.offset===r&&(this.valueBlock.value=[o.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return sr.prototype.onAsciiEncoding.call(this);const e=this.constructor.NAME,t=be.ToHex(this.valueBlock.valueHexView);return`${e} : ${t}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof zo&&e.push(t.valueBlock.valueHexView);return ae.concat(e)}}zo=ir,F.OctetString=zo,ir.NAME=bl;class Ml extends Vt(ln){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let s=-1;if(this.isConstructed){if(s=ln.prototype.fromBER.call(this,e,t,r),s===-1)return s;for(const a of this.value){const c=a.constructor.NAME;if(c===Gr){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(c!==El)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const l=a.valueBlock;if(this.unusedBits>0&&l.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=l.unusedBits}return s}const i=ae.toUint8Array(e);if(!Ft(this,i,t,r))return-1;const o=i.subarray(t,t+r);if(this.unusedBits=o[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const a=o.subarray(1);try{if(a.byteLength){const c=ei(a,0,a.byteLength);c.offset!==-1&&c.offset===r-1&&(this.value=[c.result])}}catch{}}return this.valueHexView=o.subarray(1),this.blockLength=o.length,t+r}toBER(e,t){if(this.isConstructed)return ln.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return wt;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}Ml.NAME="BitStringValueBlock";var Fl;class qo extends ze{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,i;(s=r.isConstructed)!==null&&s!==void 0||(r.isConstructed=!!(!((i=r.value)===null||i===void 0)&&i.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},Ml),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return sr.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const o of t)e.push(o.toString(2).padStart(8,"0"));const r=e.join(""),s=this.constructor.NAME,i=r.substring(0,r.length-this.valueBlock.unusedBits);return`${s} : ${i}`}}}Fl=qo,F.BitString=Fl,qo.NAME=El;var Vl;function Rm(n,e){const t=new Uint8Array([0]),r=new Uint8Array(n),s=new Uint8Array(e);let i=r.slice(0);const o=i.length-1,a=s.slice(0),c=a.length-1;let l=0;const u=c<o?o:c;let h=0;for(let g=u;g>=0;g--,h++){switch(!0){case h<a.length:l=i[o-h]+a[c-h]+t[0];break;default:l=i[o-h]+t[0]}switch(t[0]=l/10,!0){case h>=i.length:i=Vo(new Uint8Array([l%10]),i);break;default:i[o-h]=l%10}}return t[0]>0&&(i=Vo(t,i)),i}function $l(n){if(n>=qr.length)for(let e=qr.length;e<=n;e++){const t=new Uint8Array([0]);let r=qr[e-1].slice(0);for(let s=r.length-1;s>=0;s--){const i=new Uint8Array([(r[s]<<1)+t[0]]);t[0]=i[0]/10,r[s]=i[0]%10}t[0]>0&&(r=Vo(t,r)),qr.push(r)}return qr[n]}function Im(n,e){let t=0;const r=new Uint8Array(n),s=new Uint8Array(e),i=r.slice(0),o=i.length-1,a=s.slice(0),c=a.length-1;let l,u=0;for(let h=c;h>=0;h--,u++)switch(l=i[o-u]-a[c-u]-t,!0){case l<0:t=1,i[o-u]=l+10;break;default:t=0,i[o-u]=l}if(t>0)for(let h=o-c+1;h>=0;h--,u++)if(l=i[o-u]-t,l<0)t=1,i[o-u]=l+10;else{t=0,i[o-u]=l;break}return i.slice()}class Go extends Vt(je){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=ml.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),e!==void 0&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(_m(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const i=this.fromBER(e,t,r);if(i===-1)return i;const o=this.valueHexView;return o[0]===0&&o[1]&128?this.valueHexView=o.subarray(1):s!==0&&o.length<s&&(s-o.length>1&&(s=o.length+1),this.valueHexView=o.subarray(s-o.length)),i}toDER(e=!1){const t=this.valueHexView;switch(!0){case(t[0]&128)!==0:{const r=new Uint8Array(this.valueHexView.length+1);r[0]=0,r.set(t,1),this.valueHexView=r}break;case(t[0]===0&&(t[1]&128)===0):this.valueHexView=this.valueHexView.subarray(1);break}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return s===-1||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=this.valueHexView.length*8-1;let t=new Uint8Array(this.valueHexView.length*8/3),r=0,s;const i=this.valueHexView;let o="",a=!1;for(let c=i.byteLength-1;c>=0;c--){s=i[c];for(let l=0;l<8;l++){if((s&1)===1)switch(r){case e:t=Im($l(r),t),o="-";break;default:t=Rm(t,$l(r))}r++,s>>=1}}for(let c=0;c<t.length;c++)t[c]&&(a=!0),a&&(o+=wl.charAt(t[c]));return a===!1&&(o+=wl.charAt(0)),o}}Vl=Go,Go.NAME="IntegerValueBlock",Object.defineProperty(Vl.prototype,"valueHex",{set:function(n){this.valueHexView=new Uint8Array(n),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});var Yr;class Ne extends ze{constructor(e={}){super(e,Go),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return Js(),BigInt(this.valueBlock.toString())}static fromBigInt(e){Js();const t=BigInt(e),r=new Ho,s=t.toString(16).replace(/^-/,""),i=new Uint8Array(be.FromHex(s));if(t<0){const a=new Uint8Array(i.length+(i[0]&128?1:0));a[0]|=128;const l=BigInt(`0x${be.ToHex(a)}`)+t,u=ae.toUint8Array(be.FromHex(l.toString(16)));u[0]|=128,r.write(u)}else i[0]&128&&r.write(new Uint8Array([0])),r.write(i);return new Yr({valueHex:r.final()})}convertToDER(){const e=new Yr({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new Yr({valueHex:this.valueBlock.valueHexView[0]===0?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}Yr=Ne,F.Integer=Yr,Ne.NAME="INTEGER";var Hl;class Kl extends Ne{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}Hl=Kl,F.Enumerated=Hl,Kl.NAME="ENUMERATED";class Wo extends Vt(je){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const s=ae.toUint8Array(e);if(!Ft(this,s,t,r))return-1;const i=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=nr(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){Js();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let s=0;s<r.length;s++)r[s]=parseInt(t.slice(s*7,s*7+7),2)+(s+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const t=xn(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",wt;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r}toString(){let e="";if(this.isHexOnly)e=be.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}Wo.NAME="sidBlock";class zl extends je{constructor({value:e=rr,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const i=new Wo;if(s=i.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.value.length===0&&(i.isFirstSid=!0),this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(s.byteLength===0)return this.error=this.value[r].error,wt;t.push(s)}return $o(t)}fromString(e){this.value=[];let t=0,r=0,s="",i=!1;do if(r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1,i){const o=this.value[0];let a=0;switch(o.valueDec){case 0:break;case 1:a=40;break;case 2:a=80;break;default:this.value=[];return}const c=parseInt(s,10);if(isNaN(c))return;o.valueDec=c+a,i=!1}else{const o=new Wo;if(s>Number.MAX_SAFE_INTEGER){Js();const a=BigInt(s);o.valueBigInt=a}else if(o.valueDec=parseInt(s,10),isNaN(o.valueDec))return;this.value.length||(o.isFirstSid=!0,i=!0),this.value.push(o)}while(r!==-1)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}zl.NAME="ObjectIdentifierValueBlock";var ql;class un extends ze{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,zl),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}ql=un,F.ObjectIdentifier=ql,un.NAME="OBJECT IDENTIFIER";class Yo extends Vt(Rn){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(r===0)return t;const s=ae.toUint8Array(e);if(!Ft(this,s,t,r))return-1;const i=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let a=0;a<r&&(this.valueHexView[a]=i[a]&127,this.blockLength++,!!(i[a]&128));a++);const o=new Uint8Array(this.blockLength);for(let a=0;a<this.blockLength;a++)o[a]=this.valueHexView[a];return this.valueHexView=o,i[this.blockLength-1]&128?(this.error="End of input reached before message was fully decoded",-1):(this.valueHexView[0]===0&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=nr(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const s=this.valueHexView,i=new Uint8Array(this.blockLength);for(let o=0;o<this.blockLength-1;o++)i[o]=s[o]|128;return i[this.blockLength-1]=s[this.blockLength-1],i.buffer}const t=xn(this.valueDec,7);if(t.byteLength===0)return this.error="Error during encoding SID value",wt;const r=new Uint8Array(t.byteLength);if(!e){const s=new Uint8Array(t),i=t.byteLength-1;for(let o=0;o<i;o++)r[o]=s[o]|128;r[i]=s[i]}return r.buffer}toString(){let e="";return this.isHexOnly?e=be.ToHex(this.valueHexView):e=this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}Yo.NAME="relativeSidBlock";class Gl extends je{constructor({value:e=rr,...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const i=new Yo;if(s=i.fromBER(e,s,r),s===-1)return this.blockLength=0,this.error=i.error,s;this.blockLength+=i.blockLength,r-=i.blockLength,this.value.push(i)}return s}toBER(e,t){const r=[];for(let s=0;s<this.value.length;s++){const i=this.value[s].toBER(e);if(i.byteLength===0)return this.error=this.value[s].error,wt;r.push(i)}return $o(r)}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),r===-1?s=e.substring(t):s=e.substring(t,r),t=r+1;const i=new Yo;if(i.valueDec=parseInt(s,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(r!==-1);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();r!==0&&(e=`${e}.`),t&&(s=`{${s}}`),e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}Gl.NAME="RelativeObjectIdentifierValueBlock";var Wl;class Yl extends ze{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,Gl),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}Wl=Yl,F.RelativeObjectIdentifier=Wl,Yl.NAME="RelativeObjectIdentifier";var jl;class qe extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}jl=qe,F.Sequence=jl,qe.NAME="SEQUENCE";var Xl;let Zl=class extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}};Xl=Zl,F.Set=Xl,Zl.NAME="SET";class Ql extends Vt(je){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=rr}toJSON(){return{...super.toJSON(),value:this.value}}}Ql.NAME="StringValueBlock";class Jl extends Ql{}Jl.NAME="SimpleStringValueBlock";class rt extends Sl{constructor({...e}={}){super(e,Jl)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,ae.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}rt.NAME="SIMPLE STRING";class eu extends rt{fromBuffer(e){this.valueBlock.valueHexView=ae.toUint8Array(e);try{this.valueBlock.value=be.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=be.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(be.FromUtf8String(e)),this.valueBlock.value=e}}eu.NAME="Utf8StringValueBlock";var tu;class In extends eu{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}tu=In,F.Utf8String=tu,In.NAME="UTF8String";class nu extends rt{fromBuffer(e){this.valueBlock.value=be.ToUtf16String(e),this.valueBlock.valueHexView=ae.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(be.FromUtf16String(e))}}nu.NAME="BmpStringValueBlock";var ru;class su extends nu{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}ru=su,F.BmpString=ru,su.NAME="BMPString";class iu extends rt{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let s=0;s<r.length;s+=4)r[s]=r[s+3],r[s+1]=r[s+2],r[s+2]=0,r[s+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t*4);for(let s=0;s<t;s++){const i=xn(e.charCodeAt(s),8),o=new Uint8Array(i);if(o.length>4)continue;const a=4-o.length;for(let c=o.length-1;c>=0;c--)r[s*4+c+a]=o[c]}this.valueBlock.value=e}}iu.NAME="UniversalStringValueBlock";var ou;class au extends iu{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}ou=au,F.UniversalString=ou,au.NAME="UniversalString";var cu;class lu extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}cu=lu,F.NumericString=cu,lu.NAME="NumericString";var uu;class hu extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}uu=hu,F.PrintableString=uu,hu.NAME="PrintableString";var fu;class du extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}fu=du,F.TeletexString=fu,du.NAME="TeletexString";var gu;class pu extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}gu=pu,F.VideotexString=gu,pu.NAME="VideotexString";var yu;class mu extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}yu=mu,F.IA5String=yu,mu.NAME="IA5String";var wu;class bu extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}wu=bu,F.GraphicString=wu,bu.NAME="GraphicString";var Eu;class jo extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}Eu=jo,F.VisibleString=Eu,jo.NAME="VisibleString";var vu;class _u extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}vu=_u,F.GeneralString=vu,_u.NAME="GeneralString";var Au;class Su extends rt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}Au=Su,F.CharacterString=Au,Su.NAME="CharacterString";var xu;class Xo extends jo{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let s=0;s<e.length;s++)this.valueBlock.valueHexView[s]=e.charCodeAt(s)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,ae.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let s=0;s<e.length;s++)r[s]=e.charCodeAt(s);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig.exec(e);if(r===null){this.error="Wrong input string for conversion";return}const s=parseInt(r[1],10);s>=50?this.year=1900+s:this.year=2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(e="iso"){if(e==="iso"){const t=new Array(7);return t[0]=nt(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=nt(this.month,2),t[2]=nt(this.day,2),t[3]=nt(this.hour,2),t[4]=nt(this.minute,2),t[5]=nt(this.second,2),t[6]="Z",t.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}xu=Xo,F.UTCTime=xu,Xo.NAME="UTCTime";var Ru;class Iu extends Xo{constructor(e={}){var t;super(e),(t=this.millisecond)!==null&&t!==void 0||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){const e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t=!1,r="",s="",i=0,o,a=0,c=0;if(e[e.length-1]==="Z")r=e.substring(0,e.length-1),t=!0;else{const h=new Number(e[e.length-1]);if(isNaN(h.valueOf()))throw new Error("Wrong input string for conversion");r=e}if(t){if(r.indexOf("+")!==-1)throw new Error("Wrong input string for conversion");if(r.indexOf("-")!==-1)throw new Error("Wrong input string for conversion")}else{let h=1,g=r.indexOf("+"),y="";if(g===-1&&(g=r.indexOf("-"),h=-1),g!==-1){if(y=r.substring(g+1),r=r.substring(0,g),y.length!==2&&y.length!==4)throw new Error("Wrong input string for conversion");let m=parseInt(y.substring(0,2),10);if(isNaN(m.valueOf()))throw new Error("Wrong input string for conversion");if(a=h*m,y.length===4){if(m=parseInt(y.substring(2,4),10),isNaN(m.valueOf()))throw new Error("Wrong input string for conversion");c=h*m}}}let l=r.indexOf(".");if(l===-1&&(l=r.indexOf(",")),l!==-1){const h=new Number(`0${r.substring(l)}`);if(isNaN(h.valueOf()))throw new Error("Wrong input string for conversion");i=h.valueOf(),s=r.substring(0,l)}else s=r;switch(!0){case s.length===8:if(o=/(\d{4})(\d{2})(\d{2})/ig,l!==-1)throw new Error("Wrong input string for conversion");break;case s.length===10:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let h=60*i;this.minute=Math.floor(h),h=60*(h-this.minute),this.second=Math.floor(h),h=1e3*(h-this.second),this.millisecond=Math.floor(h)}break;case s.length===12:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){let h=60*i;this.second=Math.floor(h),h=1e3*(h-this.second),this.millisecond=Math.floor(h)}break;case s.length===14:if(o=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig,l!==-1){const h=1e3*i;this.millisecond=Math.floor(h)}break;default:throw new Error("Wrong input string for conversion")}const u=o.exec(s);if(u===null)throw new Error("Wrong input string for conversion");for(let h=1;h<u.length;h++)switch(h){case 1:this.year=parseInt(u[h],10);break;case 2:this.month=parseInt(u[h],10);break;case 3:this.day=parseInt(u[h],10);break;case 4:this.hour=parseInt(u[h],10)+a;break;case 5:this.minute=parseInt(u[h],10)+c;break;case 6:this.second=parseInt(u[h],10);break;default:throw new Error("Wrong input string for conversion")}if(t===!1){const h=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=h.getUTCFullYear(),this.month=h.getUTCMonth(),this.day=h.getUTCDay(),this.hour=h.getUTCHours(),this.minute=h.getUTCMinutes(),this.second=h.getUTCSeconds(),this.millisecond=h.getUTCMilliseconds()}}toString(e="iso"){if(e==="iso"){const t=[];return t.push(nt(this.year,4)),t.push(nt(this.month,2)),t.push(nt(this.day,2)),t.push(nt(this.hour,2)),t.push(nt(this.minute,2)),t.push(nt(this.second,2)),this.millisecond!==0&&(t.push("."),t.push(nt(this.millisecond,3))),t.push("Z"),t.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}Ru=Iu,F.GeneralizedTime=Ru,Iu.NAME="GeneralizedTime";var ku;class Tu extends In{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}}ku=Tu,F.DATE=ku,Tu.NAME="DATE";var Cu;class Nu extends In{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Cu=Nu,F.TimeOfDay=Cu,Nu.NAME="TimeOfDay";var Lu;class Du extends In{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}Lu=Du,F.DateTime=Lu,Du.NAME="DateTime";var Bu;class Ou extends In{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Bu=Ou,F.Duration=Bu,Ou.NAME="Duration";var Pu;class Uu extends In{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}Pu=Uu,F.TIME=Pu,Uu.NAME="TIME";function km(n){const{result:e}=kl(n),t=e.valueBlock.value;return{n:j(xt(t[1].toBigInt()),"base64url"),e:j(xt(t[2].toBigInt()),"base64url"),d:j(xt(t[3].toBigInt()),"base64url"),p:j(xt(t[4].toBigInt()),"base64url"),q:j(xt(t[5].toBigInt()),"base64url"),dp:j(xt(t[6].toBigInt()),"base64url"),dq:j(xt(t[7].toBigInt()),"base64url"),qi:j(xt(t[8].toBigInt()),"base64url"),kty:"RSA",alg:"RS256"}}function Tm(n){if(n.n==null||n.e==null||n.d==null||n.p==null||n.q==null||n.dp==null||n.dq==null||n.qi==null)throw new R("JWK was missing components","ERR_INVALID_PARAMETERS");const t=new qe({value:[new Ne({value:0}),Ne.fromBigInt(Rt(z(n.n,"base64url"))),Ne.fromBigInt(Rt(z(n.e,"base64url"))),Ne.fromBigInt(Rt(z(n.d,"base64url"))),Ne.fromBigInt(Rt(z(n.p,"base64url"))),Ne.fromBigInt(Rt(z(n.q,"base64url"))),Ne.fromBigInt(Rt(z(n.dp,"base64url"))),Ne.fromBigInt(Rt(z(n.dq,"base64url"))),Ne.fromBigInt(Rt(z(n.qi,"base64url")))]}).toBER();return new Uint8Array(t,0,t.byteLength)}function Cm(n){const{result:e}=kl(n),t=e.valueBlock.value[1].valueBlock.value[0].valueBlock.value;return{kty:"RSA",n:j(xt(t[0].toBigInt()),"base64url"),e:j(xt(t[1].toBigInt()),"base64url")}}function Nm(n){if(n.n==null||n.e==null)throw new R("JWK was missing components","ERR_INVALID_PARAMETERS");const t=new qe({value:[new qe({value:[new un({value:"1.2.840.113549.1.1.1"}),new Wr]}),new qo({valueHex:new qe({value:[Ne.fromBigInt(Rt(z(n.n,"base64url"))),Ne.fromBigInt(Rt(z(n.e,"base64url")))]}).toBER()})]}).toBER();return new Uint8Array(t,0,t.byteLength)}function xt(n){let e=n.toString(16);e.length%2>0&&(e=`0${e}`);const t=e.length/2,r=new Uint8Array(t);let s=0,i=0;for(;s<t;)r[s]=parseInt(e.slice(i,i+2),16),s+=1,i+=2;return r}function Rt(n){const e=[];return n.forEach(function(t){let r=t.toString(16);r.length%2>0&&(r=`0${r}`),e.push(r)}),BigInt("0x"+e.join(""))}const Lm=16,Mu=32,Fu=1e4;async function Dm(n,e){const t=yt.get(),s=new qe({value:[new Ne({value:0}),new qe({value:[new un({value:"1.2.840.113549.1.1.1"}),new Wr]}),new ir({valueHex:n.marshal()})]}).toBER(),i=new Uint8Array(s,0,s.byteLength),o=Kr(Lm),a=await ym(mm,e,o,{c:Fu,dkLen:Mu}),c=Kr(16),l=await t.subtle.importKey("raw",a,"AES-CBC",!1,["encrypt"]),u=await t.subtle.encrypt({name:"AES-CBC",iv:c},l,i),h=new qe({value:[new ir({valueHex:o}),new Ne({value:Fu}),new Ne({value:Mu}),new qe({value:[new un({value:"1.2.840.113549.2.11"}),new Wr]})]}),g=new qe({value:[new un({value:"1.2.840.113549.1.5.13"}),new qe({value:[new qe({value:[new un({value:"1.2.840.113549.1.5.12"}),h]}),new qe({value:[new un({value:"2.16.840.1.101.3.4.1.42"}),new ir({valueHex:c})]})]})]}),m=new qe({value:[g,new ir({valueHex:u})]}).toBER(),d=new Uint8Array(m,0,m.byteLength);return["-----BEGIN ENCRYPTED PRIVATE KEY-----",...j(d,"base64pad").split(/(.{64})/).filter(Boolean),"-----END ENCRYPTED PRIVATE KEY-----"].join(`
`)}async function Bm(n){const e=await yt.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:n,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),t=await $u(e);return{privateKey:t[0],publicKey:t[1]}}async function Vu(n){const t=[await yt.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await Um(n)],r=await $u({privateKey:t[0],publicKey:t[1]});return{privateKey:r[0],publicKey:r[1]}}async function Om(n,e){const t=await yt.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await yt.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},t,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(r,0,r.byteLength)}async function Pm(n,e,t){const r=await yt.get().subtle.importKey("jwk",n,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return yt.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,e,t instanceof Uint8Array?t:t.subarray())}async function $u(n){if(n.privateKey==null||n.publicKey==null)throw new R("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([yt.get().subtle.exportKey("jwk",n.privateKey),yt.get().subtle.exportKey("jwk",n.publicKey)])}async function Um(n){return yt.get().subtle.importKey("jwk",{kty:n.kty,n:n.n,e:n.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function Zo(n){if(n.kty!=="RSA")throw new R("invalid key type","ERR_INVALID_KEY_TYPE");if(n.n==null)throw new R("invalid key modulus","ERR_INVALID_KEY_MODULUS");return z(n.n,"base64url").length*8}const jr=8192;class Qo{constructor(e){f(this,"_key");this._key=e}verify(e,t){return Pm(this._key,t,e)}marshal(){return Nm(this._key)}get bytes(){return Jn.encode({Type:Ae.RSA,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}hash(){const e=pt.digest(this.bytes);return Jt(e)?e.then(({bytes:t})=>t):e.bytes}}class ti{constructor(e,t){f(this,"_key");f(this,"_publicKey");this._key=e,this._publicKey=t}genSecret(){return Kr(16)}sign(e){return Om(this._key,e)}get public(){if(this._publicKey==null)throw new R("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new Qo(this._publicKey)}marshal(){return Tm(this._key)}get bytes(){return er.encode({Type:Ae.RSA,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}hash(){const e=pt.digest(this.bytes);return Jt(e)?e.then(({bytes:t})=>t):e.bytes}async id(){const e=await this.public.hash();return j(e,"base58btc")}async export(e,t="pkcs-8"){if(t==="pkcs-8")return Dm(this,e);if(t==="libp2p-key")return Io(this.bytes,e);throw new R(`export format '${t}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}async function Mm(n){const e=km(n);if(Zo(e)>jr)throw new R("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await Vu(e);return new ti(t.privateKey,t.publicKey)}function Fm(n){const e=Cm(n);if(Zo(e)>jr)throw new R("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new Qo(e)}async function Vm(n){if(Zo(n)>jr)throw new R("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const e=await Vu(n);return new ti(e.privateKey,e.publicKey)}async function $m(n){if(n>jr)throw new R("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const e=await Bm(n);return new ti(e.privateKey,e.publicKey)}const Hm=Object.freeze(Object.defineProperty({__proto__:null,MAX_RSA_KEY_SIZE:jr,RsaPrivateKey:ti,RsaPublicKey:Qo,fromJwk:Vm,generateKeyPair:$m,unmarshalRsaPrivateKey:Mm,unmarshalRsaPublicKey:Fm},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Hu(n){n.lowS!==void 0&&on("lowS",n.lowS),n.prehash!==void 0&&on("prehash",n.prehash)}function Km(n){const e=So(n);jn(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}class zm extends Error{constructor(e=""){super(e)}}const $t={Err:zm,_tlv:{encode:(n,e)=>{const{Err:t}=$t;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,s=Hs(r);if(s.length/2&128)throw new t("tlv.encode: long form length too big");const i=r>127?Hs(s.length/2|128):"";return Hs(n)+i+s+e},decode(n,e){const{Err:t}=$t;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const s=e[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new t("tlv.decode(long): indefinite length not supported");if(c>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(r,r+c);if(l.length!==c)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const u of l)o=o<<8|u;if(r+=c,o<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+o);if(a.length!==o)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+o)}}},_int:{encode(n){const{Err:e}=$t;if(n<Ht)throw new e("integer: negative integers are not allowed");let t=Hs(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=$t;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return vn(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=$t,s=we("signature",n),{v:i,l:o}=r.decode(48,s);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:l,l:u}=r.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(l)}},hexFromSig(n){const{_tlv:e,_int:t}=$t,r=e.encode(2,t.encode(n.r)),s=e.encode(2,t.encode(n.s)),i=r+s;return e.encode(48,i)}},Ht=BigInt(0),ke=BigInt(1);BigInt(2);const Ku=BigInt(3);BigInt(4);function qm(n){const e=Km(n),{Fp:t}=e,r=Xn(e.n,e.nBitLength),s=e.toBytes||((d,p,b)=>{const v=p.toAffine();return Yn(Uint8Array.from([4]),t.toBytes(v.x),t.toBytes(v.y))}),i=e.fromBytes||(d=>{const p=d.subarray(1),b=t.fromBytes(p.subarray(0,t.BYTES)),v=t.fromBytes(p.subarray(t.BYTES,2*t.BYTES));return{x:b,y:v}});function o(d){const{a:p,b}=e,v=t.sqr(d),w=t.mul(v,d);return t.add(t.add(w,t.mul(d,p)),b)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(d){return go(d,ke,e.n)}function c(d){const{allowedPrivateKeyLengths:p,nByteLength:b,wrapPrivateKey:v,n:w}=e;if(p&&typeof d!="bigint"){if(Gn(d)&&(d=Wn(d)),typeof d!="string"||!p.includes(d.length))throw new Error("invalid private key");d=d.padStart(b*2,"0")}let E;try{E=typeof d=="bigint"?d:vn(we("private key",d,b))}catch{throw new Error("invalid private key, expected hex or "+b+" bytes, got "+typeof d)}return v&&(E=le(E,w)),Qe("private key",E,ke,w),E}function l(d){if(!(d instanceof g))throw new Error("ProjectivePoint expected")}const u=qs((d,p)=>{const{px:b,py:v,pz:w}=d;if(t.eql(w,t.ONE))return{x:b,y:v};const E=d.is0();p==null&&(p=E?t.ONE:t.inv(w));const A=t.mul(b,p),S=t.mul(v,p),k=t.mul(w,p);if(E)return{x:t.ZERO,y:t.ZERO};if(!t.eql(k,t.ONE))throw new Error("invZ was invalid");return{x:A,y:S}}),h=qs(d=>{if(d.is0()){if(e.allowInfinityPoint&&!t.is0(d.py))return;throw new Error("bad point: ZERO")}const{x:p,y:b}=d.toAffine();if(!t.isValid(p)||!t.isValid(b))throw new Error("bad point: x or y not FE");const v=t.sqr(b),w=o(p);if(!t.eql(v,w))throw new Error("bad point: equation left != right");if(!d.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(p,b,v){if(p==null||!t.isValid(p))throw new Error("x required");if(b==null||!t.isValid(b)||t.is0(b))throw new Error("y required");if(v==null||!t.isValid(v))throw new Error("z required");this.px=p,this.py=b,this.pz=v,Object.freeze(this)}static fromAffine(p){const{x:b,y:v}=p||{};if(!p||!t.isValid(b)||!t.isValid(v))throw new Error("invalid affine point");if(p instanceof g)throw new Error("projective point not allowed");const w=E=>t.eql(E,t.ZERO);return w(b)&&w(v)?g.ZERO:new g(b,v,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(p){const b=wo(t,p.map(v=>v.pz));return p.map((v,w)=>v.toAffine(b[w])).map(g.fromAffine)}static fromHex(p){const b=g.fromAffine(i(we("pointHex",p)));return b.assertValidity(),b}static fromPrivateKey(p){return g.BASE.multiply(c(p))}static msm(p,b){return rl(g,r,p,b)}_setWindowSize(p){m.setWindowSize(this,p)}assertValidity(){h(this)}hasEvenY(){const{y:p}=this.toAffine();if(t.isOdd)return!t.isOdd(p);throw new Error("Field doesn't support isOdd")}equals(p){l(p);const{px:b,py:v,pz:w}=this,{px:E,py:A,pz:S}=p,k=t.eql(t.mul(b,S),t.mul(E,w)),C=t.eql(t.mul(v,S),t.mul(A,w));return k&&C}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:p,b}=e,v=t.mul(b,Ku),{px:w,py:E,pz:A}=this;let S=t.ZERO,k=t.ZERO,C=t.ZERO,_=t.mul(w,w),U=t.mul(E,E),V=t.mul(A,A),P=t.mul(w,E);return P=t.add(P,P),C=t.mul(w,A),C=t.add(C,C),S=t.mul(p,C),k=t.mul(v,V),k=t.add(S,k),S=t.sub(U,k),k=t.add(U,k),k=t.mul(S,k),S=t.mul(P,S),C=t.mul(v,C),V=t.mul(p,V),P=t.sub(_,V),P=t.mul(p,P),P=t.add(P,C),C=t.add(_,_),_=t.add(C,_),_=t.add(_,V),_=t.mul(_,P),k=t.add(k,_),V=t.mul(E,A),V=t.add(V,V),_=t.mul(V,P),S=t.sub(S,_),C=t.mul(V,U),C=t.add(C,C),C=t.add(C,C),new g(S,k,C)}add(p){l(p);const{px:b,py:v,pz:w}=this,{px:E,py:A,pz:S}=p;let k=t.ZERO,C=t.ZERO,_=t.ZERO;const U=e.a,V=t.mul(e.b,Ku);let P=t.mul(b,E),K=t.mul(v,A),L=t.mul(w,S),T=t.add(b,v),O=t.add(E,A);T=t.mul(T,O),O=t.add(P,K),T=t.sub(T,O),O=t.add(b,w);let N=t.add(E,S);return O=t.mul(O,N),N=t.add(P,L),O=t.sub(O,N),N=t.add(v,w),k=t.add(A,S),N=t.mul(N,k),k=t.add(K,L),N=t.sub(N,k),_=t.mul(U,O),k=t.mul(V,L),_=t.add(k,_),k=t.sub(K,_),_=t.add(K,_),C=t.mul(k,_),K=t.add(P,P),K=t.add(K,P),L=t.mul(U,L),O=t.mul(V,O),K=t.add(K,L),L=t.sub(P,L),L=t.mul(U,L),O=t.add(O,L),P=t.mul(K,O),C=t.add(C,P),P=t.mul(N,O),k=t.mul(T,k),k=t.sub(k,P),P=t.mul(T,K),_=t.mul(N,_),_=t.add(_,P),new g(k,C,_)}subtract(p){return this.add(p.negate())}is0(){return this.equals(g.ZERO)}wNAF(p){return m.wNAFCached(this,p,g.normalizeZ)}multiplyUnsafe(p){const{endo:b,n:v}=e;Qe("scalar",p,Ht,v);const w=g.ZERO;if(p===Ht)return w;if(this.is0()||p===ke)return this;if(!b||m.hasPrecomputes(this))return m.wNAFCachedUnsafe(this,p,g.normalizeZ);let{k1neg:E,k1:A,k2neg:S,k2:k}=b.splitScalar(p),C=w,_=w,U=this;for(;A>Ht||k>Ht;)A&ke&&(C=C.add(U)),k&ke&&(_=_.add(U)),U=U.double(),A>>=ke,k>>=ke;return E&&(C=C.negate()),S&&(_=_.negate()),_=new g(t.mul(_.px,b.beta),_.py,_.pz),C.add(_)}multiply(p){const{endo:b,n:v}=e;Qe("scalar",p,ke,v);let w,E;if(b){const{k1neg:A,k1:S,k2neg:k,k2:C}=b.splitScalar(p);let{p:_,f:U}=this.wNAF(S),{p:V,f:P}=this.wNAF(C);_=m.constTimeNegate(A,_),V=m.constTimeNegate(k,V),V=new g(t.mul(V.px,b.beta),V.py,V.pz),w=_.add(V),E=U.add(P)}else{const{p:A,f:S}=this.wNAF(p);w=A,E=S}return g.normalizeZ([w,E])[0]}multiplyAndAddUnsafe(p,b,v){const w=g.BASE,E=(S,k)=>k===Ht||k===ke||!S.equals(w)?S.multiplyUnsafe(k):S.multiply(k),A=E(this,b).add(E(p,v));return A.is0()?void 0:A}toAffine(p){return u(this,p)}isTorsionFree(){const{h:p,isTorsionFree:b}=e;if(p===ke)return!0;if(b)return b(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:p,clearCofactor:b}=e;return p===ke?this:b?b(g,this):this.multiplyUnsafe(e.h)}toRawBytes(p=!0){return on("isCompressed",p),this.assertValidity(),s(g,this,p)}toHex(p=!0){return on("isCompressed",p),Wn(this.toRawBytes(p))}}g.BASE=new g(e.Gx,e.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const y=e.nBitLength,m=nl(g,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:a}}function Gm(n){const e=So(n);return jn(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Wm(n){const e=Gm(n),{Fp:t,n:r}=e,s=t.BYTES+1,i=2*t.BYTES+1;function o(L){return le(L,r)}function a(L){return mo(L,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:u,isWithinCurveOrder:h}=qm({...e,toBytes(L,T,O){const N=T.toAffine(),x=t.toBytes(N.x),I=Yn;return on("isCompressed",O),O?I(Uint8Array.from([T.hasEvenY()?2:3]),x):I(Uint8Array.from([4]),x,t.toBytes(N.y))},fromBytes(L){const T=L.length,O=L[0],N=L.subarray(1);if(T===s&&(O===2||O===3)){const x=vn(N);if(!go(x,ke,t.ORDER))throw new Error("Point is not on curve");const I=u(x);let B;try{B=t.sqrt(I)}catch(q){const G=q instanceof Error?": "+q.message:"";throw new Error("Point is not on curve"+G)}const M=(B&ke)===ke;return(O&1)===1!==M&&(B=t.neg(B)),{x,y:B}}else if(T===i&&O===4){const x=t.fromBytes(N.subarray(0,t.BYTES)),I=t.fromBytes(N.subarray(t.BYTES,2*t.BYTES));return{x,y:I}}else{const x=s,I=i;throw new Error("invalid Point, expected length of "+x+", or uncompressed "+I+", got "+T)}}}),g=L=>Wn(Or(L,e.nByteLength));function y(L){const T=r>>ke;return L>T}function m(L){return y(L)?o(-L):L}const d=(L,T,O)=>vn(L.slice(T,O));class p{constructor(T,O,N){Qe("r",T,ke,r),Qe("s",O,ke,r),this.r=T,this.s=O,N!=null&&(this.recovery=N),Object.freeze(this)}static fromCompact(T){const O=e.nByteLength;return T=we("compactSignature",T,O*2),new p(d(T,0,O),d(T,O,2*O))}static fromDER(T){const{r:O,s:N}=$t.toSig(we("DER",T));return new p(O,N)}assertValidity(){}addRecoveryBit(T){return new p(this.r,this.s,T)}recoverPublicKey(T){const{r:O,s:N,recovery:x}=this,I=S(we("msgHash",T));if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");const B=x===2||x===3?O+e.n:O;if(B>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=x&1?"03":"02",$=c.fromHex(M+g(B)),q=a(B),G=o(-I*q),W=o(N*q),Y=c.BASE.multiplyAndAddUnsafe($,G,W);if(!Y)throw new Error("point at infinify");return Y.assertValidity(),Y}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Ks(this.toDERHex())}toDERHex(){return $t.hexFromSig(this)}toCompactRawBytes(){return Ks(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const b={isValidPrivateKey(L){try{return l(L),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const L=Zc(e.n);return my(e.randomBytes(L),e.n)},precompute(L=8,T=c.BASE){return T._setWindowSize(L),T.multiply(BigInt(3)),T}};function v(L,T=!0){return c.fromPrivateKey(L).toRawBytes(T)}function w(L){const T=Gn(L),O=typeof L=="string",N=(T||O)&&L.length;return T?N===s||N===i:O?N===2*s||N===2*i:L instanceof c}function E(L,T,O=!0){if(w(L))throw new Error("first arg must be private key");if(!w(T))throw new Error("second arg must be public key");return c.fromHex(T).multiply(l(L)).toRawBytes(O)}const A=e.bits2int||function(L){if(L.length>8192)throw new Error("input is too large");const T=vn(L),O=L.length*8-e.nBitLength;return O>0?T>>BigInt(O):T},S=e.bits2int_modN||function(L){return o(A(L))},k=zs(e.nBitLength);function C(L){return Qe("num < 2^"+e.nBitLength,L,Ht,k),Or(L,e.nByteLength)}function _(L,T,O=U){if(["recovered","canonical"].some(se=>se in O))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:x}=e;let{lowS:I,prehash:B,extraEntropy:M}=O;I==null&&(I=!0),L=we("msgHash",L),Hu(O),B&&(L=we("prehashed msgHash",N(L)));const $=S(L),q=l(T),G=[C(q),C($)];if(M!=null&&M!==!1){const se=M===!0?x(t.BYTES):M;G.push(we("extraEntropy",se))}const W=Yn(...G),Y=$;function ce(se){const ge=A(se);if(!h(ge))return;const Ze=a(ge),Te=c.BASE.multiply(ge).toAffine(),Fe=o(Te.x);if(Fe===Ht)return;const lt=o(Ze*o(Y+Fe*q));if(lt===Ht)return;let Ot=(Te.x===Fe?0:2)|Number(Te.y&ke),Zt=lt;return I&&y(lt)&&(Zt=m(lt),Ot^=1),new p(Fe,Zt,Ot)}return{seed:W,k2sig:ce}}const U={lowS:e.lowS,prehash:!1},V={lowS:e.lowS,prehash:!1};function P(L,T,O=U){const{seed:N,k2sig:x}=_(L,T,O),I=e;return ay(I.hash.outputLen,I.nByteLength,I.hmac)(N,x)}c.BASE._setWindowSize(8);function K(L,T,O,N=V){var Ot;const x=L;T=we("msgHash",T),O=we("publicKey",O);const{lowS:I,prehash:B,format:M}=N;if(Hu(N),"strict"in N)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const $=typeof x=="string"||Gn(x),q=!$&&!M&&typeof x=="object"&&x!==null&&typeof x.r=="bigint"&&typeof x.s=="bigint";if(!$&&!q)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let G,W;try{if(q&&(G=new p(x.r,x.s)),$){try{M!=="compact"&&(G=p.fromDER(x))}catch(Zt){if(!(Zt instanceof $t.Err))throw Zt}!G&&M!=="der"&&(G=p.fromCompact(x))}W=c.fromHex(O)}catch{return!1}if(!G||I&&G.hasHighS())return!1;B&&(T=e.hash(T));const{r:Y,s:ce}=G,se=S(T),ge=a(ce),Ze=o(se*ge),Te=o(Y*ge),Fe=(Ot=c.BASE.multiplyAndAddUnsafe(W,Ze,Te))==null?void 0:Ot.toAffine();return Fe?o(Fe.x)===Y:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:E,sign:P,verify:K,ProjectivePoint:c,Signature:p,utils:b}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ym(n){return{hash:n,hmac:(e,...t)=>zr(n,e,$p(...t)),randomBytes:Ms}}function jm(n,e){const t=r=>Wm({...n,...Ym(r)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zu=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),qu=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Xm=BigInt(1),Jo=BigInt(2),Gu=(n,e)=>(n+e/Jo)/e;function Zm(n){const e=zu,t=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),l=n*n*n%e,u=l*l*n%e,h=pe(u,t,e)*u%e,g=pe(h,t,e)*u%e,y=pe(g,Jo,e)*l%e,m=pe(y,s,e)*y%e,d=pe(m,i,e)*m%e,p=pe(d,a,e)*d%e,b=pe(p,c,e)*p%e,v=pe(b,a,e)*d%e,w=pe(v,t,e)*u%e,E=pe(w,o,e)*m%e,A=pe(E,r,e)*l%e,S=pe(A,Jo,e);if(!ea.eql(ea.sqr(S),n))throw new Error("Cannot find square root");return S}const ea=Xn(zu,void 0,void 0,{sqrt:Zm}),It=jm({a:BigInt(0),b:BigInt(7),Fp:ea,n:qu,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=qu,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Xm*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=t,o=BigInt("0x100000000000000000000000000000000"),a=Gu(i*n,e),c=Gu(-r*n,e);let l=le(n-a*t-c*s,e),u=le(-a*r-c*i,e);const h=l>o,g=u>o;if(h&&(l=e-l),g&&(u=e-u),l>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:h,k1:l,k2neg:g,k2:u}}}},Vc);BigInt(0),It.ProjectivePoint;function Qm(){return It.utils.randomPrivateKey()}function Jm(n,e){const t=pt.digest(e instanceof Uint8Array?e:e.subarray());if(Jt(t))return t.then(({digest:r})=>It.sign(r,n).toDERRawBytes()).catch(r=>{throw new R(String(r),"ERR_INVALID_INPUT")});try{return It.sign(t.digest,n).toDERRawBytes()}catch(r){throw new R(String(r),"ERR_INVALID_INPUT")}}function ew(n,e,t){const r=pt.digest(t instanceof Uint8Array?t:t.subarray());if(Jt(r))return r.then(({digest:s})=>It.verify(e,s,n)).catch(s=>{throw new R(String(s),"ERR_INVALID_INPUT")});try{return It.verify(e,r.digest,n)}catch(s){throw new R(String(s),"ERR_INVALID_INPUT")}}function tw(n){return It.ProjectivePoint.fromHex(n).toRawBytes(!0)}function nw(n){try{It.getPublicKey(n,!0)}catch(e){throw new R(String(e),"ERR_INVALID_PRIVATE_KEY")}}function Wu(n){try{It.ProjectivePoint.fromHex(n)}catch(e){throw new R(String(e),"ERR_INVALID_PUBLIC_KEY")}}function rw(n){try{return It.getPublicKey(n,!0)}catch(e){throw new R(String(e),"ERR_INVALID_PRIVATE_KEY")}}class ta{constructor(e){f(this,"_key");Wu(e),this._key=e}verify(e,t){return ew(this._key,t,e)}marshal(){return tw(this._key)}get bytes(){return Jn.encode({Type:Ae.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}async hash(){const e=pt.digest(this.bytes);let t;return Jt(e)?{bytes:t}=await e:t=e.bytes,t}}class na{constructor(e,t){f(this,"_key");f(this,"_publicKey");this._key=e,this._publicKey=t??rw(e),nw(this._key),Wu(this._publicKey)}sign(e){return Jm(this._key,e)}get public(){return new ta(this._publicKey)}marshal(){return this._key}get bytes(){return er.encode({Type:Ae.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return $e(this.bytes,e.bytes)}hash(){const e=pt.digest(this.bytes);return Jt(e)?e.then(({bytes:t})=>t):e.bytes}async id(){const e=await this.public.hash();return j(e,"base58btc")}async export(e,t="libp2p-key"){if(t==="libp2p-key")return Io(this.bytes,e);throw new R(`export format '${t}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function sw(n){return new na(n)}function iw(n){return new ta(n)}async function ow(){const n=Qm();return new na(n)}const hn={rsa:Hm,ed25519:dm,secp256k1:Object.freeze(Object.defineProperty({__proto__:null,Secp256k1PrivateKey:na,Secp256k1PublicKey:ta,generateKeyPair:ow,unmarshalSecp256k1PrivateKey:sw,unmarshalSecp256k1PublicKey:iw},Symbol.toStringTag,{value:"Module"}))};function ra(n){const e=Object.keys(hn).join(" / ");return new R(`invalid or unsupported key type ${n}. Must be ${e}`,"ERR_UNSUPPORTED_KEY_TYPE")}function sa(n){if(n=n.toLowerCase(),n==="rsa"||n==="ed25519"||n==="secp256k1")return hn[n];throw ra(n)}async function aw(n,e){return sa(n).generateKeyPair(2048)}function ia(n){const e=Jn.decode(n),t=e.Data??new Uint8Array;switch(e.Type){case Ae.RSA:return hn.rsa.unmarshalRsaPublicKey(t);case Ae.Ed25519:return hn.ed25519.unmarshalEd25519PublicKey(t);case Ae.Secp256k1:return hn.secp256k1.unmarshalSecp256k1PublicKey(t);default:throw ra(e.Type??"unknown")}}function cw(n,e){return e=(e??"rsa").toLowerCase(),sa(e),n.bytes}async function ni(n){const e=er.decode(n),t=e.Data??new Uint8Array;switch(e.Type){case Ae.RSA:return hn.rsa.unmarshalRsaPrivateKey(t);case Ae.Ed25519:return hn.ed25519.unmarshalEd25519PrivateKey(t);case Ae.Secp256k1:return hn.secp256k1.unmarshalSecp256k1PrivateKey(t);default:throw ra(e.Type??"RSA")}}function lw(n,e){return e=(e??"rsa").toLowerCase(),sa(e),n.bytes}const or=1e3,ar=or*60,cr=ar*60,kn=cr*24,Xr=kn*7,lr=kn*365.25,Zr=lr/12;function uw(n,e){if(typeof n=="string")return hw(n);if(typeof n=="number")return gw(n,e);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(n)}`)}var Yu=uw;function hw(n){if(typeof n!="string"||n.length===0||n.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(n)}`);let e=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(n);if(!(e!=null&&e.groups))return NaN;let{value:t,unit:r="ms"}=e.groups,s=parseFloat(t),i=r.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*lr;case"months":case"month":case"mo":return s*Zr;case"weeks":case"week":case"w":return s*Xr;case"days":case"day":case"d":return s*kn;case"hours":case"hour":case"hrs":case"hr":case"h":return s*cr;case"minutes":case"minute":case"mins":case"min":case"m":return s*ar;case"seconds":case"second":case"secs":case"sec":case"s":return s*or;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(n)}`)}}function fw(n){let e=Math.abs(n);return e>=lr?`${Math.round(n/lr)}y`:e>=Zr?`${Math.round(n/Zr)}mo`:e>=Xr?`${Math.round(n/Xr)}w`:e>=kn?`${Math.round(n/kn)}d`:e>=cr?`${Math.round(n/cr)}h`:e>=ar?`${Math.round(n/ar)}m`:e>=or?`${Math.round(n/or)}s`:`${n}ms`}function dw(n){let e=Math.abs(n);return e>=lr?Tn(n,e,lr,"year"):e>=Zr?Tn(n,e,Zr,"month"):e>=Xr?Tn(n,e,Xr,"week"):e>=kn?Tn(n,e,kn,"day"):e>=cr?Tn(n,e,cr,"hour"):e>=ar?Tn(n,e,ar,"minute"):e>=or?Tn(n,e,or,"second"):`${n} ms`}function gw(n,e){if(typeof n!="number"||!Number.isFinite(n))throw Error("Value provided to ms.format() must be of type number.");return e!=null&&e.long?dw(n):fw(n)}function Tn(n,e,t,r){let s=e>=t*1.5;return`${Math.round(n/t)} ${r}${s?"s":""}`}function pw(n){t.debug=t,t.default=t,t.coerce=c,t.disable=i,t.enable=s,t.enabled=o,t.humanize=Yu,t.destroy=l,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let g=0;g<u.length;g++)h=(h<<5)-h+u.charCodeAt(g),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,g=null,y,m;function d(...p){if(!d.enabled)return;const b=d,v=Number(new Date),w=v-(h||v);b.diff=w,b.prev=h,b.curr=v,h=v,p[0]=t.coerce(p[0]),typeof p[0]!="string"&&p.unshift("%O");let E=0;p[0]=p[0].replace(/%([a-zA-Z%])/g,(S,k)=>{if(S==="%%")return"%";E++;const C=t.formatters[k];if(typeof C=="function"){const _=p[E];S=C.call(b,_),p.splice(E,1),E--}return S}),t.formatArgs.call(b,p),(b.log||t.log).apply(b,p)}return d.namespace=u,d.useColors=t.useColors(),d.color=t.selectColor(u),d.extend=r,d.destroy=t.destroy,Object.defineProperty(d,"enabled",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(y!==t.namespaces&&(y=t.namespaces,m=t.enabled(u)),m),set:p=>{g=p}}),typeof t.init=="function"&&t.init(d),d}function r(u,h){const g=t(this.namespace+(typeof h>"u"?":":h)+u);return g.log=this.log,g}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const g=(typeof u=="string"?u:"").split(/[\s,]+/),y=g.length;for(h=0;h<y;h++)g[h]&&(u=g[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.substr(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,g;for(h=0,g=t.skips.length;h<g;h++)if(t.skips[h].test(u))return!1;for(h=0,g=t.names.length;h<g;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack??u.message:u}function l(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.setupFormatters(t.formatters),t.enable(t.load()),t}var yw={};const kt=Aw(),mw=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function ww(){var n,e,t,r,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((t=(e=document.documentElement)==null?void 0:e.style)==null?void 0:t.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function bw(n){if(n[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+n[0]+(this.useColors?"%c ":" ")+"+"+Yu(this.diff),!this.useColors)return;const e="color: "+this.color;n.splice(1,0,e,"color: inherit");let t=0,r=0;n[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(t++,s==="%c"&&(r=t))}),n.splice(r,0,e)}const Ew=console.debug??console.log??(()=>{});function vw(n){try{n?kt==null||kt.setItem("debug",n):kt==null||kt.removeItem("debug")}catch{}}function _w(){let n;try{n=kt==null?void 0:kt.getItem("debug")}catch{}return!n&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(n=yw.DEBUG),n}function Aw(){try{return localStorage}catch{}}function Sw(n){n.j=function(e){try{return JSON.stringify(e)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}const ht=pw({formatArgs:bw,save:vw,load:_w,useColors:ww,setupFormatters:Sw,colors:mw,storage:kt,log:Ew});ht.formatters.b=n=>n==null?"undefined":Ve.baseEncode(n),ht.formatters.t=n=>n==null?"undefined":Qt.baseEncode(n),ht.formatters.m=n=>n==null?"undefined":io.baseEncode(n),ht.formatters.p=n=>n==null?"undefined":n.toString(),ht.formatters.c=n=>n==null?"undefined":n.toString(),ht.formatters.k=n=>n==null?"undefined":n.toString(),ht.formatters.a=n=>n==null?"undefined":n.toString();function xw(n){const e=()=>{};return e.enabled=!1,e.color="",e.diff=0,e.log=()=>{},e.namespace=n,e.destroy=()=>!0,e.extend=()=>e,e}function ju(){return{forComponent(n){return Rw(n)}}}function Rw(n){let e=xw(`${n}:trace`);return ht.enabled(`${n}:trace`)&&ht.names.map(t=>t.toString()).find(t=>t.includes(":trace"))!=null&&(e=ht(`${n}:trace`)),Object.assign(ht(n),{error:ht(`${n}:error`),trace:e})}const Xu=Symbol.for("nodejs.util.inspect.custom"),Iw=Object.values(Dr).map(n=>n.decoder).reduce((n,e)=>n.or(e),Dr.identity.decoder),Zu=114,oa=36,aa=37;class ca{constructor(e){f(this,"type");f(this,"multihash");f(this,"privateKey");f(this,"publicKey");f(this,"string");f(this,Pd,!0);this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Ve.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return _e.createV1(Zu,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e==null)return!1;if(e instanceof Uint8Array)return $e(this.multihash.bytes,e);if(typeof e=="string")return st(e).equals(this);if(((t=e==null?void 0:e.multihash)==null?void 0:t.bytes)!=null)return $e(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[(Pd=Tr,Xu)](){return`PeerId(${this.toString()})`}}class Qr extends ca{constructor(t){super({...t,type:"RSA"});f(this,"type","RSA");f(this,"publicKey");this.publicKey=t.publicKey}}class Jr extends ca{constructor(t){super({...t,type:"Ed25519"});f(this,"type","Ed25519");f(this,"publicKey");this.publicKey=t.multihash.digest}}class es extends ca{constructor(t){super({...t,type:"secp256k1"});f(this,"type","secp256k1");f(this,"publicKey");this.publicKey=t.multihash.digest}}const la=2336;class kw{constructor(e){f(this,"type","url");f(this,"multihash");f(this,"privateKey");f(this,"publicKey");f(this,"url");f(this,Ud,!0);this.url=e.toString(),this.multihash=$n.digest(z(this.url))}[(Md=Xu,Ud=Tr,Md)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toCID(){return _e.createV1(la,this.multihash)}toBytes(){return this.toCID().bytes}equals(e){return e==null?!1:(e instanceof Uint8Array&&(e=j(e)),e.toString()===this.toString())}}function Tw(n){if(n.type==="RSA")return new Qr(n);if(n.type==="Ed25519")return new Jr(n);if(n.type==="secp256k1")return new es(n);throw new R("Not a PeerId","ERR_INVALID_PARAMETERS")}function st(n,e){if(n.charAt(0)==="1"||n.charAt(0)==="Q"){const t=ro(Ve.decode(`z${n}`));return n.startsWith("12D")?new Jr({multihash:t}):n.startsWith("16U")?new es({multihash:t}):new Qr({multihash:t})}return ua(Iw.decode(n))}function ua(n){try{const e=ro(n);if(e.code===$n.code){if(e.digest.length===oa)return new Jr({multihash:e});if(e.digest.length===aa)return new es({multihash:e})}if(e.code===pt.code)return new Qr({multihash:e})}catch{return Cw(_e.decode(n))}throw new Error("Supplied PeerID CID is invalid")}function Cw(n){if((n==null?void 0:n.multihash)==null||n.version==null||n.version===1&&n.code!==Zu&&n.code!==la)throw new Error("Supplied PeerID CID is invalid");if(n.code===la){const t=j(n.multihash.digest);return new kw(new URL(t))}const e=n.multihash;if(e.code===pt.code)return new Qr({multihash:n.multihash});if(e.code===$n.code){if(e.digest.length===oa)return new Jr({multihash:n.multihash});if(e.digest.length===aa)return new es({multihash:n.multihash})}throw new Error("Supplied PeerID CID is invalid")}async function Cn(n,e){return n.length===oa?new Jr({multihash:Nr($n.code,n),privateKey:e}):n.length===aa?new es({multihash:Nr($n.code,n),privateKey:e}):new Qr({multihash:await pt.digest(n),publicKey:n,privateKey:e})}function ri(n,e){const t={[Symbol.iterator]:()=>t,next:()=>{const r=n.next(),s=r.value;return r.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:e(s)}}};return t}class ts{constructor(e){f(this,"map");if(this.map=new Map,e!=null)for(const[t,r]of e.entries())this.map.set(t.toString(),r)}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(e){return this.map.delete(e.toString())}entries(){return ri(this.map.entries(),e=>[st(e[0]),e[1]])}forEach(e){this.map.forEach((t,r)=>{e(t,st(r),this)})}get(e){return this.map.get(e.toString())}has(e){return this.map.has(e.toString())}set(e,t){this.map.set(e.toString(),t)}keys(){return ri(this.map.keys(),e=>st(e))}values(){return this.map.values()}get size(){return this.map.size}}class Nn{constructor(e){f(this,"set");if(this.set=new Set,e!=null)for(const t of e)this.set.add(t.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(e){this.set.add(e.toString())}clear(){this.set.clear()}delete(e){this.set.delete(e.toString())}entries(){return ri(this.set.entries(),e=>{const t=st(e[0]);return[t,t]})}forEach(e){this.set.forEach(t=>{const r=st(t);e(r,r,this)})}has(e){return this.set.has(e.toString())}values(){return ri(this.set.values(),e=>st(e))}intersection(e){const t=new Nn;for(const r of e)this.has(r)&&t.add(r);return t}difference(e){const t=new Nn;for(const r of this)e.has(r)||t.add(r);return t}union(e){const t=new Nn;for(const r of e)t.add(r);for(const r of this)t.add(r);return t}}const ha=Vc;var Qu=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ns(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var Ju={exports:{}};(function(n,e){(function(t,r){var s={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(d){if(!Array.isArray(d)&&!ArrayBuffer.isView(d))return!1;for(var p=0;p<d.length;p++)if(!Number.isInteger(d[p])||d[p]<0||d[p]>255)return!1;return!0}function o(d,p){return(d&65535)*p+(((d>>>16)*p&65535)<<16)}function a(d,p){return d<<p|d>>>32-p}function c(d){return d^=d>>>16,d=o(d,2246822507),d^=d>>>13,d=o(d,3266489909),d^=d>>>16,d}function l(d,p){d=[d[0]>>>16,d[0]&65535,d[1]>>>16,d[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var b=[0,0,0,0];return b[3]+=d[3]+p[3],b[2]+=b[3]>>>16,b[3]&=65535,b[2]+=d[2]+p[2],b[1]+=b[2]>>>16,b[2]&=65535,b[1]+=d[1]+p[1],b[0]+=b[1]>>>16,b[1]&=65535,b[0]+=d[0]+p[0],b[0]&=65535,[b[0]<<16|b[1],b[2]<<16|b[3]]}function u(d,p){d=[d[0]>>>16,d[0]&65535,d[1]>>>16,d[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var b=[0,0,0,0];return b[3]+=d[3]*p[3],b[2]+=b[3]>>>16,b[3]&=65535,b[2]+=d[2]*p[3],b[1]+=b[2]>>>16,b[2]&=65535,b[2]+=d[3]*p[2],b[1]+=b[2]>>>16,b[2]&=65535,b[1]+=d[1]*p[3],b[0]+=b[1]>>>16,b[1]&=65535,b[1]+=d[2]*p[2],b[0]+=b[1]>>>16,b[1]&=65535,b[1]+=d[3]*p[1],b[0]+=b[1]>>>16,b[1]&=65535,b[0]+=d[0]*p[3]+d[1]*p[2]+d[2]*p[1]+d[3]*p[0],b[0]&=65535,[b[0]<<16|b[1],b[2]<<16|b[3]]}function h(d,p){return p%=64,p===32?[d[1],d[0]]:p<32?[d[0]<<p|d[1]>>>32-p,d[1]<<p|d[0]>>>32-p]:(p-=32,[d[1]<<p|d[0]>>>32-p,d[0]<<p|d[1]>>>32-p])}function g(d,p){return p%=64,p===0?d:p<32?[d[0]<<p|d[1]>>>32-p,d[1]<<p]:[d[1]<<p-32,0]}function y(d,p){return[d[0]^p[0],d[1]^p[1]]}function m(d){return d=y(d,[0,d[0]>>>1]),d=u(d,[4283543511,3981806797]),d=y(d,[0,d[0]>>>1]),d=u(d,[3301882366,444984403]),d=y(d,[0,d[0]>>>1]),d}s.x86.hash32=function(d,p){if(s.inputValidation&&!i(d))return r;p=p||0;for(var b=d.length%4,v=d.length-b,w=p,E=0,A=3432918353,S=461845907,k=0;k<v;k=k+4)E=d[k]|d[k+1]<<8|d[k+2]<<16|d[k+3]<<24,E=o(E,A),E=a(E,15),E=o(E,S),w^=E,w=a(w,13),w=o(w,5)+3864292196;switch(E=0,b){case 3:E^=d[k+2]<<16;case 2:E^=d[k+1]<<8;case 1:E^=d[k],E=o(E,A),E=a(E,15),E=o(E,S),w^=E}return w^=d.length,w=c(w),w>>>0},s.x86.hash128=function(d,p){if(s.inputValidation&&!i(d))return r;p=p||0;for(var b=d.length%16,v=d.length-b,w=p,E=p,A=p,S=p,k=0,C=0,_=0,U=0,V=597399067,P=2869860233,K=951274213,L=2716044179,T=0;T<v;T=T+16)k=d[T]|d[T+1]<<8|d[T+2]<<16|d[T+3]<<24,C=d[T+4]|d[T+5]<<8|d[T+6]<<16|d[T+7]<<24,_=d[T+8]|d[T+9]<<8|d[T+10]<<16|d[T+11]<<24,U=d[T+12]|d[T+13]<<8|d[T+14]<<16|d[T+15]<<24,k=o(k,V),k=a(k,15),k=o(k,P),w^=k,w=a(w,19),w+=E,w=o(w,5)+1444728091,C=o(C,P),C=a(C,16),C=o(C,K),E^=C,E=a(E,17),E+=A,E=o(E,5)+197830471,_=o(_,K),_=a(_,17),_=o(_,L),A^=_,A=a(A,15),A+=S,A=o(A,5)+2530024501,U=o(U,L),U=a(U,18),U=o(U,V),S^=U,S=a(S,13),S+=w,S=o(S,5)+850148119;switch(k=0,C=0,_=0,U=0,b){case 15:U^=d[T+14]<<16;case 14:U^=d[T+13]<<8;case 13:U^=d[T+12],U=o(U,L),U=a(U,18),U=o(U,V),S^=U;case 12:_^=d[T+11]<<24;case 11:_^=d[T+10]<<16;case 10:_^=d[T+9]<<8;case 9:_^=d[T+8],_=o(_,K),_=a(_,17),_=o(_,L),A^=_;case 8:C^=d[T+7]<<24;case 7:C^=d[T+6]<<16;case 6:C^=d[T+5]<<8;case 5:C^=d[T+4],C=o(C,P),C=a(C,16),C=o(C,K),E^=C;case 4:k^=d[T+3]<<24;case 3:k^=d[T+2]<<16;case 2:k^=d[T+1]<<8;case 1:k^=d[T],k=o(k,V),k=a(k,15),k=o(k,P),w^=k}return w^=d.length,E^=d.length,A^=d.length,S^=d.length,w+=E,w+=A,w+=S,E+=w,A+=w,S+=w,w=c(w),E=c(E),A=c(A),S=c(S),w+=E,w+=A,w+=S,E+=w,A+=w,S+=w,("00000000"+(w>>>0).toString(16)).slice(-8)+("00000000"+(E>>>0).toString(16)).slice(-8)+("00000000"+(A>>>0).toString(16)).slice(-8)+("00000000"+(S>>>0).toString(16)).slice(-8)},s.x64.hash128=function(d,p){if(s.inputValidation&&!i(d))return r;p=p||0;for(var b=d.length%16,v=d.length-b,w=[0,p],E=[0,p],A=[0,0],S=[0,0],k=[2277735313,289559509],C=[1291169091,658871167],_=0;_<v;_=_+16)A=[d[_+4]|d[_+5]<<8|d[_+6]<<16|d[_+7]<<24,d[_]|d[_+1]<<8|d[_+2]<<16|d[_+3]<<24],S=[d[_+12]|d[_+13]<<8|d[_+14]<<16|d[_+15]<<24,d[_+8]|d[_+9]<<8|d[_+10]<<16|d[_+11]<<24],A=u(A,k),A=h(A,31),A=u(A,C),w=y(w,A),w=h(w,27),w=l(w,E),w=l(u(w,[0,5]),[0,1390208809]),S=u(S,C),S=h(S,33),S=u(S,k),E=y(E,S),E=h(E,31),E=l(E,w),E=l(u(E,[0,5]),[0,944331445]);switch(A=[0,0],S=[0,0],b){case 15:S=y(S,g([0,d[_+14]],48));case 14:S=y(S,g([0,d[_+13]],40));case 13:S=y(S,g([0,d[_+12]],32));case 12:S=y(S,g([0,d[_+11]],24));case 11:S=y(S,g([0,d[_+10]],16));case 10:S=y(S,g([0,d[_+9]],8));case 9:S=y(S,[0,d[_+8]]),S=u(S,C),S=h(S,33),S=u(S,k),E=y(E,S);case 8:A=y(A,g([0,d[_+7]],56));case 7:A=y(A,g([0,d[_+6]],48));case 6:A=y(A,g([0,d[_+5]],40));case 5:A=y(A,g([0,d[_+4]],32));case 4:A=y(A,g([0,d[_+3]],24));case 3:A=y(A,g([0,d[_+2]],16));case 2:A=y(A,g([0,d[_+1]],8));case 1:A=y(A,[0,d[_]]),A=u(A,k),A=h(A,31),A=u(A,C),w=y(w,A)}return w=y(w,[0,d.length]),E=y(E,[0,d.length]),w=l(w,E),E=l(E,w),w=m(w),E=m(E),w=l(w,E),E=l(E,w),("00000000"+(w[0]>>>0).toString(16)).slice(-8)+("00000000"+(w[1]>>>0).toString(16)).slice(-8)+("00000000"+(E[0]>>>0).toString(16)).slice(-8)+("00000000"+(E[1]>>>0).toString(16)).slice(-8)},n.exports&&(e=n.exports=s),e.murmurHash3=s})()})(Ju,Ju.exports);const eh=Symbol.for("@achingbrain/uint8arraylist");function th(n,e){if(e==null||e<0)throw new RangeError("index is out of bounds");let t=0;for(const r of n){const s=t+r.byteLength;if(e<s)return{buf:r,index:e-t};t=s}throw new RangeError("index is out of bounds")}function si(n){return!!(n!=null&&n[eh])}class Ee{constructor(...e){f(this,"bufs");f(this,"length");f(this,Fd,!0);this.bufs=[],this.length=0,e.length>0&&this.appendAll(e)}*[(Fd=eh,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...e){this.appendAll(e)}appendAll(e){let t=0;for(const r of e)if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.push(r);else if(si(r))t+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}prepend(...e){this.prependAll(e)}prependAll(e){let t=0;for(const r of e.reverse())if(r instanceof Uint8Array)t+=r.byteLength,this.bufs.unshift(r);else if(si(r))t+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=t}get(e){const t=th(this.bufs,e);return t.buf[t.index]}set(e,t){const r=th(this.bufs,e);r.buf[r.index]=t}write(e,t=0){if(e instanceof Uint8Array)for(let r=0;r<e.length;r++)this.set(t+r,e[r]);else if(si(e))for(let r=0;r<e.length;r++)this.set(t+r,e.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(e){if(e=Math.trunc(e),!(Number.isNaN(e)||e<=0)){if(e===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(e>=this.bufs[0].byteLength)e-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(e),this.length-=e;break}}}slice(e,t){const{bufs:r,length:s}=this._subList(e,t);return Pt(r,s)}subarray(e,t){const{bufs:r,length:s}=this._subList(e,t);return r.length===1?r[0]:Pt(r,s)}sublist(e,t){const{bufs:r,length:s}=this._subList(e,t),i=new Ee;return i.length=s,i.bufs=[...r],i}_subList(e,t){if(e=e??0,t=t??this.length,e<0&&(e=this.length+e),t<0&&(t=this.length+t),e<0||t>this.length)throw new RangeError("index is out of bounds");if(e===t)return{bufs:[],length:0};if(e===0&&t===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,e>=c)continue;const l=e>=a&&e<c,u=t>a&&t<=c;if(l&&u){if(e===a&&t===c){r.push(o);break}const h=e-a;r.push(o.subarray(h,h+(t-e)));break}if(l){if(e===0){r.push(o);continue}r.push(o.subarray(e-a));continue}if(u){if(t===c){r.push(o);break}r.push(o.subarray(0,t-a));break}r.push(o)}return{bufs:r,length:t-e}}indexOf(e,t=0){if(!si(e)&&!(e instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=e instanceof Uint8Array?e:e.subarray();if(t=Number(t??0),isNaN(t)&&(t=0),t<0&&(t=this.length+t),t<0&&(t=0),e.length===0)return t>this.length?this.length:t;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[r[h]]=h;const a=o,c=this.byteLength-r.byteLength,l=r.byteLength-1;let u;for(let h=t;h<=c;h+=u){u=0;for(let g=l;g>=0;g--){const y=this.get(h+g);if(r[g]!==y){u=Math.max(1,g-a[y]);break}}if(u===0)return h}return-1}getInt8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getInt8(0)}setInt8(e,t){const r=vt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,t),this.write(r,e)}getInt16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,t)}setInt16(e,t,r){const s=He(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,t,r),this.write(s,e)}getInt32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,t)}setInt32(e,t,r){const s=He(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,t,r),this.write(s,e)}getBigInt64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,t)}setBigInt64(e,t,r){const s=He(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,t,r),this.write(s,e)}getUint8(e){const t=this.subarray(e,e+1);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint8(0)}setUint8(e,t){const r=vt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,t),this.write(r,e)}getUint16(e,t){const r=this.subarray(e,e+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,t)}setUint16(e,t,r){const s=He(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,t,r),this.write(s,e)}getUint32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,t)}setUint32(e,t,r){const s=He(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,t,r),this.write(s,e)}getBigUint64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,t)}setBigUint64(e,t,r){const s=He(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,t,r),this.write(s,e)}getFloat32(e,t){const r=this.subarray(e,e+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,t)}setFloat32(e,t,r){const s=He(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,t,r),this.write(s,e)}getFloat64(e,t){const r=this.subarray(e,e+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,t)}setFloat64(e,t,r){const s=He(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,t,r),this.write(s,e)}equals(e){if(e==null||!(e instanceof Ee)||e.bufs.length!==this.bufs.length)return!1;for(let t=0;t<this.bufs.length;t++)if(!$e(this.bufs[t],e.bufs[t]))return!1;return!0}static fromUint8Arrays(e,t){const r=new Ee;return r.bufs=e,t==null&&(t=e.reduce((s,i)=>s+i.byteLength,0)),r.length=t,r}}const nh=64;class Ln{constructor(e,t,r,s=2){f(this,"fp");f(this,"h");f(this,"seed");if(s>nh)throw new TypeError("Invalid Fingerprint Size");const i=t.hashV(e,r),o=He(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=t,this.seed=r}hash(){return this.h.hash(this.fp,this.seed)}equals(e){return(e==null?void 0:e.fp)instanceof Uint8Array?$e(this.fp,e.fp):!1}}function ii(n,e){return Math.floor(Math.random()*(e-n))+n}class oi{constructor(e){f(this,"contents");this.contents=new Array(e).fill(null)}has(e){if(!(e instanceof Ln))throw new TypeError("Invalid Fingerprint");return this.contents.some(t=>e.equals(t))}add(e){if(!(e instanceof Ln))throw new TypeError("Invalid Fingerprint");for(let t=0;t<this.contents.length;t++)if(this.contents[t]==null)return this.contents[t]=e,!0;return!0}swap(e){if(!(e instanceof Ln))throw new TypeError("Invalid Fingerprint");const t=ii(0,this.contents.length-1),r=this.contents[t];return this.contents[t]=e,r}remove(e){if(!(e instanceof Ln))throw new TypeError("Invalid Fingerprint");const t=this.contents.findIndex(r=>e.equals(r));return t>-1?(this.contents[t]=null,!0):!1}}const fa={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},rh={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},sh=new globalThis.TextEncoder;function Nw(n,e){const t=fa[e];let r=rh[e];for(let s=0;s<n.length;s++)r^=BigInt(n[s]),r=BigInt.asUintN(e,r*t);return r}function Lw(n,e,t){if(t.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const r=fa[e];let s=rh[e],i=n;for(;i.length>0;){const o=sh.encodeInto(i,t);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(t[a]),s=BigInt.asUintN(e,s*r)}return s}function Dw(n,{size:e=32,utf8Buffer:t}={}){if(!fa[e])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof n=="string"){if(t)return Lw(n,e,t);n=sh.encode(n)}return Nw(n,e)}const da={hash:n=>Number(Dw(n,{size:32})),hashV:(n,e)=>Bw(da.hash(n,e))};function Bw(n){let e=n.toString(16);return e.length%2===1&&(e=`0${e}`),z(e,"base16")}const Ow=500;class ih{constructor(e){f(this,"bucketSize");f(this,"filterSize");f(this,"fingerprintSize");f(this,"buckets");f(this,"count");f(this,"hash");f(this,"seed");this.filterSize=e.filterSize,this.bucketSize=e.bucketSize??4,this.fingerprintSize=e.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=e.hash??da,this.seed=e.seed??ii(0,Math.pow(2,10))}add(e){typeof e=="string"&&(e=z(e));const t=new Ln(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=(r^t.hash())%this.filterSize;if(this.buckets[r]==null&&(this.buckets[r]=new oi(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new oi(this.bucketSize)),this.buckets[r].add(t)||this.buckets[s].add(t))return this.count++,!0;const i=[r,s];let o=i[ii(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new oi(this.bucketSize));for(let a=0;a<Ow;a++){const c=this.buckets[o].swap(t);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new oi(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(e){var o,a;typeof e=="string"&&(e=z(e));const t=new Ln(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=((o=this.buckets[r])==null?void 0:o.has(t))??!1;if(s)return s;const i=(r^t.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(t))??!1}remove(e){var a,c;typeof e=="string"&&(e=z(e));const t=new Ln(e,this.hash,this.seed,this.fingerprintSize),r=this.hash.hash(e,this.seed)%this.filterSize,s=((a=this.buckets[r])==null?void 0:a.remove(t))??!1;if(s)return this.count--,s;const i=(r^t.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(t))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const Pw={1:.5,2:.84,4:.95,8:.98};function Uw(n=.001){return n>.002?2:n>1e-5?4:8}function Mw(n,e=.001){const t=Uw(e),r=Pw[t],s=Math.round(n/r),i=Math.min(Math.ceil(Math.log2(1/e)+Math.log2(2*t)),nh);return{filterSize:s,bucketSize:t,fingerprintSize:i}}class Fw{constructor(e){f(this,"filterSize");f(this,"bucketSize");f(this,"fingerprintSize");f(this,"scale");f(this,"filterSeries");f(this,"hash");f(this,"seed");this.bucketSize=e.bucketSize??4,this.filterSize=e.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=e.fingerprintSize??2,this.scale=e.scale??2,this.hash=e.hash??da,this.seed=e.seed??ii(0,Math.pow(2,10)),this.filterSeries=[new ih({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(e){if(typeof e=="string"&&(e=z(e)),this.has(e))return!0;let t=this.filterSeries.find(r=>r.reliable);if(t==null){const r=this.filterSize*Math.pow(this.scale,this.filterSeries.length);t=new ih({filterSize:r,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(t)}return t.add(e)}has(e){typeof e=="string"&&(e=z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].has(e))return!0;return!1}remove(e){typeof e=="string"&&(e=z(e));for(let t=0;t<this.filterSeries.length;t++)if(this.filterSeries[t].remove(e))return!0;return!1}get count(){return this.filterSeries.reduce((e,t)=>e+t.count,0)}}function Vw(n,e=.001,t){return new Fw({...Mw(n,e)})}const $w=async()=>{const n=await aw("Ed25519"),e=await Hw(n);if(e.type==="Ed25519")return e;throw new Error(`Generated unexpected PeerId type "${e.type}"`)};async function Hw(n){return Cn(cw(n.public),lw(n))}const Kw={ERR_SIGNATURE_NOT_VALID:"ERR_SIGNATURE_NOT_VALID"};var ai;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.publicKey!=null&&t.publicKey.byteLength>0&&(r.uint32(10),r.bytes(t.publicKey)),t.payloadType!=null&&t.payloadType.byteLength>0&&(r.uint32(18),r.bytes(t.payloadType)),t.payload!=null&&t.payload.byteLength>0&&(r.uint32(26),r.bytes(t.payload)),t.signature!=null&&t.signature.byteLength>0&&(r.uint32(42),r.bytes(t.signature)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={publicKey:new Uint8Array(0),payloadType:new Uint8Array(0),payload:new Uint8Array(0),signature:new Uint8Array(0)},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.publicKey=t.bytes();break;case 2:s.payloadType=t.bytes();break;case 3:s.payload=t.bytes();break;case 5:s.signature=t.bytes();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(ai||(ai={}));const mn=class mn{constructor(e){f(this,"peerId");f(this,"payloadType");f(this,"payload");f(this,"signature");f(this,"marshaled");const{peerId:t,payloadType:r,payload:s,signature:i}=e;this.peerId=t,this.payloadType=r,this.payload=s,this.signature=i}marshal(){if(this.peerId.publicKey==null)throw new Error("Missing public key");return this.marshaled==null&&(this.marshaled=ai.encode({publicKey:this.peerId.publicKey,payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(e){return $e(this.marshal(),e.marshal())}async validate(e){const t=oh(e,this.payloadType,this.payload);if(this.peerId.publicKey==null)throw new Error("Missing public key");return ia(this.peerId.publicKey).verify(t.subarray(),this.signature)}};f(mn,"createFromProtobuf",async e=>{const t=ai.decode(e),r=await Cn(t.publicKey);return new mn({peerId:r,payloadType:t.payloadType,payload:t.payload,signature:t.signature})}),f(mn,"seal",async(e,t)=>{if(t.privateKey==null)throw new Error("Missing private key");const r=e.domain,s=e.codec,i=e.marshal(),o=oh(r,s,i),c=await(await ni(t.privateKey)).sign(o.subarray());return new mn({peerId:t,payloadType:s,payload:i,signature:c})}),f(mn,"openAndCertify",async(e,t)=>{const r=await mn.createFromProtobuf(e);if(!await r.validate(t))throw new R("envelope signature is not valid for the given domain",Kw.ERR_SIGNATURE_NOT_VALID);return r});let Dn=mn;const oh=(n,e,t)=>{const r=z(n),s=Qn(r.byteLength),i=Qn(e.length),o=Qn(t.length);return new Ee(s,r,i,e,o,t)};function zw(n,e){const t=(r,s)=>r.toString().localeCompare(s.toString());return n.length!==e.length?!1:(e.sort(t),n.sort(t).every((r,s)=>e[s].equals(r)))}class it extends Error{constructor(){super(...arguments);f(this,"name","InvalidMultiaddrError")}}f(it,"name","InvalidMultiaddrError");class ur extends Error{constructor(){super(...arguments);f(this,"name","ValidationError")}}f(ur,"name","ValidationError");class ah extends Error{constructor(){super(...arguments);f(this,"name","InvalidParametersError")}}f(ah,"name","InvalidParametersError");class ch extends Error{constructor(){super(...arguments);f(this,"name","UnknownProtocolError")}}f(ch,"name","UnknownProtocolError");class qw{constructor(){f(this,"index",0);f(this,"input","")}new(e){return this.index=0,this.input=e,this}readAtomically(e){const t=this.index,r=e();return r===void 0&&(this.index=t),r}parseWith(e){const t=e();if(this.index===this.input.length)return t}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(e){return this.readAtomically(()=>{const t=this.readChar();if(t===e)return t})}readSeparator(e,t,r){return this.readAtomically(()=>{if(!(t>0&&this.readGivenChar(e)===void 0))return r()})}readNumber(e,t,r,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",l=2**(8*s)-1;for(;;){const u=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const g=Number.parseInt(h,e);if(!Number.isNaN(g))return g});if(u===void 0)break;if(i*=e,i+=u,i>l||(o+=1,t!==void 0&&o>t))return}if(o!==0)return!r&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const e=new Uint8Array(4);for(let t=0;t<e.length;t++){const r=this.readSeparator(".",t,()=>this.readNumber(10,3,!1,1));if(r===void 0)return;e[t]=r}return e})}readIPv6Addr(){const e=t=>{for(let r=0;r<t.length/2;r++){const s=r*2;if(r<t.length-3){const o=this.readSeparator(":",r,()=>this.readIPv4Addr());if(o!==void 0)return t[s]=o[0],t[s+1]=o[1],t[s+2]=o[2],t[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",r,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];t[s]=i>>8,t[s+1]=i&255}return[t.length,!1]};return this.readAtomically(()=>{const t=new Uint8Array(16),[r,s]=e(t);if(r===16)return t;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(r+2),[a]=e(i.subarray(0,o));return t.set(i.subarray(0,a),16-a),t})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const Gw=45,Ww=15,ci=new qw;function Yw(n){if(!(n.length>Ww))return ci.new(n).parseWith(()=>ci.readIPv4Addr())}function jw(n){if(n.includes("%")&&(n=n.split("%")[0]),!(n.length>Gw))return ci.new(n).parseWith(()=>ci.readIPv6Addr())}function li(n){return!!Yw(n)}function ga(n){return!!jw(n)}const pa=4,ya=6,ma=273,Xw=33,ui=41,lh=42,Zw=43,uh=53,hh=54,wa=55,fh=56,Qw=132,Jw=301,e0=302,t0=400,dh=421,n0=444,r0=445,s0=446,i0=447,o0=448,a0=449,c0=454,l0=460,u0=461,h0=465,f0=466,d0=480,g0=481,p0=443,y0=477,m0=478,w0=479,b0=277,E0=275,v0=276,_0=280,A0=281,gh=290,S0=777;function ph(n){return e=>j(e,n)}function yh(n){return e=>z(e,n)}function rs(n){return new DataView(n.buffer).getUint16(n.byteOffset).toString()}function hr(n){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,typeof n=="string"?parseInt(n):n),new Uint8Array(e)}function x0(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=z(e[0],"base32"),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=hr(r);return Pt([t,s],t.length+s.length)}function R0(n){const e=n.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=Qt.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const s=hr(r);return Pt([t,s],t.length+s.length)}function mh(n){const e=n.subarray(0,n.length-2),t=n.subarray(n.length-2),r=j(e,"base32"),s=rs(t);return`${r}:${s}`}const wh=function(n){n=n.toString().trim();const e=new Uint8Array(4);return n.split(/\./g).forEach((t,r)=>{const s=parseInt(t,10);if(isNaN(s)||s<0||s>255)throw new it("Invalid byte value in IP address");e[r]=s}),e},I0=function(n){let e=0;n=n.toString().trim();const t=n.split(":",8);let r;for(r=0;r<t.length;r++){const i=li(t[r]);let o;i&&(o=wh(t[r]),t[r]=j(o.subarray(0,2),"base16")),o!=null&&++r<8&&t.splice(r,0,j(o.subarray(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const i=[r,1];for(r=9-t.length;r>0;r--)i.push("0");t.splice.apply(t,i)}const s=new Uint8Array(e+16);for(r=0;r<t.length;r++){t[r]===""&&(t[r]="0");const i=parseInt(t[r],16);if(isNaN(i)||i<0||i>65535)throw new it("Invalid byte value in IP address");s[e++]=i>>8&255,s[e++]=i&255}return s},k0=function(n){if(n.byteLength!==4)throw new it("IPv4 address was incorrect length");const e=[];for(let t=0;t<n.byteLength;t++)e.push(n[t]);return e.join(".")},T0=function(n){if(n.byteLength!==16)throw new it("IPv6 address was incorrect length");const e=[];for(let r=0;r<n.byteLength;r+=2){const s=n[r],i=n[r+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;e.push(o)}const t=e.join(":");try{const r=new URL(`http://[${t}]`);return r.hostname.substring(1,r.hostname.length-1)}catch{throw new it(`Invalid IPv6 address "${t}"`)}};function C0(n){try{const e=new URL(`http://[${n}]`);return e.hostname.substring(1,e.hostname.length-1)}catch{throw new it(`Invalid IPv6 address "${n}"`)}}const ba=Object.values(Dr).map(n=>n.decoder),N0=function(){let n=ba[0].or(ba[1]);return ba.slice(2).forEach(e=>n=n.or(e)),n}();function L0(n){return N0.decode(n)}function D0(n){return e=>n.encoder.encode(e)}function B0(n){if(parseInt(n).toString()!==n)throw new ur("Value must be an integer")}function O0(n){if(n<0)throw new ur("Value must be a positive integer, or zero")}function P0(n){return e=>{if(e>n)throw new ur(`Value must be smaller than or equal to ${n}`)}}function U0(...n){return e=>{for(const t of n)t(e)}}const hi=U0(B0,O0,P0(65535)),Ue=-1;class M0{constructor(){f(this,"protocolsByCode",new Map);f(this,"protocolsByName",new Map)}getProtocol(e){let t;if(typeof e=="string"?t=this.protocolsByName.get(e):t=this.protocolsByCode.get(e),t==null)throw new ch(`Protocol ${e} was unknown`);return t}addProtocol(e){var t;this.protocolsByCode.set(e.code,e),this.protocolsByName.set(e.name,e),(t=e.aliases)==null||t.forEach(r=>{this.protocolsByName.set(r,e)})}removeProtocol(e){var r;const t=this.protocolsByCode.get(e);t!=null&&(this.protocolsByCode.delete(t.code),this.protocolsByName.delete(t.name),(r=t.aliases)==null||r.forEach(s=>{this.protocolsByName.delete(s)}))}}const Tt=new M0;[{code:pa,name:"ip4",size:32,valueToBytes:wh,bytesToValue:k0,validate:n=>{if(!li(n))throw new ur(`Invalid IPv4 address "${n}"`)}},{code:ya,name:"tcp",size:16,valueToBytes:hr,bytesToValue:rs,validate:hi},{code:ma,name:"udp",size:16,valueToBytes:hr,bytesToValue:rs,validate:hi},{code:Xw,name:"dccp",size:16,valueToBytes:hr,bytesToValue:rs,validate:hi},{code:ui,name:"ip6",size:128,valueToBytes:I0,bytesToValue:T0,stringToValue:C0,validate:n=>{if(!ga(n))throw new ur(`Invalid IPv6 address "${n}"`)}},{code:lh,name:"ip6zone",size:Ue},{code:Zw,name:"ipcidr",size:8,bytesToValue:ph("base10"),valueToBytes:yh("base10")},{code:uh,name:"dns",size:Ue,resolvable:!0},{code:hh,name:"dns4",size:Ue,resolvable:!0},{code:wa,name:"dns6",size:Ue,resolvable:!0},{code:fh,name:"dnsaddr",size:Ue,resolvable:!0},{code:Qw,name:"sctp",size:16,valueToBytes:hr,bytesToValue:rs,validate:hi},{code:Jw,name:"udt"},{code:e0,name:"utp"},{code:t0,name:"unix",size:Ue,path:!0,stringToValue:n=>decodeURIComponent(n),valueToString:n=>encodeURIComponent(n)},{code:dh,name:"p2p",aliases:["ipfs"],size:Ue,bytesToValue:ph("base58btc"),valueToBytes:n=>n.startsWith("Q")||n.startsWith("1")?yh("base58btc")(n):_e.parse(n).multihash.bytes},{code:n0,name:"onion",size:96,bytesToValue:mh,valueToBytes:x0},{code:r0,name:"onion3",size:296,bytesToValue:mh,valueToBytes:R0},{code:s0,name:"garlic64",size:Ue},{code:i0,name:"garlic32",size:Ue},{code:o0,name:"tls"},{code:a0,name:"sni",size:Ue},{code:c0,name:"noise"},{code:l0,name:"quic"},{code:u0,name:"quic-v1"},{code:h0,name:"webtransport"},{code:f0,name:"certhash",size:Ue,bytesToValue:D0(oo),valueToBytes:L0},{code:d0,name:"http"},{code:g0,name:"http-path",size:Ue,stringToValue:n=>`/${decodeURIComponent(n)}`,valueToString:n=>encodeURIComponent(n.substring(1))},{code:p0,name:"https"},{code:y0,name:"ws"},{code:m0,name:"wss"},{code:w0,name:"p2p-websocket-star"},{code:b0,name:"p2p-stardust"},{code:E0,name:"p2p-webrtc-star"},{code:v0,name:"p2p-webrtc-direct"},{code:_0,name:"webrtc-direct"},{code:A0,name:"webrtc"},{code:gh,name:"p2p-circuit"},{code:S0,name:"memory",size:Ue}].forEach(n=>{Tt.addProtocol(n)});function F0(n){var r;const e=[];let t=0;for(;t<n.length;){const s=js(n,t),i=Tt.getProtocol(s),o=ut(s),a=K0(i,n,t+o);let c=0;a>0&&i.size===Ue&&(c=ut(a));const l=o+c+a,u={code:s,name:i.name,bytes:n.subarray(t,t+l)};if(a>0){const h=t+o+c,g=n.subarray(h,h+a);u.value=((r=i.bytesToValue)==null?void 0:r.call(i,g))??j(g)}e.push(u),t+=l}return e}function V0(n){var r;let e=0;const t=[];for(const s of n){if(s.bytes==null){const i=Tt.getProtocol(s.code),o=ut(s.code);let a,c=0,l=0;s.value!=null&&(a=((r=i.valueToBytes)==null?void 0:r.call(i,s.value))??z(s.value),c=a.byteLength,i.size===Ue&&(l=ut(c)));const u=new Uint8Array(o+l+c);let h=0;Ys(s.code,u,h),h+=o,a!=null&&(i.size===Ue&&(Ys(c,u,h),h+=l),u.set(a,h)),s.bytes=u}t.push(s.bytes),e+=s.bytes.byteLength}return Pt(t,e)}function $0(n){var i;if(n.charAt(0)!=="/")throw new it('String multiaddr must start with "/"');const e=[];let t="protocol",r="",s="";for(let o=1;o<n.length;o++){const a=n.charAt(o);a!=="/"&&(t==="protocol"?s+=n.charAt(o):r+=n.charAt(o));const c=o===n.length-1;if(a==="/"||c){const l=Tt.getProtocol(s);if(t==="protocol"){if(l.size==null||l.size===0){e.push({code:l.code,name:l.name}),r="",s="",t="protocol";continue}else if(c)throw new it(`Component ${s} was missing value`);t="value"}else if(t==="value"){const u={code:l.code,name:l.name};if(l.size!=null&&l.size!==0){if(r==="")throw new it(`Component ${s} was missing value`);u.value=((i=l.stringToValue)==null?void 0:i.call(l,r))??r}e.push(u),r="",s="",t="protocol"}}}if(s!==""&&r!=="")throw new it("Incomplete multiaddr");return e}function H0(n){return`/${n.flatMap(e=>{var r;if(e.value==null)return e.name;const t=Tt.getProtocol(e.code);if(t==null)throw new it(`Unknown protocol code ${e.code}`);return[e.name,((r=t.valueToString)==null?void 0:r.call(t,e.value))??e.value]}).join("/")}`}function K0(n,e,t){return n.size==null||n.size===0?0:n.size>0?n.size/8:js(e,t)}const z0=Symbol.for("nodejs.util.inspect.custom"),bh=Symbol.for("@multiformats/multiaddr"),q0=[uh,hh,wa,fh];class G0 extends Error{constructor(e="No available resolver"){super(e),this.name="NoAvailableResolverError"}}function W0(n){if(n==null&&(n="/"),fi(n))return n.getComponents();if(n instanceof Uint8Array)return F0(n);if(typeof n=="string")return n=n.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),n===""&&(n="/"),$0(n);if(Array.isArray(n))return n;throw new it("Must be a string, Uint8Array, Component[], or another Multiaddr")}const _r=class _r{constructor(e="/",t={}){f(this,Vd,!0);ue(this,de);ue(this,Er);ue(this,vr);he(this,de,W0(e)),t.validate!==!1&&Y0(this)}get bytes(){return D(this,vr)==null&&he(this,vr,V0(D(this,de))),D(this,vr)}toString(){return D(this,Er)==null&&he(this,Er,H0(D(this,de))),D(this,Er)}toJSON(){return this.toString()}toOptions(){let e,t,r,s,i="";for(const{code:a,name:c,value:l}of D(this,de))a===lh&&(i=`%${l??""}`),q0.includes(a)&&(t="tcp",s=443,r=`${l??""}${i}`,e=a===wa?6:4),(a===ya||a===ma)&&(t=c==="tcp"?"tcp":"udp",s=parseInt(l??"")),(a===pa||a===ui)&&(t="tcp",r=`${l??""}${i}`,e=a===ui?6:4);if(e==null||t==null||r==null||s==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:s}}getComponents(){return[...D(this,de)]}protos(){return D(this,de).map(({code:e,value:t})=>{const r=Tt.getProtocol(e);return{code:e,size:r.size??0,name:r.name,resolvable:!!r.resolvable,path:!!r.path}})}protoCodes(){return D(this,de).map(({code:e})=>e)}protoNames(){return D(this,de).map(({name:e})=>e)}tuples(){return D(this,de).map(({code:e,value:t})=>{var i;if(t==null)return[e];const r=Tt.getProtocol(e),s=[e];return t!=null&&s.push(((i=r.valueToBytes)==null?void 0:i.call(r,t))??z(t)),s})}stringTuples(){return D(this,de).map(({code:e,value:t})=>t==null?[e]:[e,t])}encapsulate(e){const t=new _r(e);return new _r([...D(this,de),...t.getComponents()],{validate:!1})}decapsulate(e){const t=e.toString(),r=this.toString(),s=r.lastIndexOf(t);if(s<0)throw new ah(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new _r(r.slice(0,s),{validate:!1})}decapsulateCode(e){let t;for(let r=D(this,de).length-1;r>-1;r--)if(D(this,de)[r].code===e){t=r;break}return new _r(D(this,de).slice(0,t),{validate:!1})}getPeerId(){try{let e=[];D(this,de).forEach(({code:r,value:s})=>{r===dh&&e.push([r,s]),r===gh&&(e=[])});const t=e.pop();if((t==null?void 0:t[1])!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?j(Ve.decode(`z${r}`),"base58btc"):j(_e.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){for(const e of D(this,de))if(Tt.getProtocol(e.code).path)return e.value??null;return null}equals(e){return $e(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(i=>i.resolvable);if(t==null)return[this];const r=va.get(t.name);if(r==null)throw new G0(`no available resolver for ${t.name}`);return(await r(this,e)).map(i=>xe(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(){return!(D(this,de).length!==2||D(this,de)[0].code!==pa&&D(this,de)[0].code!==ui||D(this,de)[1].code!==ya&&D(this,de)[1].code!==ma)}[(Vd=bh,z0)](){return`Multiaddr(${this.toString()})`}};de=new WeakMap,Er=new WeakMap,vr=new WeakMap;let Ea=_r;function Y0(n){n.getComponents().forEach(e=>{var r;const t=Tt.getProtocol(e.code);e.value!=null&&((r=t.validate)==null||r.call(t,e.value))})}const va=new Map;function fi(n){return!!(n!=null&&n[bh])}function xe(n){return new Ea(n)}function j0(n){const e=Tt.getProtocol(n);return{code:e.code,size:e.size??0,name:e.name,resolvable:!!e.resolvable,path:!!e.path}}const X0="libp2p-peer-record",Z0=Uint8Array.from([3,1]);var di;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=tt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i)=>{const o={multiaddr:new Uint8Array(0)},a=i==null?s.len:s.pos+i;for(;s.pos<a;){const c=s.uint32();switch(c>>>3){case 1:o.multiaddr=s.bytes();break;default:s.skipType(c&7);break}}return o})),r),t.encode=s=>et(s,t.codec()),t.decode=s=>Je(s,t.codec())})(n.AddressInfo||(n.AddressInfo={}));let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.peerId!=null&&t.peerId.byteLength>0&&(r.uint32(10),r.bytes(t.peerId)),t.seq!=null&&t.seq!==0n&&(r.uint32(16),r.uint64(t.seq)),t.addresses!=null)for(const i of t.addresses)r.uint32(26),n.AddressInfo.codec().encode(i,r);s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={peerId:new Uint8Array(0),seq:0n,addresses:[]},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.peerId=t.bytes();break;case 2:s.seq=t.uint64();break;case 3:s.addresses.push(n.AddressInfo.codec().decode(t,t.uint32()));break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(di||(di={}));const jt=class jt{constructor(e){f(this,"peerId");f(this,"multiaddrs");f(this,"seqNumber");f(this,"domain",jt.DOMAIN);f(this,"codec",jt.CODEC);f(this,"marshaled");const{peerId:t,multiaddrs:r,seqNumber:s}=e;this.peerId=t,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=di.encode({peerId:this.peerId.toBytes(),seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(e=>({multiaddr:e.bytes}))})),this.marshaled}equals(e){return!(!(e instanceof jt)||!this.peerId.equals(e.peerId)||this.seqNumber!==e.seqNumber||!zw(this.multiaddrs,e.multiaddrs))}};f(jt,"createFromProtobuf",e=>{const t=di.decode(e),r=ua(t.peerId),s=(t.addresses??[]).map(o=>xe(o.multiaddr)),i=t.seq;return new jt({peerId:r,multiaddrs:s,seqNumber:i})}),f(jt,"DOMAIN",X0),f(jt,"CODEC",Z0);let Kt=jt;function Q0(n){return n[Symbol.asyncIterator]!=null}function _a(n){if(Q0(n))return(async()=>{const t=[];for await(const r of n)t.push(r);return t})();const e=[];for(const t of n)e.push(t);return e}let fr=(ac=class extends Error{constructor(t="The operation was aborted",...r){super(t,...r);f(this,"name","AbortError")}},f(ac,"name","AbortError"),ac);function ye(){const n={};return n.promise=new Promise((e,t)=>{n.resolve=e,n.reject=t}),n}class Eh{constructor(e){f(this,"buffer");f(this,"mask");f(this,"top");f(this,"btm");f(this,"next");if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class Aa{constructor(e={}){f(this,"size");f(this,"hwm");f(this,"head");f(this,"tail");this.hwm=e.splitLimit??16,this.head=new Eh(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Eh(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const t=this.tail.next;this.tail.next=null,this.tail=t,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}let J0=class extends Error{constructor(t,r){super(t??"The operation was aborted");f(this,"type");f(this,"code");this.type="aborted",this.code=r??"ABORT_ERR"}};function ss(n={}){return eb(t=>{const r=t.shift();if(r==null)return{done:!0};if(r.error!=null)throw r.error;return{done:r.done===!0,value:r.value}},n)}function eb(n,e){e=e??{};let t=e.onEnd,r=new Aa,s,i,o,a=ye();const c=async()=>{try{return r.isEmpty()?o?{done:!0}:await new Promise((p,b)=>{i=v=>{i=null,r.push(v);try{p(n(r))}catch(w){b(w)}return s}}):n(r)}finally{r.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=ye()})}},l=p=>i!=null?i(p):(r.push(p),s),u=p=>(r=new Aa,i!=null?i({error:p}):(r.push({error:p}),s)),h=p=>{if(o)return s;if((e==null?void 0:e.objectMode)!==!0&&(p==null?void 0:p.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:p})},g=p=>o?s:(o=!0,p!=null?u(p):l({done:!0})),y=()=>(r=new Aa,g(),{done:!0}),m=p=>(g(p),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:y,throw:m,push:h,end:g,get readableLength(){return r.size},onEmpty:async p=>{const b=p==null?void 0:p.signal;if(b==null||b.throwIfAborted(),r.isEmpty())return;let v,w;b!=null&&(v=new Promise((E,A)=>{w=()=>{A(new J0)},b.addEventListener("abort",w)}));try{await Promise.race([a.promise,v])}finally{w!=null&&b!=null&&(b==null||b.removeEventListener("abort",w))}}},t==null)return s;const d=s;return s={[Symbol.asyncIterator](){return this},next(){return d.next()},throw(p){return d.throw(p),t!=null&&(t(p),t=void 0),{done:!0}},return(){return d.return(),t!=null&&(t(),t=void 0),{done:!0}},push:h,end(p){return d.end(p),t!=null&&(t(p),t=void 0),s},get readableLength(){return d.readableLength},onEmpty:p=>d.onEmpty(p)},s}function rA(){}class vh extends EventTarget{constructor(){super();ue(this,Dt,new Map)}listenerCount(t){const r=D(this,Dt).get(t);return r==null?0:r.length}addEventListener(t,r,s){super.addEventListener(t,r,s);let i=D(this,Dt).get(t);i==null&&(i=[],D(this,Dt).set(t,i)),i.push({callback:r,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(t,r,s){super.removeEventListener(t.toString(),r??null,s);let i=D(this,Dt).get(t);i!=null&&(i=i.filter(({callback:o})=>o!==r),D(this,Dt).set(t,i))}dispatchEvent(t){const r=super.dispatchEvent(t);let s=D(this,Dt).get(t.type);return s==null||(s=s.filter(({once:i})=>!i),D(this,Dt).set(t.type,s)),r}safeDispatchEvent(t,r={}){return this.dispatchEvent(new CustomEvent(t,r))}}Dt=new WeakMap;async function Bn(n,e,t,r){const s=new fr(r==null?void 0:r.errorMessage);(r==null?void 0:r.errorCode)!=null&&(s.code=r.errorCode);const i=(r==null?void 0:r.errorEvent)??"error";return(t==null?void 0:t.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){xa(t,"abort",h),xa(n,e,l),xa(n,i,u)}const l=g=>{var y;try{if(((y=r==null?void 0:r.filter)==null?void 0:y.call(r,g))===!1)return}catch(m){c(),a(m);return}c(),o(g)},u=g=>{if(c(),g instanceof Error){a(g);return}a(g.detail??(r==null?void 0:r.error)??new Error(`The "${r==null?void 0:r.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};Sa(t,"abort",h),Sa(n,e,l),Sa(n,i,u)})}function Sa(n,e,t){n!=null&&(_h(n)?n.addEventListener(e,t):n.addListener(e,t))}function xa(n,e,t){n!=null&&(_h(n)?n.removeEventListener(e,t):n.removeListener(e,t))}function _h(n){return typeof n.addEventListener=="function"&&typeof n.removeEventListener=="function"}class Ah extends Error{constructor(e="The queue was full"){super(e),this.name="QueueFullError"}}f(Ah,"name","QueueFullError");let Sh=class extends Error{constructor(t,r,s){super(t??"The operation was aborted");f(this,"type");f(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=r??"ABORT_ERR"}};async function Ct(n,e,t){if(e==null)return n;if(e.aborted)return n.catch(()=>{}),Promise.reject(new Sh(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName));let r;const s=new Sh(t==null?void 0:t.errorMessage,t==null?void 0:t.errorCode,t==null?void 0:t.errorName);try{return await Promise.race([n,new Promise((i,o)=>{r=()=>{o(s)},e.addEventListener("abort",r)})])}finally{r!=null&&e.removeEventListener("abort",r)}}let tb=class{constructor(e){f(this,"deferred");f(this,"signal");var t;this.signal=e,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new fr)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}};function nb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let rb=class{constructor(e,t){f(this,"id");f(this,"fn");f(this,"options");f(this,"recipients");f(this,"status");f(this,"timeline");f(this,"controller");this.id=nb(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>{var s;return t&&((s=r.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new fr),this.cleanup())}async join(e={}){var r;const t=new tb(e.signal);return this.recipients.push(t),(r=e.signal)==null||r.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Ct(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}};function xh(n,e){let t;const r=function(){const s=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(s,e)};return r.start=()=>{},r.stop=()=>{clearTimeout(t)},r}let Rh=class extends vh{constructor(t={}){super();f(this,"concurrency");f(this,"maxSize");f(this,"queue");f(this,"pending");f(this,"sort");f(this,"autoStart");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=xh(this.emitEmpty.bind(this),1),this.emitIdle=xh(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const r of this.queue)if(r.status==="queued"){t=r;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let r=0;r<this.queue.length;r++)if(this.queue[r]===t){this.queue.splice(r,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,r){var i;if((i=r==null?void 0:r.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Ah;const s=new rb(t,r);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(r).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new fr)}),this.clear()}async onEmpty(t){this.size!==0&&await Bn(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,r){this.size<t||await Bn(this,"next",r==null?void 0:r.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Bn(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,h;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const r=ss({objectMode:!0}),s=g=>{g!=null?this.abort():this.clear(),r.end(g)},i=g=>{g.detail!=null&&r.push(g.detail.result)},o=g=>{s(g.detail.error)},a=()=>{s()},c=()=>{s(new fr("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*r}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),s()}}};const Ih="lock:worker:request-read",kh="lock:worker:abort-read-request",Th="lock:worker:release-read",Ch="lock:master:grant-read",Nh="lock:master:error-read",Lh="lock:worker:request-write",Dh="lock:worker:abort-write-request",Bh="lock:worker:release-write",Oh="lock:master:grant-write",Ph="lock:master:error-write",Uh="lock:worker:finalize",Mh="mortice",sb={singleProcess:!1},Fh=(n,e,t,r,s,i,o,a,c)=>l=>{if(l.data==null)return;const u={type:l.data.type,name:l.data.name,identifier:l.data.identifier};u.type===s&&n.safeDispatchEvent(t,{detail:{name:u.name,identifier:u.identifier,handler:async()=>{e.postMessage({type:c,name:u.name,identifier:u.identifier}),await new Promise(h=>{const g=y=>{if((y==null?void 0:y.data)==null)return;const m={type:y.data.type,name:y.data.name,identifier:y.data.identifier};m.type===a&&m.identifier===u.identifier&&(e.removeEventListener("message",g),h())};e.addEventListener("message",g)})},onError:h=>{e.postMessage({type:o,name:u.name,identifier:u.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),u.type===i&&n.safeDispatchEvent(r,{detail:{name:u.name,identifier:u.identifier}}),u.type===Uh&&n.safeDispatchEvent("finalizeRequest",{detail:{name:u.name}})},ib=(n=10)=>Math.random().toString().substring(2,n+2);class ob{constructor(e){f(this,"name");f(this,"channel");this.name=e,this.channel=new BroadcastChannel(Mh)}readLock(e){return this.sendRequest(Ih,kh,Ch,Nh,Th,e)}writeLock(e){return this.sendRequest(Lh,Dh,Oh,Ph,Bh,e)}finalize(){this.channel.postMessage({type:Uh,name:this.name}),this.channel.close()}async sendRequest(e,t,r,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=ib();return this.channel.postMessage({type:e,identifier:a,name:this.name}),new Promise((l,u)=>{var y;const h=()=>{this.channel.postMessage({type:t,identifier:a,name:this.name})};(y=o==null?void 0:o.signal)==null||y.addEventListener("abort",h,{once:!0});const g=m=>{var d,p,b,v;if(((d=m.data)==null?void 0:d.identifier)===a&&(((p=m.data)==null?void 0:p.type)===r&&(this.channel.removeEventListener("message",g),(b=o==null?void 0:o.signal)==null||b.removeEventListener("abort",h),l(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),m.data.type===s)){this.channel.removeEventListener("message",g),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const w=new Error;m.data.error!=null&&(w.message=m.data.error.message,w.name=m.data.error.name,w.stack=m.data.error.stack),u(w)}};this.channel.addEventListener("message",g)})}}const ab=n=>{if(n=Object.assign({},sb,n),!!globalThis.document||n.singleProcess){const t=new BroadcastChannel(Mh),r=new vh;return t.addEventListener("message",Fh(r,t,"requestReadLock","abortReadLockRequest",Ih,kh,Nh,Th,Ch)),t.addEventListener("message",Fh(r,t,"requestWriteLock","abortWriteLockRequest",Lh,Dh,Ph,Bh,Oh)),r}return new ob(n.name)},On=new Map;let is;function Vh(n){return typeof(n==null?void 0:n.readLock)=="function"&&typeof(n==null?void 0:n.writeLock)=="function"}function cb(n){if(is==null&&(is=ab(n),!Vh(is))){const e=is;e.addEventListener("requestReadLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=On.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortReadLockRequest",a)})}),e.addEventListener("requestWriteLock",t=>{const r=t.detail.name,s=t.detail.identifier,i=On.get(r);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==r||c.detail.identifier!==s||o.abort()};e.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await t.detail.handler().finally(()=>{c()})}).catch(c=>{t.detail.onError(c)}).finally(()=>{e.removeEventListener("abortWriteLockRequest",a)})}),e.addEventListener("finalizeRequest",t=>{const r=t.detail.name,s=On.get(r);s!=null&&s.finalize()})}return is}async function Ra(n,e){var o;let t,r;const s=new Promise((a,c)=>{t=a,r=c}),i=()=>{r(new fr)};return(o=e==null?void 0:e.signal)==null||o.addEventListener("abort",i,{once:!0}),n.add(async()=>{await new Promise(a=>{t(()=>{var c;(c=e==null?void 0:e.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:e==null?void 0:e.signal}).catch(a=>{r(a)}),s}const lb=(n,e)=>{let t=On.get(n);if(t!=null)return t;const r=cb(e);if(Vh(r))return t=r,On.set(n,t),t;const s=new Rh({concurrency:1});let i;return t={async readLock(o){if(i!=null)return Ra(i,o);i=new Rh({concurrency:e.concurrency,autoStart:!1});const a=i,c=Ra(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Ra(s,o)},finalize:()=>{On.delete(n)},queue:s},On.set(n,t),e.autoFinalize===!0&&s.addEventListener("idle",()=>{t.finalize()},{once:!0}),t},ub={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function hb(n){const e=Object.assign({},ub,n);return lb(e.name,e)}const ot={ERR_INVALID_PARAMETERS:"ERR_INVALID_PARAMETERS"};var gi;(function(n){(function(t){let r;t.codec=()=>(r==null&&(r=tt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i)=>{const o={key:"",value:new Uint8Array(0)},a=i==null?s.len:s.pos+i;for(;s.pos<a;){const c=s.uint32();switch(c>>>3){case 1:o.key=s.string();break;case 2:o.value=s.bytes();break;default:s.skipType(c&7);break}}return o})),r),t.encode=s=>et(s,t.codec()),t.decode=s=>Je(s,t.codec())})(n.Peer$metadataEntry||(n.Peer$metadataEntry={})),function(t){let r;t.codec=()=>(r==null&&(r=tt((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),yi.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i)=>{const o={key:""},a=i==null?s.len:s.pos+i;for(;s.pos<a;){const c=s.uint32();switch(c>>>3){case 1:o.key=s.string();break;case 2:o.value=yi.codec().decode(s,s.uint32());break;default:s.skipType(c&7);break}}return o})),r),t.encode=s=>et(s,t.codec()),t.decode=s=>Je(s,t.codec())}(n.Peer$tagsEntry||(n.Peer$tagsEntry={}));let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.addresses!=null)for(const i of t.addresses)r.uint32(10),pi.codec().encode(i,r);if(t.protocols!=null)for(const i of t.protocols)r.uint32(18),r.string(i);if(t.publicKey!=null&&(r.uint32(34),r.bytes(t.publicKey)),t.peerRecordEnvelope!=null&&(r.uint32(42),r.bytes(t.peerRecordEnvelope)),t.metadata!=null&&t.metadata.size!==0)for(const[i,o]of t.metadata.entries())r.uint32(50),n.Peer$metadataEntry.codec().encode({key:i,value:o},r);if(t.tags!=null&&t.tags.size!==0)for(const[i,o]of t.tags.entries())r.uint32(58),n.Peer$tagsEntry.codec().encode({key:i,value:o},r);s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={addresses:[],protocols:[],metadata:new Map,tags:new Map},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.addresses.push(pi.codec().decode(t,t.uint32()));break;case 2:s.protocols.push(t.string());break;case 4:s.publicKey=t.bytes();break;case 5:s.peerRecordEnvelope=t.bytes();break;case 6:{const a=n.Peer$metadataEntry.codec().decode(t,t.uint32());s.metadata.set(a.key,a.value);break}case 7:{const a=n.Peer$tagsEntry.codec().decode(t,t.uint32());s.tags.set(a.key,a.value);break}default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(gi||(gi={}));var pi;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.multiaddr!=null&&t.multiaddr.byteLength>0&&(r.uint32(10),r.bytes(t.multiaddr)),t.isCertified!=null&&(r.uint32(16),r.bool(t.isCertified)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={multiaddr:new Uint8Array(0)},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.multiaddr=t.bytes();break;case 2:s.isCertified=t.bool();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(pi||(pi={}));var yi;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.value!=null&&t.value!==0&&(r.uint32(8),r.uint32(t.value)),t.expiry!=null&&(r.uint32(16),r.uint64(t.expiry)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={value:0},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:s.value=t.uint32();break;case 2:s.expiry=t.uint64();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(yi||(yi={}));function os(n,e){const t=gi.decode(e);t.publicKey!=null&&n.publicKey==null&&(n=Tw({...n,publicKey:n.publicKey}));const r=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||r.set(i,o);return{...t,id:n,addresses:t.addresses.map(({multiaddr:i,isCertified:o})=>({multiaddr:xe(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:r}}const zt="/",$h=new TextEncoder().encode(zt),mi=$h[0];class Ge{constructor(e,t){f(this,"_buf");if(typeof e=="string")this._buf=z(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==mi)throw new Error("Invalid key")}toString(e="utf8"){return j(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Ge(e.join(zt))}static random(){return new Ge(Math.random().toString().substring(2))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Ge(e):typeof e.uint8Array=="function"?new Ge(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=$h),this._buf[0]!==mi){const e=new Uint8Array(this._buf.byteLength+1);e.fill(mi,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===mi;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),r=e.list();for(let s=0;s<t.length;s++){if(r.length<s+1)return!1;const i=t[s],o=r[s];if(i<o)return!0;if(i>o)return!1}return t.length<r.length}reverse(){return Ge.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(zt).slice(1)}type(){return fb(this.baseNamespace())}name(){return db(this.baseNamespace())}instance(e){return new Ge(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(zt)||(e+=zt),e+=this.type(),new Ge(e)}parent(){const e=this.list();return e.length===1?new Ge(zt):new Ge(e.slice(0,-1).join(zt))}child(e){return this.toString()===zt?e:e.toString()===zt?this:new Ge(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Ge.withNamespaces([...this.namespaces(),...gb(e.map(t=>t.namespaces()))])}}function fb(n){const e=n.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function db(n){const e=n.split(":");return e[e.length-1]}function gb(n){return[].concat(...n)}const Hh="/peers/";function as(n){if(!fc(n)||n.type==null)throw new R("Invalid PeerId",ot.ERR_INVALID_PARAMETERS);const e=n.toCID().toString();return new Ge(`${Hh}${e}`)}async function pb(n,e,t){const r=new Map;for(const s of t){if(s==null)continue;if(s.multiaddr instanceof Uint8Array&&(s.multiaddr=xe(s.multiaddr)),!fi(s.multiaddr))throw new R("Multiaddr was invalid",ot.ERR_INVALID_PARAMETERS);if(!await e(n,s.multiaddr))continue;const i=s.isCertified??!1,o=s.multiaddr.toString(),a=r.get(o);a!=null?s.isCertified=a.isCertified||i:r.set(o,{multiaddr:s.multiaddr,isCertified:i})}return[...r.values()].sort((s,i)=>s.multiaddr.toString().localeCompare(i.multiaddr.toString())).map(({isCertified:s,multiaddr:i})=>({isCertified:s,multiaddr:i.bytes}))}async function Ia(n,e,t,r){if(e==null)throw new R("Invalid PeerData",ot.ERR_INVALID_PARAMETERS);if(e.publicKey!=null&&n.publicKey!=null&&!$e(e.publicKey,n.publicKey))throw new R("publicKey bytes do not match peer id publicKey bytes",ot.ERR_INVALID_PARAMETERS);const s=r.existingPeer;if(s!=null&&!n.equals(s.id))throw new R("peer id did not match existing peer id",ot.ERR_INVALID_PARAMETERS);let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,l=s==null?void 0:s.peerRecordEnvelope;if(t==="patch"){if((e.multiaddrs!=null||e.addresses!=null)&&(i=[],e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses)),e.protocols!=null&&(o=new Set(e.protocols)),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);a=wi(h,{validate:Kh})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags);c=wi(h,{validate:zh,map:qh})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}if(t==="merge"){if(e.multiaddrs!=null&&i.push(...e.multiaddrs.map(h=>({isCertified:!1,multiaddr:h}))),e.addresses!=null&&i.push(...e.addresses),e.protocols!=null&&(o=new Set([...o,...e.protocols])),e.metadata!=null){const h=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[g,y]of h)y==null?a.delete(g):a.set(g,y);a=wi([...a.entries()],{validate:Kh})}if(e.tags!=null){const h=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),g=new Map(c);for(const[y,m]of h)m==null?g.delete(y):g.set(y,m);c=wi([...g.entries()],{validate:zh,map:qh})}e.peerRecordEnvelope!=null&&(l=e.peerRecordEnvelope)}const u={addresses:await pb(n,r.addressFilter??(async()=>!0),i),protocols:[...o.values()].sort((h,g)=>h.localeCompare(g)),metadata:a,tags:c,publicKey:(s==null?void 0:s.id.publicKey)??e.publicKey??n.publicKey,peerRecordEnvelope:l};return n.type!=="RSA"&&delete u.publicKey,u}function wi(n,e){var r;const t=new Map;for(const[s,i]of n)i!=null&&e.validate(s,i);for(const[s,i]of n.sort(([o],[a])=>o.localeCompare(a)))i!=null&&t.set(s,((r=e.map)==null?void 0:r.call(e,s,i))??i);return t}function Kh(n,e){if(typeof n!="string")throw new R("Metadata key must be a string",ot.ERR_INVALID_PARAMETERS);if(!(e instanceof Uint8Array))throw new R("Metadata value must be a Uint8Array",ot.ERR_INVALID_PARAMETERS)}function zh(n,e){if(typeof n!="string")throw new R("Tag name must be a string",ot.ERR_INVALID_PARAMETERS);if(e.value!=null){if(parseInt(`${e.value}`,10)!==e.value)throw new R("Tag value must be an integer",ot.ERR_INVALID_PARAMETERS);if(e.value<0||e.value>100)throw new R("Tag value must be between 0-100",ot.ERR_INVALID_PARAMETERS)}if(e.ttl!=null){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new R("Tag ttl must be an integer",ot.ERR_INVALID_PARAMETERS);if(e.ttl<0)throw new R("Tag ttl must be between greater than 0",ot.ERR_INVALID_PARAMETERS)}}function qh(n,e){let t;return e.expiry!=null&&(t=e.expiry),e.ttl!=null&&(t=BigInt(Date.now()+Number(e.ttl))),{value:e.value??0,expiry:t}}function bi(n,e,t){const r=n.toString().split("/")[2],s=Qt.decode(r),i=ua(s),o=t.get(i);if(o!=null)return o;const a=os(i,e);return t.set(i,a),a}function yb(n,e){return n==null?{}:{prefix:Hh,filters:(n.filters??[]).map(t=>({key:r,value:s})=>t(bi(r,s,e))),orders:(n.orders??[]).map(t=>(r,s)=>t(bi(r.key,r.value,e),bi(s.key,s.value,e)))}}class mb{constructor(e,t={}){ue(this,Bt);f(this,"peerId");f(this,"datastore");f(this,"lock");f(this,"addressFilter");this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=t.addressFilter,this.lock=hb({name:"peer-store",singleProcess:!0})}async has(e){return this.datastore.has(as(e))}async delete(e){if(this.peerId.equals(e))throw new R("Cannot delete self peer",ot.ERR_INVALID_PARAMETERS);await this.datastore.delete(as(e))}async load(e){const t=await this.datastore.get(as(e));return os(e,t)}async save(e,t){const{existingBuf:r,existingPeer:s}=await ie(this,Bt,Yi).call(this,e),i=await Ia(e,t,"patch",{addressFilter:this.addressFilter});return ie(this,Bt,ji).call(this,e,i,r,s)}async patch(e,t){const{existingBuf:r,existingPeer:s}=await ie(this,Bt,Yi).call(this,e),i=await Ia(e,t,"patch",{addressFilter:this.addressFilter,existingPeer:s});return ie(this,Bt,ji).call(this,e,i,r,s)}async merge(e,t){const{existingBuf:r,existingPeer:s}=await ie(this,Bt,Yi).call(this,e),i=await Ia(e,t,"merge",{addressFilter:this.addressFilter,existingPeer:s});return ie(this,Bt,ji).call(this,e,i,r,s)}async*all(e){const t=new ts;for await(const{key:r,value:s}of this.datastore.query(yb(e??{},t))){const i=bi(r,s,t);i.id.equals(this.peerId)||(yield i)}}}Bt=new WeakSet,Yi=async function(e){try{const t=await this.datastore.get(as(e)),r=os(e,t);return{existingBuf:t,existingPeer:r}}catch(t){if(t.code!=="ERR_NOT_FOUND")throw t}return{}},ji=async function(e,t,r,s){const i=gi.encode(t);return r!=null&&$e(i,r)?{peer:os(e,i),previous:s,updated:!1}:(await this.datastore.put(as(e),i),{peer:os(e,i),previous:s,updated:!0})},$d=Symbol.toStringTag;class wb{constructor(e,t={}){ue(this,Ar);f(this,"store");f(this,"events");f(this,"peerId");f(this,"log");f(this,$d,"@libp2p/peer-store");this.log=e.logger.forComponent("libp2p:peer-store"),this.events=e.events,this.peerId=e.peerId,this.store=new mb(e,t)}async forEach(e,t){this.log.trace("forEach await read lock");const r=await this.store.lock.readLock();this.log.trace("forEach got read lock");try{for await(const s of this.store.all(t))e(s)}finally{this.log.trace("forEach release read lock"),r()}}async all(e){this.log.trace("all await read lock");const t=await this.store.lock.readLock();this.log.trace("all got read lock");try{return await _a(this.store.all(e))}finally{this.log.trace("all release read lock"),t()}}async delete(e){this.log.trace("delete await write lock");const t=await this.store.lock.writeLock();this.log.trace("delete got write lock");try{await this.store.delete(e)}finally{this.log.trace("delete release write lock"),t()}}async has(e){this.log.trace("has await read lock");const t=await this.store.lock.readLock();this.log.trace("has got read lock");try{return await this.store.has(e)}finally{this.log.trace("has release read lock"),t()}}async get(e){this.log.trace("get await read lock");const t=await this.store.lock.readLock();this.log.trace("get got read lock");try{return await this.store.load(e)}finally{this.log.trace("get release read lock"),t()}}async save(e,t){this.log.trace("save await write lock");const r=await this.store.lock.writeLock();this.log.trace("save got write lock");try{const s=await this.store.save(e,t);return ie(this,Ar,Xi).call(this,e,s),s.peer}finally{this.log.trace("save release write lock"),r()}}async patch(e,t){this.log.trace("patch await write lock");const r=await this.store.lock.writeLock();this.log.trace("patch got write lock");try{const s=await this.store.patch(e,t);return ie(this,Ar,Xi).call(this,e,s),s.peer}finally{this.log.trace("patch release write lock"),r()}}async merge(e,t){this.log.trace("merge await write lock");const r=await this.store.lock.writeLock();this.log.trace("merge got write lock");try{const s=await this.store.merge(e,t);return ie(this,Ar,Xi).call(this,e,s),s.peer}finally{this.log.trace("merge release write lock"),r()}}async consumePeerRecord(e,t){const r=await Dn.openAndCertify(e,Kt.DOMAIN);if((t==null?void 0:t.equals(r.peerId))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",t,r.peerId),!1;const s=Kt.createFromProtobuf(r.payload);let i;try{i=await this.get(r.peerId)}catch(o){if(o.code!=="ERR_NOT_FOUND")throw o}if((i==null?void 0:i.peerRecordEnvelope)!=null){const o=await Dn.createFromProtobuf(i.peerRecordEnvelope),a=Kt.createFromProtobuf(o.payload);if(a.seqNumber>=s.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",a.seqNumber,s.seqNumber),!1}return await this.patch(s.peerId,{peerRecordEnvelope:e,addresses:s.multiaddrs.map(o=>({isCertified:!0,multiaddr:o}))}),!0}}Ar=new WeakSet,Xi=function(e,t){t.updated&&(this.peerId.equals(e)?this.events.safeDispatchEvent("self:peer:update",{detail:t}):this.events.safeDispatchEvent("peer:update",{detail:t}))};function bb(n){return n[Symbol.asyncIterator]!=null}function Gh(n){if(bb(n))return(async()=>{for await(const e of n);})();for(const e of n);}function Wh(n){const[e,t]=n[Symbol.asyncIterator]!=null?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>e.next(),push:s=>{r.push(s)},next:()=>r.length>0?{done:!1,value:r.shift()}:e.next(),[t](){return this}}}function Eb(n){return n[Symbol.asyncIterator]!=null}function dr(n,e){let t=0;if(Eb(n))return async function*(){for await(const c of n)await e(c,t++)&&(yield c)}();const r=Wh(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of r)await e(c,t++)&&(yield c)}();const a=e;return function*(){o===!0&&(yield s);for(const c of r)a(c,t++)&&(yield c)}()}function vb(n){return n[Symbol.asyncIterator]!=null}function Yh(n,e){return vb(n)?async function*(){yield*(await _a(n)).sort(e)}():function*(){yield*_a(n).sort(e)}()}function _b(n){return n[Symbol.asyncIterator]!=null}function jh(n,e){return _b(n)?async function*(){let t=0;if(!(e<1)){for await(const r of n)if(yield r,t++,t===e)return}}():function*(){let t=0;if(!(e<1)){for(const r of n)if(yield r,t++,t===e)return}}()}class Ab{put(e,t,r){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(const{key:r,value:s}of e)await this.put(r,s,t),yield r}async*getMany(e,t={}){for await(const r of e)yield{key:r,value:await this.get(r,t)}}async*deleteMany(e,t={}){for await(const r of e)await this.delete(r,t),yield r}batch(){let e=[],t=[];return{put(r,s){e.push({key:r,value:s})},delete(r){t.push(r)},commit:async r=>{await Gh(this.putMany(e,r)),e=[],await Gh(this.deleteMany(t,r)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let r=this._all(e,t);if(e.prefix!=null){const s=e.prefix;r=dr(r,i=>i.key.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>dr(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Yh(s,i),r)),e.offset!=null){let s=0;const i=e.offset;r=dr(r,()=>s++>=i)}return e.limit!=null&&(r=jh(r,e.limit)),r}queryKeys(e,t){let r=this._allKeys(e,t);if(e.prefix!=null){const s=e.prefix;r=dr(r,i=>i.toString().startsWith(s))}if(Array.isArray(e.filters)&&(r=e.filters.reduce((s,i)=>dr(s,i),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((s,i)=>Yh(s,i),r)),e.offset!=null){const s=e.offset;let i=0;r=dr(r,()=>i++>=s)}return e.limit!=null&&(r=jh(r,e.limit)),r}}function Xh(n,e){for(const t in e)Object.defineProperty(n,t,{value:e[t],enumerable:!0,configurable:!0});return n}function Sb(n,e,t){if(!n||typeof n=="string")throw new TypeError("Please pass an Error to err-code");t||(t={}),typeof e=="object"&&(t=e,e=""),e&&(t.code=e);try{return Xh(n,t)}catch{t.message=n.message,t.stack=n.stack;const s=function(){};return s.prototype=Object.create(Object.getPrototypeOf(n)),Xh(new s,t)}}var xb=Sb;const Rb=ns(xb);function Ib(n){return n=n??new Error("Not Found"),Rb(n,"ERR_NOT_FOUND")}class kb extends Ab{constructor(){super();f(this,"data");this.data=new Map}put(t,r){return this.data.set(t.toString(),r),t}get(t){const r=this.data.get(t.toString());if(r==null)throw Ib();return r}has(t){return this.data.has(t.toString())}delete(t){this.data.delete(t.toString())}*_all(){for(const[t,r]of this.data.entries())yield{key:new Ge(t),value:r}}*_allKeys(){for(const t of this.data.keys())yield new Ge(t)}}function Tb(n,e){let t;return function(){const r=function(){t=void 0,n()};clearTimeout(t),t=setTimeout(r,e)}}const Cb=n=>n;function ka(n,e){const t=n.getPeerId();return t!=null&&st(t).equals(e)&&(n=n.decapsulate(xe(`/p2p/${e.toString()}`))),n}Hd=Symbol.toStringTag;class Nb{constructor(e,t={}){f(this,"log");f(this,"components");f(this,"listen");f(this,"announce");f(this,"observed");f(this,"announceFilter");f(this,Hd,"@libp2p/address-manager");const{listen:r=[],announce:s=[]}=t;this.components=e,this.log=e.logger.forComponent("libp2p:address-manager"),this.listen=r.map(i=>i.toString()),this.announce=new Set(s.map(i=>i.toString())),this.observed=new Map,this.announceFilter=t.announceFilter??Cb,this._updatePeerStoreAddresses=Tb(this._updatePeerStoreAddresses.bind(this),1e3),e.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),e.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const e=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([t,r])=>r.confident).map(([t])=>xe(t))).map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:e}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(e=>xe(e))}getAnnounceAddrs(){return Array.from(this.announce).map(e=>xe(e))}getObservedAddrs(){return Array.from(this.observed).map(([e])=>xe(e))}addObservedAddr(e){e=ka(e,this.components.peerId);const t=e.toString();this.observed.has(t)||this.observed.set(t,{confident:!1})}confirmObservedAddr(e){e=ka(e,this.components.peerId);const t=e.toString(),s=(this.observed.get(t)??{confident:!1}).confident;this.observed.set(t,{confident:!0}),s||this._updatePeerStoreAddresses()}removeObservedAddr(e){e=ka(e,this.components.peerId);const t=e.toString();this.observed.delete(t)}getAddresses(){let e=this.getAnnounceAddrs().map(r=>r.toString());e.length===0&&(e=this.components.transportManager.getAddrs().map(r=>r.toString())),e=e.concat(Array.from(this.observed).filter(([r,s])=>s.confident).map(([r])=>r));const t=new Set(e);return this.announceFilter(Array.from(t).map(r=>xe(r))).map(r=>{var s;return((s=r.protos().pop())==null?void 0:s.path)===!0||r.getPeerId()===this.components.peerId.toString()?r:r.encapsulate(`/p2p/${this.components.peerId.toString()}`)})}}class Lb{constructor(e={}){f(this,"components",{});f(this,"_started",!1);this.components={};for(const[t,r]of Object.entries(e))this.components[t]=r;this.components.logger==null&&(this.components.logger=ju())}isStarted(){return this._started}async _invokeStartableMethod(e){await Promise.all(Object.values(this.components).filter(t=>yg(t)).map(async t=>{var r;await((r=t[e])==null?void 0:r.call(t))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Db=["metrics","connectionProtector","dns"],Bb=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Ob(n={}){const e=new Lb(n);return new Proxy(e,{get(r,s,i){if(typeof s=="string"&&!Bb.includes(s)){const o=e.components[s];if(o==null&&!Db.includes(s))throw new R(`${s} not set`,"ERR_SERVICE_MISSING");return o}return Reflect.get(r,s,i)},set(r,s,i){return typeof s=="string"?e.components[s]=i:Reflect.set(r,s,i),!0}})}function Pb(n){const e={};for(const t of Object.values(n.components))for(const r of Ub(t))e[r]=!0;for(const t of Object.values(n.components))for(const r of Mb(t))if(e[r]!==!0)throw new R(`Service "${Fb(t)}" required capability "${r}" but it was not provided by any component, you may need to add additional configuration when creating your node.`,"ERR_UNMET_SERVICE_DEPENDENCIES")}function Ub(n){return Array.isArray(n==null?void 0:n[ks])?n[ks]:[]}function Mb(n){return Array.isArray(n==null?void 0:n[yc])?n[yc]:[]}function Fb(n){return(n==null?void 0:n[Symbol.toStringTag])??(n==null?void 0:n.toString())??"unknown"}var Zh;(function(){var n,e,t,r,s,i,o,a;a=function(c){var l,u,h,g;return l=(c&255<<24)>>>24,u=(c&255<<16)>>>16,h=(c&65280)>>>8,g=c&255,[l,u,h,g].join(".")},o=function(c){var l,u,h,g,y,m;for(l=[],h=g=0;g<=3&&c.length!==0;h=++g){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}m=e(c),y=m[0],u=m[1],c=c.substring(u),l.push(y)}if(c.length!==0)throw new Error("Invalid IP");switch(l.length){case 1:if(l[0]>4294967295)throw new Error("Invalid IP");return l[0]>>>0;case 2:if(l[0]>255||l[1]>16777215)throw new Error("Invalid IP");return(l[0]<<24|l[1])>>>0;case 3:if(l[0]>255||l[1]>255||l[2]>65535)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2])>>>0;case 4:if(l[0]>255||l[1]>255||l[2]>255||l[3]>255)throw new Error("Invalid IP");return(l[0]<<24|l[1]<<16|l[2]<<8|l[3])>>>0;default:throw new Error("Invalid IP")}},t=function(c){return c.charCodeAt(0)},r=t("0"),i=t("a"),s=t("A"),e=function(c){var l,u,h,g,y;for(g=0,l=10,u="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,l=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,l=8,u="7")),y=h;h<c.length;){if("0"<=c[h]&&c[h]<=u)g=g*l+(t(c[h])-r)>>>0;else if(l===16)if("a"<=c[h]&&c[h]<="f")g=g*l+(10+t(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")g=g*l+(10+t(c[h])-s)>>>0;else break;else break;if(g>4294967295)throw new Error("too large");h++}if(h===y)throw new Error("empty octet");return[g,h]},n=function(){function c(l,u){var h,g,y;if(typeof l!="string")throw new Error("Missing `net' parameter");if(u||(y=l.split("/",2),l=y[0],u=y[1]),u||(u=32),typeof u=="string"&&u.indexOf(".")>-1){try{this.maskLong=o(u)}catch{throw new Error("Invalid mask: "+u)}for(h=g=32;g>=0;h=--g)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(u||u===0)this.bitmask=parseInt(u,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(l)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+l)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+u);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(l){return typeof l=="string"&&(l.indexOf("/")>0||l.split(".").length!==4)&&(l=new c(l)),l instanceof c?this.contains(l.base)&&this.contains(l.broadcast||l.last):(o(l)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(l){return l==null&&(l=1),new c(a(this.netLong+this.size*l),this.mask)},c.prototype.forEach=function(l){var u,h,g;for(g=o(this.first),h=o(this.last),u=0;g<=h;)l(a(g),g,u),u++,g++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Zh=n}).call(Qu);const Vb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(n=>new Zh(n));function Ta(n){for(const e of Vb)if(e.contains(n))return!0;return!1}function $b(n){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(n)}function Hb(n){const e=n.split(":");if(e.length<2)return!1;const t=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0"),s=`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(t.substring(0,2),16)}.${parseInt(t.substring(2),16)}`;return Ta(s)}function Kb(n){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)}function zb(n){const e=n.split(":"),t=e[e.length-1];return Ta(t)}function qb(n){return/^::$/.test(n)||/^::1$/.test(n)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(n)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(n)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(n)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(n)||/^ff([0-9a-fA-F]{2,2}):/i.test(n)}function Qh(n){return li(n)?Ta(n):$b(n)?Hb(n):Kb(n)?zb(n):ga(n)?qb(n):void 0}function Gb(n={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async e=>{const t=e.stringTuples();return t[0][0]===4||t[0][0]===41?!!Qh(`${t[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...n}}const Wb=n=>n.toString().split("/").slice(1),cs=n=>({match:e=>e.length<1?!1:n(e[0])?e.slice(1):!1,pattern:"fn"}),X=n=>({match:e=>cs(t=>t===n).match(e),pattern:n}),Pn=()=>({match:n=>cs(e=>typeof e=="string").match(n),pattern:"{string}"}),ls=()=>({match:n=>cs(e=>!isNaN(parseInt(e))).match(n),pattern:"{number}"}),re=()=>({match:n=>{if(n.length<2||n[0]!=="p2p"&&n[0]!=="ipfs")return!1;if(n[1].startsWith("Q")||n[1].startsWith("1"))try{Ve.decode(`z${n[1]}`)}catch{return!1}else return!1;return n.slice(2)},pattern:"/p2p/{peerid}"}),Ei=()=>({match:n=>{if(n.length<2||n[0]!=="certhash")return!1;try{oo.decode(n[1])}catch{return!1}return n.slice(2)},pattern:"/certhash/{certhash}"}),te=n=>({match:e=>{const t=n.match(e);return t===!1?e:t},pattern:`optional(${n.pattern})`}),Me=(...n)=>({match:e=>{let t;for(const r of n){const s=r.match(e);s!==!1&&(t==null||s.length<t.length)&&(t=s)}return t??!1},pattern:`or(${n.map(e=>e.pattern).join(", ")})`}),Z=(...n)=>({match:e=>{for(const t of n){const r=t.match(e);if(r===!1)return!1;e=r}return e},pattern:`and(${n.map(e=>e.pattern).join(", ")})`});function fe(...n){function e(s){let i=Wb(s);for(const o of n){const a=o.match(i);if(a===!1)return!1;i=a}return i}function t(s){return e(s)!==!1}function r(s){const i=e(s);return i===!1?!1:i.length===0}return{matchers:n,matches:t,exactMatch:r}}const Yb=re();fe(Yb);const vi=Z(X("dns4"),Pn()),_i=Z(X("dns6"),Pn()),Ai=Z(X("dnsaddr"),Pn()),Ca=Z(X("dns"),Pn());fe(vi,te(re())),fe(_i,te(re())),fe(Ai,te(re())),fe(Me(Ca,Ai,vi,_i),te(re()));const Jh=Z(X("ip4"),cs(li)),ef=Z(X("ip6"),cs(ga)),Na=Me(Jh,ef),qt=Me(Na,Ca,vi,_i,Ai),jb=fe(Me(Na,Z(Me(Ca,Ai,vi,_i),te(re()))));fe(Jh),fe(ef),fe(Na);const La=Z(qt,X("tcp"),ls()),us=Z(qt,X("udp"),ls());fe(Z(La,te(re()))),fe(us);const Da=Z(us,X("quic"),te(re())),Si=Z(us,X("quic-v1"),te(re())),Xb=Me(Da,Si);fe(Da),fe(Si);const Ba=Me(qt,La,us,Da,Si),tf=Me(Z(Ba,X("ws"),te(re())));fe(tf);const nf=Me(Z(Ba,X("wss"),te(re())),Z(Ba,X("tls"),te(Z(X("sni"),Pn())),X("ws"),te(re())));fe(nf);const rf=Z(us,X("webrtc-direct"),te(Ei()),te(Ei()),te(re()));fe(rf);const sf=Z(Si,X("webtransport"),te(Ei()),te(Ei()),te(re()));fe(sf);const xi=Me(tf,nf,Z(La,te(re())),Z(Xb,te(re())),Z(qt,te(re())),rf,sf,re());fe(xi);const Zb=Z(xi,X("p2p-circuit"),re()),Oa=fe(Zb),Qb=Me(Z(xi,X("p2p-circuit"),X("webrtc"),te(re())),Z(xi,X("webrtc"),te(re())),Z(X("webrtc"),te(re())));fe(Qb);const Jb=Me(Z(qt,X("tcp"),ls(),X("http"),te(re())),Z(qt,X("http"),te(re())));fe(Jb);const eE=Me(Z(qt,X("tcp"),Me(Z(X("443"),X("http")),Z(ls(),X("https")),Z(ls(),X("tls"),X("http"))),te(re())),Z(qt,X("tls"),X("http"),te(re())),Z(qt,X("https"),te(re())));fe(eE);const tE=Me(Z(X("memory"),Pn(),te(re())));fe(tE);const nE=Me(Z(X("unix"),Pn(),te(re())));fe(nE);function of(n){try{const{address:e}=n.nodeAddress();return!!Qh(e)}catch{return!0}}function rE(n,e){const t=of(n.multiaddr),r=of(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function sE(n,e){return n.isCertified&&!e.isCertified?-1:!n.isCertified&&e.isCertified?1:0}function iE(n,e){const t=Oa.exactMatch(n.multiaddr),r=Oa.exactMatch(e.multiaddr);return t&&!r?1:!t&&r?-1:0}function Pa(n,e){const t=rE(n,e);if(t!==0)return t;const r=iE(n,e);return r!==0?r:sE(n,e)}class at extends Event{constructor(t,r){super(t);f(this,"type");f(this,"detail");this.type=t,this.detail=r}}var af={exports:{}};(function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,l,u){this.fn=c,this.context=l,this.once=u||!1}function i(c,l,u,h,g){if(typeof u!="function")throw new TypeError("The listener must be a function");var y=new s(u,h||c,g),m=t?t+l:l;return c._events[m]?c._events[m].fn?c._events[m]=[c._events[m],y]:c._events[m].push(y):(c._events[m]=y,c._eventsCount++),c}function o(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function a(){this._events=new r,this._eventsCount=0}a.prototype.eventNames=function(){var l=[],u,h;if(this._eventsCount===0)return l;for(h in u=this._events)e.call(u,h)&&l.push(t?h.slice(1):h);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(u)):l},a.prototype.listeners=function(l){var u=t?t+l:l,h=this._events[u];if(!h)return[];if(h.fn)return[h.fn];for(var g=0,y=h.length,m=new Array(y);g<y;g++)m[g]=h[g].fn;return m},a.prototype.listenerCount=function(l){var u=t?t+l:l,h=this._events[u];return h?h.fn?1:h.length:0},a.prototype.emit=function(l,u,h,g,y,m){var d=t?t+l:l;if(!this._events[d])return!1;var p=this._events[d],b=arguments.length,v,w;if(p.fn){switch(p.once&&this.removeListener(l,p.fn,void 0,!0),b){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,u),!0;case 3:return p.fn.call(p.context,u,h),!0;case 4:return p.fn.call(p.context,u,h,g),!0;case 5:return p.fn.call(p.context,u,h,g,y),!0;case 6:return p.fn.call(p.context,u,h,g,y,m),!0}for(w=1,v=new Array(b-1);w<b;w++)v[w-1]=arguments[w];p.fn.apply(p.context,v)}else{var E=p.length,A;for(w=0;w<E;w++)switch(p[w].once&&this.removeListener(l,p[w].fn,void 0,!0),b){case 1:p[w].fn.call(p[w].context);break;case 2:p[w].fn.call(p[w].context,u);break;case 3:p[w].fn.call(p[w].context,u,h);break;case 4:p[w].fn.call(p[w].context,u,h,g);break;default:if(!v)for(A=1,v=new Array(b-1);A<b;A++)v[A-1]=arguments[A];p[w].fn.apply(p[w].context,v)}}return!0},a.prototype.on=function(l,u,h){return i(this,l,u,h,!1)},a.prototype.once=function(l,u,h){return i(this,l,u,h,!0)},a.prototype.removeListener=function(l,u,h,g){var y=t?t+l:l;if(!this._events[y])return this;if(!u)return o(this,y),this;var m=this._events[y];if(m.fn)m.fn===u&&(!g||m.once)&&(!h||m.context===h)&&o(this,y);else{for(var d=0,p=[],b=m.length;d<b;d++)(m[d].fn!==u||g&&!m[d].once||h&&m[d].context!==h)&&p.push(m[d]);p.length?this._events[y]=p.length===1?p[0]:p:o(this,y)}return this},a.prototype.removeAllListeners=function(l){var u;return l?(u=t?t+l:l,this._events[u]&&o(this,u)):(this._events=new r,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,n.exports=a})(af);var oE=af.exports;const aE=ns(oE);class cf extends Error{constructor(e){super(e),this.name="TimeoutError"}}let cE=class extends Error{constructor(e){super(),this.name="AbortError",this.message=e}};const lf=n=>globalThis.DOMException===void 0?new cE(n):new DOMException(n),uf=n=>{const e=n.reason===void 0?lf("This operation was aborted."):n.reason;return e instanceof Error?e:lf(e)};function lE(n,e){const{milliseconds:t,fallback:r,message:s,customTimers:i={setTimeout,clearTimeout}}=e;let o,a;const l=new Promise((u,h)=>{if(typeof t!="number"||Math.sign(t)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${t}\``);if(e.signal){const{signal:y}=e;y.aborted&&h(uf(y)),a=()=>{h(uf(y))},y.addEventListener("abort",a,{once:!0})}if(t===Number.POSITIVE_INFINITY){n.then(u,h);return}const g=new cf;o=i.setTimeout.call(void 0,()=>{if(r){try{u(r())}catch(y){h(y)}return}typeof n.cancel=="function"&&n.cancel(),s===!1?u():s instanceof Error?h(s):(g.message=s??`Promise timed out after ${t} milliseconds`,h(g))},t),(async()=>{try{u(await n)}catch(y){h(y)}})()}).finally(()=>{l.clear(),a&&e.signal&&e.signal.removeEventListener("abort",a)});return l.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},l}function uE(n,e,t){let r=0,s=n.length;for(;s>0;){const i=Math.trunc(s/2);let o=r+i;t(n[o],e)<=0?(r=++o,s-=i+1):s=i}return r}let hE=(Kd=class{constructor(){ue(this,ft,[])}enqueue(e,t){t={priority:0,...t};const r={priority:t.priority,id:t.id,run:e};if(this.size===0||D(this,ft)[this.size-1].priority>=t.priority){D(this,ft).push(r);return}const s=uE(D(this,ft),r,(i,o)=>o.priority-i.priority);D(this,ft).splice(s,0,r)}setPriority(e,t){const r=D(this,ft).findIndex(i=>i.id===e);if(r===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[s]=D(this,ft).splice(r,1);this.enqueue(s.run,{priority:t,id:e})}dequeue(){const e=D(this,ft).shift();return e==null?void 0:e.run}filter(e){return D(this,ft).filter(t=>t.priority===e.priority).map(t=>t.run)}get size(){return D(this,ft).length}},ft=new WeakMap,Kd);class fE extends aE{constructor(t){var r,s;super();ue(this,J);ue(this,Sr);ue(this,xr);ue(this,wn,0);ue(this,vs);ue(this,Rr);ue(this,_s,0);ue(this,dt);ue(this,Ir);ue(this,We);ue(this,As);ue(this,gt,0);ue(this,kr);ue(this,Xt);ue(this,Ss);ue(this,qi,1n);f(this,"timeout");if(t={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:hE,...t},!(typeof t.intervalCap=="number"&&t.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((r=t.intervalCap)==null?void 0:r.toString())??""}\` (${typeof t.intervalCap})`);if(t.interval===void 0||!(Number.isFinite(t.interval)&&t.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=t.interval)==null?void 0:s.toString())??""}\` (${typeof t.interval})`);he(this,Sr,t.carryoverConcurrencyCount),he(this,xr,t.intervalCap===Number.POSITIVE_INFINITY||t.interval===0),he(this,vs,t.intervalCap),he(this,Rr,t.interval),he(this,We,new t.queueClass),he(this,As,t.queueClass),this.concurrency=t.concurrency,this.timeout=t.timeout,he(this,Ss,t.throwOnTimeout===!0),he(this,Xt,t.autoStart===!1)}get concurrency(){return D(this,kr)}set concurrency(t){if(!(typeof t=="number"&&t>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`);he(this,kr,t),ie(this,J,Qi).call(this)}setPriority(t,r){D(this,We).setPriority(t,r)}async add(t,r={}){return r.id??(r.id=(Rs(this,qi)._++).toString()),r={timeout:this.timeout,throwOnTimeout:D(this,Ss),...r},new Promise((s,i)=>{D(this,We).enqueue(async()=>{var o;Rs(this,gt)._++;try{(o=r.signal)==null||o.throwIfAborted(),Rs(this,wn)._++;let a=t({signal:r.signal});r.timeout&&(a=lE(Promise.resolve(a),{milliseconds:r.timeout})),r.signal&&(a=Promise.race([a,ie(this,J,dg).call(this,r.signal)]));const c=await a;s(c),this.emit("completed",c)}catch(a){if(a instanceof cf&&!r.throwOnTimeout){s();return}i(a),this.emit("error",a)}finally{ie(this,J,ug).call(this)}},r),this.emit("add"),ie(this,J,Zi).call(this)})}async addAll(t,r){return Promise.all(t.map(async s=>this.add(s,r)))}start(){return D(this,Xt)?(he(this,Xt,!1),ie(this,J,Qi).call(this),this):this}pause(){he(this,Xt,!0)}clear(){he(this,We,new(D(this,As)))}async onEmpty(){D(this,We).size!==0&&await ie(this,J,Ji).call(this,"empty")}async onSizeLessThan(t){D(this,We).size<t||await ie(this,J,Ji).call(this,"next",()=>D(this,We).size<t)}async onIdle(){D(this,gt)===0&&D(this,We).size===0||await ie(this,J,Ji).call(this,"idle")}get size(){return D(this,We).size}sizeBy(t){return D(this,We).filter(t).length}get pending(){return D(this,gt)}get isPaused(){return D(this,Xt)}}Sr=new WeakMap,xr=new WeakMap,wn=new WeakMap,vs=new WeakMap,Rr=new WeakMap,_s=new WeakMap,dt=new WeakMap,Ir=new WeakMap,We=new WeakMap,As=new WeakMap,gt=new WeakMap,kr=new WeakMap,Xt=new WeakMap,Ss=new WeakMap,qi=new WeakMap,J=new WeakSet,cg=function(){return D(this,xr)||D(this,wn)<D(this,vs)},lg=function(){return D(this,gt)<D(this,kr)},ug=function(){Rs(this,gt)._--,ie(this,J,Zi).call(this),this.emit("next")},hg=function(){ie(this,J,uc).call(this),ie(this,J,lc).call(this),he(this,Ir,void 0)},fg=function(){const t=Date.now();if(D(this,dt)===void 0){const r=D(this,_s)-t;if(r<0)he(this,wn,D(this,Sr)?D(this,gt):0);else return D(this,Ir)===void 0&&he(this,Ir,setTimeout(()=>{ie(this,J,hg).call(this)},r)),!0}return!1},Zi=function(){if(D(this,We).size===0)return D(this,dt)&&clearInterval(D(this,dt)),he(this,dt,void 0),this.emit("empty"),D(this,gt)===0&&this.emit("idle"),!1;if(!D(this,Xt)){const t=!D(this,J,fg);if(D(this,J,cg)&&D(this,J,lg)){const r=D(this,We).dequeue();return r?(this.emit("active"),r(),t&&ie(this,J,lc).call(this),!0):!1}}return!1},lc=function(){D(this,xr)||D(this,dt)!==void 0||(he(this,dt,setInterval(()=>{ie(this,J,uc).call(this)},D(this,Rr))),he(this,_s,Date.now()+D(this,Rr)))},uc=function(){D(this,wn)===0&&D(this,gt)===0&&D(this,dt)&&(clearInterval(D(this,dt)),he(this,dt,void 0)),he(this,wn,D(this,Sr)?D(this,gt):0),ie(this,J,Qi).call(this)},Qi=function(){for(;ie(this,J,Zi).call(this););},dg=async function(t){return new Promise((r,s)=>{t.addEventListener("abort",()=>{s(t.reason)},{once:!0})})},Ji=async function(t,r){return new Promise(s=>{const i=()=>{r&&!r()||(this.off(t,i),s())};this.on(t,i)})};function hf(n){const e=[fn.A];return n==null?e:Array.isArray(n)?n.length===0?e:n:[n]}const ff=60;function df(n){return{Status:n.Status??0,TC:n.TC??n.flag_tc??!1,RD:n.RD??n.flag_rd??!1,RA:n.RA??n.flag_ra??!1,AD:n.AD??n.flag_ad??!1,CD:n.CD??n.flag_cd??!1,Question:(n.Question??n.questions??[]).map(e=>({name:e.name,type:fn[e.type]})),Answer:(n.Answer??n.answers??[]).map(e=>({name:e.name,type:fn[e.type],TTL:e.TTL??e.ttl??ff,data:e.data instanceof Uint8Array?j(e.data):e.data}))}}const dE=4;function gf(n,e={}){const t=new fE({concurrency:e.queryConcurrency??dE});return async(r,s={})=>{var a;const i=new URLSearchParams;i.set("name",r),hf(s.types).forEach(c=>{i.append("type",fn[c])}),(a=s.onProgress)==null||a.call(s,new at("dns:query",r));const o=await t.add(async()=>{var u;const c=await fetch(`${n}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const l=df(await c.json());return(u=s.onProgress)==null||u.call(s,new at("dns:response",l)),l},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function gE(){return[gf("https://cloudflare-dns.com/dns-query"),gf("https://dns.google/resolve")]}var pE=function(n){if(!n)throw Error("hashlru must have a max value, of type number, greater than 0");var e=0,t=Object.create(null),r=Object.create(null);function s(i,o){t[i]=o,e++,e>=n&&(e=0,r=t,t=Object.create(null))}return{has:function(i){return t[i]!==void 0||r[i]!==void 0},remove:function(i){t[i]!==void 0&&(t[i]=void 0),r[i]!==void 0&&(r[i]=void 0)},get:function(i){var o=t[i];if(o!==void 0)return o;if((o=r[i])!==void 0)return s(i,o),o},set:function(i,o){t[i]!==void 0?t[i]=o:s(i,o)},clear:function(){t=Object.create(null),r=Object.create(null)}}};const yE=ns(pE);class mE{constructor(e){f(this,"lru");this.lru=yE(e)}get(e,t){let r=!0;const s=[];for(const i of t){const o=this.getAnswers(e,i);if(o.length===0){r=!1;break}s.push(...o)}if(r)return df({answers:s})}getAnswers(e,t){const r=`${e.toLowerCase()}-${t}`,s=this.lru.get(r);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:fn[a.type]}));return i.length===0&&this.lru.remove(r),i}return[]}add(e,t){const r=`${e.toLowerCase()}-${t.type}`,s=this.lru.get(r)??[];s.push({expires:Date.now()+(t.TTL??ff)*1e3,value:t}),this.lru.set(r,s)}remove(e,t){const r=`${e.toLowerCase()}-${t}`;this.lru.remove(r)}clear(){this.lru.clear()}}function wE(n){return new mE(n)}const bE=1e3;class EE{constructor(e){f(this,"resolvers");f(this,"cache");this.resolvers={},this.cache=wE(e.cacheSize??bE),Object.entries(e.resolvers??{}).forEach(([t,r])=>{Array.isArray(r)||(r=[r]),t.endsWith(".")||(t=`${t}.`),this.resolvers[t]=r}),this.resolvers["."]==null&&(this.resolvers["."]=gE())}async query(e,t={}){var c,l,u;const r=hf(t.types),s=t.cached!==!1?this.cache.get(e,r):void 0;if(s!=null)return(c=t.onProgress)==null||c.call(t,new at("dns:cache",s)),s;const i=`${e.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((l=t.signal)==null?void 0:l.aborted)===!0)break;try{const g=await h(e,{...t,types:r});for(const y of g.Answer)this.cache.add(e,y);return g}catch(g){a.push(g),(u=t.onProgress)==null||u.call(t,new at("dns:error",g))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${e} ${r} failed`)}}var fn;(function(n){n[n.A=1]="A",n[n.CNAME=5]="CNAME",n[n.TXT=16]="TXT",n[n.AAAA=28]="AAAA"})(fn||(fn={}));function vE(n={}){return new EE(n)}const ct=-1,Ua={},_E={};[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,ct,"ip6zone"],[43,8,"ipcidr"],[53,ct,"dns",!0],[54,ct,"dns4",!0],[55,ct,"dns6",!0],[56,ct,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,ct,"unix",!1,!0],[421,ct,"ipfs"],[421,ct,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,ct,"garlic64"],[448,0,"tls"],[449,ct,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,ct,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[481,ct,"http-path"],[777,ct,"memory"]].forEach(n=>{const e=AE(...n);_E[e.code]=e,Ua[e.name]=e});function AE(n,e,t,r,s){return{code:n,size:e,name:t,resolvable:!!r,path:!!s}}function SE(n){{if(Ua[n]!=null)return Ua[n];throw new Error(`no protocol with name: ${n}`)}}const xE=32,{code:RE}=SE("dnsaddr");class IE extends Error{constructor(e="Max recursive depth reached"){super(e),this.name="RecursionLimitError"}}const pf=async function(e,t={}){const r=t.maxRecursiveDepth??xE;if(r===0)throw new IE("Max recursive depth reached");const[,s]=e.stringTuples().find(([l])=>l===RE)??[],o=await((t==null?void 0:t.dns)??vE()).query(`_dnsaddr.${s}`,{signal:t==null?void 0:t.signal,types:[fn.TXT]}),a=e.getPeerId(),c=[];for(const l of o.Answer){const u=l.data.replace(/["']/g,"").trim().split("=")[1];if(u==null||a!=null&&!u.includes(a))continue;const h=xe(u);if(u.startsWith("/dnsaddr")){const g=await h.resolve({...t,maxRecursiveDepth:r-1});c.push(...g.map(y=>y.toString()))}else c.push(h.toString())}return c};var kE=n=>{if(Object.prototype.toString.call(n)!=="[object Object]")return!1;const e=Object.getPrototypeOf(n);return e===null||e===Object.prototype};const Ri=kE,{hasOwnProperty:yf}=Object.prototype,{propertyIsEnumerable:TE}=Object,gr=(n,e,t)=>Object.defineProperty(n,e,{value:t,writable:!0,enumerable:!0,configurable:!0}),CE=Qu,mf={concatArrays:!1,ignoreUndefined:!1},Ii=n=>{const e=[];for(const t in n)yf.call(n,t)&&e.push(t);if(Object.getOwnPropertySymbols){const t=Object.getOwnPropertySymbols(n);for(const r of t)TE.call(n,r)&&e.push(r)}return e};function pr(n){return Array.isArray(n)?NE(n):Ri(n)?LE(n):n}function NE(n){const e=n.slice(0,0);return Ii(n).forEach(t=>{gr(e,t,pr(n[t]))}),e}function LE(n){const e=Object.getPrototypeOf(n)===null?Object.create(null):{};return Ii(n).forEach(t=>{gr(e,t,pr(n[t]))}),e}const wf=(n,e,t,r)=>(t.forEach(s=>{typeof e[s]>"u"&&r.ignoreUndefined||(s in n&&n[s]!==Object.getPrototypeOf(n)?gr(n,s,Ma(n[s],e[s],r)):gr(n,s,pr(e[s])))}),n),DE=(n,e,t)=>{let r=n.slice(0,0),s=0;return[n,e].forEach(i=>{const o=[];for(let a=0;a<i.length;a++)yf.call(i,a)&&(o.push(String(a)),i===n?gr(r,s++,i[a]):gr(r,s++,pr(i[a])));r=wf(r,i,Ii(i).filter(a=>!o.includes(a)),t)}),r};function Ma(n,e,t){return t.concatArrays&&Array.isArray(n)&&Array.isArray(e)?DE(n,e,t):!Ri(e)||!Ri(n)?pr(e):wf(n,e,Ii(e),t)}var BE=function(...n){const e=Ma(pr(mf),this!==CE&&this||{},mf);let t={_:{}};for(const r of n)if(r!==void 0){if(!Ri(r))throw new TypeError("`"+r+"` is not an Option Object");t=Ma(t,{_:r},e)}return t._};const bf=ns(BE);var yr;(function(n){n.NOT_STARTED_YET="The libp2p node is not started yet",n.ERR_PROTECTOR_REQUIRED="Private network is enforced, but no protector was provided",n.NOT_FOUND="Not found"})(yr||(yr={}));var H;(function(n){n.ERR_PROTECTOR_REQUIRED="ERR_PROTECTOR_REQUIRED",n.ERR_PEER_DIAL_INTERCEPTED="ERR_PEER_DIAL_INTERCEPTED",n.ERR_CONNECTION_INTERCEPTED="ERR_CONNECTION_INTERCEPTED",n.ERR_INVALID_PROTOCOLS_FOR_STREAM="ERR_INVALID_PROTOCOLS_FOR_STREAM",n.ERR_CONNECTION_ENDED="ERR_CONNECTION_ENDED",n.ERR_CONNECTION_FAILED="ERR_CONNECTION_FAILED",n.ERR_NODE_NOT_STARTED="ERR_NODE_NOT_STARTED",n.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",n.ERR_TOO_MANY_ADDRESSES="ERR_TOO_MANY_ADDRESSES",n.ERR_NO_VALID_ADDRESSES="ERR_NO_VALID_ADDRESSES",n.ERR_RELAYED_DIAL="ERR_RELAYED_DIAL",n.ERR_DIALED_SELF="ERR_DIALED_SELF",n.ERR_DISCOVERED_SELF="ERR_DISCOVERED_SELF",n.ERR_DUPLICATE_TRANSPORT="ERR_DUPLICATE_TRANSPORT",n.ERR_ENCRYPTION_FAILED="ERR_ENCRYPTION_FAILED",n.ERR_HOP_REQUEST_FAILED="ERR_HOP_REQUEST_FAILED",n.ERR_INVALID_KEY="ERR_INVALID_KEY",n.ERR_INVALID_MESSAGE="ERR_INVALID_MESSAGE",n.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",n.ERR_INVALID_PEER="ERR_INVALID_PEER",n.ERR_MUXER_UNAVAILABLE="ERR_MUXER_UNAVAILABLE",n.ERR_NOT_FOUND="ERR_NOT_FOUND",n.ERR_TRANSPORT_UNAVAILABLE="ERR_TRANSPORT_UNAVAILABLE",n.ERR_TRANSPORT_DIAL_FAILED="ERR_TRANSPORT_DIAL_FAILED",n.ERR_UNSUPPORTED_PROTOCOL="ERR_UNSUPPORTED_PROTOCOL",n.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",n.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",n.ERR_SIGNATURE_NOT_VALID="ERR_SIGNATURE_NOT_VALID",n.ERR_FIND_SELF="ERR_FIND_SELF",n.ERR_NO_ROUTERS_AVAILABLE="ERR_NO_ROUTERS_AVAILABLE",n.ERR_CONNECTION_NOT_MULTIPLEXED="ERR_CONNECTION_NOT_MULTIPLEXED",n.ERR_NO_DIAL_TOKENS="ERR_NO_DIAL_TOKENS",n.ERR_INVALID_CMS="ERR_INVALID_CMS",n.ERR_MISSING_KEYS="ERR_MISSING_KEYS",n.ERR_NO_KEY="ERR_NO_KEY",n.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",n.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",n.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",n.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",n.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",n.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",n.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",n.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",n.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",n.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",n.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",n.ERR_MISSING_PUBLIC_KEY="ERR_MISSING_PUBLIC_KEY",n.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",n.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",n.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH",n.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",n.ERR_WRONG_PING_ACK="ERR_WRONG_PING_ACK",n.ERR_INVALID_RECORD="ERR_INVALID_RECORD",n.ERR_ALREADY_SUCCEEDED="ERR_ALREADY_SUCCEEDED",n.ERR_NO_HANDLER_FOR_PROTOCOL="ERR_NO_HANDLER_FOR_PROTOCOL",n.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",n.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",n.ERR_CONNECTION_DENIED="ERR_CONNECTION_DENIED",n.ERR_TRANSFER_LIMIT_EXCEEDED="ERR_TRANSFER_LIMIT_EXCEEDED"})(H||(H={}));const OE={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:n=>n},connectionManager:{resolvers:{dnsaddr:pf},addressSorter:Pa},transportManager:{faultTolerance:Vn.FATAL_ALL}};async function PE(n){var t,r;const e=bf(OE,n);if(e.connectionProtector===null&&((r=(t=globalThis.process)==null?void 0:t.env)==null?void 0:r.LIBP2P_FORCE_PNET)!=null)throw new R(yr.ERR_PROTECTOR_REQUIRED,H.ERR_PROTECTOR_REQUIRED);if(e.privateKey!=null&&!(await Cn(e.privateKey.public.bytes,e.privateKey.bytes)).equals(e.peerId))throw new R("Private key doesn't match peer id",H.ERR_INVALID_KEY);return e}const Ef=()=>{const n=new Error("Delay aborted");return n.name="AbortError",n},UE=new WeakMap;function ME({clearTimeout:n,setTimeout:e}={}){return(t,{value:r,signal:s}={})=>{if(s!=null&&s.aborted)return Promise.reject(Ef());let i,o,a;const c=n??clearTimeout,l=()=>{c(i),a(Ef())},u=()=>{s&&s.removeEventListener("abort",l)},h=new Promise((g,y)=>{o=()=>{u(),g(r)},a=y,i=(e??setTimeout)(o,t)});return s&&s.addEventListener("abort",l,{once:!0}),UE.set(h,()=>{c(i),i=null,o()}),h}}const FE=ME();class VE{constructor(e={}){f(this,"memoryStorage");f(this,"points");f(this,"duration");f(this,"blockDuration");f(this,"execEvenly");f(this,"execEvenlyMinDelayMs");f(this,"keyPrefix");this.points=e.points??4,this.duration=e.duration??1,this.blockDuration=e.blockDuration??0,this.execEvenly=e.execEvenly??!1,this.execEvenlyMinDelayMs=e.execEvenlyMinDelayMs??this.duration*1e3/this.points,this.keyPrefix=e.keyPrefix??"rlflx",this.memoryStorage=new $E}async consume(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r);let o=this.memoryStorage.incrby(s,t,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+t&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new R("Rate limit exceeded","ERR_RATE_LIMIT_EXCEEDED",o);if(this.execEvenly&&o.msBeforeNext>0&&!o.isFirstInDuration){let a=Math.ceil(o.msBeforeNext/(o.remainingPoints+2));a<this.execEvenlyMinDelayMs&&(a=o.consumedPoints*this.execEvenlyMinDelayMs),await FE(a)}return o}penalty(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(e,t=1,r={}){const s=this.getKey(e),i=this._getKeySecDuration(r),o=this.memoryStorage.incrby(s,-t,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(e,t){const r=t*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(e),s,t),{remainingPoints:0,msBeforeNext:r===0?-1:r,consumedPoints:s,isFirstInDuration:!1}}set(e,t,r=0){const s=(r>=0?r:this.duration)*1e3;return this.memoryStorage.set(this.getKey(e),t,r),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:t,isFirstInDuration:!1}}get(e){const t=this.memoryStorage.get(this.getKey(e));return t!=null&&(t.remainingPoints=Math.max(this.points-t.consumedPoints,0)),t}delete(e){this.memoryStorage.delete(this.getKey(e))}_getKeySecDuration(e){return(e==null?void 0:e.customDuration)!=null&&e.customDuration>=0?e.customDuration:this.duration}getKey(e){return this.keyPrefix.length>0?`${this.keyPrefix}:${e}`:e}parseKey(e){return e.substring(this.keyPrefix.length)}}class $E{constructor(){f(this,"storage");this.storage=new Map}incrby(e,t,r){const s=this.storage.get(e);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=t,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(e,t,r)}return this.set(e,t,r)}set(e,t,r){const s=r*1e3,i=this.storage.get(e);i!=null&&clearTimeout(i.timeoutId);const o={value:t,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(e,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(e)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(e){const t=this.storage.get(e);if(t!=null)return{remainingPoints:0,msBeforeNext:t.expiresAt!=null?t.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:t.value,isFirstInDuration:!1}}delete(e){const t=this.storage.get(e);return t!=null?(t.timeoutId!=null&&clearTimeout(t.timeoutId),this.storage.delete(e),!0):!1}}function vf(n){if(fc(n))return{peerId:n,multiaddrs:[]};Array.isArray(n)||(n=[n]);let e;if(n.length>0){const t=n[0].getPeerId();e=t==null?void 0:st(t),n.forEach(r=>{if(!fi(r))throw new R("Invalid Multiaddr",H.ERR_INVALID_MULTIADDR);const s=r.getPeerId();if(s==null){if(e!=null)throw new R("Multiaddrs must all have the same peer id or have no peer id",H.ERR_INVALID_PARAMETERS)}else{const i=st(s);if((e==null?void 0:e.equals(i))!==!0)throw new R("Multiaddrs must all have the same peer id or have no peer id",H.ERR_INVALID_PARAMETERS)}})}return{peerId:e,multiaddrs:n}}class HE{constructor(e){f(this,"deferred");f(this,"signal");var t;this.signal=e,this.deferred=ye(),this.onAbort=this.onAbort.bind(this),(t=this.signal)==null||t.addEventListener("abort",this.onAbort)}onAbort(){var e;this.deferred.reject(((e=this.signal)==null?void 0:e.reason)??new eo)}cleanup(){var e;(e=this.signal)==null||e.removeEventListener("abort",this.onAbort)}}function KE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class zE{constructor(e,t){f(this,"id");f(this,"fn");f(this,"options");f(this,"recipients");f(this,"status");f(this,"timeline");f(this,"controller");this.id=KE(),this.status="queued",this.fn=e,this.options=t,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,Se(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(e){this.controller.abort(e)}onAbort(){this.recipients.reduce((t,r)=>{var s;return t&&((s=r.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new eo),this.cleanup())}async join(e={}){var r;const t=new HE(e.signal);return this.recipients.push(t),(r=e.signal)==null||r.addEventListener("abort",this.onAbort),t.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const e=await Ct(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(t=>{t.deferred.resolve(e)}),this.status="complete"}catch(e){this.recipients.forEach(t=>{t.deferred.reject(e)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(e=>{var t;e.cleanup(),(t=e.signal)==null||t.removeEventListener("abort",this.onAbort)})}}class _f extends Is{constructor(t={}){var r;super();f(this,"concurrency");f(this,"queue");f(this,"pending");f(this,"sort");this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.pending=0,t.metricName!=null&&((r=t.metrics)==null||r.registerMetricGroup(t.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=t.sort,this.queue=[]}tryToStartAnother(){if(this.size===0)return queueMicrotask(()=>{this.safeDispatchEvent("empty")}),this.running===0&&queueMicrotask(()=>{this.safeDispatchEvent("idle")}),!1;if(this.pending<this.concurrency){let t;for(const r of this.queue)if(r.status==="queued"){t=r;break}return t==null?!1:(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let r=0;r<this.queue.length;r++)if(this.queue[r]===t){this.queue.splice(r,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(t){this.queue.push(t),this.sort!=null&&this.queue.sort(this.sort)}async add(t,r){var i;(i=r==null?void 0:r.signal)==null||i.throwIfAborted();const s=new zE(t,r);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(r).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("error",{detail:o}),this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new eo)}),this.clear()}async onEmpty(t){this.size!==0&&await Bn(this,"empty",t==null?void 0:t.signal)}async onSizeLessThan(t,r){this.size<t||await Bn(this,"next",r==null?void 0:r.signal,{filter:()=>this.size<t})}async onIdle(t){this.pending===0&&this.size===0||await Bn(this,"idle",t==null?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var l,u,h;(l=t==null?void 0:t.signal)==null||l.throwIfAborted();const r=ss({objectMode:!0}),s=g=>{g!=null?this.abort():this.clear(),r.end(g)},i=g=>{g.detail!=null&&r.push(g.detail)},o=g=>{s(g.detail)},a=()=>{s()},c=()=>{s(new R("Queue aborted","ERR_QUEUE_ABORTED"))};this.addEventListener("completed",i),this.addEventListener("error",o),this.addEventListener("idle",a),(u=t==null?void 0:t.signal)==null||u.addEventListener("abort",c);try{yield*r}finally{this.removeEventListener("completed",i),this.removeEventListener("error",o),this.removeEventListener("idle",a),(h=t==null?void 0:t.signal)==null||h.removeEventListener("abort",c),s()}}}class qE extends _f{has(e){return this.find(e)!=null}find(e){return this.queue.find(t=>e.equals(t.options.peerId))}}const Af=5e3,GE=2e3,Sf=25,WE=5e3,xf=25,Rf=0,If=100,kf=10,YE=5,jE=10,Tf="last-dial-failure",Cf=500,Nf=5,Lf=100,Df=50,Bf=1e3*60*7,Un={minConnections:Nf,maxQueueLength:If,autoDialConcurrency:xf,autoDialPriority:Rf,autoDialInterval:WE,autoDialPeerRetryThreshold:Bf,autoDialDiscoveredPeersDebounce:kf};class XE{constructor(e,t){f(this,"connectionManager");f(this,"peerStore");f(this,"queue");f(this,"minConnections");f(this,"autoDialPriority");f(this,"autoDialIntervalMs");f(this,"autoDialMaxQueueLength");f(this,"autoDialPeerRetryThresholdMs");f(this,"autoDialDiscoveredPeersDebounce");f(this,"autoDialInterval");f(this,"started");f(this,"running");f(this,"log");this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.minConnections=t.minConnections??Un.minConnections,this.autoDialPriority=t.autoDialPriority??Un.autoDialPriority,this.autoDialIntervalMs=t.autoDialInterval??Un.autoDialInterval,this.autoDialMaxQueueLength=t.maxQueueLength??Un.maxQueueLength,this.autoDialPeerRetryThresholdMs=t.autoDialPeerRetryThreshold??Un.autoDialPeerRetryThreshold,this.autoDialDiscoveredPeersDebounce=t.autoDialDiscoveredPeersDebounce??Un.autoDialDiscoveredPeersDebounce,this.log=e.logger.forComponent("libp2p:connection-manager:auto-dial"),this.started=!1,this.running=!1,this.queue=new qE({concurrency:t.autoDialConcurrency??Un.autoDialConcurrency,metricName:"libp2p_autodial_queue",metrics:e.metrics}),this.queue.addEventListener("error",s=>{this.log.error("error during auto-dial",s.detail)}),e.events.addEventListener("connection:close",()=>{this.autoDial().catch(s=>{this.log.error(s)})});let r;e.events.addEventListener("peer:discovery",()=>{clearTimeout(r),r=setTimeout(()=>{this.autoDial().catch(s=>{this.log.error(s)})},this.autoDialDiscoveredPeersDebounce)})}isStarted(){return this.started}start(){this.started=!0}afterStart(){this.autoDial().catch(e=>{this.log.error("error while autodialing",e)})}stop(){this.queue.clear(),clearTimeout(this.autoDialInterval),this.started=!1,this.running=!1}async autoDial(){if(!this.started||this.running)return;const e=this.connectionManager.getConnectionsMap(),t=e.size;if(t>=this.minConnections){this.minConnections>0&&this.log.trace("have enough connections %d/%d",t,this.minConnections);return}if(this.queue.size>this.autoDialMaxQueueLength){this.log("not enough connections %d/%d but auto dial queue is full",t,this.minConnections),this.sheduleNextAutodial();return}this.running=!0,this.log("not enough connections %d/%d - will dial peers to increase the number of connections",t,this.minConnections);const r=new Nn(this.connectionManager.getDialQueue().map(l=>l.peerId).filter(Boolean)),s=await this.peerStore.all({filters:[l=>l.addresses.length===0?(this.log.trace("not autodialing %p because they have no addresses",l.id),!1):e.has(l.id)?(this.log.trace("not autodialing %p because they are already connected",l.id),!1):r.has(l.id)?(this.log.trace("not autodialing %p because they are already being dialed",l.id),!1):this.queue.has(l.id)?(this.log.trace("not autodialing %p because they are already being autodialed",l.id),!1):!0]}),i=s.sort(()=>Math.random()>.5?1:-1),o=new ts;for(const l of i)o.has(l.id)||o.set(l.id,[...l.tags.values()].reduce((u,h)=>u+h.value,0));const c=i.sort((l,u)=>{const h=o.get(l.id)??0,g=o.get(u.id)??0;return h>g?-1:h<g?1:0}).filter(l=>{const u=l.metadata.get(Tf);if(u==null)return!0;const h=parseInt(j(u));return isNaN(h)?!0:Date.now()-h>this.autoDialPeerRetryThresholdMs});this.log("selected %d/%d peers to dial",c.length,s.length);for(const l of c)this.queue.add(async()=>{const u=this.connectionManager.getConnectionsMap().size;if(u>=this.minConnections){this.log("got enough connections now %d/%d",u,this.minConnections),this.queue.clear();return}this.log("connecting to a peerStore stored peer %p",l.id),await this.connectionManager.openConnection(l.id,{priority:this.autoDialPriority})},{peerId:l.id}).catch(u=>{this.log.error("could not connect to peerStore stored peer",u)});this.running=!1,this.sheduleNextAutodial()}sheduleNextAutodial(){this.started&&(this.autoDialInterval=setTimeout(()=>{this.autoDial().catch(e=>{this.log.error("error while autodialing",e)})},this.autoDialIntervalMs))}}const ZE=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function QE(n,e){var s;const t=((s=n==null?void 0:n.streams)==null?void 0:s.map(i=>i.protocol))??[],r=(e==null?void 0:e.closableProtocols)??ZE;if(!(t.filter(i=>i!=null&&!r.includes(i)).length>0))try{await(n==null?void 0:n.close(e))}catch(i){n==null||n.abort(i)}}const Of={maxConnections:Lf,allow:[]};class JE{constructor(e,t={}){f(this,"maxConnections");f(this,"connectionManager");f(this,"peerStore");f(this,"allow");f(this,"events");f(this,"log");this.maxConnections=t.maxConnections??Of.maxConnections,this.allow=t.allow??Of.allow,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager:connection-pruner"),e.events.addEventListener("connection:open",()=>{this.maybePruneConnections().catch(r=>{this.log.error(r)})})}async maybePruneConnections(){const e=this.connectionManager.getConnections(),t=e.length;if(this.log("checking max connections limit %d/%d",t,this.maxConnections),t<=this.maxConnections)return;const r=new ts;for(const a of e){const c=a.remotePeer;if(!r.has(c)){r.set(c,0);try{const l=await this.peerStore.get(c);r.set(c,[...l.tags.values()].reduce((u,h)=>u+h.value,0))}catch(l){l.code!=="ERR_NOT_FOUND"&&this.log.error("error loading peer tags",l)}}}const s=this.sortConnections(e,r),i=Math.max(t-this.maxConnections,0),o=[];for(const a of s)if(this.log("too many connections open - closing a connection to %p",a.remotePeer),this.allow.some(l=>a.remoteAddr.toString().startsWith(l.toString()))||o.push(a),o.length===i)break;await Promise.all(o.map(async a=>{await QE(a,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(e,t){return e.sort((r,s)=>{const i=r.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((r,s)=>r.direction==="outbound"&&s.direction==="inbound"?1:r.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((r,s)=>r.streams.length>s.streams.length?1:r.streams.length<s.streams.length?-1:0).sort((r,s)=>{const i=t.get(r.remotePeer)??0,o=t.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}class e1 extends _f{constructor(e={}){super({...e,sort:(t,r)=>t.options.priority>r.options.priority?-1:t.options.priority<r.options.priority?1:0})}}function ki(n){const e=new globalThis.AbortController;function t(){e.abort();for(const i of n)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",t)}for(const i of n){if((i==null?void 0:i.aborted)===!0){t();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",t)}function r(){for(const i of n)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",t)}const s=e.signal;return s.clear=r,s}async function t1(n,e){let t=!1;for(const s of va.keys())if(t=n.protoNames().includes(s),t)break;if(!t)return[n];const r=await n.resolve(e);return e.log("resolved %s to",n,r.map(s=>s.toString())),r}const hs={addressSorter:Pa,maxParallelDials:Df,maxDialQueueLength:Cf,maxPeerAddrsToDial:Sf,dialTimeout:Af};class n1{constructor(e,t={}){f(this,"queue");f(this,"components");f(this,"addressSorter");f(this,"maxPeerAddrsToDial");f(this,"maxDialQueueLength");f(this,"dialTimeout");f(this,"shutDownController");f(this,"connections");f(this,"log");this.addressSorter=t.addressSorter??hs.addressSorter,this.maxPeerAddrsToDial=t.maxPeerAddrsToDial??hs.maxPeerAddrsToDial,this.maxDialQueueLength=t.maxDialQueueLength??hs.maxDialQueueLength,this.dialTimeout=t.dialTimeout??hs.dialTimeout,this.connections=t.connections??new ts,this.log=e.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=e,this.shutDownController=new AbortController,Se(1/0,this.shutDownController.signal);for(const[r,s]of Object.entries(t.resolvers??{}))va.set(r,s);this.queue=new e1({concurrency:t.maxParallelDials??hs.maxParallelDials,metricName:"libp2p_dial_queue",metrics:e.metrics}),this.queue.addEventListener("error",r=>{this.log.error("error in dial queue",r.detail)})}start(){this.shutDownController=new AbortController,Se(1/0,this.shutDownController.signal)}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(e,t={}){var a,c,l;const{peerId:r,multiaddrs:s}=vf(e),i=Array.from(this.connections.values()).flat().find(u=>t.force===!0?!1:u.remotePeer.equals(r)?!0:s.find(h=>h.equals(u.remoteAddr)));if(i!=null)return this.log("already connected to %a",i.remoteAddr),(a=t.onProgress)==null||a.call(t,new at("dial-queue:already-connected")),i;const o=this.queue.queue.find(u=>{if((r==null?void 0:r.equals(u.options.peerId))===!0)return!0;const h=u.options.multiaddrs;if(h==null)return!1;for(const g of s)if(h.has(g.toString()))return!0;return!1});if(o!=null){this.log("joining existing dial target for %p",r);for(const u of s)o.options.multiaddrs.add(u.toString());return(c=t.onProgress)==null||c.call(t,new at("dial-queue:already-in-dial-queue")),o.join(t)}if(this.queue.size>=this.maxDialQueueLength)throw new R("Dial queue is full","ERR_DIAL_QUEUE_FULL");return this.log("creating dial target for %p",r,s.map(u=>u.toString())),(l=t.onProgress)==null||l.call(t,new at("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var y,m;(y=u==null?void 0:u.onProgress)==null||y.call(u,new at("dial-queue:start-dial"));const h=this.createDialAbortController(u==null?void 0:u.signal);let g;try{g=await this.calculateMultiaddrs(r,u==null?void 0:u.multiaddrs,{...u,signal:h}),(m=u==null?void 0:u.onProgress)==null||m.call(u,new at("dial-queue:calculated-addresses",g)),g.map(({multiaddr:d})=>d.toString()).forEach(d=>{u==null||u.multiaddrs.add(d)})}catch(d){throw h.clear(),d}try{let d=0;const p=[];for(const b of g){if(d===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",d,r),new R("Peer had more than maxPeerAddrsToDial",H.ERR_TOO_MANY_ADDRESSES);d++;try{const v=await this.components.transportManager.dial(b.multiaddr,{...u,signal:h});return this.log("dial to %a succeeded",b.multiaddr),v}catch(v){if(this.log.error("dial failed to %a",b.multiaddr,v),r!=null)try{await this.components.peerStore.patch(r,{metadata:{[Tf]:z(Date.now().toString())}})}catch(w){this.log.error("could not update last dial failure key for %p",r,w)}if(h.aborted)throw new R(v.message,gc);p.push(v)}}throw p.length===1?p[0]:new pg(p,"All multiaddr dials failed",H.ERR_TRANSPORT_DIAL_FAILED)}finally{h.clear()}},{peerId:r,priority:t.priority??Pf,multiaddrs:new Set(s.map(u=>u.toString())),signal:t.signal,onProgress:t.onProgress})}createDialAbortController(e){const t=ki([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,e]);return Se(1/0,t),t}async calculateMultiaddrs(e,t=new Set,r={}){var h,g;const s=[...t].map(y=>({multiaddr:xe(y),isCertified:!1}));if(e!=null){if(this.components.peerId.equals(e))throw new R("Tried to dial self",H.ERR_DIALED_SELF);if(await((g=(h=this.components.connectionGater).denyDialPeer)==null?void 0:g.call(h,e))===!0)throw new R("The dial request is blocked by gater.allowDialPeer",H.ERR_PEER_DIAL_INTERCEPTED);if(s.length===0){this.log("loading multiaddrs for %p",e);try{const y=await this.components.peerStore.get(e);s.push(...y.addresses),this.log("loaded multiaddrs for %p",e,s.map(({multiaddr:m})=>m.toString()))}catch(y){if(y.code!==H.ERR_NOT_FOUND)throw y}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",e);try{const y=await this.components.peerRouting.findPeer(e);this.log("found multiaddrs for %p in the peer routing",e,s.map(({multiaddr:m})=>m.toString())),s.push(...y.multiaddrs.map(m=>({multiaddr:m,isCertified:!1})))}catch(y){y.code!==H.ERR_NO_ROUTERS_AVAILABLE&&this.log.error("looking up multiaddrs for %p in the peer routing failed",e,y)}}}let i=(await Promise.all(s.map(async y=>{const m=await t1(y.multiaddr,{dns:this.components.dns,...r,log:this.log});return m.length===1&&m[0].equals(y.multiaddr)?y:m.map(d=>({multiaddr:d,isCertified:!1}))}))).flat();if(e!=null){const y=`/p2p/${e.toString()}`;i=i.map(m=>{const d=m.multiaddr.protos().pop();return(d==null?void 0:d.path)===!0?m:m.multiaddr.getPeerId()==null?{multiaddr:m.multiaddr.encapsulate(y),isCertified:m.isCertified}:m})}const o=i.filter(y=>{if(this.components.transportManager.dialTransportForMultiaddr(y.multiaddr)==null)return!1;const m=y.multiaddr.getPeerId();return e!=null&&m!=null?e.equals(m):!0}),a=new Map;for(const y of o){const m=y.multiaddr.toString(),d=a.get(m);if(d!=null){d.isCertified=d.isCertified||y.isCertified||!1;continue}a.set(m,y)}const c=[...a.values()];if(c.length===0)throw new R("The dial request has no valid addresses",H.ERR_NO_VALID_ADDRESSES);const l=[];for(const y of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(y.multiaddr)||l.push(y);const u=l.sort(this.addressSorter);if(u.length===0)throw new R("The connection gater denied all addresses in the dial request",H.ERR_NO_VALID_ADDRESSES);return this.log.trace("addresses for %p before filtering",e??"unknown peer",i.map(({multiaddr:y})=>y.toString())),this.log.trace("addresses for %p after filtering",e??"unknown peer",u.map(({multiaddr:y})=>y.toString())),u}async isDialable(e,t={}){Array.isArray(e)||(e=[e]);try{const r=await this.calculateMultiaddrs(void 0,new Set(e.map(s=>s.toString())),t);return t.runOnTransientConnection===!1?r.find(s=>!Oa.matches(s.multiaddr))!=null:!0}catch(r){this.log.trace("error calculating if multiaddr(s) were dialable",r)}return!1}}const Pf=50,Gt={minConnections:Nf,maxConnections:Lf,inboundConnectionThreshold:YE,maxIncomingPendingConnections:jE,autoDialConcurrency:xf,autoDialPriority:Rf,autoDialMaxQueueLength:If,autoDialPeerRetryThreshold:Bf,autoDialDiscoveredPeersDebounce:kf};zd=Symbol.toStringTag;class r1{constructor(e,t={}){f(this,"started");f(this,"connections");f(this,"allow");f(this,"deny");f(this,"maxIncomingPendingConnections");f(this,"incomingPendingConnections");f(this,"maxConnections");f(this,"dialQueue");f(this,"autoDial");f(this,"connectionPruner");f(this,"inboundConnectionRateLimiter");f(this,"peerStore");f(this,"metrics");f(this,"events");f(this,"log");f(this,zd,"@libp2p/connection-manager");this.maxConnections=t.maxConnections??Gt.maxConnections;const r=t.minConnections??Gt.minConnections;if(this.maxConnections<r)throw new R("Connection Manager maxConnections must be greater than minConnections",H.ERR_INVALID_PARAMETERS);this.connections=new ts,this.started=!1,this.peerStore=e.peerStore,this.metrics=e.metrics,this.events=e.events,this.log=e.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),this.allow=(t.allow??[]).map(s=>xe(s)),this.deny=(t.deny??[]).map(s=>xe(s)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=t.maxIncomingPendingConnections??Gt.maxIncomingPendingConnections,this.inboundConnectionRateLimiter=new VE({points:t.inboundConnectionThreshold??Gt.inboundConnectionThreshold,duration:1}),this.autoDial=new XE({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{minConnections:r,autoDialConcurrency:t.autoDialConcurrency??Gt.autoDialConcurrency,autoDialPriority:t.autoDialPriority??Gt.autoDialPriority,autoDialPeerRetryThreshold:t.autoDialPeerRetryThreshold??Gt.autoDialPeerRetryThreshold,autoDialDiscoveredPeersDebounce:t.autoDialDiscoveredPeersDebounce??Gt.autoDialDiscoveredPeersDebounce,maxQueueLength:t.autoDialMaxQueueLength??Gt.autoDialMaxQueueLength}),this.connectionPruner=new JE({connectionManager:this,peerStore:e.peerStore,events:e.events,logger:e.logger},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new n1(e,{addressSorter:t.addressSorter??Pa,maxParallelDials:t.maxParallelDials??Df,maxDialQueueLength:t.maxDialQueueLength??Cf,maxPeerAddrsToDial:t.maxPeerAddrsToDial??Sf,dialTimeout:t.dialTimeout??Af,resolvers:t.resolvers??{dnsaddr:pf},connections:this.connections})}isStarted(){return this.started}async start(){var e,t,r;(e=this.metrics)==null||e.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,outbound:0};for(const i of this.connections.values())for(const o of i)o.direction==="inbound"?s.inbound++:s.outbound++;return s}}),(t=this.metrics)==null||t.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(r=this.metrics)==null||r.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const l of a.streams){const u=`${l.direction} ${l.protocol??"unnegotiated"}`;c[u]=(c[u]??0)+1}for(const[l,u]of Object.entries(c))s[l]=s[l]??[],s[l].push(u)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((l,u)=>l-u);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.dialQueue.start(),this.autoDial.start(),this.started=!0,this.log("started")}async afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[t=>t.tags.has(gg)]});await Promise.all(e.map(async t=>{await this.openConnection(t.id).catch(r=>{this.log.error(r)})}))}).catch(e=>{this.log.error(e)}),this.autoDial.afterStart()}async stop(){this.dialQueue.stop(),this.autoDial.stop();const e=[];for(const t of this.connections.values())for(const r of t)e.push((async()=>{try{await r.close()}catch(s){this.log.error(s)}})());this.log("closing %d connections",e.length),await Promise.all(e),this.connections.clear(),this.log("stopped")}onConnect(e){this._onConnect(e).catch(t=>{this.log.error(t)})}async _onConnect(e){const{detail:t}=e;if(!this.started){await t.close();return}const r=t.remotePeer,s=this.connections.get(r);let i=!1;s!=null?s.push(t):(i=!0,this.connections.set(r,[t])),r.publicKey!=null&&r.type==="RSA"&&await this.peerStore.patch(r,{publicKey:r.publicKey}),i&&this.events.safeDispatchEvent("peer:connect",{detail:t.remotePeer})}onDisconnect(e){const{detail:t}=e;if(!this.started)return;const r=t.remotePeer;let s=this.connections.get(r);s!=null&&s.length>1?(s=s.filter(i=>i.id!==t.id),this.connections.set(r,s)):s!=null&&(this.connections.delete(r),this.events.safeDispatchEvent("peer:disconnect",{detail:t.remotePeer}))}getConnections(e){if(e!=null)return this.connections.get(e)??[];let t=[];for(const r of this.connections.values())t=t.concat(r);return t}getConnectionsMap(){return this.connections}async openConnection(e,t={}){var a,c;if(!this.isStarted())throw new R("Not started",H.ERR_NODE_NOT_STARTED);(a=t.signal)==null||a.throwIfAborted();const{peerId:r}=vf(e);if(r!=null&&t.force!==!0){this.log("dial %p",r);const l=this.getConnections(r).find(u=>!u.transient);if(l!=null)return this.log("had an existing non-transient connection to %p",r),(c=t.onProgress)==null||c.call(t,new at("dial-queue:already-connected")),l}const s=await this.dialQueue.dial(e,{...t,priority:t.priority??Pf});let i=this.connections.get(s.remotePeer);i==null&&(i=[],this.connections.set(s.remotePeer,i));let o=!1;for(const l of i)l.id===s.id&&(o=!0);return o||i.push(s),s}async closeConnections(e,t={}){const r=this.connections.get(e)??[];await Promise.all(r.map(async s=>{try{await s.close(t)}catch(i){s.abort(i)}}))}async acceptIncomingConnection(e){if(this.deny.some(s=>e.remoteAddr.toString().startsWith(s.toString())))return this.log("connection from %a refused - connection remote address was in deny list",e.remoteAddr),!1;if(this.allow.some(s=>e.remoteAddr.toString().startsWith(s.toString())))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",e.remoteAddr),!1;if(e.remoteAddr.isThinWaistAddress()){const s=e.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(s,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",e.remoteAddr,s),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",e.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const e={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(t=>({id:t.id,status:e[t.status],peerId:t.options.peerId,multiaddrs:[...t.options.multiaddrs].map(r=>xe(r))}))}async isDialable(e,t={}){return this.dialQueue.isDialable(e,t)}}class Fa{constructor(e){f(this,"movingAverage");f(this,"variance");f(this,"deviation");f(this,"forecast");f(this,"timespan");f(this,"previousTime");this.timespan=e,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(e,t){return 1-Math.exp(-(e-t)/this.timespan)}push(e,t=Date.now()){if(this.previousTime!=null){const r=this.alpha(t,this.previousTime),s=e-this.movingAverage,i=r*s;this.movingAverage=r*e+(1-r)*this.movingAverage,this.variance=(1-r)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+r*s}else this.movingAverage=e;this.previousTime=t}}const s1=1.2,i1=2,o1=2e3;class a1{constructor(e={}){f(this,"success");f(this,"failure");f(this,"next");f(this,"metric");f(this,"timeoutMultiplier");f(this,"failureMultiplier");f(this,"minTimeout");var t;this.success=new Fa(e.interval??5e3),this.failure=new Fa(e.interval??5e3),this.next=new Fa(e.interval??5e3),this.failureMultiplier=e.failureMultiplier??i1,this.timeoutMultiplier=e.timeoutMultiplier??s1,this.minTimeout=e.minTimeout??o1,e.metricName!=null&&(this.metric=(t=e.metrics)==null?void 0:t.registerMetricGroup(e.metricName))}getTimeoutSignal(e={}){const t=Math.max(Math.round(this.next.movingAverage*(e.timeoutFactor??this.timeoutMultiplier)),this.minTimeout),r=AbortSignal.timeout(t),s=ki([e.signal,r]);return Se(1/0,s,r),s.start=Date.now(),s.timeout=t,s}cleanUp(e){var r,s;const t=Date.now()-e.start;e.aborted?(this.failure.push(t),this.next.push(t*this.failureMultiplier),(r=this.metric)==null||r.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:t})):(this.success.push(t),this.next.push(t),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:t}))}}let c1=class{constructor(){f(this,"readNext");f(this,"haveNext");f(this,"ended");f(this,"nextResult");this.ended=!1,this.readNext=ye(),this.haveNext=ye()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=ye(),e}async throw(e){return this.ended=!0,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=ye(),await Ct(this.readNext.promise,t==null?void 0:t.signal,t)}};function l1(){return new c1}let u1=class extends Error{constructor(){super(...arguments);f(this,"name","UnexpectedEOFError");f(this,"code","ERR_UNEXPECTED_EOF")}};class h1 extends Error{constructor(t,r){super(t);f(this,"code");this.code=r}}class f1 extends h1{constructor(t){super(t,"ABORT_ERR");f(this,"type");this.type="aborted",this.name="AbortError"}}function Uf(n,e){const t=l1();n.sink(t).catch(async o=>{await t.end(o)}),n.sink=async o=>{for await(const a of o)await t.push(a);await t.end()};let r=n.source;n.source[Symbol.iterator]!=null?r=n.source[Symbol.iterator]():n.source[Symbol.asyncIterator]!=null&&(r=n.source[Symbol.asyncIterator]());const s=new Ee;return{read:async(o,a)=>{var u,h;(u=a==null?void 0:a.signal)==null||u.throwIfAborted();let c;const l=new Promise((g,y)=>{var m;c=()=>{y(new f1("Read aborted"))},(m=a==null?void 0:a.signal)==null||m.addEventListener("abort",c)});try{if(o==null){const{done:y,value:m}=await Promise.race([r.next(),l]);return y===!0?new Ee:m}for(;s.byteLength<o;){const{value:y,done:m}=await Promise.race([r.next(),l]);if(m===!0)throw new u1("unexpected end of input");s.append(y)}const g=s.sublist(0,o);return s.consume(o),g}finally{c!=null&&((h=a==null?void 0:a.signal)==null||h.removeEventListener("abort",c))}},write:async(o,a)=>{var c;(c=a==null?void 0:a.signal)==null||c.throwIfAborted(),o instanceof Uint8Array?await t.push(o,a):await t.push(o.subarray(),a)},unwrap:()=>{if(s.byteLength>0){const o=n.source;n.source=async function*(){(e==null?void 0:e.yieldBytes)===!1?yield s:yield*s,yield*o}()}return n}}}const d1=1e4,g1="1.0.0",p1="ping",y1="ipfs",Mf=32;Gd=Symbol.toStringTag,qd=ks;class m1{constructor(e,t={}){f(this,"protocol");f(this,"components");f(this,"log");f(this,"heartbeatInterval");f(this,"pingIntervalMs");f(this,"abortController");f(this,"timeout");f(this,Gd,"@libp2p/connection-monitor");f(this,qd,["@libp2p/connection-monitor"]);this.components=e,this.protocol=`/${t.protocolPrefix??y1}/${p1}/${g1}`,this.log=e.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=t.pingInterval??d1,this.timeout=new a1({...t.pingTimeout??{},metrics:e.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(e=>{Promise.resolve().then(async()=>{var r;let t=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(r=this.abortController)==null?void 0:r.signal}),i=await e.newStream(this.protocol,{signal:s,runOnTransientConnection:!0}),o=Uf(i);t=Date.now(),await Promise.all([o.write(Kr(Mf),{signal:s}),o.read(Mf,{signal:s})]),e.rtt=Date.now()-t,await o.unwrap().close({signal:s})}catch(s){if(s.code!=="ERR_UNSUPPORTED_PROTOCOL")throw s;e.rtt=(Date.now()-t)/2}}).catch(t=>{this.log.error("error during heartbeat, aborting connection",t),e.abort(t)})})},this.pingIntervalMs)}stop(){var e;(e=this.abortController)==null||e.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}class w1{constructor(){f(this,"readNext");f(this,"haveNext");f(this,"ended");f(this,"nextResult");f(this,"error");this.ended=!1,this.readNext=ye(),this.haveNext=ye()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const e=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=ye(),e}async throw(e){return this.ended=!0,this.error=e,e!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(e)),{done:!0,value:void 0}}async return(){const e={done:!0,value:void 0};return this.ended=!0,this.nextResult=e,this.haveNext.resolve(),e}async push(e,t){await this._push(e,t)}async end(e,t){e!=null?await this.throw(e):await this._push(void 0,t)}async _push(e,t){if(e!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;e!=null?this.nextResult={done:!1,value:e}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=ye(),await Ct(this.readNext.promise,t==null?void 0:t.signal,t)}}function b1(){return new w1}function E1(n){return n[Symbol.asyncIterator]!=null}async function v1(n,e,t){try{await Promise.all(n.map(async r=>{for await(const s of r)await e.push(s,{signal:t}),t.throwIfAborted()})),await e.end(void 0,{signal:t})}catch(r){await e.end(r,{signal:t}).catch(()=>{})}}async function*_1(n){const e=new AbortController,t=b1();v1(n,t,e.signal).catch(()=>{});try{yield*t}finally{e.abort()}}function*A1(n){for(const e of n)yield*e}function Ti(...n){const e=[];for(const t of n)E1(t)||e.push(t);return e.length===n.length?A1(e):_1(n)}Wd=Symbol.toStringTag;class S1{constructor(e,t){f(this,"routers");f(this,"started");f(this,"components");f(this,Wd,"@libp2p/content-routing");this.routers=t.routers??[],this.started=!1,this.components=e}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(e,t={}){if(this.routers.length===0)throw new R("No content routers available",H.ERR_NO_ROUTERS_AVAILABLE);const r=this,s=new Nn;for await(const i of Ti(...r.routers.map(o=>o.findProviders(e,t))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(e,t={}){if(this.routers.length===0)throw new R("No content routers available",H.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map(async r=>{await r.provide(e,t)}))}async put(e,t,r){if(!this.isStarted())throw new R(yr.NOT_STARTED_YET,H.ERR_NODE_NOT_STARTED);await Promise.all(this.routers.map(async s=>{await s.put(e,t,r)}))}async get(e,t){if(!this.isStarted())throw new R(yr.NOT_STARTED_YET,H.ERR_NODE_NOT_STARTED);return Promise.any(this.routers.map(async r=>r.get(e,t)))}}const Ci=globalThis.CustomEvent??Event;async function*x1(n,e={}){let t=e.concurrency??1/0;t<1&&(t=1/0);const r=e.ordered??!1,s=new EventTarget,i=[];let o=ye(),a=ye(),c=!1,l,u=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const m of n){if(i.length===t&&(o=ye(),await o.promise),u)break;const d={done:!1};i.push(d),m().then(p=>{d.done=!0,d.ok=!0,d.value=p,s.dispatchEvent(new Ci("task-complete"))},p=>{d.done=!0,d.err=p,s.dispatchEvent(new Ci("task-complete"))})}c=!0,s.dispatchEvent(new Ci("task-complete"))}catch(m){l=m,s.dispatchEvent(new Ci("task-complete"))}});function h(){var m;return r?(m=i[0])==null?void 0:m.done:!!i.find(d=>d.done)}function*g(){for(;i.length>0&&i[0].done;){const m=i[0];if(i.shift(),m.ok)yield m.value;else throw u=!0,o.resolve(),m.err;o.resolve()}}function*y(){for(;h();)for(let m=0;m<i.length;m++)if(i[m].done){const d=i[m];if(i.splice(m,1),m--,d.ok)yield d.value;else throw u=!0,o.resolve(),d.err;o.resolve()}}for(;;){if(h()||(a=ye(),await a.promise),l!=null||(r?yield*g():yield*y(),l!=null))throw l;if(c&&i.length===0)break}}Yd=Symbol.toStringTag;class R1{constructor(e,t={}){f(this,"log");f(this,"peerId");f(this,"peerStore");f(this,"routers");f(this,Yd,"@libp2p/peer-routing");this.log=e.logger.forComponent("libp2p:peer-routing"),this.peerId=e.peerId,this.peerStore=e.peerStore,this.routers=t.routers??[]}async findPeer(e,t){if(this.routers.length===0)throw new R("No peer routers available",H.ERR_NO_ROUTERS_AVAILABLE);if(e.toString()===this.peerId.toString())throw new R("Should not try to find self",H.ERR_FIND_SELF);const r=this,s=Ti(...this.routers.map(i=>async function*(){try{yield await i.findPeer(e,t)}catch(o){r.log.error(o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),i;throw new R(yr.NOT_FOUND,H.ERR_NOT_FOUND)}async*getClosestPeers(e,t={}){if(this.routers.length===0)throw new R("No peer routers available",H.ERR_NO_ROUTERS_AVAILABLE);const r=this,s=Vw(1024);for await(const i of x1(async function*(){const o=Ti(...r.routers.map(a=>a.getClosestPeers(e,t)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await r.findPeer(a.id,{...t,useCache:!1})}catch(c){r.log.error("could not find peer multiaddrs",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs}),!s.has(i.id.toBytes())&&(s.add(i.id.toBytes()),yield i))}}class I1 extends(Xd=Is,jd=Symbol.toStringTag,Xd){constructor(t){super();f(this,"peerRouting");f(this,"log");f(this,"walking");f(this,"walkers");f(this,"shutdownController");f(this,"walkController");f(this,"needNext");f(this,jd,"@libp2p/random-walk");this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,Se(1/0,this.shutdownController.signal)}start(){this.shutdownController=new AbortController,Se(1/0,this.shutdownController.signal)}stop(){this.shutdownController.abort()}async*walk(t){var s,i;this.walking||this.startWalk(),this.walkers++;const r=ki([this.shutdownController.signal,t==null?void 0:t.signal]);Se(1/0,r);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=ye(),yield(await Bn(this,"walk:peer",r,{errorEvent:"walk:error"})).detail}finally{r.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,Se(1/0,this.walkController.signal);const t=ki([this.walkController.signal,this.shutdownController.signal]);Se(1/0,t);const r=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Kr(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Ct(this.needNext.promise,t)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("randomwalk errored",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("randomwalk errored",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-r),this.walking=!1})}}const Ff=32,Vf=64;Zd=Symbol.toStringTag;class k1{constructor(e){f(this,"log");f(this,"topologies");f(this,"handlers");f(this,"components");f(this,Zd,"@libp2p/registrar");this.log=e.logger.forComponent("libp2p:registrar"),this.topologies=new Map,this.handlers=new Map,this.components=e,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(e){const t=this.handlers.get(e);if(t==null)throw new R(`No handler registered for protocol ${e}`,H.ERR_NO_HANDLER_FOR_PROTOCOL);return t}getTopologies(e){const t=this.topologies.get(e);return t==null?[]:[...t.values()]}async handle(e,t,r){if(this.handlers.has(e))throw new R(`Handler already registered for protocol ${e}`,H.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const s=bf.bind({ignoreUndefined:!0})({maxInboundStreams:Ff,maxOutboundStreams:Vf},r);this.handlers.set(e,{handler:t,options:s}),await this.components.peerStore.merge(this.components.peerId,{protocols:[e]})}async unhandle(e){(Array.isArray(e)?e:[e]).forEach(r=>{this.handlers.delete(r)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()})}async register(e,t){if(t==null)throw new R("invalid topology",H.ERR_INVALID_PARAMETERS);const r=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(e);return s==null&&(s=new Map,this.topologies.set(e,s)),s.set(r,t),r}unregister(e){for(const[t,r]of this.topologies.entries())r.has(e)&&(r.delete(e),r.size===0&&this.topologies.delete(t))}_onDisconnect(e){const t=e.detail;this.components.peerStore.get(t).then(r=>{var s,i,o;for(const a of r.protocols){const c=this.topologies.get(a);if(c!=null)for(const l of c.values())((s=l.filter)==null?void 0:s.has(t))!==!1&&((i=l.filter)==null||i.remove(t),(o=l.onDisconnect)==null||o.call(l,t))}}).catch(r=>{r.code!==H.ERR_NOT_FOUND&&this.log.error("could not inform topologies of disconnecting peer %p",t,r)})}_onPeerUpdate(e){var i,o,a;const{peer:t,previous:r}=e.detail,s=((r==null?void 0:r.protocols)??[]).filter(c=>!t.protocols.includes(c));for(const c of s){const l=this.topologies.get(c);if(l!=null)for(const u of l.values())((i=u.filter)==null?void 0:i.has(t.id))!==!1&&((o=u.filter)==null||o.remove(t.id),(a=u.onDisconnect)==null||a.call(u,t.id))}}_onPeerIdentify(e){var i,o,a;const t=e.detail.protocols,r=e.detail.connection,s=e.detail.peerId;for(const c of t){const l=this.topologies.get(c);if(l!=null)for(const u of l.values())r.transient&&u.notifyOnTransient!==!0||((i=u.filter)==null?void 0:i.has(s))!==!0&&((o=u.filter)==null||o.add(s),(a=u.onConnect)==null||a.call(u,s,r))}}}class T1 extends Map{constructor(t){super();f(this,"metric");const{name:r,metrics:s}=t;this.metric=s.registerMetric(r),this.updateComponentMetric()}set(t,r){return super.set(t,r),this.updateComponentMetric(),this}delete(t){const r=super.delete(t);return this.updateComponentMetric(),r}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function C1(n){const{name:e,metrics:t}=n;let r;return t!=null?r=new T1({name:e,metrics:t}):r=new Map,r}Qd=Symbol.toStringTag;class N1{constructor(e,t={}){f(this,"log");f(this,"components");f(this,"transports");f(this,"listeners");f(this,"faultTolerance");f(this,"started");f(this,Qd,"@libp2p/transport-manager");this.log=e.logger.forComponent("libp2p:transports"),this.components=e,this.started=!1,this.transports=new Map,this.listeners=C1({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=t.faultTolerance??Vn.FATAL_ALL}add(e){const t=e[Symbol.toStringTag];if(t==null)throw new R("Transport must have a valid tag",H.ERR_INVALID_KEY);if(this.transports.has(t))throw new R(`There is already a transport with the tag ${t}`,H.ERR_DUPLICATE_TRANSPORT);this.log("adding transport %s",t),this.transports.set(t,e),this.listeners.has(t)||this.listeners.set(t,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const e=this.components.addressManager.getListenAddrs();await this.listen(e)}async stop(){const e=[];for(const[t,r]of this.listeners)for(this.log("closing listeners for %s",t);r.length>0;){const s=r.pop();s!=null&&e.push(s.close())}await Promise.all(e),this.log("all listeners closed");for(const t of this.listeners.keys())this.listeners.set(t,[]);this.started=!1}async dial(e,t){var s;const r=this.dialTransportForMultiaddr(e);if(r==null)throw new R(`No transport available for address ${String(e)}`,H.ERR_TRANSPORT_UNAVAILABLE);(s=t==null?void 0:t.onProgress)==null||s.call(t,new at("transport-manager:selected-transport",r[Symbol.toStringTag]));try{return await r.dial(e,{...t,upgrader:this.components.upgrader})}catch(i){throw i.code==null&&(i.code=H.ERR_TRANSPORT_DIAL_FAILED),i}}getAddrs(){let e=[];for(const t of this.listeners.values())for(const r of t)e=[...e,...r.getAddrs()];return e}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(e){for(const t of this.transports.values())if(t.dialFilter([e]).length>0)return t}listenTransportForMultiaddr(e){for(const t of this.transports.values())if(t.listenFilter([e]).length>0)return t}async listen(e){if(!this.isStarted())throw new R("Not started",H.ERR_NODE_NOT_STARTED);if(e==null||e.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const t=[];for(const[r,s]of this.transports.entries()){const i=s.listenFilter(e),o=[];for(const l of i){this.log("creating listener for %s on %a",r,l);const u=s.createListener({upgrader:this.components.upgrader});let h=this.listeners.get(r)??[];h==null&&(h=[],this.listeners.set(r,h)),h.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const g=h.findIndex(y=>y===u);h.splice(g,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),o.push(u.listen(l))}if(o.length===0){t.push(r);continue}if((await Promise.allSettled(o)).find(l=>l.status==="fulfilled")==null&&this.faultTolerance!==Vn.NO_FATAL)throw new R(`Transport (${r}) could not listen on any available address`,H.ERR_NO_VALID_ADDRESSES)}if(t.length===this.transports.size){const r=`no valid addresses were provided for transports [${t.join(", ")}]`;if(this.faultTolerance===Vn.FATAL_ALL)throw new R(r,H.ERR_NO_VALID_ADDRESSES);this.log(`libp2p in dial mode only: ${r}`)}}async remove(e){const t=this.listeners.get(e)??[];this.log.trace("removing transport %s",e);const r=[];for(this.log.trace("closing listeners for %s",e);t.length>0;){const s=t.pop();s!=null&&r.push(s.close())}await Promise.all(r),this.transports.delete(e),this.listeners.delete(e)}async removeAll(){const e=[];for(const t of this.transports.keys())e.push(this.remove(t));await Promise.all(e)}}const Xe="/multistream/1.0.0",Va=1024;let L1=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidMessageLengthError");f(this,"code","ERR_INVALID_MSG_LENGTH")}},D1=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}},B1=class extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthLengthError");f(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function mr(n,e={}){const t=Uf(n,e);e.maxDataLength!=null&&e.maxLengthLength==null&&(e.maxLengthLength=ut(e.maxDataLength));const r=(e==null?void 0:e.lengthDecoder)??js,s=(e==null?void 0:e.lengthEncoder)??Qn;return{read:async o=>{let a=-1;const c=new Ee;for(;;){c.append(await t.read(1,o));try{a=r(c)}catch(l){if(l instanceof RangeError)continue;throw l}if(a<0)throw new L1("Invalid message length");if((e==null?void 0:e.maxLengthLength)!=null&&c.byteLength>e.maxLengthLength)throw new B1("message length length too long");if(a>-1)break}if((e==null?void 0:e.maxDataLength)!=null&&a>e.maxDataLength)throw new D1("message length too long");return t.read(a,o)},write:async(o,a)=>{await t.write(new Ee(s(o.byteLength),o),a)},writeV:async(o,a)=>{const c=new Ee(...o.flatMap(l=>[s(l.byteLength),l]));await t.write(c,a)},unwrap:()=>t.unwrap()}}const O1=z(`
`);async function fs(n,e,t){await n.write(e,t)}async function P1(n,e,t){await n.writeV(e,t)}async function U1(n,e){const t=await n.read(e);if(t.byteLength===0||t.get(t.byteLength-1)!==O1[0])throw e.log.error("Invalid mss message - missing newline",t),new R("missing newline","ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");return t.sublist(0,-1)}async function wr(n,e){const t=await U1(n,e);return j(t.subarray())}async function $a(n,e,t){if(e=Array.isArray(e)?[...e]:[e],e.length===1&&t.negotiateFully===!1)return M1(n,e[0],t);const r=mr(n,{...t,maxDataLength:Va}),s=e.shift();if(s==null)throw new Error("At least one protocol must be specified");t.log.trace('select: write ["%s", "%s"]',Xe,s);const i=z(`${Xe}
`),o=z(`${s}
`);await P1(r,[i,o],t),t.log.trace("select: reading multistream-select header");let a=await wr(r,t);if(t.log.trace('select: read "%s"',a),a===Xe&&(t.log.trace("select: reading protocol response"),a=await wr(r,t),t.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const c of e){t.log.trace('select: write "%s"',c),await fs(r,z(`${c}
`),t),t.log.trace("select: reading protocol response");const l=await wr(r,t);if(t.log.trace('select: read "%s" for "%s"',l,c),l===c)return{stream:r.unwrap(),protocol:c}}throw new R("protocol selection failed","ERR_UNSUPPORTED_PROTOCOL")}function M1(n,e,t){const r=n.sink.bind(n),s=n.source;let i=!1,o=!1;const a=ye();let c=!1,l=!1;const u=ye();let h=!1,g=!1;const y=ye(),m=mr({sink:r,source:s},{...t,maxDataLength:Va});n.sink=async v=>{const{sink:w}=m.unwrap();await w(async function*(){let E=!1;for await(const A of v){if(l&&await u.promise,c)yield A;else{l=!0,t.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Xe,e,A.byteLength);const S=`${e}
`;yield new Ee(Uint8Array.from([19]),z(`${Xe}
`),Qn(S.length),z(S),A).subarray(),t.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Xe,e,A.byteLength),c=!0,l=!1,u.resolve(),d().catch(k=>{t.log.error("could not finish optimistic protocol negotiation of %s",e,k)})}E=!0}E||await d()}())};async function d(){if(o){t.log.trace("optimistic: already negotiating %s stream",e),await a.promise;return}o=!0;try{c||(t.log.trace("optimistic: doing send protocol for %s stream",e),await p()),h||(t.log.trace("optimistic: doing read protocol for %s stream",e),await b())}finally{o=!1,i=!0,a.resolve()}}async function p(){if(l){await u.promise;return}l=!0;try{t.log.trace('optimistic: write ["%s", "%s", data] in source',Xe,e),await m.writeV([z(`${Xe}
`),z(`${e}
`)]),t.log.trace('optimistic: wrote ["%s", "%s", data] in source',Xe,e)}finally{c=!0,l=!1,u.resolve()}}async function b(){if(g){await y.promise;return}g=!0;try{t.log.trace("optimistic: reading multistream select header");let v=await wr(m,t);if(t.log.trace('optimistic: read multistream select header "%s"',v),v===Xe&&(v=await wr(m,t)),t.log.trace('optimistic: read protocol "%s", expecting "%s"',v,e),v!==e)throw new R("protocol selection failed","ERR_UNSUPPORTED_PROTOCOL")}finally{h=!0,g=!1,y.resolve()}}if(n.source=async function*(){await d(),t.log.trace('optimistic: reading data from "%s" stream',e),yield*m.unwrap().source}(),n.closeRead!=null){const v=n.closeRead.bind(n);n.closeRead=async w=>{i||await d().catch(E=>{t.log.error("could not negotiate protocol before close read",E)}),await v(w)}}if(n.closeWrite!=null){const v=n.closeWrite.bind(n);n.closeWrite=async w=>{i||await d().catch(E=>{t.log.error("could not negotiate protocol before close write",E)}),await v(w)}}if(n.close!=null){const v=n.close.bind(n);n.close=async w=>{const E=[];l&&E.push(u.promise),g&&E.push(y.promise),E.length>0?await Ct(Promise.all(E),w==null?void 0:w.signal):(i=!0,o=!1,a.resolve()),await v(w)}}return{stream:n,protocol:e}}function $f(n){return n[Symbol.asyncIterator]!=null}const Ni=n=>{const e=ut(n),t=vt(e);return Qn(n,t),Ni.bytes=e,t};Ni.bytes=0;function Hf(n,e){e=e??{};const t=e.lengthEncoder??Ni;function*r(s){const i=t(s.byteLength);i instanceof Uint8Array?yield i:yield*i,s instanceof Uint8Array?yield s:yield*s}return $f(n)?async function*(){for await(const s of n)yield*r(s)}():function*(){for(const s of n)yield*r(s)}()}Hf.single=(n,e)=>{e=e??{};const t=e.lengthEncoder??Ni;return new Ee(t(n.byteLength),n)};class F1 extends Error{constructor(){super(...arguments);f(this,"name","InvalidMessageLengthError");f(this,"code","ERR_INVALID_MSG_LENGTH")}}class V1 extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthError");f(this,"code","ERR_MSG_DATA_TOO_LONG")}}class $1 extends Error{constructor(){super(...arguments);f(this,"name","InvalidDataLengthLengthError");f(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class Kf extends Error{constructor(){super(...arguments);f(this,"name","UnexpectedEOFError");f(this,"code","ERR_UNEXPECTED_EOF")}}const H1=8,K1=1024*1024*4;var Mn;(function(n){n[n.LENGTH=0]="LENGTH",n[n.DATA=1]="DATA"})(Mn||(Mn={}));const Ha=n=>{const e=js(n);return Ha.bytes=ut(e),e};Ha.bytes=0;function Ka(n,e){const t=new Ee;let r=Mn.LENGTH,s=-1;const i=(e==null?void 0:e.lengthDecoder)??Ha,o=(e==null?void 0:e.maxLengthLength)??H1,a=(e==null?void 0:e.maxDataLength)??K1;function*c(){for(;t.byteLength>0;){if(r===Mn.LENGTH)try{if(s=i(t),s<0)throw new F1("Invalid message length");if(s>a)throw new V1("Message length too long");const l=i.bytes;t.consume(l),(e==null?void 0:e.onLength)!=null&&e.onLength(s),r=Mn.DATA}catch(l){if(l instanceof RangeError){if(t.byteLength>o)throw new $1("Message length length too long");break}throw l}if(r===Mn.DATA){if(t.byteLength<s)break;const l=t.sublist(0,s);t.consume(s),(e==null?void 0:e.onData)!=null&&e.onData(l),yield l,r=Mn.LENGTH}}}return $f(n)?async function*(){for await(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new Kf("Unexpected end of input")}():function*(){for(const l of n)t.append(l),yield*c();if(t.byteLength>0)throw new Kf("Unexpected end of input")}()}Ka.fromReader=(n,e)=>{let t=1;const r=async function*(){for(;;)try{const{done:i,value:o}=await n.next(t);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{t=1}}();return Ka(r,{...e??{},onLength:i=>{t=i}})};async function za(n,e,t){e=Array.isArray(e)?e:[e],t.log.trace("handle: available protocols %s",e);const r=mr(n,{...t,maxDataLength:Va,maxLengthLength:2});for(;;){t.log.trace("handle: reading incoming string");const s=await wr(r,t);if(t.log.trace('handle: read "%s"',s),s===Xe){t.log.trace('handle: respond with "%s" for "%s"',Xe,s),await fs(r,z(`${Xe}
`),t),t.log.trace('handle: responded with "%s" for "%s"',Xe,s);continue}if(e.includes(s))return t.log.trace('handle: respond with "%s" for "%s"',s,s),await fs(r,z(`${s}
`),t),t.log.trace('handle: responded with "%s" for "%s"',s,s),{stream:r.unwrap(),protocol:s};if(s==="ls"){const i=new Ee(...e.map(o=>Hf.single(z(`${o}
`))),z(`
`));t.log.trace('handle: respond with "%s" for %s',e,s),await fs(r,i,t),t.log.trace('handle: responded with "%s" for %s',e,s);continue}t.log('handle: respond with "na" for "%s"',s),await fs(r,z(`na
`),t),t.log('handle: responded with "na" for "%s"',s)}}const z1=500;eg=Symbol.toStringTag,Jd=oe;class q1{constructor(e){f(this,"id");f(this,"remoteAddr");f(this,"remotePeer");f(this,"direction");f(this,"timeline");f(this,"multiplexer");f(this,"encryption");f(this,"status");f(this,"transient");f(this,"log");f(this,"tags");f(this,"_newStream");f(this,"_close");f(this,"_abort");f(this,"_getStreams");f(this,eg,"Connection");f(this,Jd,!0);const{remoteAddr:t,remotePeer:r,newStream:s,close:i,abort:o,getStreams:a}=e;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=t,this.remotePeer=r,this.direction=e.direction,this.status="open",this.timeline=e.timeline,this.multiplexer=e.multiplexer,this.encryption=e.encryption,this.transient=e.transient??!1,this.log=e.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),this.remoteAddr.getPeerId()==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=s,this._close=i,this._abort=o,this._getStreams=a,this.tags=[]}get streams(){return this._getStreams()}async newStream(e,t){if(this.status==="closing")throw new R("the connection is being closed","ERR_CONNECTION_BEING_CLOSED");if(this.status==="closed")throw new R("the connection is closed","ERR_CONNECTION_CLOSED");if(Array.isArray(e)||(e=[e]),this.transient&&(t==null?void 0:t.runOnTransientConnection)!==!0)throw new R("Cannot open protocol stream on transient connection","ERR_TRANSIENT_CONNECTION");const r=await this._newStream(e,t);return r.direction="outbound",r}async close(e={}){if(!(this.status==="closed"||this.status==="closing")){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",e.signal==null){const t=AbortSignal.timeout(z1);Se(1/0,t),e={...e,signal:t}}try{this.log.trace("closing all streams"),await Promise.all(this.streams.map(async t=>t.close(e))),this.log.trace("closing underlying transport"),await this._close(e),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(t){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,t),this.abort(t)}}}abort(e){this.log.error("aborting connection to %a due to error",this.remoteAddr,e),this.status="closing",this.streams.forEach(t=>{t.abort(e)}),this.log.error("all streams aborted",this.streams.length),this._abort(e),this.timeline.close=Date.now(),this.status="closed"}}function G1(n){return new q1(n)}const W1=3e4;function Y1(n,e){try{const{options:t}=e.getHandler(n);return t.maxInboundStreams}catch(t){if(t.code!==H.ERR_NO_HANDLER_FOR_PROTOCOL)throw t}return Ff}function j1(n,e,t={}){try{const{options:r}=e.getHandler(n);if(r.maxOutboundStreams!=null)return r.maxOutboundStreams}catch(r){if(r.code!==H.ERR_NO_HANDLER_FOR_PROTOCOL)throw r}return t.maxOutboundStreams??Vf}function zf(n,e,t){let r=0;return t.streams.forEach(s=>{s.direction===e&&s.protocol===n&&r++}),r}tg=Symbol.toStringTag;class X1{constructor(e,t){f(this,"components");f(this,"connectionEncryption");f(this,"muxers");f(this,"inboundUpgradeTimeout");f(this,"events");f(this,tg,"@libp2p/upgrader");this.components=e,this.connectionEncryption=new Map,t.connectionEncryption.forEach(r=>{this.connectionEncryption.set(r.protocol,r)}),this.muxers=new Map,t.muxers.forEach(r=>{this.muxers.set(r.protocol,r)}),this.inboundUpgradeTimeout=t.inboundUpgradeTimeout??GE,this.events=e.events}async shouldBlockConnection(e,t,r){const s=this.components.connectionGater[r];if(s!==void 0&&await s(e,t))throw new R(`The multiaddr connection is blocked by gater.${r}`,H.ERR_CONNECTION_INTERCEPTED)}async upgradeInbound(e,t){var h,g,y,m,d;if(!await this.components.connectionManager.acceptIncomingConnection(e))throw new R("connection denied",H.ERR_CONNECTION_DENIED);let s,i,o,a,c;const l=AbortSignal.timeout(this.inboundUpgradeTimeout),u=()=>{e.abort(new R("inbound upgrade timeout",gc))};l.addEventListener("abort",u,{once:!0}),Se(1/0,l);try{if(await((g=(h=this.components.connectionGater).denyInboundConnection)==null?void 0:g.call(h,e))===!0)throw new R("The multiaddr connection is blocked by gater.acceptConnection",H.ERR_CONNECTION_INTERCEPTED);(y=this.components.metrics)==null||y.trackMultiaddrConnection(e),e.log("starting the inbound connection upgrade");let p=e;if((t==null?void 0:t.skipProtection)!==!0){const b=this.components.connectionProtector;b!=null&&(e.log("protecting the inbound connection"),p=await b.protect(e))}try{if(s=p,(t==null?void 0:t.skipEncryption)!==!0){(m=t==null?void 0:t.onProgress)==null||m.call(t,new at("upgrader:encrypt-inbound-connection")),{conn:s,remotePeer:i,protocol:c}=await this._encryptInbound(p);const b={...p,...s};await this.shouldBlockConnection(i,b,"denyInboundEncryptedConnection")}else{const b=e.remoteAddr.getPeerId();if(b==null)throw new R("inbound connection that skipped encryption must have a peer id",H.ERR_INVALID_MULTIADDR);const v=st(b);c="native",i=v}if(o=s,(t==null?void 0:t.muxerFactory)!=null)a=t.muxerFactory;else if(this.muxers.size>0){(d=t==null?void 0:t.onProgress)==null||d.call(t,new at("upgrader:multiplex-inbound-connection"));const b=await this._multiplexInbound({...p,...s},this.muxers);a=b.muxerFactory,o=b.stream}}catch(b){throw e.log.error("failed to upgrade inbound connection",b),b}return await this.shouldBlockConnection(i,e,"denyInboundUpgradedConnection"),e.log("successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:c,direction:"inbound",maConn:e,upgradedConn:o,muxerFactory:a,remotePeer:i,transient:t==null?void 0:t.transient})}finally{l.removeEventListener("abort",u),this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(e,t){var h;const r=e.remoteAddr.getPeerId();let s;r!=null&&(s=st(r),await this.shouldBlockConnection(s,e,"denyOutboundConnection"));let i,o,a,c,l;(h=this.components.metrics)==null||h.trackMultiaddrConnection(e),e.log("starting the outbound connection upgrade");let u=e;if((t==null?void 0:t.skipProtection)!==!0){const g=this.components.connectionProtector;g!=null&&(u=await g.protect(e))}try{if(i=u,(t==null?void 0:t.skipEncryption)!==!0){({conn:i,remotePeer:o,protocol:c}=await this._encryptOutbound(u,s));const g={...u,...i};await this.shouldBlockConnection(o,g,"denyOutboundEncryptedConnection")}else{if(s==null)throw new R("Encryption was skipped but no peer id was passed",H.ERR_INVALID_PEER);c="native",o=s}if(a=i,(t==null?void 0:t.muxerFactory)!=null)l=t.muxerFactory;else if(this.muxers.size>0){const g=await this._multiplexOutbound({...u,...i},this.muxers);l=g.muxerFactory,a=g.stream}}catch(g){throw e.log.error("failed to upgrade outbound connection",g),await e.close(g),g}return await this.shouldBlockConnection(o,e,"denyOutboundUpgradedConnection"),e.log("successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:c,direction:"outbound",maConn:e,upgradedConn:a,muxerFactory:l,remotePeer:o,transient:t==null?void 0:t.transient})}_createConnection(e){const{cryptoProtocol:t,direction:r,maConn:s,upgradedConn:i,remotePeer:o,muxerFactory:a,transient:c}=e;let l,u,h;a!=null&&(l=a.createStreamMuxer({direction:r,onIncomingStream:m=>{h!=null&&Promise.resolve().then(async()=>{var E;const d=this.components.registrar.getProtocols(),{stream:p,protocol:b}=await za(m,d,{log:m.log,yieldBytes:!1});if(h==null)return;h.log("incoming stream opened on %s",b);const v=Y1(b,this.components.registrar);if(zf(b,"inbound",h)===v){const A=new R(`Too many inbound protocol streams for protocol "${b}" - limit ${v}`,H.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);throw m.abort(A),A}m.source=p.source,m.sink=p.sink,m.protocol=b,p.closeWrite!=null&&(m.closeWrite=p.closeWrite),p.closeRead!=null&&(m.closeRead=p.closeRead),p.close!=null&&(m.close=p.close),await this.components.peerStore.merge(o,{protocols:[b]}),(E=this.components.metrics)==null||E.trackProtocolStream(m,h),this._onStream({connection:h,stream:m,protocol:b})}).catch(async d=>{h.log.error("error handling incoming stream id %s",m.id,d.message,d.code,d.stack),m.timeline.close==null&&await m.close()})}}),u=async(m,d={})=>{var b;if(l==null)throw new R("Stream is not multiplexed",H.ERR_MUXER_UNAVAILABLE);h.log("starting new stream for protocols %s",m);const p=await l.newStream();h.log.trace("started new stream %s for protocols %s",p.id,m);try{if(d.signal==null){p.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",m);const S=AbortSignal.timeout(W1);Se(1/0,S),d={...d,signal:S}}p.log.trace("selecting protocol from protocols %s",m);const{stream:v,protocol:w}=await $a(p,m,{...d,log:p.log,yieldBytes:!0});p.log("selected protocol %s",w);const E=j1(w,this.components.registrar,d),A=zf(w,"outbound",h);if(A>=E){const S=new R(`Too many outbound protocol streams for protocol "${w}" - ${A}/${E}`,H.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw p.abort(S),S}return await this.components.peerStore.merge(o,{protocols:[w]}),p.source=v.source,p.sink=v.sink,p.protocol=w,v.closeWrite!=null&&(p.closeWrite=v.closeWrite),v.closeRead!=null&&(p.closeRead=v.closeRead),v.close!=null&&(p.close=v.close),(b=this.components.metrics)==null||b.trackProtocolStream(p,h),p}catch(v){throw h.log.error("could not create new stream for protocols %s",m,v),p.timeline.close==null&&p.abort(v),v.code!=null?v:new R(String(v),H.ERR_UNSUPPORTED_PROTOCOL)}},Promise.all([l.sink(i.source),i.sink(l.source)]).catch(m=>{h.log.error("error piping data through muxer",m)}));const g=s.timeline;s.timeline=new Proxy(g,{set:(...m)=>(h!=null&&m[1]==="close"&&m[2]!=null&&g.close==null&&(async()=>{try{h.status==="open"&&await h.close()}catch(d){h.log.error("error closing connection after timeline close",d)}finally{this.events.safeDispatchEvent("connection:close",{detail:h})}})().catch(d=>{h.log.error("error thrown while dispatching connection:close event",d)}),Reflect.set(...m))}),s.timeline.upgraded=Date.now();const y=()=>{throw new R("connection is not multiplexed",H.ERR_CONNECTION_NOT_MULTIPLEXED)};return h=G1({remoteAddr:s.remoteAddr,remotePeer:o,status:"open",direction:r,timeline:s.timeline,multiplexer:l==null?void 0:l.protocol,encryption:t,transient:c,logger:this.components.logger,newStream:u??y,getStreams:()=>l!=null?l.streams:[],close:async m=>{l!=null&&(h.log.trace("close muxer"),await l.close(m)),h.log.trace("close maconn"),await s.close(m),h.log.trace("closed maconn")},abort:m=>{s.abort(m),l!=null&&l.abort(m)}}),this.events.safeDispatchEvent("connection:open",{detail:h}),h}_onStream(e){const{connection:t,stream:r,protocol:s}=e,{handler:i,options:o}=this.components.registrar.getHandler(s);if(t.transient&&o.runOnTransientConnection!==!0)throw new R("Cannot open protocol stream on transient connection","ERR_TRANSIENT_CONNECTION");i({connection:t,stream:r})}async _encryptInbound(e){const t=Array.from(this.connectionEncryption.keys());e.log("handling inbound crypto protocol selection",t);try{const{stream:r,protocol:s}=await za(e,t,{log:e.log}),i=this.connectionEncryption.get(s);if(i==null)throw new Error(`no crypto module found for ${s}`);return e.log("encrypting inbound connection using",s),{...await i.secureInbound(this.components.peerId,r),protocol:s}}catch(r){throw e.log.error("encrypting inbound connection failed",r),new R(r.message,H.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(e,t){const r=Array.from(this.connectionEncryption.keys());e.log("selecting outbound crypto protocol",r);try{e.log.trace("selecting encrypter from %s",r);const{stream:s,protocol:i}=await $a(e,r,{log:e.log,yieldBytes:!0}),o=this.connectionEncryption.get(i);if(o==null)throw new Error(`no crypto module found for ${i}`);return e.log("encrypting outbound connection to %p using %s",t,o),{...await o.secureOutbound(this.components.peerId,s,t),protocol:i}}catch(s){throw e.log.error("encrypting outbound connection to %p failed",t,s),new R(s.message,H.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(e,t){const r=Array.from(t.keys());e.log("outbound selecting muxer %s",r);try{e.log.trace("selecting stream muxer from %s",r);const{stream:s,protocol:i}=await $a(e,r,{log:e.log,yieldBytes:!0});e.log("selected %s as muxer protocol",i);const o=t.get(i);return{stream:s,muxerFactory:o}}catch(s){throw e.log.error("error multiplexing outbound connection",s),new R(String(s),H.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(e,t){const r=Array.from(t.keys());e.log("inbound handling muxers %s",r);try{const{stream:s,protocol:i}=await za(e,r,{log:e.log}),o=t.get(i);return{stream:s,muxerFactory:o}}catch(s){throw e.log.error("error multiplexing inbound connection",s),new R(String(s),H.ERR_MUXER_UNAVAILABLE)}}}const Z1="1.9.4",Q1="libp2p";class J1 extends Is{constructor(t){var c,l,u,h,g;super();ue(this,xs);f(this,"peerId");f(this,"peerStore");f(this,"contentRouting");f(this,"peerRouting");f(this,"metrics");f(this,"services");f(this,"logger");f(this,"status");f(this,"components");f(this,"log");this.status="stopped";const r=new Is,s=r.dispatchEvent.bind(r);r.dispatchEvent=y=>{const m=s(y),d=this.dispatchEvent(new pc(y.type,{detail:y.detail}));return m||d},Se(1/0,r),this.peerId=t.peerId,this.logger=t.logger??ju(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=this.components=Ob({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:t.nodeInfo??{name:Q1,version:Z1},logger:this.logger,events:r,datastore:t.datastore??new kb,connectionGater:Gb(t.connectionGater),dns:t.dns});this.peerStore=this.configureComponent("peerStore",new wb(i,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),t.metrics!=null&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),i.events.addEventListener("peer:update",y=>{if(y.detail.previous==null){const m={id:y.detail.peer.id,multiaddrs:y.detail.peer.addresses.map(d=>d.multiaddr)};i.events.safeDispatchEvent("peer:discovery",{detail:m})}}),t.connectionProtector!=null&&this.configureComponent("connectionProtector",t.connectionProtector(i)),this.components.upgrader=new X1(this.components,{connectionEncryption:(t.connectionEncryption??[]).map((y,m)=>this.configureComponent(`connection-encryption-${m}`,y(this.components))),muxers:(t.streamMuxers??[]).map((y,m)=>this.configureComponent(`stream-muxers-${m}`,y(this.components))),inboundUpgradeTimeout:(c=t.connectionManager)==null?void 0:c.inboundUpgradeTimeout}),this.configureComponent("transportManager",new N1(this.components,t.transportManager)),this.configureComponent("connectionManager",new r1(this.components,t.connectionManager)),((l=t.connectionMonitor)==null?void 0:l.enabled)!==!1&&this.configureComponent("connectionMonitor",new m1(this.components,t.connectionMonitor)),this.configureComponent("registrar",new k1(this.components)),this.configureComponent("addressManager",new Nb(this.components,t.addresses));const o=(t.peerRouters??[]).map((y,m)=>this.configureComponent(`peer-router-${m}`,y(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new R1(this.components,{routers:o}));const a=(t.contentRouters??[]).map((y,m)=>this.configureComponent(`content-router-${m}`,y(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new S1(this.components,{routers:a})),this.configureComponent("randomWalk",new I1(this.components)),(t.peerDiscovery??[]).forEach((y,m)=>{this.configureComponent(`peer-discovery-${m}`,y(this.components)).addEventListener("peer",p=>{ie(this,xs,hc).call(this,p)})}),(u=t.transports)==null||u.forEach((y,m)=>{this.components.transportManager.add(this.configureComponent(`transport-${m}`,y(this.components)))}),t.services!=null)for(const y of Object.keys(t.services)){const m=t.services[y],d=m(this.components);if(d==null){this.log.error("service factory %s returned null or undefined instance",y);continue}this.services[y]=d,this.configureComponent(y,d),d[me]!=null&&(this.log("registering service %s for content routing",y),a.push(d[me])),d[dc]!=null&&(this.log("registering service %s for peer routing",y),o.push(d[dc])),d[bn]!=null&&(this.log("registering service %s for peer discovery",y),(g=(h=d[bn]).addEventListener)==null||g.call(h,"peer",p=>{ie(this,xs,hc).call(this,p)}))}Pb(i)}configureComponent(t,r){return r==null&&this.log.error("component %s was null or undefined",t),this.components[t]=r,r}async start(){var t,r,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((r=(t=this.components).beforeStart)==null?void 0:r.call(t)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(o){throw this.log.error("An error occurred starting libp2p",o),this.status="started",await this.stop(),o}}}async stop(){var t,r,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((r=(t=this.components).beforeStop)==null?void 0:r.call(t)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new Nn;for(const r of this.components.connectionManager.getConnections())t.add(r.remotePeer);return Array.from(t)}async dial(t,r={}){return this.components.connectionManager.openConnection(t,{priority:75,...r})}async dialProtocol(t,r,s={}){if(r==null)throw new R("no protocols were provided to open a stream",H.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(r=Array.isArray(r)?r:[r],r.length===0)throw new R("no protocols were provided to open a stream",H.ERR_INVALID_PROTOCOLS_FOR_STREAM);return(await this.dial(t,s)).newStream(r,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,r={}){fi(t)&&(t=st(t.getPeerId()??"")),await this.components.connectionManager.closeConnections(t,r)}async getPublicKey(t,r={}){if(this.log("getPublicKey %p",t),t.publicKey!=null)return t.publicKey;try{const o=await this.peerStore.get(t);if(o.id.publicKey!=null)return o.id.publicKey}catch(o){if(o.code!==H.ERR_NOT_FOUND)throw o}const s=Pt([z("/pk/"),t.multihash.digest]),i=await this.contentRouting.get(s,r);return ia(i),await this.peerStore.patch(t,{publicKey:i}),i}async handle(t,r,s){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async i=>{await this.components.registrar.handle(i,r,s)}))}async unhandle(t){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async r=>{await this.components.registrar.unhandle(r)}))}async register(t,r){return this.components.registrar.register(t,r)}unregister(t){this.components.registrar.unregister(t)}async isDialable(t,r={}){return this.components.connectionManager.isDialable(t,r)}}xs=new WeakSet,hc=function(t){const{detail:r}=t;if(r.id.toString()===this.peerId.toString()){this.log.error(new Error(H.ERR_DISCOVERED_SELF));return}this.components.peerStore.merge(r.id,{multiaddrs:r.multiaddrs}).catch(s=>{this.log.error(s)})};async function ev(n={}){const e=n.peerId??(n.peerId=await $w());if(e.privateKey==null)throw new R("peer id was missing private key","ERR_MISSING_PRIVATE_KEY");return n.privateKey??(n.privateKey=await ni(e.privateKey)),new J1(await PE(n))}async function tv(n={}){const e=await ev(n);return n.start!==!1&&await e.start(),e}function qf(){const n=ye();let e=!1;return{sink:async t=>{if(e)throw new Error("already piped");e=!0,n.resolve(t)},source:async function*(){yield*await n.promise}()}}function nv(){const n=qf(),e=qf();return[{source:n.source,sink:e.sink},{source:e.source,sink:n.sink}]}function rv(n,...e){if(n==null)throw new Error("Empty pipeline");if(qa(n)){const r=n;n=()=>r.source}else if(Wf(n)||Gf(n)){const r=n;n=()=>r}const t=[n,...e];if(t.length>1&&qa(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let r=1;r<t.length-1;r++)qa(t[r])&&(t[r]=iv(t[r]));return sv(...t)}const sv=(...n)=>{let e;for(;n.length>0;)e=n.shift()(e);return e},Gf=n=>(n==null?void 0:n[Symbol.asyncIterator])!=null,Wf=n=>(n==null?void 0:n[Symbol.iterator])!=null,qa=n=>n==null?!1:n.sink!=null&&n.source!=null,iv=n=>e=>{const t=n.sink(e);if((t==null?void 0:t.then)!=null){const r=ss({objectMode:!0});t.then(()=>{r.end()},o=>{r.end(o)});let s;const i=n.source;if(Gf(i))s=async function*(){yield*i,r.end()};else if(Wf(i))s=function*(){yield*i,r.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return Ti(r,s())}return n.source},ds=65535,Yf=ds-16,gs=!!((rg=(ng=globalThis.process)==null?void 0:ng.env)!=null&&rg.DUMP_SESSION_KEYS);/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const dn=n=>new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4));function jf(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}const ov=n=>new DataView(n.buffer,n.byteOffset,n.byteLength);if(!(new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68))throw new Error("Non little-endian hardware is not supported");function Ga(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Wa(n){if(typeof n=="string")n=Ga(n);else if(jf(n))n=n.slice();else throw new Error(`expected Uint8Array, got ${typeof n}`);return n}const av=n=>Object.prototype.toString.call(n)==="[object Object]"&&n.constructor===Object;function cv(n,e){if(e!==void 0&&(typeof e!="object"||!av(e)))throw new Error("options must be object or undefined");return Object.assign(n,e)}function ps(n,e){if(!jf(n))throw new Error("Uint8Array expected");if(typeof e=="number"&&n.length!==e)throw new Error(`Uint8Array length ${e} expected`)}function lv(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}const uv=(n,e)=>(Object.assign(e,n),e);function Xf(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),i=BigInt(4294967295),o=Number(t>>s&i),a=Number(t&i),c=4,l=0;n.setUint32(e+c,o,r),n.setUint32(e+l,a,r)}function Ya(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`wrong positive integer: ${n}`)}function Zf(n){if(typeof n!="boolean")throw new Error(`boolean expected, not ${n}`)}function hv(n){return n!=null&&typeof n=="object"&&(n instanceof Uint8Array||n.constructor.name==="Uint8Array")}function ys(n,...e){if(!hv(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${n.length}`)}function Qf(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function fv(n,e){ys(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const Le=(n,e)=>n[e++]&255|(n[e++]&255)<<8;class dv{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=Wa(e),ps(e,32);const t=Le(e,0),r=Le(e,2),s=Le(e,4),i=Le(e,6),o=Le(e,8),a=Le(e,10),c=Le(e,12),l=Le(e,14);this.r[0]=t&8191,this.r[1]=(t>>>13|r<<3)&8191,this.r[2]=(r>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|l<<8)&8191,this.r[9]=l>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Le(e,16+2*u)}process(e,t,r=!1){const s=r?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],l=o[2],u=o[3],h=o[4],g=o[5],y=o[6],m=o[7],d=o[8],p=o[9],b=Le(e,t+0),v=Le(e,t+2),w=Le(e,t+4),E=Le(e,t+6),A=Le(e,t+8),S=Le(e,t+10),k=Le(e,t+12),C=Le(e,t+14);let _=i[0]+(b&8191),U=i[1]+((b>>>13|v<<3)&8191),V=i[2]+((v>>>10|w<<6)&8191),P=i[3]+((w>>>7|E<<9)&8191),K=i[4]+((E>>>4|A<<12)&8191),L=i[5]+(A>>>1&8191),T=i[6]+((A>>>14|S<<2)&8191),O=i[7]+((S>>>11|k<<5)&8191),N=i[8]+((k>>>8|C<<8)&8191),x=i[9]+(C>>>5|s),I=0,B=I+_*a+U*(5*p)+V*(5*d)+P*(5*m)+K*(5*y);I=B>>>13,B&=8191,B+=L*(5*g)+T*(5*h)+O*(5*u)+N*(5*l)+x*(5*c),I+=B>>>13,B&=8191;let M=I+_*c+U*a+V*(5*p)+P*(5*d)+K*(5*m);I=M>>>13,M&=8191,M+=L*(5*y)+T*(5*g)+O*(5*h)+N*(5*u)+x*(5*l),I+=M>>>13,M&=8191;let $=I+_*l+U*c+V*a+P*(5*p)+K*(5*d);I=$>>>13,$&=8191,$+=L*(5*m)+T*(5*y)+O*(5*g)+N*(5*h)+x*(5*u),I+=$>>>13,$&=8191;let q=I+_*u+U*l+V*c+P*a+K*(5*p);I=q>>>13,q&=8191,q+=L*(5*d)+T*(5*m)+O*(5*y)+N*(5*g)+x*(5*h),I+=q>>>13,q&=8191;let G=I+_*h+U*u+V*l+P*c+K*a;I=G>>>13,G&=8191,G+=L*(5*p)+T*(5*d)+O*(5*m)+N*(5*y)+x*(5*g),I+=G>>>13,G&=8191;let W=I+_*g+U*h+V*u+P*l+K*c;I=W>>>13,W&=8191,W+=L*a+T*(5*p)+O*(5*d)+N*(5*m)+x*(5*y),I+=W>>>13,W&=8191;let Y=I+_*y+U*g+V*h+P*u+K*l;I=Y>>>13,Y&=8191,Y+=L*c+T*a+O*(5*p)+N*(5*d)+x*(5*m),I+=Y>>>13,Y&=8191;let ce=I+_*m+U*y+V*g+P*h+K*u;I=ce>>>13,ce&=8191,ce+=L*l+T*c+O*a+N*(5*p)+x*(5*d),I+=ce>>>13,ce&=8191;let se=I+_*d+U*m+V*y+P*g+K*h;I=se>>>13,se&=8191,se+=L*u+T*l+O*c+N*a+x*(5*p),I+=se>>>13,se&=8191;let ge=I+_*p+U*d+V*m+P*y+K*g;I=ge>>>13,ge&=8191,ge+=L*h+T*u+O*l+N*c+x*a,I+=ge>>>13,ge&=8191,I=(I<<2)+I|0,I=I+B|0,B=I&8191,I=I>>>13,M+=I,i[0]=B,i[1]=M,i[2]=$,i[3]=q,i[4]=G,i[5]=W,i[6]=Y,i[7]=ce,i[8]=se,i[9]=ge}finalize(){const{h:e,pad:t}=this,r=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let a=2;a<10;a++)e[a]+=s,s=e[a]>>>13,e[a]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,r[0]=e[0]+5,s=r[0]>>>13,r[0]&=8191;for(let a=1;a<10;a++)r[a]=e[a]+s,s=r[a]>>>13,r[a]&=8191;r[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)r[a]&=i;i=~i;for(let a=0;a<10;a++)e[a]=e[a]&i|r[a];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let o=e[0]+t[0];e[0]=o&65535;for(let a=1;a<8;a++)o=(e[a]+t[a]|0)+(o>>>16)|0,e[a]=o&65535}update(e){Qf(this);const{buffer:t,blockLen:r}=this;e=Wa(e);const s=e.length;for(let i=0;i<s;){const o=Math.min(r-this.pos,s-i);if(o===r){for(;r<=s-i;i+=r)this.process(e,i);continue}t.set(e.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===r&&(this.process(t,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(e){Qf(this),fv(e,this),this.finished=!0;const{buffer:t,h:r}=this;let{pos:s}=this;if(s){for(t[s++]=1;s<16;s++)t[s]=0;this.process(t,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)e[i++]=r[o]>>>0,e[i++]=r[o]>>>8;return e}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}}function gv(n){const e=(r,s)=>n(s).update(Wa(r)).digest(),t=n(new Uint8Array(32));return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=r=>n(r),e}const pv=gv(n=>new dv(n)),yv=Ga("expand 16-byte k"),mv=Ga("expand 32-byte k"),wv=dn(yv),bv=dn(mv);function Q(n,e){return n<<e|n>>>32-e}function ja(n){return n.byteOffset%4===0}const Li=64,Ev=16,Jf=2**32-1,ed=new Uint32Array;function vv(n,e,t,r,s,i,o,a){const c=s.length,l=new Uint8Array(Li),u=dn(l),h=ja(s)&&ja(i),g=h?dn(s):ed,y=h?dn(i):ed;for(let m=0;m<c;o++){if(n(e,t,r,u,o,a),o>=Jf)throw new Error("arx: counter overflow");const d=Math.min(Li,c-m);if(h&&d===Li){const p=m/4;if(m%4!==0)throw new Error("arx: invalid block position");for(let b=0,v;b<Ev;b++)v=p+b,y[v]=g[v]^u[b];m+=Li;continue}for(let p=0,b;p<d;p++)b=m+p,i[b]=s[b]^l[p];m+=d}}function _v(n,e){const{allowShortKeys:t,extendNonceFn:r,counterLength:s,counterRight:i,rounds:o}=cv({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof n!="function")throw new Error("core must be a function");return Ya(s),Ya(o),Zf(i),Zf(t),(a,c,l,u,h=0)=>{ys(a),ys(c),ys(l);const g=l.length;if(u||(u=new Uint8Array(g)),ys(u),Ya(h),h<0||h>=Jf)throw new Error("arx: counter overflow");if(u.length<g)throw new Error(`arx: output (${u.length}) is shorter than data (${g})`);const y=[];let m=a.length,d,p;if(m===32)d=a.slice(),y.push(d),p=bv;else if(m===16&&t)d=new Uint8Array(32),d.set(a),d.set(a,16),p=wv,y.push(d);else throw new Error(`arx: invalid 32-byte key, got length=${m}`);ja(c)||(c=c.slice(),y.push(c));const b=dn(d);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(p,b,dn(c.subarray(0,16)),b),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const E=new Uint8Array(12);E.set(c,i?0:12-c.length),c=E,y.push(c)}const w=dn(c);for(vv(n,p,b,w,l,u,h,o);y.length>0;)y.pop().fill(0);return u}}function Av(n,e,t,r,s,i=20){let o=n[0],a=n[1],c=n[2],l=n[3],u=e[0],h=e[1],g=e[2],y=e[3],m=e[4],d=e[5],p=e[6],b=e[7],v=s,w=t[0],E=t[1],A=t[2],S=o,k=a,C=c,_=l,U=u,V=h,P=g,K=y,L=m,T=d,O=p,N=b,x=v,I=w,B=E,M=A;for(let q=0;q<i;q+=2)S=S+U|0,x=Q(x^S,16),L=L+x|0,U=Q(U^L,12),S=S+U|0,x=Q(x^S,8),L=L+x|0,U=Q(U^L,7),k=k+V|0,I=Q(I^k,16),T=T+I|0,V=Q(V^T,12),k=k+V|0,I=Q(I^k,8),T=T+I|0,V=Q(V^T,7),C=C+P|0,B=Q(B^C,16),O=O+B|0,P=Q(P^O,12),C=C+P|0,B=Q(B^C,8),O=O+B|0,P=Q(P^O,7),_=_+K|0,M=Q(M^_,16),N=N+M|0,K=Q(K^N,12),_=_+K|0,M=Q(M^_,8),N=N+M|0,K=Q(K^N,7),S=S+V|0,M=Q(M^S,16),O=O+M|0,V=Q(V^O,12),S=S+V|0,M=Q(M^S,8),O=O+M|0,V=Q(V^O,7),k=k+P|0,x=Q(x^k,16),N=N+x|0,P=Q(P^N,12),k=k+P|0,x=Q(x^k,8),N=N+x|0,P=Q(P^N,7),C=C+K|0,I=Q(I^C,16),L=L+I|0,K=Q(K^L,12),C=C+K|0,I=Q(I^C,8),L=L+I|0,K=Q(K^L,7),_=_+U|0,B=Q(B^_,16),T=T+B|0,U=Q(U^T,12),_=_+U|0,B=Q(B^_,8),T=T+B|0,U=Q(U^T,7);let $=0;r[$++]=o+S|0,r[$++]=a+k|0,r[$++]=c+C|0,r[$++]=l+_|0,r[$++]=u+U|0,r[$++]=h+V|0,r[$++]=g+P|0,r[$++]=y+K|0,r[$++]=m+L|0,r[$++]=d+T|0,r[$++]=p+O|0,r[$++]=b+N|0,r[$++]=v+x|0,r[$++]=w+I|0,r[$++]=E+B|0,r[$++]=A+M|0}const Sv=_v(Av,{counterRight:!1,counterLength:4,allowShortKeys:!1}),xv=new Uint8Array(16),td=(n,e)=>{n.update(e);const t=e.length%16;t&&n.update(xv.subarray(t))},Rv=new Uint8Array(32);function nd(n,e,t,r,s){const i=n(e,t,Rv),o=pv.create(i);s&&td(o,s),td(o,r);const a=new Uint8Array(16),c=ov(a);Xf(c,0,BigInt(s?s.length:0),!0),Xf(c,8,BigInt(r.length),!0),o.update(a);const l=o.digest();return i.fill(0),l}const rd=uv({blockSize:64,nonceLength:12,tagLength:16},(n=>(e,t,r)=>(ps(e,32),ps(t),{encrypt:(i,o)=>{const a=i.length,c=a+16;o?ps(o,c):o=new Uint8Array(c),n(e,t,i,o,1);const l=nd(n,e,t,o.subarray(0,-16),r);return o.set(l,a),o},decrypt:(i,o)=>{const a=i.length,c=a-16;if(a<16)throw new Error("encrypted data must be at least 16 bytes");o?ps(o,c):o=new Uint8Array(c);const l=i.subarray(0,-16),u=i.subarray(-16),h=nd(n,e,t,l,r);if(!lv(u,h))throw new Error("invalid tag");return n(e,t,l,o,1),o}}))(Sv));function Iv(n,e,t){return Os(n),t===void 0&&(t=new Uint8Array(n.outputLen)),zr(n,Br(t),Br(e))}const Xa=Uint8Array.from([0]),sd=Uint8Array.of();function kv(n,e,t,r=32){Os(n),En(r);const s=n.outputLen;if(r>255*s)throw new Error("Length should be <= 255*HashLen");const i=Math.ceil(r/s);t===void 0&&(t=sd);const o=new Uint8Array(i*s),a=zr.create(n,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let u=0;u<i;u++)Xa[0]=u+1,c.update(u===0?sd:l).update(t).update(Xa).digestInto(l),o.set(l,s*u),a._cloneInto(c);return a.destroy(),c.destroy(),en(l,Xa),o.slice(0,r)}const Tv={hashSHA256(n){return ha(n.subarray())},getHKDF(n,e){const t=Iv(ha,e,n),s=kv(ha,t,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const n=Gs.utils.randomPrivateKey();return{publicKey:Gs.getPublicKey(n),privateKey:n}},generateX25519KeyPairFromSeed(n){return{publicKey:Gs.getPublicKey(n),privateKey:n}},generateX25519SharedKey(n,e){return Gs.getSharedSecret(n.subarray(),e.subarray())},chaCha20Poly1305Encrypt(n,e,t,r){return rd(r,e,t).encrypt(n.subarray())},chaCha20Poly1305Decrypt(n,e,t,r,s){return rd(r,e,t).decrypt(n.subarray(),s)}};function Cv(n){return{generateKeypair:n.generateX25519KeyPair,dh:(e,t)=>n.generateX25519SharedKey(e.privateKey,t).subarray(0,32),encrypt:n.chaCha20Poly1305Encrypt,decrypt:n.chaCha20Poly1305Decrypt,hash:n.hashSHA256,hkdf:n.getHKDF}}const Di=n=>{const e=vt(2);return e[0]=n>>8,e[1]=n,e};Di.bytes=2;const Bi=n=>{if(n.length<2)throw RangeError("Could not decode int16BE");if(n instanceof Uint8Array){let e=0;return e+=n[0]<<8,e+=n[1],e}return n.getUint16(0)};Bi.bytes=2;function Nv(n){return{xxHandshakeSuccesses:n.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:n.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:n.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:n.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:n.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function id(n,e){!e.enabled||!gs||(n?(e(`LOCAL_STATIC_PUBLIC_KEY ${j(n.publicKey,"hex")}`),e(`LOCAL_STATIC_PRIVATE_KEY ${j(n.privateKey,"hex")}`)):e("Missing local static keys."))}function od(n,e){!e.enabled||!gs||(n?(e(`LOCAL_PUBLIC_EPHEMERAL_KEY ${j(n.publicKey,"hex")}`),e(`LOCAL_PRIVATE_EPHEMERAL_KEY ${j(n.privateKey,"hex")}`)):e("Missing local ephemeral keys."))}function Lv(n,e){!e.enabled||!gs||e(n?`REMOTE_STATIC_PUBLIC_KEY ${j(n.subarray(),"hex")}`:"Missing remote static public key.")}function ad(n,e){!e.enabled||!gs||e(n?`REMOTE_EPHEMERAL_PUBLIC_KEY ${j(n.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function cd(n,e,t){!t.enabled||!gs||(t(`CIPHER_STATE_1 ${n.n.getUint64()} ${n.k&&j(n.k,"hex")}`),t(`CIPHER_STATE_2 ${e.n.getUint64()} ${e.k&&j(e.k,"hex")}`))}const Gi=class Gi extends Error{constructor(t="Unexpected Peer"){super(t);f(this,"code");this.code=Gi.code}};f(Gi,"code","ERR_UNEXPECTED_PEER");let Za=Gi;const Wi=class Wi extends Error{constructor(t="Invalid crypto exchange"){super(t);f(this,"code");this.code=Wi.code}};f(Wi,"code","ERR_INVALID_CRYPTO_EXCHANGE");let ms=Wi;const Dv=0,Bv=4294967295,Ov="Cipherstate has reached maximum n, a new handshake must be performed";class Pv{constructor(e=Dv){f(this,"n");f(this,"bytes");f(this,"view");this.n=e,this.bytes=He(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>Bv)throw new Error(Ov)}}const br=He(0);class Oi{constructor(e,t=void 0,r=0){f(this,"k");f(this,"n");f(this,"crypto");this.crypto=e,this.k=t,this.n=new Pv(r)}hasKey(){return!!this.k}encryptWithAd(e,t){if(!this.hasKey())return t;this.n.assertValue();const r=this.crypto.encrypt(t,this.n.getBytes(),e,this.k);return this.n.increment(),r}decryptWithAd(e,t,r){if(!this.hasKey())return t;this.n.assertValue();const s=this.crypto.decrypt(t,this.n.getBytes(),e,this.k,r);return this.n.increment(),s}}class Uv{constructor(e,t){f(this,"cs");f(this,"ck");f(this,"h");f(this,"crypto");this.crypto=e;const r=z(t,"utf-8");this.h=Fv(e,r),this.ck=this.h,this.cs=new Oi(e)}mixKey(e){const[t,r]=this.crypto.hkdf(this.ck,e);this.ck=t,this.cs=new Oi(this.crypto,r)}mixHash(e){this.h=this.crypto.hash(new Ee(this.h,e))}encryptAndHash(e){const t=this.cs.encryptWithAd(this.h,e);return this.mixHash(t),t}decryptAndHash(e){const t=this.cs.decryptWithAd(this.h,e);return this.mixHash(e),t}split(){const[e,t]=this.crypto.hkdf(this.ck,br);return[new Oi(this.crypto,e),new Oi(this.crypto,t)]}}class Mv{constructor(e){f(this,"ss");f(this,"s");f(this,"e");f(this,"rs");f(this,"re");f(this,"initiator");f(this,"crypto");const{crypto:t,protocolName:r,prologue:s,initiator:i,s:o,e:a,rs:c,re:l}=e;this.crypto=t,this.ss=new Uv(t,r),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=l}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const e=this.crypto.generateKeypair();return this.ss.mixHash(e.publicKey),this.e=e,e.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(e,t=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(e.byteLength<t+32)throw new Error("message is not long enough");this.re=e.sublist(t,t+32),this.ss.mixHash(this.re)}readS(e,t=0){if(this.rs)throw new Error("remote static public key is already set");const r=32+(this.ss.cs.hasKey()?16:0);if(e.byteLength<t+r)throw new Error("message is not long enough");const s=e.sublist(t,t+r);return this.rs=this.ss.decryptAndHash(s),r}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class ld extends Mv{writeMessageA(e){return new Ee(this.writeE(),this.ss.encryptAndHash(e))}writeMessageB(e){const t=this.writeE();this.writeEE();const r=this.writeS();return this.writeES(),new Ee(t,r,this.ss.encryptAndHash(e))}writeMessageC(e){const t=this.writeS();return this.writeSE(),new Ee(t,this.ss.encryptAndHash(e))}readMessageA(e){try{return this.readE(e),this.ss.decryptAndHash(e.sublist(32))}catch(t){throw new ms(`handshake stage 0 validation fail: ${t.message}`)}}readMessageB(e){try{this.readE(e),this.readEE();const t=this.readS(e,32);return this.readES(),this.ss.decryptAndHash(e.sublist(32+t))}catch(t){throw new ms(`handshake stage 1 validation fail: ${t.message}`)}}readMessageC(e){try{const t=this.readS(e);return this.readSE(),this.ss.decryptAndHash(e.sublist(t))}catch(t){throw new ms(`handshake stage 2 validation fail: ${t.message}`)}}}function Fv(n,e){if(e.length<=32){const t=He(32);return t.set(e),t}else return n.hash(e)}var Pi;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.webtransportCerthashes!=null)for(const i of t.webtransportCerthashes)r.uint32(10),r.bytes(i);s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={webtransportCerthashes:[]},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:{s.webtransportCerthashes.push(t.bytes());break}default:{t.skipType(o&7);break}}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(Pi||(Pi={}));var Ui;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),t.identityKey!=null&&t.identityKey.byteLength>0&&(r.uint32(10),r.bytes(t.identityKey)),t.identitySig!=null&&t.identitySig.byteLength>0&&(r.uint32(18),r.bytes(t.identitySig)),t.extensions!=null&&(r.uint32(34),Pi.codec().encode(t.extensions,r)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={identityKey:He(0),identitySig:He(0)},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 1:{s.identityKey=t.bytes();break}case 2:{s.identitySig=t.bytes();break}case 4:{s.extensions=Pi.codec().decode(t,t.uint32());break}default:{t.skipType(o&7);break}}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(Ui||(Ui={}));async function ud(n,e,t){const r=await n.sign(fd(e));return Ui.encode({identityKey:n.public.bytes,identitySig:r,extensions:t})}async function hd(n,e,t){try{const r=Ui.decode(n);if(t){const o=t.subarray();if(!$e(o,r.identityKey))throw new Error(`Payload identity key ${j(r.identityKey,"hex")} does not match expected remote identity key ${j(o,"hex")}`)}if(!e)throw new Error("Remote static does not exist");const s=fd(e);if(!await ia(r.identityKey).verify(s,r.identitySig))throw new Error("Invalid payload signature");return r}catch(r){throw new Za(r.message)}}function fd(n){const e=z("noise-libp2p-static-key:");return n instanceof Uint8Array?Pt([e,n],e.length+n.length):(n.prepend(e),n)}async function Vv(n){const{log:e,connection:t,crypto:r,privateKey:s,prologue:i,s:o,remoteIdentityKey:a,extensions:c}=n,l=await ud(s,o.publicKey,c),u=new ld({crypto:r,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:i,s:o});id(u.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await t.write(u.writeMessageA(br)),e.trace("Stage 0 - Initiator finished sending first message."),od(u.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const h=u.readMessageB(await t.read());e.trace("Stage 1 - Initiator received the message."),ad(u.re,e),Lv(u.rs,e),e.trace("Initiator going to check remote's signature...");const g=await hd(h,u.rs,a);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await t.write(u.writeMessageC(l)),e.trace("Stage 2 - Initiator sent message with signed payload.");const[y,m]=u.ss.split();return cd(y,m,e),{payload:g,encrypt:d=>y.encryptWithAd(br,d),decrypt:(d,p)=>m.decryptWithAd(br,d,p)}}async function $v(n){const{log:e,connection:t,crypto:r,privateKey:s,prologue:i,s:o,remoteIdentityKey:a,extensions:c}=n,l=await ud(s,o.publicKey,c),u=new ld({crypto:r,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:i,s:o});id(u.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),u.readMessageA(await t.read()),e.trace("Stage 0 - Responder received first message."),ad(u.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await t.write(u.writeMessageB(l)),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),od(u.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const h=u.readMessageC(await t.read());e.trace("Stage 2 - Responder received the message, finished handshake.");const g=await hd(h,u.rs,a),[y,m]=u.ss.split();return cd(y,m,e),{payload:g,encrypt:d=>m.encryptWithAd(br,d),decrypt:(d,p)=>y.decryptWithAd(br,d,p)}}const dd=16;function Hv(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=Yf){let i=s+Yf;i>r.length&&(i=r.length);let o;r instanceof Uint8Array?o=n.encrypt(r.subarray(s,i)):o=n.encrypt(r.sublist(s,i)),e==null||e.encryptedPackets.increment(),yield new Ee(Di(o.byteLength),o)}}}function Kv(n,e){return async function*(t){for await(const r of t)for(let s=0;s<r.length;s+=ds){let i=s+ds;if(i>r.length&&(i=r.length),i-dd<s)throw new Error("Invalid chunk");const o=r.sublist(s,i),a=r.subarray(s,i-dd);try{const c=n.decrypt(o,a);e==null||e.decryptedPackets.increment(),yield c}catch(c){throw e==null||e.decryptErrors.increment(),c}}}}class zv{constructor(e,t={}){f(this,"protocol","/noise");f(this,"crypto");f(this,"prologue");f(this,"staticKey");f(this,"extensions");f(this,"metrics");f(this,"components");const{staticNoiseKey:r,extensions:s,crypto:i,prologueBytes:o}=t,{metrics:a}=e;this.components=e;const c=i??Tv;this.crypto=Cv(c),this.extensions=s,this.metrics=a?Nv(a):void 0,r?this.staticKey=c.generateX25519KeyPairFromSeed(r):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??He(0)}async secureOutbound(e,t,r){const s=mr(t,{lengthEncoder:Di,lengthDecoder:Bi,maxDataLength:ds});if(!e.privateKey)throw new R("local peerId does not contain private key","ERR_NO_PRIVATE_KEY");const i=await ni(e.privateKey),o=r==null?void 0:r.publicKey,a=await this.performHandshakeInitiator(s,i,o),c=await this.createSecureConnection(s,a);return t.source=c.source,t.sink=c.sink,{conn:t,remoteExtensions:a.payload.extensions,remotePeer:await Cn(a.payload.identityKey)}}async secureInbound(e,t,r){const s=mr(t,{lengthEncoder:Di,lengthDecoder:Bi,maxDataLength:ds});if(!e.privateKey)throw new R("local peerId does not contain private key","ERR_NO_PRIVATE_KEY");const i=await ni(e.privateKey),o=r==null?void 0:r.publicKey,a=await this.performHandshakeResponder(s,i,o),c=await this.createSecureConnection(s,a);return t.source=c.source,t.sink=c.sink,{conn:t,remoteExtensions:a.payload.extensions,remotePeer:await Cn(a.payload.identityKey)}}async performHandshakeInitiator(e,t,r){var i,o;let s;try{s=await Vv({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions}),(i=this.metrics)==null||i.xxHandshakeSuccesses.increment()}catch(a){throw(o=this.metrics)==null||o.xxHandshakeErrors.increment(),a}return s}async performHandshakeResponder(e,t,r){var i,o;let s;try{s=await $v({connection:e,privateKey:t,remoteIdentityKey:r,log:this.components.logger.forComponent("libp2p:noise:xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:this.extensions}),(i=this.metrics)==null||i.xxHandshakeSuccesses.increment()}catch(a){throw(o=this.metrics)==null||o.xxHandshakeErrors.increment(),a}return s}async createSecureConnection(e,t){const[r,s]=nv(),i=e.unwrap();return await rv(r,Hv(t,this.metrics),i,o=>Ka(o,{lengthDecoder:Bi}),Kv(t,this.metrics),r),s}}function qv(n={}){return e=>new zv(e,n)}function gd(n){if(n!=null){if(typeof n[Symbol.iterator]=="function")return n[Symbol.iterator]();if(typeof n[Symbol.asyncIterator]=="function")return n[Symbol.asyncIterator]();if(typeof n.next=="function")return n}throw new Error("argument is not an iterator or iterable")}const ws="ERR_INVALID_FRAME",pd="ERR_UNREQUESTED_PING",yd="ERR_NOT_MATCHING_PING",md="ERR_STREAM_ALREADY_EXISTS",wd="ERR_DECODE_INVALID_VERSION",bd="ERR_BOTH_CLIENTS",Ed="ERR_RECV_WINDOW_EXCEEDED",Gv=new Set([ws,pd,yd,md,wd,bd,Ed]),Fn="ERR_INVALID_CONFIG",Qa="ERR_MUXER_LOCAL_CLOSED",vd="ERR_MUXER_REMOTE_CLOSED",Wv="ERR_STREAM_ABORT",Yv="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",jv="ERR_DECODE_IN_PROGRESS",Ja=256*1024,Xv=16*1024*1024,Zv={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:Ja,maxStreamWindowSize:Xv,maxMessageSize:64*1024};function Qv(n){if(n.keepAliveInterval<=0)throw new R("keep-alive interval must be positive",Fn);if(n.maxInboundStreams<0)throw new R("max inbound streams must be larger or equal 0",Fn);if(n.maxOutboundStreams<0)throw new R("max outbound streams must be larger or equal 0",Fn);if(n.initialStreamWindowSize<Ja)throw new R("InitialStreamWindowSize must be larger or equal 256 kB",Fn);if(n.maxStreamWindowSize<n.initialStreamWindowSize)throw new R("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",Fn);if(n.maxStreamWindowSize>2**32-1)throw new R("MaxStreamWindowSize must be less than equal MAX_UINT32",Fn);if(n.maxMessageSize<1024)throw new R("MaxMessageSize must be greater than a kilobyte",Fn)}var Re;(function(n){n[n.Data=0]="Data",n[n.WindowUpdate=1]="WindowUpdate",n[n.Ping=2]="Ping",n[n.GoAway=3]="GoAway"})(Re||(Re={}));var ve;(function(n){n[n.SYN=1]="SYN",n[n.ACK=2]="ACK",n[n.FIN=4]="FIN",n[n.RST=8]="RST"})(ve||(ve={})),Object.values(ve).filter(n=>typeof n!="string");const Jv=0;var Nt;(function(n){n[n.NormalTermination=0]="NormalTermination",n[n.ProtocolError=1]="ProtocolError",n[n.InternalError=2]="InternalError"})(Nt||(Nt={}));const bs=12,_d=2**24;function e_(n){if(n[0]!==Jv)throw new R("Invalid frame version",wd);return{type:n[1],flag:(n[2]<<8)+n[3],streamID:n[4]*_d+(n[5]<<16)+(n[6]<<8)+n[7],length:n[8]*_d+(n[9]<<16)+(n[10]<<8)+n[11]}}class t_{constructor(e){f(this,"source");f(this,"buffer");f(this,"frameInProgress");this.source=n_(e),this.buffer=new Ee,this.frameInProgress=!1}async*emitFrames(){for await(const e of this.source)for(this.buffer.append(e);;){const t=this.readHeader();if(t===void 0)break;const{type:r,length:s}=t;r===Re.Data?(this.frameInProgress=!0,yield{header:t,readData:this.readBytes.bind(this,s)}):yield{header:t}}}readHeader(){if(this.frameInProgress)throw new R("decoding frame already in progress",jv);if(this.buffer.length<bs)return;const e=e_(this.buffer.subarray(0,bs));return this.buffer.consume(bs),e}async readBytes(e){if(this.buffer.length<e){for await(const r of this.source)if(this.buffer.append(r),this.buffer.length>=e)break}const t=this.buffer.sublist(0,e);return this.buffer.consume(e),this.frameInProgress=!1,t}}function n_(n){if(n[Symbol.iterator]!==void 0){const e=n[Symbol.iterator]();return e.return=void 0,{[Symbol.iterator](){return e}}}else if(n[Symbol.asyncIterator]!==void 0){const e=n[Symbol.asyncIterator]();return e.return=void 0,{[Symbol.asyncIterator](){return e}}}else throw new Error("a source must be either an iterable or an async iterable")}function Ad(n){const e=new Uint8Array(bs);return e[1]=n.type,e[2]=n.flag>>>8,e[3]=n.flag,e[4]=n.streamID>>>24,e[5]=n.streamID>>>16,e[6]=n.streamID>>>8,e[7]=n.streamID,e[8]=n.length>>>24,e[9]=n.length>>>16,e[10]=n.length>>>8,e[11]=n.length,e}function r_(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}function s_(n,e){var r,s;const t=(s=(r=gd(n)).return)==null?void 0:s.call(r);r_(t)&&t.catch(i=>{e.error("could not cause iterator to return",i)})}const i_="ERR_STREAM_RESET",o_="ERR_SINK_INVALID_STATE",a_=5e3;function tc(n){return n==null?!1:typeof n.then=="function"&&typeof n.catch=="function"&&typeof n.finally=="function"}class c_{constructor(e){f(this,"id");f(this,"direction");f(this,"timeline");f(this,"protocol");f(this,"metadata");f(this,"source");f(this,"status");f(this,"readStatus");f(this,"writeStatus");f(this,"log");f(this,"sinkController");f(this,"sinkEnd");f(this,"closed");f(this,"endErr");f(this,"streamSource");f(this,"onEnd");f(this,"onCloseRead");f(this,"onCloseWrite");f(this,"onReset");f(this,"onAbort");f(this,"sendCloseWriteTimeout");f(this,"sendingData");this.sinkController=new AbortController,this.sinkEnd=ye(),this.closed=ye(),this.log=e.log,this.status="open",this.readStatus="ready",this.writeStatus="ready",this.id=e.id,this.metadata=e.metadata??{},this.direction=e.direction,this.timeline={open:Date.now()},this.sendCloseWriteTimeout=e.sendCloseWriteTimeout??a_,this.onEnd=e.onEnd,this.onCloseRead=e==null?void 0:e.onCloseRead,this.onCloseWrite=e==null?void 0:e.onCloseWrite,this.onReset=e==null?void 0:e.onReset,this.onAbort=e==null?void 0:e.onAbort,this.source=this.streamSource=ss({onEnd:t=>{t!=null?this.log.trace("source ended with error",t):this.log.trace("source ended"),this.onSourceEnd(t)}}),this.sink=this.sink.bind(this)}async sink(e){if(this.writeStatus!=="ready")throw new R(`writable end state is "${this.writeStatus}" not "ready"`,o_);try{this.writeStatus="writing";const t={signal:this.sinkController.signal};if(this.direction==="outbound"){const s=this.sendNewStream(t);tc(s)&&await s}const r=()=>{s_(e,this.log)};try{this.sinkController.signal.addEventListener("abort",r),this.log.trace("sink reading from source");for await(let s of e){s=s instanceof Uint8Array?new Ee(s):s;const i=this.sendData(s,t);tc(i)&&(this.sendingData=ye(),await i,this.sendingData.resolve(),this.sendingData=void 0)}}finally{this.sinkController.signal.removeEventListener("abort",r)}this.log.trace('sink finished reading from source, write status is "%s"',this.writeStatus),this.writeStatus==="writing"&&(this.writeStatus="closing",this.log.trace("send close write to remote"),await this.sendCloseWrite({signal:AbortSignal.timeout(this.sendCloseWriteTimeout)}),this.writeStatus="closed"),this.onSinkEnd()}catch(t){throw this.log.trace("sink ended with error, calling abort with error",t),this.abort(t),t}finally{this.log.trace("resolve sink end"),this.sinkEnd.resolve()}}onSourceEnd(e){var t;this.timeline.closeRead==null&&(this.timeline.closeRead=Date.now(),this.readStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),(t=this.onCloseRead)==null||t.call(this),this.timeline.closeWrite!=null?(this.log.trace("source and sink ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("source ended, waiting for sink to end"))}onSinkEnd(e){var t;this.timeline.closeWrite==null&&(this.timeline.closeWrite=Date.now(),this.writeStatus="closed",e!=null&&this.endErr==null&&(this.endErr=e),(t=this.onCloseWrite)==null||t.call(this),this.timeline.closeRead!=null?(this.log.trace("sink and source ended"),this.timeline.close=Date.now(),this.status!=="aborted"&&this.status!=="reset"&&(this.status="closed"),this.onEnd!=null&&this.onEnd(this.endErr),this.closed.resolve()):this.log.trace("sink ended, waiting for source to end"))}async close(e){this.log.trace("closing gracefully"),this.status="closing",await Ct(Promise.all([this.closeWrite(e),this.closeRead(e),this.closed.promise]),e==null?void 0:e.signal),this.status="closed",this.log.trace("closed gracefully")}async closeRead(e={}){if(this.readStatus==="closing"||this.readStatus==="closed")return;this.log.trace('closing readable end of stream with starting read status "%s"',this.readStatus);const t=this.readStatus;this.readStatus="closing",this.status!=="reset"&&this.status!=="aborted"&&this.timeline.closeRead==null&&(this.log.trace("send close read to remote"),await this.sendCloseRead(e)),t==="ready"&&(this.log.trace("ending internal source queue with %d queued bytes",this.streamSource.readableLength),this.streamSource.end()),this.log.trace("closed readable end of stream")}async closeWrite(e={}){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.log.trace('closing writable end of stream with starting write status "%s"',this.writeStatus),this.writeStatus==="ready"&&(this.log.trace("sink was never sunk, sink an empty array"),await Ct(this.sink([]),e.signal)),this.writeStatus==="writing"&&(this.sendingData!=null&&await Ct(this.sendingData.promise,e.signal),this.log.trace("aborting source passed to .sink"),this.sinkController.abort(),await Ct(this.sinkEnd.promise,e.signal)),this.writeStatus="closed",this.log.trace("closed writable end of stream"))}abort(e){var r;if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;this.log("abort with error",e),this.log("try to send reset to remote");const t=this.sendReset();tc(t)&&t.catch(s=>{this.log.error("error sending reset message",s)}),this.status="aborted",this.timeline.abort=Date.now(),this._closeSinkAndSource(e),(r=this.onAbort)==null||r.call(this,e)}reset(){var t;if(this.status==="closed"||this.status==="aborted"||this.status==="reset")return;const e=new R("stream reset",i_);this.status="reset",this.timeline.reset=Date.now(),this._closeSinkAndSource(e),(t=this.onReset)==null||t.call(this)}_closeSinkAndSource(e){this._closeSink(e),this._closeSource(e)}_closeSink(e){this.writeStatus==="writing"&&(this.log.trace("end sink source"),this.sinkController.abort()),this.onSinkEnd(e)}_closeSource(e){this.readStatus!=="closing"&&this.readStatus!=="closed"&&(this.log.trace("ending source with %d bytes to be read by consumer",this.streamSource.readableLength),this.readStatus="closing",this.streamSource.end(e))}remoteCloseWrite(){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("received remote close write but local source is already closed");return}this.log.trace("remote close write"),this._closeSource()}remoteCloseRead(){if(this.writeStatus==="closing"||this.writeStatus==="closed"){this.log("received remote close read but local sink is already closed");return}this.log.trace("remote close read"),this._closeSink()}destroy(){if(this.status==="closed"||this.status==="aborted"||this.status==="reset"){this.log("received destroy but we are already closed");return}this.log.trace("stream destroyed"),this._closeSinkAndSource()}sourcePush(e){this.streamSource.push(e)}sourceReadableLength(){return this.streamSource.readableLength}}function l_(n){return n[Symbol.asyncIterator]!=null}function Sd(n){return(n==null?void 0:n.then)!=null}function u_(n,e){let t=0;if(l_(n))return async function*(){for await(const c of n){const l=e(c,t++);Sd(l)&&await l,yield c}}();const r=Wh(n),{value:s,done:i}=r.next();if(i===!0)return function*(){}();const o=e(s,t++);if(typeof(o==null?void 0:o.then)=="function")return async function*(){yield s;for(const c of r){const l=e(c,t++);Sd(l)&&await l,yield c}}();const a=e;return function*(){yield s;for(const c of r)a(c,t++),yield c}()}var bt;(function(n){n[n.Init=0]="Init",n[n.SYNSent=1]="SYNSent",n[n.SYNReceived=2]="SYNReceived",n[n.Established=3]="Established",n[n.Finished=4]="Finished"})(bt||(bt={}));class h_ extends c_{constructor(t){super({...t,onEnd:r=>{var s;this.state=bt.Finished,(s=t.onEnd)==null||s.call(t,r)}});f(this,"name");f(this,"state");f(this,"config");f(this,"_id");f(this,"sendWindowCapacity");f(this,"sendWindowCapacityUpdate");f(this,"recvWindow");f(this,"recvWindowCapacity");f(this,"epochStart");f(this,"getRTT");f(this,"sendFrame");this.config=t.config,this._id=parseInt(t.id,10),this.name=t.name,this.state=t.state,this.sendWindowCapacity=Ja,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=t.getRTT,this.sendFrame=t.sendFrame,this.source=u_(this.source,()=>{this.sendWindowUpdate()})}async sendNewStream(){}async sendData(t,r={}){var s,i;for(t=t.sublist();t.byteLength!==0;){if(this.sendWindowCapacity===0&&((s=this.log)==null||s.trace("wait for send window capacity, status %s",this.status),await this.waitForSendWindowCapacity(r),this.status==="closed"||this.status==="aborted"||this.status==="reset")){(i=this.log)==null||i.trace("%s while waiting for send window capacity",this.status);return}const o=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-bs,t.length),a=this.getSendFlags();this.sendFrame({type:Re.Data,flag:a,streamID:this._id,length:o},t.sublist(0,o)),this.sendWindowCapacity-=o,t.consume(o)}}async sendReset(){this.sendFrame({type:Re.WindowUpdate,flag:ve.RST,streamID:this._id,length:0})}async sendCloseWrite(){const t=this.getSendFlags()|ve.FIN;this.sendFrame({type:Re.WindowUpdate,flag:t,streamID:this._id,length:0})}async sendCloseRead(){}async waitForSendWindowCapacity(t={}){var o,a;if(this.sendWindowCapacity>0)return;let r,s;const i=()=>{this.status==="open"||this.status==="closing"?s(new R("stream aborted",Wv)):r()};(o=t.signal)==null||o.addEventListener("abort",i);try{await new Promise((c,l)=>{this.sendWindowCapacityUpdate=()=>{c()},s=l,r=c})}finally{(a=t.signal)==null||a.removeEventListener("abort",i)}}handleWindowUpdate(t){var s,i;(s=this.log)==null||s.trace("stream received window update id=%s",this._id),this.processFlags(t.flag);const r=this.sendWindowCapacity;this.sendWindowCapacity+=t.length,r===0&&t.length>0&&((i=this.sendWindowCapacityUpdate)==null||i.call(this))}async handleData(t,r){var i;if((i=this.log)==null||i.trace("stream received data id=%s",this._id),this.processFlags(t.flag),this.recvWindowCapacity<t.length)throw new R("receive window exceeded",Ed,{available:this.recvWindowCapacity,recv:t.length});const s=await r();this.recvWindowCapacity-=t.length,this.sourcePush(s)}processFlags(t){(t&ve.ACK)===ve.ACK&&this.state===bt.SYNSent&&(this.state=bt.Established),(t&ve.FIN)===ve.FIN&&this.remoteCloseWrite(),(t&ve.RST)===ve.RST&&this.reset()}getSendFlags(){switch(this.state){case bt.Init:return this.state=bt.SYNSent,ve.SYN;case bt.SYNReceived:return this.state=bt.Established,ve.ACK;default:return 0}}sendWindowUpdate(){const t=this.getSendFlags(),r=Date.now(),s=this.getRTT();if(t===0&&s>-1&&r-this.epochStart<s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&t===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=r,this.sendFrame({type:Re.WindowUpdate,flag:t,streamID:this._id,length:i})}}const xd="/yamux/1.0.0",f_=500;class d_{constructor(e,t={}){f(this,"protocol",xd);f(this,"_components");f(this,"_init");this._components=e,this._init=t}createStreamMuxer(e){return new g_(this._components,{...this._init,...e})}}class g_{constructor(e,t){f(this,"protocol",xd);f(this,"source");f(this,"sink");f(this,"config");f(this,"log");f(this,"logger");f(this,"closeController");f(this,"nextStreamID");f(this,"_streams");f(this,"nextPingID");f(this,"activePing");f(this,"rtt");f(this,"client");f(this,"localGoAway");f(this,"remoteGoAway");f(this,"numInboundStreams");f(this,"numOutboundStreams");f(this,"onIncomingStream");f(this,"onStreamEnd");var r;this.client=t.direction==="outbound",this.config={...Zv,...t},this.logger=e.logger,this.log=this.logger.forComponent("libp2p:yamux"),Qv(this.config),this.closeController=new AbortController,Se(1/0,this.closeController.signal),this.onIncomingStream=t.onIncomingStream,this.onStreamEnd=t.onStreamEnd,this._streams=new Map,this.source=ss({onEnd:()=>{var s;(s=this.log)==null||s.trace("muxer source ended"),this._streams.forEach(i=>{i.destroy()})}}),this.sink=async s=>{var c,l,u;const i=()=>{const h=gd(s);if(h.return!=null){const g=h.return();p_(g)&&g.catch(y=>{var m;(m=this.log)==null||m.call(this,"could not cause sink source to return",y)})}};let o,a;try{const h=new t_(s);try{this.closeController.signal.addEventListener("abort",i);for await(const g of h.emitFrames())await this.handleFrame(g.header,g.readData)}finally{this.closeController.signal.removeEventListener("abort",i)}o=Nt.NormalTermination}catch(h){const g=h.code;Gv.has(g)?((c=this.log)==null||c.error("protocol error in sink",h),o=Nt.ProtocolError):((l=this.log)==null||l.error("internal error in sink",h),o=Nt.InternalError),a=h}(u=this.log)==null||u.trace("muxer sink ended"),a!=null?this.abort(a,o):await this.close({reason:o})},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,(r=this.log)==null||r.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("keepalive error: %s",s)}),this.ping().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("ping error: %s",s)})}get streams(){return Array.from(this._streams.values())}newStream(e){var s;if(this.remoteGoAway!==void 0)throw new R("muxer closed remotely",vd);if(this.localGoAway!==void 0)throw new R("muxer closed locally",Qa);const t=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new R("max outbound streams exceeded",Yv);(s=this.log)==null||s.trace("new outgoing stream id=%s",t);const r=this._newStream(t,e,bt.Init,"outbound");return this._streams.set(t,r),this.numOutboundStreams++,r.sendWindowUpdate(),r}async ping(){if(this.remoteGoAway!==void 0)throw new R("muxer closed remotely",vd);if(this.localGoAway!==void 0)throw new R("muxer closed locally",Qa);if(this.activePing===void 0){let e=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((s,i)=>{const o=()=>{i(new R("muxer closed locally",Qa))};this.closeController.signal.addEventListener("abort",o,{once:!0}),e=()=>{this.closeController.signal.removeEventListener("abort",o),s()}}),resolve:e};const t=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const r=Date.now();this.rtt=r-t}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}async close(e={}){var r;if(this.closeController.signal.aborted)return;const t=(e==null?void 0:e.reason)??Nt.NormalTermination;if((r=this.log)==null||r.trace("muxer close reason=%s",t),e.signal==null){const s=AbortSignal.timeout(f_);Se(1/0,s),e={...e,signal:s}}try{await Promise.all([...this._streams.values()].map(async s=>s.close(e))),this.sendGoAway(t),this._closeMuxer()}catch(s){this.abort(s)}}abort(e,t){var r;if(!this.closeController.signal.aborted){t=t??Nt.InternalError,(r=this.log)==null||r.error("muxer abort reason=%s error=%s",t,e);for(const s of this._streams.values())s.abort(e);this.sendGoAway(t),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(e,t,r,s){if(this._streams.get(e)!=null)throw new R("Stream already exists",md,{id:e});const i=new h_({id:e.toString(),name:t,state:r,direction:s,sendFrame:this.sendFrame.bind(this),onEnd:()=>{var o;this.closeStream(e),(o=this.onStreamEnd)==null||o.call(this,i)},log:this.logger.forComponent(`libp2p:yamux:${s}:${e}`),config:this.config,getRTT:this.getRTT.bind(this)});return i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(e)}async keepAliveLoop(){var t;const e=new Promise((r,s)=>{this.closeController.signal.addEventListener("abort",s,{once:!0})});for((t=this.log)==null||t.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let r;try{await Promise.race([e,new Promise(s=>{r=setTimeout(s,this.config.keepAliveInterval)})]),this.ping().catch(s=>{var i;return(i=this.log)==null?void 0:i.error("ping error: %s",s)})}catch{clearInterval(r);return}}}async handleFrame(e,t){var o;const{streamID:r,type:s,length:i}=e;if((o=this.log)==null||o.trace("received frame %o",e),r===0)switch(s){case Re.Ping:{this.handlePing(e);return}case Re.GoAway:{this.handleGoAway(i);return}default:throw new R("Invalid frame type",ws,{header:e})}else switch(e.type){case Re.Data:case Re.WindowUpdate:{await this.handleStreamMessage(e,t);return}default:throw new R("Invalid frame type",ws,{header:e})}}handlePing(e){var t,r;if(e.flag===ve.SYN)(t=this.log)==null||t.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,ve.ACK);else if(e.flag===ve.ACK)(r=this.log)==null||r.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new R("Invalid frame flag",ws,{header:e})}handlePingResponse(e){if(this.activePing===void 0)throw new R("ping not requested",pd);if(this.activePing.id!==e)throw new R("ping doesn't match our id",yd);this.activePing.resolve()}handleGoAway(e){var t;(t=this.log)==null||t.trace("received GoAway reason=%s",Nt[e]??"unknown"),this.remoteGoAway=e;for(const r of this._streams.values())r.reset();this._closeMuxer()}async handleStreamMessage(e,t){var a,c;const{streamID:r,flag:s,type:i}=e;(s&ve.SYN)===ve.SYN&&this.incomingStream(r);const o=this._streams.get(r);if(o===void 0){if(i===Re.Data){if((a=this.log)==null||a.call(this,"discarding data for stream id=%s",r),t===void 0)throw new Error("unreachable");await t()}else(c=this.log)==null||c.call(this,"frame for missing stream id=%s",r);return}switch(i){case Re.WindowUpdate:{o.handleWindowUpdate(e);return}case Re.Data:{if(t===void 0)throw new Error("unreachable");await o.handleData(e,t);return}default:throw new Error("unreachable")}}incomingStream(e){var r,s,i;if(this.client!==(e%2===0))throw new R("both endpoints are clients",bd);if(this._streams.has(e))return;if((r=this.log)==null||r.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:Re.WindowUpdate,flag:ve.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){(s=this.log)==null||s.call(this,"maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:Re.WindowUpdate,flag:ve.RST,streamID:e,length:0});return}const t=this._newStream(e,void 0,bt.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(e,t),(i=this.onIncomingStream)==null||i.call(this,t)}sendFrame(e,t){var r;if((r=this.log)==null||r.trace("sending frame %o",e),e.type===Re.Data){if(t===void 0)throw new R("invalid frame",ws);this.source.push(new Ee(Ad(e),t))}else this.source.push(Ad(e))}sendPing(e,t=ve.SYN){var r,s;t===ve.SYN?(r=this.log)==null||r.trace("sending ping request pingId=%s",e):(s=this.log)==null||s.trace("sending ping response pingId=%s",e),this.sendFrame({type:Re.Ping,flag:t,streamID:0,length:e})}sendGoAway(e=Nt.NormalTermination){var t;(t=this.log)==null||t.call(this,"sending GoAway reason=%s",Nt[e]),this.localGoAway=e,this.sendFrame({type:Re.GoAway,flag:0,streamID:0,length:e})}}function p_(n){return n!=null&&typeof n.then=="function"}function y_(n={}){return e=>new d_(e,n)}function Rd(n,e){const t=mr(n,e),r={read:async(s,i)=>{const o=await t.read(i);return s.decode(o)},write:async(s,i,o)=>{await t.write(i.encode(s),o)},writeV:async(s,i,o)=>{await t.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>r.read(s,i),write:async(i,o)=>r.write(i,s,o),writeV:async(i,o)=>r.writeV(i,s,o),unwrap:()=>r}),unwrap:()=>t.unwrap()};return r}const m_="0.1.0",w_="id",b_="1.0.0",E_=1024*8;var Mi;(function(n){let e;n.codec=()=>(e==null&&(e=tt((t,r,s={})=>{if(s.lengthDelimited!==!1&&r.fork(),t.protocolVersion!=null&&(r.uint32(42),r.string(t.protocolVersion)),t.agentVersion!=null&&(r.uint32(50),r.string(t.agentVersion)),t.publicKey!=null&&(r.uint32(10),r.bytes(t.publicKey)),t.listenAddrs!=null)for(const i of t.listenAddrs)r.uint32(18),r.bytes(i);if(t.observedAddr!=null&&(r.uint32(34),r.bytes(t.observedAddr)),t.protocols!=null)for(const i of t.protocols)r.uint32(26),r.string(i);t.signedPeerRecord!=null&&(r.uint32(66),r.bytes(t.signedPeerRecord)),s.lengthDelimited!==!1&&r.ldelim()},(t,r)=>{const s={listenAddrs:[],protocols:[]},i=r==null?t.len:t.pos+r;for(;t.pos<i;){const o=t.uint32();switch(o>>>3){case 5:s.protocolVersion=t.string();break;case 6:s.agentVersion=t.string();break;case 1:s.publicKey=t.bytes();break;case 2:s.listenAddrs.push(t.bytes());break;case 4:s.observedAddr=t.bytes();break;case 3:s.protocols.push(t.string());break;case 8:s.signedPeerRecord=t.bytes();break;default:t.skipType(o&7);break}}return s})),e),n.encode=t=>et(t,n.codec()),n.decode=t=>Je(t,n.codec())})(Mi||(Mi={}));function v_(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}var __=v_;const A_=ns(__),nc=typeof window=="object"&&typeof document=="object"&&document.nodeType===9,Fi=A_(),S_=nc&&!Fi,x_=Fi&&!nc,R_=Fi&&nc,I_=typeof globalThis.process<"u"&&typeof globalThis.process.release<"u"&&globalThis.process.release.name==="node"&&!Fi,k_=typeof importScripts=="function"&&typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,T_=typeof navigator<"u"&&navigator.product==="ReactNative",Wt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:E_,runOnConnectionOpen:!0,runOnTransientConnection:!0};function C_(n){if(n!=null&&n.length>0)try{return xe(n)}catch{}}function N_(n,e){return e!=null||(e=`${n.name}/${n.version}`,I_||x_?e+=` UserAgent=${globalThis.process.version}`:(S_||k_||R_||T_)&&(e+=` UserAgent=${globalThis.navigator.userAgent}`)),e}async function L_(n,e,t,r,s){if(t("received identify from %p",r.remotePeer),s==null)throw new R("message was null or undefined","ERR_INVALID_MESSAGE");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:xe(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null&&(i.publicKey=s.publicKey,!(await Cn(s.publicKey)).equals(r.remotePeer)))throw new R("public key did not match remote PeerId","ERR_INVALID_PUBLIC_KEY");let o;if(s.signedPeerRecord!=null){t("received signedPeerRecord from %p",r.remotePeer);let c=s.signedPeerRecord;const l=await Dn.openAndCertify(c,Kt.DOMAIN);let u=Kt.createFromProtobuf(l.payload);if(!u.peerId.equals(l.peerId))throw new R("signing key does not match PeerId in the PeerRecord","ERR_INVALID_SIGNING_KEY");if(!r.remotePeer.equals(u.peerId))throw new R("signing key does not match remote PeerId","ERR_INVALID_PEER_RECORD_KEY");let h;try{h=await n.get(u.peerId)}catch(g){if(g.code!=="ERR_NOT_FOUND")throw g}if(h!=null&&(i.metadata=h.metadata,h.peerRecordEnvelope!=null)){const g=await Dn.createFromProtobuf(h.peerRecordEnvelope),y=Kt.createFromProtobuf(g.payload);y.seqNumber>=u.seqNumber&&(t("sequence number was lower or equal to existing sequence number - stored: %d received: %d",y.seqNumber,u.seqNumber),u=y,c=h.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=u.multiaddrs.map(g=>({isCertified:!0,multiaddr:g})),o={seq:u.seqNumber,addresses:u.multiaddrs}}else t("%p did not send a signed peer record",r.remotePeer);if(t("patching %p with",r.remotePeer,i),await n.patch(r.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=z(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=z(s.protocolVersion)),t("merging %p metadata",r.remotePeer,c),await n.merge(r.remotePeer,{metadata:c})}const a={peerId:r.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>xe(c)),observedAddr:s.observedAddr==null?void 0:xe(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:r};return e.safeDispatchEvent("peer:identify",{detail:a}),a}class D_{constructor(e,t){f(this,"host");f(this,"protocol");f(this,"started");f(this,"timeout");f(this,"peerId");f(this,"peerStore");f(this,"registrar");f(this,"addressManager");f(this,"maxInboundStreams");f(this,"maxOutboundStreams");f(this,"maxMessageSize");f(this,"maxObservedAddresses");f(this,"events");f(this,"runOnTransientConnection");f(this,"log");this.protocol=t.protocol,this.started=!1,this.peerId=e.peerId,this.peerStore=e.peerStore,this.registrar=e.registrar,this.addressManager=e.addressManager,this.events=e.events,this.log=t.log,this.timeout=t.timeout??Wt.timeout,this.maxInboundStreams=t.maxInboundStreams??Wt.maxInboundStreams,this.maxOutboundStreams=t.maxOutboundStreams??Wt.maxOutboundStreams,this.maxMessageSize=t.maxMessageSize??Wt.maxMessageSize,this.maxObservedAddresses=t.maxObservedAddresses??Wt.maxObservedAddresses,this.runOnTransientConnection=t.runOnTransientConnection??Wt.runOnTransientConnection,this.host={protocolVersion:`${t.protocolPrefix??Wt.protocolPrefix}/${m_}`,agentVersion:N_(e.nodeInfo,t.agentVersion)}}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:z(this.host.agentVersion),ProtocolVersion:z(this.host.protocolVersion)}}),await this.registrar.handle(this.protocol,e=>{this.handleProtocol(e).catch(t=>{this.log.error(t)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0)}async stop(){await this.registrar.unhandle(this.protocol),this.started=!1}}class B_ extends(ig=D_,sg=ks,ig){constructor(t,r={}){super(t,{...r,protocol:`/${r.protocolPrefix??Wt.protocolPrefix}/${w_}/${b_}`,log:t.logger.forComponent("libp2p:identify")});f(this,sg,["@libp2p/identify"]);(r.runOnConnectionOpen??Wt.runOnConnectionOpen)&&t.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(o=>{this.log.error("error during identify trigged by connection:open",o)})})}async _identify(t,r={}){let s;if(r.signal==null){const i=AbortSignal.timeout(this.timeout);Se(1/0,i),r={...r,signal:i}}try{s=await t.newStream(this.protocol,{...r,runOnTransientConnection:this.runOnTransientConnection});const o=await Rd(s,{maxDataLength:this.maxMessageSize}).pb(Mi).read(r);return await s.close(r),o}catch(i){throw this.log.error("error while reading identify message",i),s==null||s.abort(i),i}}async identify(t,r={}){const s=await this._identify(t,r),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new R("public key was missing from identify message","ERR_MISSING_PUBLIC_KEY");const c=await Cn(i);if(!t.remotePeer.equals(c))throw new R("identified peer does not match the expected peer","ERR_INVALID_PEER");if(this.peerId.equals(c))throw new R("identified peer is our own peer id?","ERR_INVALID_PEER");const l=C_(a);return this.log("identify completed for peer %p and protocols %o",c,o),this.log("our observed address is %a",l),l!=null&&this.addressManager.getObservedAddrs().length<(this.maxObservedAddresses??1/0)&&(this.log("storing our observed address %a",l),this.addressManager.addObservedAddr(l)),L_(this.peerStore,this.events,this.log,t,s)}async handleProtocol(t){const{connection:r,stream:s}=t,i=AbortSignal.timeout(this.timeout);Se(1/0,i);try{const o=this.peerId.publicKey??new Uint8Array(0),a=await this.peerStore.get(this.peerId),c=this.addressManager.getAddresses().map(g=>g.decapsulateCode(j0("p2p").code));let l=a.peerRecordEnvelope;if(c.length>0&&l==null){const g=new Kt({peerId:this.peerId,multiaddrs:c});l=(await Dn.seal(g,this.peerId)).marshal().subarray()}let u=r.remoteAddr.bytes;jb.matches(r.remoteAddr)||(u=void 0),await Rd(s).pb(Mi).write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:o,listenAddrs:c.map(g=>g.bytes),signedPeerRecord:l,observedAddr:u,protocols:a.protocols},{signal:i}),await s.close({signal:i})}catch(o){this.log.error("could not respond to identify request",o),s.abort(o)}}}function O_(n={}){return e=>new B_(e,n)}let P_=require("webrtc/webrtc.js");const Id=location.hostname.split(".")[0],U_=location.pathname==="/"||location.pathname===""?`${Id}.github.io`:location.pathname.split("/")[1],Et=`${Id}/${U_}`,rc=`https://api.github.com/repos/${Et}/contents/data/state.json`,sc="gitchain_github_access_token",Vi=`https://api.github.com/repos/${Et}/issues`,kd="/gitchain/tx/1.0.0",gn="data/server-peer.json",M_=5*60*1e3;let pn=null,$i=!1,Td=null;function Cd(n,e,t,r){const s=`${n}${e}${t}${JSON.stringify(r)}`;return CryptoJS.SHA256(s).toString()}function F_(){const n=new Date().toISOString();return{index:0,previousHash:"0",timestamp:n,transactions:[],hash:Cd(0,"0",n,[])}}function Nd(n){return JSON.stringify(n,Object.keys(n).sort())}function ic(n){const t=sha3.keccak256(n).match(/.{2}/g);if(!t)throw new Error("Failed to parse hex string");return new Uint8Array(t.map(r=>parseInt(r,16)))}function V_(n){const e=new Uint8Array(n.length/2);for(let t=0;t<n.length;t+=2)e[t/2]=parseInt(n.substr(t,2),16);return e}function Es(n){return Array.from(n,e=>e.toString(16).padStart(2,"0")).join("")}function oc(n){try{const e=ic(Nd({from:n.from,to:n.to,amount:n.amount,nonce:n.nonce})),t=V_(n.signature);if(t.length!==65)return!1;const r=Es(t.slice(0,32)),s=Es(t.slice(32,64)),i=t[64]-27,o=new ec("secp256k1"),a=Es(e),c={r,s},l=o.recoverPubKey(a,c,i),u=ic(l.encode("array",!0).slice(1));return`0x${Es(u.slice(-20))}`.toLowerCase()===n.from.toLowerCase()}catch{return!1}}async function $_(n,e){const t=Es(ic(Nd({from:n.from,to:n.to,amount:n.amount,nonce:n.nonce})));return oc(n)?(e.nonces[n.from]||0)+1!==n.nonce?{valid:!1,txid:t}:n.from.toLowerCase()!==ee.toLowerCase()&&(e.balances[n.from]||0)<n.amount?{valid:!1,txid:t}:!/^0x[a-fA-F0-9]{40}$/.test(n.from)||!/^0x[a-fA-F0-9]{40}$/.test(n.to)?{valid:!1,txid:t}:(e.pending.push(n),{valid:!0,txid:t}):{valid:!1,txid:t}}async function H_(n){if(n.pending.length===0)return null;const e=[],t={...n.balances},r={...n.nonces};for(const l of n.pending)oc(l)&&(r[l.from]||0)+1===l.nonce&&(l.from.toLowerCase()===ee.toLowerCase()||(t[l.from]||0)>=l.amount)&&(l.from.toLowerCase()!==ee.toLowerCase()&&(t[l.from]=(t[l.from]||0)-l.amount),t[l.to]=(t[l.to]||0)+l.amount,r[l.from]=l.nonce,e.push(l));if(e.length===0)return n.pending=[],null;const s=n.chain.length,i=n.chain.length>0?n.chain[n.chain.length-1].hash:"0",o=new Date().toISOString(),a=Cd(s,i,o,e),c={index:s,previousHash:i,timestamp:o,transactions:e,hash:a};return n.chain.push(c),n.pending=[],n.balances=t,n.nonces=r,s}function yn(){var e;let n=localStorage.getItem(sc);if(!n){if(n=(e=document.getElementById("githubAccessToken"))==null?void 0:e.value,!n)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(sc,n)}return console.log("Retrieved GitHub access token"),n}async function K_(n){console.log("Entering initP2P, isHost:",n),$i=n;try{console.log("Creating libp2p node..."),pn=await tv({transports:[P_({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncryption:[qv()],streamMuxers:[y_()],services:{identify:O_()},addresses:{listen:["/webrtc"]}}),console.log("Starting libp2p node..."),await pn.start(),console.log("libp2p started, peerId:",pn.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(t=>setTimeout(t,1e3)),pn.addEventListener("peer:connect",t=>{console.log("Connected to peer:",t.detail.toString())}),console.log("Registering protocol handler for:",kd),await pn.handle(kd,async({stream:t,connection:r})=>{console.log("Incoming TX stream from",r.remotePeer.toString());const s=await q_(t);try{const i=JSON.parse(s);if(oc(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:Et,txn:i}),a=await fetch(Vi,{method:"POST",headers:{Authorization:`token ${yn()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}t.close()}),$i&&(console.log("Host mode: Advertising peer info"),await Ld(),console.log("Setting interval for periodic peer advertising"),setInterval(Ld,M_),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await z_()})),console.log("initP2P completed successfully")}catch(e){console.error("Failed to initialize P2P:",e),$i&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function Ld(n=3,e=1e3){if(console.log("Entering advertiseServerPeer, retries:",n),!$i||!pn)return console.log("Not in host mode or libp2p not initialized"),!1;const t=pn.peerId.toString(),r=pn.getMultiaddrs().map(a=>a.toString()),s={peerId:t,multiaddrs:r,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===Td)return console.log("No change in peer info, skipping update"),!0;Td=i;const o=yn();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=n;a++){console.log(`Attempt ${a}/${n} to advertise peer info`);try{console.log("Fetching SHA for",gn);const c=await Dd(gn);console.log("SHA:",c||"none (new file)");const l={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(l.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${Et}/contents/${gn}`);const u=await fetch(`https://api.github.com/repos/${Et}/contents/${gn}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(l)});if(u.ok)return console.log("Advertised peer info successfully"),!0;{const h=await u.text();if(console.error(`Attempt ${a}/${n} - Failed to advertise peer: ${u.status} ${h}`),(u.status===403||u.status===429)&&(console.log(`Retrying after ${e}ms due to ${u.status}`),a<n)){await new Promise(g=>setTimeout(g,e));continue}throw new Error(`HTTP ${u.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${n} - Error advertising peer:`,c),a===n)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(l=>setTimeout(l,e))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function z_(){console.log("Entering deleteServerPeerFile");const n=yn();if(!n){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",gn);const e=await Dd(gn);if(!e){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",gn);const t=await fetch(`https://api.github.com/repos/${Et}/contents/${gn}`,{method:"DELETE",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:e})});t.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",t.status,await t.text())}catch(e){console.error("Error deleting peer file:",e)}}async function Dd(n){console.log("Entering getFileSha for",n);const e=yn();if(!e)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${Et}/contents/${n}?ref=main`);const t=await fetch(`https://api.github.com/repos/${Et}/contents/${n}?ref=main`,{headers:{Authorization:`token ${e}`,Accept:"application/vnd.github.v3+json"}});if(t.ok){const r=await t.json();return console.log("SHA retrieved:",r.sha),r.sha}return t.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${n}: ${t.status} ${await t.text()}`),null)}catch(t){return console.error(`Error fetching SHA for ${n}:`,t),null}}async function q_(n){console.log("Reading stream to string");const e=[];for await(const s of n.source)e.push(s);const t=Pt(e),r=j(t);return console.log("Stream read complete, length:",r.length),r}async function Hi(){console.log("Entering fetchState");const n=yn();if(!n)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",rc);const e=await fetch(`${rc}?ref=main`,{headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json"}});if(!e.ok){if(e.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",e.status,await e.text()),new Error(`Error fetching state: ${e.statusText}`)}const t=await e.json(),r=JSON.parse(atob(t.content));return console.log("State fetched, chain length:",r.chain.length),{content:r,sha:t.sha}}catch(e){return console.error("Error fetching state:",e),null}}async function Ki(n,e,t,r=3){console.log("Entering updateState, message:",t);const s=yn();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(n,null,2));try{const o={message:t,content:i,branch:"main"};e&&(o.sha=e),console.log("Sending PUT request to update state");const a=await fetch(rc,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&r>0){console.log("Conflict detected, retrying...");const c=await Hi();if(!c)throw new Error("Failed to refetch");return Ki(n,c.sha,t,r-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function zi(n,e,t){console.log("Entering closeIssueWithComment, issue:",n);const r=yn();if(!r){console.log("No PAT available for closing issue");return}const s=t&&e!==null?`Confirmed in block ${e}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${Et}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${Et})`;console.log("Creating comment for issue:",n),await fetch(`${Vi}/${n}/comments`,{method:"POST",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",n),await fetch(`${Vi}/${n}`,{method:"PATCH",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function G_(){console.log("Entering processTxns");const n=document.getElementById("output"),e=document.getElementById("processingMessage");e.style.display="block";let t=await Hi(),r=t==null?void 0:t.content;if(!r){if(console.log("No state found, initializing"),r={chain:[F_()],pending:[],balances:{[ee]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await Ki(r,null,"Initialize state")){console.log("Failed to initialize state"),n.textContent+=`
Failed to initialize.`,e.style.display="none";return}t=await Hi(),r=t.content}console.log("Fetching open issues");const i=await(await fetch(`${Vi}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${yn()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=r.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(r.lastProcessedDate))continue;let c;try{const m=JSON.parse(a.body);if(m.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await zi(a.number,null,!1);continue}if(m.repo!==Et){console.log("Skipping issue from wrong repo:",a.number),await zi(a.number,null,!1);continue}c=m.txn}catch{console.log("Invalid issue body, closing:",a.number),await zi(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:l,txid:u}=await $_(c,r);console.log(`Transaction ID: ${u}, valid: ${l}`);const h=l?await H_(r):null;if(await zi(a.number,h,l),l&&h!==null?(console.log(`Transaction ID: ${u} settled in block ${h}`),n.textContent+=`
Processed txn ${u} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),n.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await Ki(r,t.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),n.textContent+=`
Failed to update state after issue #${a.number}`,e.style.display="none";return}t=await Hi(),r=t.content;const y=a.created_at;new Date(y)>new Date(o)&&(o=y)}o!==r.lastProcessedDate&&(console.log("Updating last processed date:",o),r.lastProcessedDate=o,await Ki(r,t.sha,"Update last processed date")),console.log("processTxns completed"),e.style.display="none"}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(sc)?(console.log("PAT found, initializing P2P as host"),K_(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{G_()},15e3)})})();
