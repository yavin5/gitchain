var n2=Object.defineProperty;var Ag=ne=>{throw TypeError(ne)};var r2=(ne,le,ve)=>le in ne?n2(ne,le,{enumerable:!0,configurable:!0,writable:!0,value:ve}):ne[le]=ve;var l=(ne,le,ve)=>r2(ne,typeof le!="symbol"?le+"":le,ve),wc=(ne,le,ve)=>le.has(ne)||Ag("Cannot "+ve);var $=(ne,le,ve)=>(wc(ne,le,"read from private field"),ve?ve.call(ne):le.get(ne)),ge=(ne,le,ve)=>le.has(ne)?Ag("Cannot add the same private member more than once"):le instanceof WeakSet?le.add(ne):le.set(ne,ve),ye=(ne,le,ve,ft)=>(wc(ne,le,"write to private field"),ft?ft.call(ne,ve):le.set(ne,ve),ve),H=(ne,le,ve)=>(wc(ne,le,"access private method"),ve);var os=(ne,le,ve,ft)=>({set _(ls){ye(ne,le,ls,ve)},get _(){return $(ne,le,ft)}});(function(){"use strict";var lc,uc,dc,hc,fc,gc,wt,Mf,Nf,Of,Ff,Bf,mc,pc,$f,ht,er,tr,yc,Ze,Yi,Xi,Qi,Uf,rr,Zi,zf,rt,ir,or,Qt,es,ar,ts,st,cr,He,ns,it,lr,Pt,rs,Wi,te,Cg,_g,Ig,Tg,Lg,Ji,bc,Ec,ji,Dg,eo,qf,Kf,Vf,Wf,Hf,Gf,Yf,Xf,Qf,Zf,Jf,jf,eg,ss,vc,tg,ng,rg,sg,ig,og,ag,cg,lg,ug,dg,hg,Je,Pg,as,cs,fg,gg,mg,pg,yg,wg,bg,Eg;const ne="0x097efb2a92bc5205e1615db52338a118f1619f3f",le=Symbol.for("@libp2p/connection"),ve=Symbol.for("@libp2p/content-routing");let ft=(lc=class extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}},l(lc,"name","AbortError"),lc);class ls extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}l(ls,"name","UnexpectedPeerError");let Rg=(uc=class extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},l(uc,"name","InvalidCryptoExchangeError"),uc),W=(dc=class extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},l(dc,"name","InvalidParametersError"),dc);class to extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}l(to,"name","InvalidPublicKeyError");class us extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}l(us,"name","ConnectionClosedError");class Sc extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}l(Sc,"name","ConnectionFailedError");class bn extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}l(bn,"name","MuxerClosedError");class no extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}l(no,"name","StreamResetError");class Zt extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}l(Zt,"name","StreamStateError");class ro extends Error{constructor(t="The stream buffer was full"){super(t),this.name="StreamBufferError"}}l(ro,"name","StreamBufferError");let so=(hc=class extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}},l(hc,"name","NotFoundError"),hc);class io extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}l(io,"name","InvalidPeerIdError");let ds=(fc=class extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}},l(fc,"name","InvalidMultiaddrError"),fc);class xc extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}l(xc,"name","InvalidCIDError");class Ac extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}l(Ac,"name","InvalidMultihashError");class Cc extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}l(Cc,"name","UnsupportedProtocolError");class ot extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}l(ot,"name","InvalidMessageError");let kg=(gc=class extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}},l(gc,"name","TimeoutError"),gc);class ur extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}l(ur,"name","NotStartedError");class dr extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}l(dr,"name","DialError");class hs extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}l(hs,"name","ListenError");class oo extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}l(oo,"name","LimitedConnectionError");class _c extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}l(_c,"name","TooManyInboundProtocolStreamsError");class ao extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}l(ao,"name","TooManyOutboundProtocolStreamsError");class fs extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}l(fs,"name","UnsupportedKeyTypeError");class Mg extends Event{constructor(e,n){super("message",n);l(this,"data");this.data=e}}class gs extends Event{constructor(e,n,s){super("close",s);l(this,"error");l(this,"local");this.error=n,this.local=e}}class Ng extends gs{constructor(t,e){super(!0,t,e)}}class Og extends gs{constructor(t,e){super(!1,t,e)}}const co=Symbol.for("@libp2p/peer-discovery"),lo=Symbol.for("@libp2p/peer-id");function hr(r){return!!(r!=null&&r[lo])}const Ic=Symbol.for("@libp2p/peer-routing"),uo="keep-alive";function ho(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function Tc(...r){const t=[];for(const e of r)ho(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function Lc(...r){const t=[];for(const e of r)ho(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}const Dc=Symbol.for("@libp2p/transport");var ms;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(ms||(ms={}));function s2(){}class Ge extends EventTarget{constructor(){super();ge(this,wt,new Map)}listenerCount(e){const n=$(this,wt).get(e);return n==null?0:n.length}addEventListener(e,n,s){super.addEventListener(e,n,s);let i=$(this,wt).get(e);i==null&&(i=[],$(this,wt).set(e,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(e,n,s){super.removeEventListener(e.toString(),n??null,s);let i=$(this,wt).get(e);i!=null&&(i=i.filter(({callback:o})=>o!==n),$(this,wt).set(e,i))}dispatchEvent(e){const n=super.dispatchEvent(e);let s=$(this,wt).get(e.type);return s==null||(s=s.filter(({once:i})=>!i),$(this,wt).set(e.type,s)),n}safeDispatchEvent(e,n={}){return this.dispatchEvent(new CustomEvent(e,n))}}wt=new WeakMap;const bt=Symbol.for("@libp2p/service-capabilities"),ps=Symbol.for("@libp2p/service-dependencies");function Fg(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ys(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Bg(r){return new TextEncoder().encode(r)}function $g(r){return new TextDecoder().decode(r)}function Ug(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function h(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,m=0,S=0,v=g.length;S!==v&&g[S]===0;)S++,y++;for(var E=(v-S)*d+1>>>0,L=new Uint8Array(E);S!==v;){for(var x=g[S],_=0,N=E-1;(x!==0||_<m)&&N!==-1;N--,_++)x+=256*L[N]>>>0,L[N]=x%a>>>0,x=x/a>>>0;if(x!==0)throw new Error("Non-zero carry");m=_,S++}for(var T=E-m;T!==E&&L[T]===0;)T++;for(var I=c.repeat(y);T<E;++T)I+=r.charAt(L[T]);return I}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var y=0;if(g[y]!==" "){for(var m=0,S=0;g[y]===c;)m++,y++;for(var v=(g.length-y)*u+1>>>0,E=new Uint8Array(v);g[y];){var L=e[g.charCodeAt(y)];if(L===255)return;for(var x=0,_=v-1;(L!==0||x<S)&&_!==-1;_--,x++)L+=a*E[_]>>>0,E[_]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");S=x,y++}if(g[y]!==" "){for(var N=v-S;N!==v&&E[N]===0;)N++;for(var T=new Uint8Array(m+(v-N)),I=m;N!==v;)T[I++]=E[N++];return T}}}function p(g){var y=f(g);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:h,decodeUnsafe:f,decode:p}}var zg=Ug,qg=zg;class Kg{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}let Vg=class{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseDecode");l(this,"prefixCodePoint");this.name=t,this.prefix=e;const s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Pc(this,t)}};class Wg{constructor(t){l(this,"decoders");this.decoders=t}or(t){return Pc(this,t)}decode(t){const e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Pc(r,t){return new Wg({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}class Hg{constructor(t,e,n,s){l(this,"name");l(this,"prefix");l(this,"baseEncode");l(this,"baseDecode");l(this,"encoder");l(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Kg(t,e,n),this.decoder=new Vg(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function ws({name:r,prefix:t,encode:e,decode:n}){return new Hg(r,t,e,n)}function fr({name:r,prefix:t,alphabet:e}){const{encode:n,decode:s}=qg(e,r);return ws({prefix:t,name:r,encode:n,decode:i=>ys(s(i))})}function Gg(r,t,e,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const d=t[r[u]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|d,o+=e,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=e||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function Yg(r,t,e){const n=t[t.length-1]==="=",s=(1<<e)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function Xg(r){const t={};for(let e=0;e<r.length;++e)t[r[e]]=e;return t}function Te({name:r,prefix:t,bitsPerChar:e,alphabet:n}){const s=Xg(n);return ws({prefix:t,name:r,encode(i){return Yg(i,n,e)},decode(i){return Gg(i,s,e,r)}})}const Le=fr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Qg=fr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Zg=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Le,base58flickr:Qg},Symbol.toStringTag,{value:"Module"})),Rt=Te({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Jg=Te({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),jg=Te({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),em=Te({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),tm=Te({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),nm=Te({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),rm=Te({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),sm=Te({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),im=Te({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),om=Object.freeze(Object.defineProperty({__proto__:null,base32:Rt,base32hex:tm,base32hexpad:rm,base32hexpadupper:sm,base32hexupper:nm,base32pad:jg,base32padupper:em,base32upper:Jg,base32z:im},Symbol.toStringTag,{value:"Module"})),bs=fr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),am=fr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),cm=Object.freeze(Object.defineProperty({__proto__:null,base36:bs,base36upper:am},Symbol.toStringTag,{value:"Module"}));var lm=kc,Rc=128,um=-128,dm=Math.pow(2,31);function kc(r,t,e){t=t||[],e=e||0;for(var n=e;r>=dm;)t[e++]=r&255|Rc,r/=128;for(;r&um;)t[e++]=r&255|Rc,r>>>=7;return t[e]=r|0,kc.bytes=e-n+1,t}var hm=fo,fm=128,Mc=127;function fo(r,n){var e=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw fo.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&Mc)<<s:(o&Mc)*Math.pow(2,s),s+=7}while(o>=fm);return fo.bytes=i-n,e}var gm=Math.pow(2,7),mm=Math.pow(2,14),pm=Math.pow(2,21),ym=Math.pow(2,28),wm=Math.pow(2,35),bm=Math.pow(2,42),Em=Math.pow(2,49),vm=Math.pow(2,56),Sm=Math.pow(2,63),xm=function(r){return r<gm?1:r<mm?2:r<pm?3:r<ym?4:r<wm?5:r<bm?6:r<Em?7:r<vm?8:r<Sm?9:10},Am={encode:lm,decode:hm,encodingLength:xm},Es=Am;function go(r,t=0){return[Es.decode(r,t),Es.decode.bytes]}function vs(r,t,e=0){return Es.encode(r,t,e),t}function Ss(r){return Es.encodingLength(r)}function xs(r,t){const e=t.byteLength,n=Ss(r),s=n+Ss(e),i=new Uint8Array(s+e);return vs(r,i,0),vs(e,i,n),i.set(t,s),new mo(r,e,t,i)}function gr(r){const t=ys(r),[e,n]=go(t),[s,i]=go(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new mo(e,s,o,t)}function Cm(r,t){if(r===t)return!0;{const e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Fg(r.bytes,e.bytes)}}class mo{constructor(t,e,n,s){l(this,"code");l(this,"size");l(this,"digest");l(this,"bytes");this.code=t,this.size=e,this.digest=n,this.bytes=s}}function Nc(r,t){const{bytes:e,version:n}=r;switch(n){case 0:return Im(e,po(r),t??Le.encoder);default:return Tm(e,po(r),t??Rt.encoder)}}const Oc=new WeakMap;function po(r){const t=Oc.get(r);if(t==null){const e=new Map;return Oc.set(r,e),e}return t}class me{constructor(t,e,n,s){l(this,"code");l(this,"version");l(this,"multihash");l(this,"bytes");l(this,"/");l(this,Mf,"CID");this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==mr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Lm)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return me.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,n=xs(t,e);return me.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return me.equals(this,t)}static equals(t,e){const n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Cm(t.multihash,n.multihash)}toString(t){return Nc(this,t)}toJSON(){return{"/":Nc(this)}}link(){return this}[(Mf=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof me)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:n,code:s,multihash:i,bytes:o}=e;return new me(n,s,i,o??Fc(n,s,i.bytes))}else if(e[Dm]===!0){const{version:n,multihash:s,code:i}=e,o=gr(s);return me.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==mr)throw new Error(`Version 0 CID must use dag-pb (code: ${mr}) block encoding`);return new me(t,e,n,n.bytes)}case 1:{const s=Fc(t,e,n.bytes);return new me(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return me.create(0,mr,t)}static createV1(t,e){return me.create(1,t,e)}static decode(t){const[e,n]=me.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=me.inspectBytes(t),n=e.size-e.multihashSize,s=ys(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=s.subarray(e.multihashSize-e.digestSize),o=new mo(e.multihashCode,e.digestSize,i,s);return[e.version===0?me.createV0(o):me.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const n=()=>{const[h,f]=go(t.subarray(e));return e+=f,h};let s=n(),i=mr;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=e,a=n(),c=n(),u=e+c,d=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:u}}static parse(t,e){const[n,s]=_m(t,e),i=me.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return po(i).set(n,t),i}}function _m(r,t){switch(r[0]){case"Q":{const e=t??Le;return[Le.prefix,e.decode(`${Le.prefix}${r}`)]}case Le.prefix:{const e=t??Le;return[Le.prefix,e.decode(r)]}case Rt.prefix:{const e=t??Rt;return[Rt.prefix,e.decode(r)]}case bs.prefix:{const e=t??bs;return[bs.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Im(r,t,e){const{prefix:n}=e;if(n!==Le.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const s=t.get(n);if(s==null){const i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Tm(r,t,e){const{prefix:n}=e,s=t.get(n);if(s==null){const i=e.encode(r);return t.set(n,i),i}else return s}const mr=112,Lm=18;function Fc(r,t,e){const n=Ss(r),s=n+Ss(t),i=new Uint8Array(s+e.byteLength);return vs(r,i,0),vs(t,i,n),i.set(e,s),i}const Dm=Symbol.for("@ipld/js-cid/CID"),Bc=0,Pm="identity",$c=ys;function Rm(r,t){if((t==null?void 0:t.truncate)!=null&&t.truncate!==r.byteLength){if(t.truncate<0||t.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t.truncate)}return xs(Bc,$c(r))}const pr={code:Bc,name:Pm,encode:$c,digest:Rm};function ze(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ae(r=0){return new Uint8Array(r)}function gt(r=0){return new Uint8Array(r)}function i2(r){return r}function kt(r,t){t==null&&(t=r.reduce((s,i)=>s+i.length,0));const e=gt(t);let n=0;for(const s of r)e.set(s,n),n+=s.length;return e}const Uc=Symbol.for("@achingbrain/uint8arraylist");function zc(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(const n of r){const s=e+n.byteLength;if(t<s)return{buf:n,index:t-e};e=s}throw new RangeError("index is out of bounds")}function As(r){return!!(r!=null&&r[Uc])}class Q{constructor(...t){l(this,"bufs");l(this,"length");l(this,Nf,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(Nf=Uc,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(const n of t)if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.push(n);else if(As(n))e+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(const n of t.reverse())if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.unshift(n);else if(As(n))e+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){const e=zc(this.bufs,t);return e.buf[e.index]}set(t,e){const n=zc(this.bufs,t);n.buf[n.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let n=0;n<t.length;n++)this.set(e+n,t[n]);else if(As(t))for(let n=0;n<t.length;n++)this.set(e+n,t.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){const{bufs:n,length:s}=this._subList(t,e);return kt(n,s)}subarray(t,e){const{bufs:n,length:s}=this._subList(t,e);return n.length===1?n[0]:kt(n,s)}sublist(t,e){const{bufs:n,length:s}=this._subList(t,e),i=new Q;return i.length=s,i.bufs=[...n],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const u=t>=a&&t<c,d=e>a&&e<=c;if(u&&d){if(t===a&&e===c){n.push(o);break}const h=t-a;n.push(o.subarray(h,h+(e-t)));break}if(u){if(t===0){n.push(o);continue}n.push(o.subarray(t-a));continue}if(d){if(e===c){n.push(o);break}n.push(o.subarray(0,e-a));break}n.push(o)}return{bufs:n,length:e-t}}indexOf(t,e=0){if(!As(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,u=n.byteLength-1;let d;for(let h=e;h<=c;h+=d){d=0;for(let f=u;f>=0;f--){const p=this.get(h+f);if(n[f]!==p){d=Math.max(1,f-a[p]);break}}if(d===0)return h}return-1}getInt8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,e),this.write(n,t)}getInt16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,e)}setInt16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,e,n),this.write(s,t)}getInt32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,e)}setInt32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,e,n),this.write(s,t)}getBigInt64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,e)}setBigInt64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,e,n),this.write(s,t)}getUint8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,e),this.write(n,t)}getUint16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,e)}setUint16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,e,n),this.write(s,t)}getUint32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,e)}setUint32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,e,n),this.write(s,t)}getBigUint64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,e)}setBigUint64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,e,n),this.write(s,t)}getFloat32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,e)}setFloat32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,e,n),this.write(s,t)}getFloat64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,e)}setFloat64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,e,n),this.write(s,t)}equals(t){if(t==null||!(t instanceof Q)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!ze(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){const n=new Q;return n.bufs=t,e==null&&(e=t.reduce((s,i)=>s+i.byteLength,0)),n.length=e,n}}const km=fr({prefix:"9",name:"base10",alphabet:"0123456789"}),Mm=Object.freeze(Object.defineProperty({__proto__:null,base10:km},Symbol.toStringTag,{value:"Module"})),Nm=Te({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Om=Te({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Fm=Object.freeze(Object.defineProperty({__proto__:null,base16:Nm,base16upper:Om},Symbol.toStringTag,{value:"Module"})),Bm=Te({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),$m=Object.freeze(Object.defineProperty({__proto__:null,base2:Bm},Symbol.toStringTag,{value:"Module"})),qc=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Um=qc.reduce((r,t,e)=>(r[e]=t,r),[]),zm=qc.reduce((r,t,e)=>{const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function qm(r){return r.reduce((t,e)=>(t+=Um[e],t),"")}function Km(r){const t=[];for(const e of r){const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);const s=zm[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}const Vm=ws({prefix:"ðŸš€",name:"base256emoji",encode:qm,decode:Km}),Wm=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Vm},Symbol.toStringTag,{value:"Module"})),Kc=Te({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Hm=Te({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Vc=Te({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Gm=Te({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Ym=Object.freeze(Object.defineProperty({__proto__:null,base64:Kc,base64pad:Hm,base64url:Vc,base64urlpad:Gm},Symbol.toStringTag,{value:"Module"})),Xm=Te({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Qm=Object.freeze(Object.defineProperty({__proto__:null,base8:Xm},Symbol.toStringTag,{value:"Module"})),Zm=ws({prefix:"\0",name:"identity",encode:r=>$g(r),decode:r=>Bg(r)}),Jm=Object.freeze(Object.defineProperty({__proto__:null,identity:Zm},Symbol.toStringTag,{value:"Module"}));new TextEncoder,new TextDecoder;const jm=20;function ep({name:r,code:t,encode:e,minDigestLength:n,maxDigestLength:s}){return new tp(r,t,e,n,s)}class tp{constructor(t,e,n,s,i){l(this,"name");l(this,"code");l(this,"encode");l(this,"minDigestLength");l(this,"maxDigestLength");this.name=t,this.code=e,this.encode=n,this.minDigestLength=s??jm,this.maxDigestLength=i}digest(t,e){if((e==null?void 0:e.truncate)!=null){if(e.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&e.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const n=this.encode(t);return n instanceof Uint8Array?Wc(n,this.code,e==null?void 0:e.truncate):n.then(s=>Wc(s,this.code,e==null?void 0:e.truncate))}else throw Error("Unknown type, must be binary type")}}function Wc(r,t,e){if(e!=null&&e!==r.byteLength){if(e>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e)}return xs(t,r)}function np(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}const Hc=ep({name:"sha2-256",code:18,encode:np("SHA-256")}),yo={...Jm,...$m,...Qm,...Mm,...Fm,...om,...cm,...Zg,...Ym,...Wm};function Gc(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}const Yc=Gc("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),wo=Gc("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);const t=gt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Xc={utf8:Yc,"utf-8":Yc,hex:yo.base16,latin1:wo,ascii:wo,binary:wo,...yo};function G(r,t="utf8"){const e=Xc[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function Z(r,t="utf8"){const e=Xc[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}const rp=parseInt("11111",2),bo=parseInt("10000000",2),sp=parseInt("01111111",2),Qc={0:wr,1:wr,2:ip,3:cp,4:lp,5:ap,6:op,16:wr,22:wr,48:wr};function Cs(r,t={offset:0}){const e=r[t.offset]&rp;if(t.offset++,Qc[e]!=null)return Qc[e](r,t);throw new Error("No decoder for tag "+e)}function yr(r,t){let e=0;if((r[t.offset]&bo)===bo){const n=r[t.offset]&sp;let s="0x";t.offset++;for(let i=0;i<n;i++,t.offset++)s+=r[t.offset].toString(16).padStart(2,"0");e=parseInt(s,16)}else e=r[t.offset],t.offset++;return e}function wr(r,t){yr(r,t);const e=[];for(;!(t.offset>=r.byteLength);){const n=Cs(r,t);if(n===null)break;e.push(n)}return e}function ip(r,t){const e=yr(r,t),n=t.offset,s=t.offset+e,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return t.offset+=e,Uint8Array.from(i)}function op(r,t){const e=yr(r,t),n=t.offset+e,s=r[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const u=r[t.offset];if(t.offset++,c.push(u&127),u<128){c.reverse();let d=0;for(let h=0;h<c.length;h++)d+=c[h]<<h*7;a+=`.${d}`,c=[]}}return a}function ap(r,t){return t.offset++,null}function cp(r,t){const e=yr(r,t),n=r[t.offset];t.offset++;const s=r.subarray(t.offset,t.offset+e-1);if(t.offset+=e,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function lp(r,t){const e=yr(r,t),n=r.subarray(t.offset,t.offset+e);return t.offset+=e,n}function up(r){let t=r.toString(16);t.length%2===1&&(t="0"+t);const e=new Q;for(let n=0;n<t.length;n+=2)e.append(Uint8Array.from([parseInt(`${t[n]}${t[n+1]}`,16)]));return e}function Eo(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const t=up(r.byteLength);return new Q(Uint8Array.from([t.byteLength|bo]),t)}function vo(r){const t=new Q,e=128;return(r.subarray()[0]&e)===e&&t.append(Uint8Array.from([0])),t.append(r),new Q(Uint8Array.from([2]),Eo(t),t)}function Zc(r){const t=Uint8Array.from([0]),e=new Q(t,r);return new Q(Uint8Array.from([3]),Eo(e),e)}function br(r,t=48){const e=new Q;for(const n of r)e.append(n);return new Q(Uint8Array.from([t]),Eo(e),e)}async function dp(r,t,e,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const hp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),fp=Uint8Array.from([6,5,43,129,4,0,34]),gp=Uint8Array.from([6,5,43,129,4,0,35]),mp={ext:!0,kty:"EC",crv:"P-256"},pp={ext:!0,kty:"EC",crv:"P-384"},yp={ext:!0,kty:"EC",crv:"P-521"},So=32,xo=48,Ao=66;function Jc(r){const t=Cs(r);return wp(t)}function wp(r){const t=r[1][1][0],e=1;let n,s;if(t.byteLength===So*2+1)return n=Z(t.subarray(e,e+So),"base64url"),s=Z(t.subarray(e+So),"base64url"),new Co({...mp,key_ops:["verify"],x:n,y:s});if(t.byteLength===xo*2+1)return n=Z(t.subarray(e,e+xo),"base64url"),s=Z(t.subarray(e+xo),"base64url"),new Co({...pp,key_ops:["verify"],x:n,y:s});if(t.byteLength===Ao*2+1)return n=Z(t.subarray(e,e+Ao),"base64url"),s=Z(t.subarray(e+Ao),"base64url"),new Co({...yp,key_ops:["verify"],x:n,y:s});throw new W(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function bp(r){return br([vo(Uint8Array.from([1])),br([Ep(r.crv)],160),br([Zc(new Q(Uint8Array.from([4]),G(r.x??"","base64url"),G(r.y??"","base64url")))],161)]).subarray()}function Ep(r){if(r==="P-256")return hp;if(r==="P-384")return fp;if(r==="P-521")return gp;throw new W(`Invalid curve ${r}`)}class Co{constructor(t){l(this,"type","ECDSA");l(this,"jwk");l(this,"_raw");this.jwk=t}get raw(){return this._raw==null&&(this._raw=bp(this.jwk)),this._raw}toMultihash(){return pr.digest(At(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Le.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:ze(this.raw,t.raw)}async verify(t,e,n){return dp(this.jwk,e,t,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _s(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Mt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function Y(r,t,e=""){const n=_s(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Is(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Mt(r.outputLen),Mt(r.blockLen)}function Ts(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function vp(r,t){Y(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function Jt(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function _o(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function mt(r,t){return r<<32-t|r>>>t}const jc=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Sp=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Er(r){if(Y(r),jc)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=Sp[r[e]];return t}const Et={_0:48,_9:57,A:65,F:70,a:97,f:102};function el(r){if(r>=Et._0&&r<=Et._9)return r-Et._0;if(r>=Et.A&&r<=Et.F)return r-(Et.A-10);if(r>=Et.a&&r<=Et.f)return r-(Et.a-10)}function vr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(jc)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=el(r.charCodeAt(i)),a=el(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function pt(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];Y(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function tl(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function Sr(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(t==null?void 0:t.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const nl=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function xp(r,t,e){return r&t^~r&e}function Ap(r,t,e){return r&t^r&e^t&e}class rl{constructor(t,e,n,s){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=_o(this.buffer)}update(t){Ts(this),Y(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=_o(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ts(this),vp(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,Jt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)e[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=_o(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,d[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const Nt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Ne=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Ls=BigInt(2**32-1),sl=BigInt(32);function Cp(r,t=!1){return t?{h:Number(r&Ls),l:Number(r>>sl&Ls)}:{h:Number(r>>sl&Ls)|0,l:Number(r&Ls)|0}}function _p(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=Cp(r[i],t);[n[i],s[i]]=[o,a]}return[n,s]}const il=(r,t,e)=>r>>>e,ol=(r,t,e)=>r<<32-e|t>>>e,En=(r,t,e)=>r>>>e|t<<32-e,vn=(r,t,e)=>r<<32-e|t>>>e,Ds=(r,t,e)=>r<<64-e|t>>>e-32,Ps=(r,t,e)=>r>>>e-32|t<<64-e;function vt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Ip=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Tp=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Lp=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Dp=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Pp=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),Rp=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,kp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ot=new Uint32Array(64);class Mp extends rl{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)Ot[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=Ot[h-15],p=Ot[h-2],g=mt(f,7)^mt(f,18)^f>>>3,y=mt(p,17)^mt(p,19)^p>>>10;Ot[h]=y+Ot[h-7]+g+Ot[h-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let h=0;h<64;h++){const f=mt(a,6)^mt(a,11)^mt(a,25),p=d+f+xp(a,c,u)+kp[h]+Ot[h]|0,y=(mt(n,2)^mt(n,13)^mt(n,22))+Ap(n,s,i)|0;d=u,u=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){Jt(Ot)}destroy(){this.set(0,0,0,0,0,0,0,0),Jt(this.buffer)}}class Np extends Mp{constructor(){super(32);l(this,"A",Nt[0]|0);l(this,"B",Nt[1]|0);l(this,"C",Nt[2]|0);l(this,"D",Nt[3]|0);l(this,"E",Nt[4]|0);l(this,"F",Nt[5]|0);l(this,"G",Nt[6]|0);l(this,"H",Nt[7]|0)}}const al=_p(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Op=al[0],Fp=al[1],Ft=new Uint32Array(80),Bt=new Uint32Array(80);class Bp extends rl{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:d,Fh:h,Fl:f,Gh:p,Gl:g,Hh:y,Hl:m}=this;return[t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m]}set(t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=d|0,this.Fh=h|0,this.Fl=f|0,this.Gh=p|0,this.Gl=g|0,this.Hh=y|0,this.Hl=m|0}process(t,e){for(let E=0;E<16;E++,e+=4)Ft[E]=t.getUint32(e),Bt[E]=t.getUint32(e+=4);for(let E=16;E<80;E++){const L=Ft[E-15]|0,x=Bt[E-15]|0,_=En(L,x,1)^En(L,x,8)^il(L,x,7),N=vn(L,x,1)^vn(L,x,8)^ol(L,x,7),T=Ft[E-2]|0,I=Bt[E-2]|0,B=En(T,I,19)^Ds(T,I,61)^il(T,I,6),U=vn(T,I,19)^Ps(T,I,61)^ol(T,I,6),k=Lp(N,U,Bt[E-7],Bt[E-16]),M=Dp(k,_,B,Ft[E-7],Ft[E-16]);Ft[E]=M|0,Bt[E]=k|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:d,Eh:h,El:f,Fh:p,Fl:g,Gh:y,Gl:m,Hh:S,Hl:v}=this;for(let E=0;E<80;E++){const L=En(h,f,14)^En(h,f,18)^Ds(h,f,41),x=vn(h,f,14)^vn(h,f,18)^Ps(h,f,41),_=h&p^~h&y,N=f&g^~f&m,T=Pp(v,x,N,Fp[E],Bt[E]),I=Rp(T,S,L,_,Op[E],Ft[E]),B=T|0,U=En(n,s,28)^Ds(n,s,34)^Ds(n,s,39),k=vn(n,s,28)^Ps(n,s,34)^Ps(n,s,39),M=n&i^n&a^i&a,w=s&o^s&c^o&c;S=y|0,v=m|0,y=p|0,m=g|0,p=h|0,g=f|0,{h,l:f}=vt(u|0,d|0,I|0,B|0),u=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=Ip(B,k,w);n=Tp(b,I,U,M),s=b|0}({h:n,l:s}=vt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=vt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=vt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:d}=vt(this.Dh|0,this.Dl|0,u|0,d|0),{h,l:f}=vt(this.Eh|0,this.El|0,h|0,f|0),{h:p,l:g}=vt(this.Fh|0,this.Fl|0,p|0,g|0),{h:y,l:m}=vt(this.Gh|0,this.Gl|0,y|0,m|0),{h:S,l:v}=vt(this.Hh|0,this.Hl|0,S|0,v|0),this.set(n,s,i,o,a,c,u,d,h,f,p,g,y,m,S,v)}roundClean(){Jt(Ft,Bt)}destroy(){Jt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $p extends Bp{constructor(){super(64);l(this,"Ah",Ne[0]|0);l(this,"Al",Ne[1]|0);l(this,"Bh",Ne[2]|0);l(this,"Bl",Ne[3]|0);l(this,"Ch",Ne[4]|0);l(this,"Cl",Ne[5]|0);l(this,"Dh",Ne[6]|0);l(this,"Dl",Ne[7]|0);l(this,"Eh",Ne[8]|0);l(this,"El",Ne[9]|0);l(this,"Fh",Ne[10]|0);l(this,"Fl",Ne[11]|0);l(this,"Gh",Ne[12]|0);l(this,"Gl",Ne[13]|0);l(this,"Hh",Ne[14]|0);l(this,"Hl",Ne[15]|0)}}const xr=tl(()=>new Np,nl(1)),Up=tl(()=>new $p,nl(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Io=BigInt(0),To=BigInt(1);function jt(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function cl(r){if(typeof r=="bigint"){if(!Ms(r))throw new Error("positive bigint expected, got "+r)}else Mt(r);return r}function Rs(r){const t=cl(r).toString(16);return t.length&1?"0"+t:t}function ll(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Io:BigInt("0x"+r)}function ks(r){return ll(Er(r))}function en(r){return ll(Er(Ar(Y(r)).reverse()))}function Lo(r,t){Mt(t),r=cl(r);const e=vr(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Do(r,t){return Lo(r,t).reverse()}function Ar(r){return Uint8Array.from(r)}const Ms=r=>typeof r=="bigint"&&Io<=r;function zp(r,t,e){return Ms(r)&&Ms(t)&&Ms(e)&&t<=r&&r<e}function Cr(r,t,e,n){if(!zp(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function qp(r){let t;for(t=0;r>Io;r>>=To,t+=1);return t}const Po=r=>(To<<BigInt(r))-To;function Kp(r,t,e){if(Mt(r,"hashLen"),Mt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=m=>new Uint8Array(m),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),d=0;const h=()=>{c.fill(1),u.fill(0),d=0},f=(...m)=>e(u,pt(c,...m)),p=(m=s)=>{u=f(i,m),c=f(),m.length!==0&&(u=f(o,m),c=f())},g=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const S=[];for(;m<t;){c=f();const v=c.slice();S.push(v),m+=c.length}return pt(...S)};return(m,S)=>{h(),p(m);let v;for(;!(v=S(g()));)p();return h(),v}}function Sn(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(t,!1),s(e,!0)}function Ns(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ye=BigInt(0),De=BigInt(1),tn=BigInt(2),ul=BigInt(3),dl=BigInt(4),hl=BigInt(5),Vp=BigInt(7),fl=BigInt(8),Wp=BigInt(9),gl=BigInt(16);function Se(r,t){const e=r%t;return e>=Ye?e:t+e}function be(r,t,e){let n=r;for(;t-- >Ye;)n*=n,n%=e;return n}function ml(r,t){if(r===Ye)throw new Error("invert: expected non-zero number");if(t<=Ye)throw new Error("invert: expected positive modulus, got "+t);let e=Se(r,t),n=t,s=Ye,i=De;for(;e!==Ye;){const a=n/e,c=n%e,u=s-i*a;n=e,e=c,s=i,i=u}if(n!==De)throw new Error("invert: does not exist");return Se(s,t)}function Ro(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function pl(r,t){const e=(r.ORDER+De)/dl,n=r.pow(t,e);return Ro(r,n,t),n}function Hp(r,t){const e=(r.ORDER-hl)/fl,n=r.mul(t,tn),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,tn),s),a=r.mul(i,r.sub(o,r.ONE));return Ro(r,a,t),a}function Gp(r){const t=Os(r),e=yl(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+Vp)/gl;return(a,c)=>{let u=a.pow(c,o),d=a.mul(u,n);const h=a.mul(u,s),f=a.mul(u,i),p=a.eql(a.sqr(d),c),g=a.eql(a.sqr(h),c);u=a.cmov(u,d,p),d=a.cmov(f,h,g);const y=a.eql(a.sqr(d),c),m=a.cmov(u,d,y);return Ro(a,m,c),m}}function yl(r){if(r<ul)throw new Error("sqrt is not defined for small field");let t=r-De,e=0;for(;t%tn===Ye;)t/=tn,e++;let n=tn;const s=Os(r);for(;bl(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return pl;let i=s.pow(n,t);const o=(t+De)/tn;return function(c,u){if(c.is0(u))return u;if(bl(c,u)!==1)throw new Error("Cannot find square root");let d=e,h=c.mul(c.ONE,i),f=c.pow(u,t),p=c.pow(u,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,y=c.sqr(f);for(;!c.eql(y,c.ONE);)if(g++,y=c.sqr(y),g===d)throw new Error("Cannot find square root");const m=De<<BigInt(d-g-1),S=c.pow(h,m);d=g,h=c.sqr(S),f=c.mul(f,h),p=c.mul(p,S)}return p}}function Yp(r){return r%dl===ul?pl:r%fl===hl?Hp:r%gl===Wp?Gp(r):yl(r)}const Xp=(r,t)=>(Se(r,t)&De)===De,Qp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zp(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Qp.reduce((n,s)=>(n[s]="function",n),t);return Sn(r,e),r}function Jp(r,t,e){if(e<Ye)throw new Error("invalid exponent, negatives unsupported");if(e===Ye)return r.ONE;if(e===De)return t;let n=r.ONE,s=t;for(;e>Ye;)e&De&&(n=r.mul(n,s)),s=r.sqr(s),e>>=De;return n}function wl(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return t.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function bl(r,t){const e=(r.ORDER-De)/tn,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function jp(r,t){t!==void 0&&Mt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ey{constructor(t,e={}){l(this,"ORDER");l(this,"BITS");l(this,"BYTES");l(this,"isLE");l(this,"ZERO",Ye);l(this,"ONE",De);l(this,"_lengths");l(this,"_sqrt");l(this,"_mod");var o;if(t<=Ye)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=(o=e.allowedLengths)==null?void 0:o.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=jp(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return Se(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return Ye<=t&&t<this.ORDER}is0(t){return t===Ye}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&De)===De}neg(t){return Se(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return Se(t*t,this.ORDER)}add(t,e){return Se(t+e,this.ORDER)}sub(t,e){return Se(t-e,this.ORDER)}mul(t,e){return Se(t*e,this.ORDER)}pow(t,e){return Jp(this,t,e)}div(t,e){return Se(t*ml(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return ml(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Yp(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Do(t,this.BYTES):Lo(t,this.BYTES)}fromBytes(t,e=!1){Y(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?en(t):ks(t);if(a&&(c=Se(c,o)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return wl(this,t)}cmov(t,e,n){return n?e:t}}function Os(r,t={}){return new ey(r,t)}function El(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function vl(r){const t=El(r);return t+Math.ceil(t/2)}function ty(r,t,e=!1){Y(r);const n=r.length,s=El(t),i=vl(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?en(r):ks(r),a=Se(o,t-De)+De;return e?Do(a,s):Lo(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xn=BigInt(0),nn=BigInt(1);function Fs(r,t){const e=t.negate();return r?e:t}function _r(r,t){const e=wl(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function Sl(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function ko(r,t){Sl(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=Po(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function xl(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=nn);const u=t*n,d=u+Math.abs(a)-1,h=a===0,f=a<0,p=t%2!==0;return{nextN:c,offset:d,isZero:h,isNeg:f,isNegF:p,offsetF:u}}const Mo=new WeakMap,Al=new WeakMap;function No(r){return Al.get(r)||1}function Cl(r){if(r!==xn)throw new Error("invalid wNAF")}class _l{constructor(t,e){l(this,"BASE");l(this,"ZERO");l(this,"Fn");l(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>xn;)e&nn&&(n=n.add(s)),s=s.double(),e>>=nn;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=ko(e,this.bits),i=[];let o=t,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=ko(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:f,offsetF:p}=xl(n,a,o);n=c,d?i=i.add(Fs(f,e[p])):s=s.add(Fs(h,e[u]))}return Cl(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=ko(t,this.bits);for(let o=0;o<i.windows&&n!==xn;o++){const{nextN:a,offset:c,isZero:u,isNeg:d}=xl(n,o,i);if(n=a,!u){const h=e[c];s=s.add(d?h.negate():h)}}return Cl(n),s}getPrecomputes(t,e,n){let s=Mo.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),Mo.set(e,s))),s}cached(t,e,n){const s=No(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=No(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){Sl(e,this.bits),Al.set(t,e),Mo.delete(t)}hasCache(t){return No(t)!==1}}function ny(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>xn||n>xn;)e&nn&&(i=i.add(s)),n&nn&&(o=o.add(s)),s=s.double(),e>>=nn,n>>=nn;return{p1:i,p2:o}}function Il(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Zp(t),t}else return Os(r,{isLE:e})}function Tl(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>xn))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Il(t.p,e.Fp,n),i=Il(t.n,e.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function Oo(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $t=BigInt(0),Ie=BigInt(1),Fo=BigInt(2),ry=BigInt(8);function sy(r,t,e,n){const s=r.sqr(e),i=r.sqr(n),o=r.add(r.mul(t.a,s),i),a=r.add(r.ONE,r.mul(t.d,r.mul(s,i)));return r.eql(o,a)}function iy(r,t={}){const e=Tl("edwards",r,t,t.FpFnLE),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o}=i;Sn(t,{},{uvRatio:"function"});const a=Fo<<BigInt(s.BYTES*8)-Ie,c=S=>n.create(S),u=t.uvRatio||((S,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(S,v))}}catch{return{isValid:!1,value:$t}}});if(!sy(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(S,v,E=!1){const L=E?Ie:$t;return Cr("coordinate "+S,v,L,a),v}function h(S){if(!(S instanceof g))throw new Error("EdwardsPoint expected")}const f=Ns((S,v)=>{const{X:E,Y:L,Z:x}=S,_=S.is0();v==null&&(v=_?ry:n.inv(x));const N=c(E*v),T=c(L*v),I=n.mul(x,v);if(_)return{x:$t,y:Ie};if(I!==Ie)throw new Error("invZ was invalid");return{x:N,y:T}}),p=Ns(S=>{const{a:v,d:E}=i;if(S.is0())throw new Error("bad point: ZERO");const{X:L,Y:x,Z:_,T:N}=S,T=c(L*L),I=c(x*x),B=c(_*_),U=c(B*B),k=c(T*v),M=c(B*c(k+I)),w=c(U+c(E*c(T*I)));if(M!==w)throw new Error("bad point: equation left != right (1)");const b=c(L*x),C=c(_*N);if(b!==C)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(v,E,L,x){l(this,"X");l(this,"Y");l(this,"Z");l(this,"T");this.X=d("x",v),this.Y=d("y",E),this.Z=d("z",L,!0),this.T=d("t",x),Object.freeze(this)}static CURVE(){return i}static fromAffine(v){if(v instanceof m)throw new Error("extended point not allowed");const{x:E,y:L}=v||{};return d("x",E),d("y",L),new m(E,L,Ie,c(E*L))}static fromBytes(v,E=!1){const L=n.BYTES,{a:x,d:_}=i;v=Ar(Y(v,L,"point")),jt(E,"zip215");const N=Ar(v),T=v[L-1];N[L-1]=T&-129;const I=en(N),B=E?a:n.ORDER;Cr("point.y",I,$t,B);const U=c(I*I),k=c(U-Ie),M=c(_*U-x);let{isValid:w,value:b}=u(k,M);if(!w)throw new Error("bad point: invalid y coordinate");const C=(b&Ie)===Ie,D=(T&128)!==0;if(!E&&b===$t&&D)throw new Error("bad point: x=0 and x_0=1");return D!==C&&(b=c(-b)),m.fromAffine({x:b,y:I})}static fromHex(v,E=!1){return m.fromBytes(vr(v),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,E=!0){return y.createCache(this,v),E||this.multiply(Fo),this}assertValidity(){p(this)}equals(v){h(v);const{X:E,Y:L,Z:x}=this,{X:_,Y:N,Z:T}=v,I=c(E*T),B=c(_*x),U=c(L*T),k=c(N*x);return I===B&&U===k}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=i,{X:E,Y:L,Z:x}=this,_=c(E*E),N=c(L*L),T=c(Fo*c(x*x)),I=c(v*_),B=E+L,U=c(c(B*B)-_-N),k=I+N,M=k-T,w=I-N,b=c(U*M),C=c(k*w),D=c(U*w),R=c(M*k);return new m(b,C,R,D)}add(v){h(v);const{a:E,d:L}=i,{X:x,Y:_,Z:N,T}=this,{X:I,Y:B,Z:U,T:k}=v,M=c(x*I),w=c(_*B),b=c(T*L*k),C=c(N*U),D=c((x+_)*(I+B)-M-w),R=C-b,A=C+b,O=c(w-E*M),P=c(D*R),F=c(A*O),z=c(D*O),re=c(R*A);return new m(P,F,re,z)}subtract(v){return this.add(v.negate())}multiply(v){if(!s.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:L}=y.cached(this,v,x=>_r(m,x));return _r(m,[E,L])[0]}multiplyUnsafe(v,E=m.ZERO){if(!s.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===$t?m.ZERO:this.is0()||v===Ie?this:y.unsafe(this,v,L=>_r(m,L),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(v){return f(this,v)}clearCofactor(){return o===Ie?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:E}=this.toAffine(),L=n.toBytes(E);return L[L.length-1]|=v&Ie?128:0,L}toHex(){return Er(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(m,"BASE",new m(i.Gx,i.Gy,Ie,c(i.Gx*i.Gy))),l(m,"ZERO",new m($t,Ie,Ie,$t)),l(m,"Fp",n),l(m,"Fn",s);let g=m;const y=new _l(g,s.BITS);return g.BASE.precompute(8),g}function oy(r,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');Sn(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=e,{BASE:s,Fp:i,Fn:o}=r,a=e.randomBytes||Sr,c=e.adjustScalarBytes||(T=>T),u=e.domain||((T,I,B)=>{if(jt(B,"phflag"),I.length||B)throw new Error("Contexts/pre-hash are not supported");return T});function d(T){return o.create(en(T))}function h(T){const I=E.secretKey;Y(T,E.secretKey,"secretKey");const B=Y(t(T),2*I,"hashedSecretKey"),U=c(B.slice(0,I)),k=B.slice(I,2*I),M=d(U);return{head:U,prefix:k,scalar:M}}function f(T){const{head:I,prefix:B,scalar:U}=h(T),k=s.multiply(U),M=k.toBytes();return{head:I,prefix:B,scalar:U,point:k,pointBytes:M}}function p(T){return f(T).pointBytes}function g(T=Uint8Array.of(),...I){const B=pt(...I);return d(t(u(B,Y(T,void 0,"context"),!!n)))}function y(T,I,B={}){T=Y(T,void 0,"message"),n&&(T=n(T));const{prefix:U,scalar:k,pointBytes:M}=f(I),w=g(B.context,U,T),b=s.multiply(w).toBytes(),C=g(B.context,b,M,T),D=o.create(w+C*k);if(!o.isValid(D))throw new Error("sign failed: invalid s");const R=pt(b,o.toBytes(D));return Y(R,E.signature,"result")}const m={zip215:!0};function S(T,I,B,U=m){const{context:k,zip215:M}=U,w=E.signature;T=Y(T,w,"signature"),I=Y(I,void 0,"message"),B=Y(B,E.publicKey,"publicKey"),M!==void 0&&jt(M,"zip215"),n&&(I=n(I));const b=w/2,C=T.subarray(0,b),D=en(T.subarray(b,w));let R,A,O;try{R=r.fromBytes(B,M),A=r.fromBytes(C,M),O=s.multiplyUnsafe(D)}catch{return!1}if(!M&&R.isSmallOrder())return!1;const P=g(k,A.toBytes(),R.toBytes(),I);return A.add(R.multiplyUnsafe(P)).subtract(O).clearCofactor().is0()}const v=i.BYTES,E={secretKey:v,publicKey:v,signature:2*v,seed:v};function L(T=a(E.seed)){return Y(T,E.seed,"seed")}function x(T){return _s(T)&&T.length===o.BYTES}function _(T,I){try{return!!r.fromBytes(T,I)}catch{return!1}}const N={getExtendedPublicKey:f,randomSecretKey:L,isValidSecretKey:x,isValidPublicKey:_,toMontgomery(T){const{y:I}=r.fromBytes(T),B=E.publicKey,U=B===32;if(!U&&B!==57)throw new Error("only defined for 25519 and 448");const k=U?i.div(Ie+I,Ie-I):i.div(I-Ie,I+Ie);return i.toBytes(k)},toMontgomerySecret(T){const I=E.secretKey;Y(T,I);const B=t(T.subarray(0,I));return c(B).subarray(0,I)}};return Object.freeze({keygen:Oo(L,p),getPublicKey:p,sign:y,verify:S,utils:N,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ir=BigInt(0),An=BigInt(1),Bs=BigInt(2);function ay(r){return Sn(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function cy(r){const t=ay(r),{P:e,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=t,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||Sr,u=a?255:448,d=a?32:56,h=BigInt(a?9:5),f=BigInt(a?121665:39081),p=a?Bs**BigInt(254):Bs**BigInt(447),g=a?BigInt(8)*Bs**BigInt(251)-An:BigInt(4)*Bs**BigInt(445)-An,y=p+g+An,m=w=>Se(w,e),S=v(h);function v(w){return Do(m(w),d)}function E(w){const b=Ar(Y(w,d,"uCoordinate"));return a&&(b[31]&=127),m(en(b))}function L(w){return en(s(Ar(Y(w,d,"scalar"))))}function x(w,b){const C=B(E(b),L(w));if(C===Ir)throw new Error("invalid private or public key received");return v(C)}function _(w){return x(w,S)}const N=_,T=x;function I(w,b,C){const D=m(w*(b-C));return b=m(b-D),C=m(C+D),{x_2:b,x_3:C}}function B(w,b){Cr("u",w,Ir,e),Cr("scalar",b,p,y);const C=b,D=w;let R=An,A=Ir,O=w,P=An,F=Ir;for(let re=BigInt(u-1);re>=Ir;re--){const j=C>>re&An;F^=j,{x_2:R,x_3:O}=I(F,R,O),{x_2:A,x_3:P}=I(F,A,P),F=j;const K=R+A,ce=m(K*K),fe=R-A,Ee=m(fe*fe),we=ce-Ee,Me=O+P,Gi=O-P,is=m(Gi*K),vg=m(Me*fe),Sg=is+vg,xg=is-vg;O=m(Sg*Sg),P=m(D*m(xg*xg)),R=m(ce*Ee),A=m(we*(ce+m(f*we)))}({x_2:R,x_3:O}=I(F,R,O)),{x_2:A,x_3:P}=I(F,A,P);const z=i(A);return m(R*z)}const U={secretKey:d,publicKey:d,seed:d},k=(w=c(d))=>(Y(w,U.seed,"seed"),w),M={randomSecretKey:k};return Object.freeze({keygen:Oo(k,N),getSharedSecret:T,getPublicKey:N,scalarMult:x,scalarMultBase:_,utils:M,GuBytes:S.slice(),lengths:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ly=BigInt(1),Ll=BigInt(2),uy=BigInt(3),dy=BigInt(5),hy=BigInt(8),$s=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),fy={p:$s,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:hy,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Dl(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=$s,a=r*r%i*r%i,c=be(a,Ll,i)*a%i,u=be(c,ly,i)*r%i,d=be(u,dy,i)*u%i,h=be(d,t,i)*d%i,f=be(h,e,i)*h%i,p=be(f,n,i)*f%i,g=be(p,s,i)*p%i,y=be(g,s,i)*p%i,m=be(y,t,i)*d%i;return{pow_p_5_8:be(m,Ll,i)*r%i,b2:a}}function Pl(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const Rl=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function gy(r,t){const e=$s,n=Se(t*t*t,e),s=Se(n*n*t,e),i=Dl(r*s).pow_p_5_8;let o=Se(r*n*i,e);const a=Se(t*o*o,e),c=o,u=Se(o*Rl,e),d=a===r,h=a===Se(-r,e),f=a===Se(-r*Rl,e);return d&&(o=c),(h||f)&&(o=u),Xp(o,e)&&(o=Se(-o,e)),{isValid:d||h,value:o}}const my=iy(fy,{uvRatio:gy});function py(r){return oy(my,Up,Object.assign({adjustScalarBytes:Pl},r))}const Us=py({}),zs=(()=>{const r=$s;return cy({P:r,type:"x25519",powPminus2:t=>{const{pow_p_5_8:e,b2:n}=Dl(t);return Se(be(e,uy,r)*n,r)},adjustScalarBytes:Pl})})();class kl extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class yy extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const rn={get(r=globalThis){const t=r.crypto;if((t==null?void 0:t.subtle)==null)throw new yy("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},Ml=32,Bo=64,$o=32;let Cn;const Nl=(async()=>{try{return await rn.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function wy(){const r=Us.utils.randomSecretKey(),t=Us.getPublicKey(r);return{privateKey:Cy(r,t),publicKey:t}}async function by(r,t){let e;r.length===Bo?e=r.subarray(0,32):e=r;const n={crv:"Ed25519",kty:"OKP",x:Z(r.subarray(32),"base64url"),d:Z(e,"base64url"),ext:!0,key_ops:["sign"]},s=await rn.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await rn.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Ey(r,t){const e=r.subarray(0,$o);return Us.sign(t instanceof Uint8Array?t:t.subarray(),e)}async function vy(r,t){return Cn==null&&(Cn=await Nl),Cn?by(r,t):Ey(r,t)}async function Sy(r,t,e){if(r.buffer instanceof ArrayBuffer){const n=await rn.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await rn.get().subtle.verify({name:"Ed25519"},n,t,e instanceof Uint8Array?e:e.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function xy(r,t,e){return Us.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}async function Ay(r,t,e){return Cn==null&&(Cn=await Nl),Cn?Sy(r,t,e):xy(r,t,e)}function Cy(r,t){const e=new Uint8Array(Bo);for(let n=0;n<$o;n++)e[n]=r[n],e[$o+n]=t[n];return e}function Uo(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Ol{constructor(t){l(this,"type","Ed25519");l(this,"raw");this.raw=zo(t,Ml)}toMultihash(){return pr.digest(At(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Le.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:ze(this.raw,t.raw)}verify(t,e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=Ay(this.raw,e,t);return Uo(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class _y{constructor(t,e){l(this,"type","Ed25519");l(this,"raw");l(this,"publicKey");this.raw=zo(t,Bo),this.publicKey=new Ol(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:ze(this.raw,t.raw)}sign(t,e){var s,i;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const n=vy(this.raw,t);return Uo(n)?n.then(o=>{var a;return(a=e==null?void 0:e.signal)==null||a.throwIfAborted(),o}):((i=e==null?void 0:e.signal)==null||i.throwIfAborted(),n)}}function Fl(r){return r=zo(r,Ml),new Ol(r)}async function Iy(){const{privateKey:r,publicKey:t}=wy();return new _y(r,t)}function zo(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new W(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}const Ty=Math.pow(2,7),Ly=Math.pow(2,14),Dy=Math.pow(2,21),qo=Math.pow(2,28),Ko=Math.pow(2,35),Vo=Math.pow(2,42),Wo=Math.pow(2,49),se=128,Oe=127;function Pe(r){if(r<Ty)return 1;if(r<Ly)return 2;if(r<Dy)return 3;if(r<qo)return 4;if(r<Ko)return 5;if(r<Vo)return 6;if(r<Wo)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function qs(r,t,e=0){switch(Pe(r)){case 8:t[e++]=r&255|se,r/=128;case 7:t[e++]=r&255|se,r/=128;case 6:t[e++]=r&255|se,r/=128;case 5:t[e++]=r&255|se,r/=128;case 4:t[e++]=r&255|se,r>>>=7;case 3:t[e++]=r&255|se,r>>>=7;case 2:t[e++]=r&255|se,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Py(r,t,e=0){switch(Pe(r)){case 8:t.set(e++,r&255|se),r/=128;case 7:t.set(e++,r&255|se),r/=128;case 6:t.set(e++,r&255|se),r/=128;case 5:t.set(e++,r&255|se),r/=128;case 4:t.set(e++,r&255|se),r>>>=7;case 3:t.set(e++,r&255|se),r>>>=7;case 2:t.set(e++,r&255|se),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Bl(r,t){let e=r[t],n=0;if(n+=e&Oe,e<se||(e=r[t+1],n+=(e&Oe)<<7,e<se)||(e=r[t+2],n+=(e&Oe)<<14,e<se)||(e=r[t+3],n+=(e&Oe)<<21,e<se)||(e=r[t+4],n+=(e&Oe)*qo,e<se)||(e=r[t+5],n+=(e&Oe)*Ko,e<se)||(e=r[t+6],n+=(e&Oe)*Vo,e<se)||(e=r[t+7],n+=(e&Oe)*Wo,e<se))return n;throw new RangeError("Could not decode varint")}function Ry(r,t){let e=r.get(t),n=0;if(n+=e&Oe,e<se||(e=r.get(t+1),n+=(e&Oe)<<7,e<se)||(e=r.get(t+2),n+=(e&Oe)<<14,e<se)||(e=r.get(t+3),n+=(e&Oe)<<21,e<se)||(e=r.get(t+4),n+=(e&Oe)*qo,e<se)||(e=r.get(t+5),n+=(e&Oe)*Ko,e<se)||(e=r.get(t+6),n+=(e&Oe)*Vo,e<se)||(e=r.get(t+7),n+=(e&Oe)*Wo,e<se))return n;throw new RangeError("Could not decode varint")}function Tr(r,t,e=0){return t==null&&(t=gt(Pe(r))),t instanceof Uint8Array?qs(r,t,e):Py(r,t,e)}function Lr(r,t=0){return r instanceof Uint8Array?Bl(r,t):Ry(r,t)}const Ho=new Float32Array([-0]),Ut=new Uint8Array(Ho.buffer);function ky(r,t,e){Ho[0]=r,t[e]=Ut[0],t[e+1]=Ut[1],t[e+2]=Ut[2],t[e+3]=Ut[3]}function My(r,t){return Ut[0]=r[t],Ut[1]=r[t+1],Ut[2]=r[t+2],Ut[3]=r[t+3],Ho[0]}const Go=new Float64Array([-0]),Fe=new Uint8Array(Go.buffer);function Ny(r,t,e){Go[0]=r,t[e]=Fe[0],t[e+1]=Fe[1],t[e+2]=Fe[2],t[e+3]=Fe[3],t[e+4]=Fe[4],t[e+5]=Fe[5],t[e+6]=Fe[6],t[e+7]=Fe[7]}function Oy(r,t){return Fe[0]=r[t],Fe[1]=r[t+1],Fe[2]=r[t+2],Fe[3]=r[t+3],Fe[4]=r[t+4],Fe[5]=r[t+5],Fe[6]=r[t+6],Fe[7]=r[t+7],Go[0]}const Fy=BigInt(Number.MAX_SAFE_INTEGER),By=BigInt(Number.MIN_SAFE_INTEGER);class Be{constructor(t,e){l(this,"lo");l(this,"hi");this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return sn;if(t<Fy&&t>By)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>$l&&(s=0n,++n>$l&&(n=0n))),new Be(Number(s),Number(n))}static fromNumber(t){if(t===0)return sn;const e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Be(n,s)}static from(t){return typeof t=="number"?Be.fromNumber(t):typeof t=="bigint"?Be.fromBigInt(t):typeof t=="string"?Be.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new Be(t.low>>>0,t.high>>>0):sn}}const sn=new Be(0,0);sn.toBigInt=function(){return 0n},sn.zzEncode=sn.zzDecode=function(){return this},sn.length=function(){return 1};const $l=4294967296n;function $y(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Uy(r,t,e){if(e-t<1)return"";let s;const i=[];let o=0,a;for(;t<e;)a=r[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Ul(r,t,e){const n=e;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function at(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function Ks(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}class zy{constructor(t){l(this,"buf");l(this,"pos");l(this,"len");l(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,at(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw at(this,4);return Ks(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw at(this,4);return Ks(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw at(this,4);const t=My(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw at(this,4);const t=Oy(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw at(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){const t=this.bytes();return Uy(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw at(this,t);this.pos+=t}else do if(this.pos>=this.len)throw at(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new Be(0,0);let e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw at(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw at(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw at(this,8);const t=Ks(this.buf,this.pos+=4),e=Ks(this.buf,this.pos+=4);return new Be(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=Bl(this.buf,this.pos);return this.pos+=Pe(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function qy(r){return new zy(r instanceof Uint8Array?r:r.subarray())}function xe(r,t,e){const n=qy(r);return t.decode(n,void 0,e)}function Ky(r){let n,s=8192;return function(o){if(o<1||o>4096)return gt(o);s+o>8192&&(n=gt(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class Dr{constructor(t,e,n){l(this,"fn");l(this,"len");l(this,"next");l(this,"val");this.fn=t,this.len=e,this.next=void 0,this.val=n}}function Yo(){}class Vy{constructor(t){l(this,"head");l(this,"tail");l(this,"len");l(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const Wy=Ky();function Hy(r){return globalThis.Buffer!=null?gt(r):Wy(r)}class Xo{constructor(){l(this,"len");l(this,"head");l(this,"tail");l(this,"states");this.len=0,this.head=new Dr(Yo,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new Dr(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Yy((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Vs,10,Be.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=Be.fromBigInt(t);return this._push(Vs,e.length(),e)}uint64Number(t){return this._push(qs,Pe(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=Be.fromBigInt(t).zzEncode();return this._push(Vs,e.length(),e)}sint64Number(t){const e=Be.fromNumber(t).zzEncode();return this._push(Vs,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Qo,1,t?1:0)}fixed32(t){return this._push(Pr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=Be.fromBigInt(t);return this._push(Pr,4,e.lo)._push(Pr,4,e.hi)}fixed64Number(t){const e=Be.fromNumber(t);return this._push(Pr,4,e.lo)._push(Pr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(ky,4,t)}double(t){return this._push(Ny,8,t)}bytes(t){const e=t.length>>>0;return e===0?this._push(Qo,1,0):this.uint32(e)._push(Xy,e,t)}string(t){const e=$y(t);return e!==0?this.uint32(e)._push(Ul,e,t):this._push(Qo,1,0)}fork(){return this.states=new Vy(this),this.head=this.tail=new Dr(Yo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Dr(Yo,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next;const e=Hy(this.len);let n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}}function Qo(r,t,e){t[e]=r&255}function Gy(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}class Yy extends Dr{constructor(e,n){super(Gy,e,n);l(this,"next");this.next=void 0}}function Vs(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function Pr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Xy(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Xo.prototype.bytes=function(r){const t=r.length>>>0;return this.uint32(t),t>0&&this._push(Qy,t,r),this},Xo.prototype.string=function(r){const t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(Zy,t,r),this});function Qy(r,t,e){t.set(r,e)}function Zy(r,t,e){r.length<40?Ul(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(G(r),e)}function Jy(){return new Xo}function Ae(r,t){const e=Jy();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var Ws;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(Ws||(Ws={}));function zl(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function _n(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const e=function(i,o){const a=t(i);o.int32(a)},n=function(i){const o=i.int32();return t(o)};return zl("enum",Ws.VARINT,e,n)}function Ce(r,t){return zl("message",Ws.LENGTH_DELIMITED,r,t)}class St extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_LENGTH");l(this,"name","MaxLengthError")}}class ql extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_SIZE");l(this,"name","MaxSizeError")}}var Re;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Re||(Re={}));var Zo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Zo||(Zo={})),function(r){r.codec=()=>_n(Zo)}(Re||(Re={}));var In;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),Re.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=Re.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(In||(In={}));var Kl;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),Re.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=Re.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Kl||(Kl={}));function Vl(r){if(isNaN(r)||r<=0)throw new W("random bytes length must be a Number bigger than 0");return Sr(r)}class jy{constructor(t,e){l(this,"type","RSA");l(this,"jwk");l(this,"_raw");l(this,"_multihash");this.jwk=t,this._multihash=e}get raw(){return this._raw==null&&(this._raw=sw(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return me.createV1(114,this._multihash)}toString(){return Le.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:ze(this.raw,t.raw)}verify(t,e,n){return aw(this.jwk,e,t,n)}}const ew=18,tw=1062,nw=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function rw(r){const t=Cs(r[1],{offset:0});return{kty:"RSA",n:Z(t[0],"base64url"),e:Z(t[1],"base64url")}}function sw(r){if(r.n==null||r.e==null)throw new W("JWK was missing components");return br([nw,Zc(br([vo(G(r.n,"base64url")),vo(G(r.e,"base64url"))]))]).subarray()}function iw(r,t){if(r.byteLength>=tw)throw new to("Key size is too large");const e=Cs(r,{offset:0});return ow(e,r,t)}function ow(r,t,e){const n=rw(r);if(e==null){const s=xr(In.encode({Type:Re.RSA,Data:t}));e=xs(ew,s)}return new jy(n,e)}async function aw(r,t,e,n){var o,a;const s=await rn.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await rn.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,e instanceof Uint8Array?e:e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}class Wl{constructor(t,e){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Is(t),Y(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),Jt(s)}update(t){return Ts(this),this.iHash.update(t),this}digestInto(t){Ts(this),Y(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Hs=(r,t,e)=>new Wl(r,t).update(e).digest();Hs.create=(r,t)=>new Wl(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Hl=(r,t)=>(r+(r>=0?t:-t)/Gl)/t;function cw(r,t,e){const[[n,s],[i,o]]=t,a=Hl(o*r,e),c=Hl(-s*r,e);let u=r-a*n-c*i,d=-a*s-c*o;const h=u<xt,f=d<xt;h&&(u=-u),f&&(d=-d);const p=Po(Math.ceil(qp(e)/2))+Tn;if(u<xt||u>=p||d<xt||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:f,k2:d}}function Jo(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function jo(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return jt(e.lowS,"lowS"),jt(e.prehash,"prehash"),e.format!==void 0&&Jo(e.format),e}class lw extends Error{constructor(t=""){super(t)}}const zt={Err:lw,_tlv:{encode:(r,t)=>{const{Err:e}=zt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=Rs(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?Rs(s.length/2|128):"";return Rs(r)+i+s+t},decode(r,t){const{Err:e}=zt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+c);if(u.length!==c)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)o=o<<8|d;if(n+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=zt;if(r<xt)throw new t("integer: negative integers are not allowed");let e=Rs(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=zt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return ks(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=zt,s=Y(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=zt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},xt=BigInt(0),Tn=BigInt(1),Gl=BigInt(2),Gs=BigInt(3),uw=BigInt(4);function dw(r,t={}){const e=Tl("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;Sn(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=Xl(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(M,w,b){const{x:C,y:D}=w.toAffine(),R=n.toBytes(C);if(jt(b,"isCompressed"),b){d();const A=!n.isOdd(D);return pt(Yl(A),R)}else return pt(Uint8Array.of(4),R,n.toBytes(D))}function f(M){Y(M,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=u,C=M.length,D=M[0],R=M.subarray(1);if(C===w&&(D===2||D===3)){const A=n.fromBytes(R);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const O=y(A);let P;try{P=n.sqrt(O)}catch(re){const j=re instanceof Error?": "+re.message:"";throw new Error("bad point: is not on curve, sqrt error"+j)}d();const F=n.isOdd(P);return(D&1)===1!==F&&(P=n.neg(P)),{x:A,y:P}}else if(C===b&&D===4){const A=n.BYTES,O=n.fromBytes(R.subarray(0,A)),P=n.fromBytes(R.subarray(A,A*2));if(!m(O,P))throw new Error("bad point: is not on curve");return{x:O,y:P}}else throw new Error(`bad point: got length ${C}, expected compressed=${w} or uncompressed=${b}`)}const p=t.toBytes||h,g=t.fromBytes||f;function y(M){const w=n.sqr(M),b=n.mul(w,M);return n.add(n.add(b,n.mul(M,i.a)),i.b)}function m(M,w){const b=n.sqr(w),C=y(M);return n.eql(b,C)}if(!m(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(i.a,Gs),uw),v=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(S,v)))throw new Error("bad curve params: a or b");function E(M,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${M}`);return w}function L(M){if(!(M instanceof I))throw new Error("Weierstrass Point expected")}function x(M){if(!c||!c.basises)throw new Error("no endo");return cw(M,c.basises,s.ORDER)}const _=Ns((M,w)=>{const{X:b,Y:C,Z:D}=M;if(n.eql(D,n.ONE))return{x:b,y:C};const R=M.is0();w==null&&(w=R?n.ONE:n.inv(D));const A=n.mul(b,w),O=n.mul(C,w),P=n.mul(D,w);if(R)return{x:n.ZERO,y:n.ZERO};if(!n.eql(P,n.ONE))throw new Error("invZ was invalid");return{x:A,y:O}}),N=Ns(M=>{if(M.is0()){if(t.allowInfinityPoint&&!n.is0(M.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=M.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!m(w,b))throw new Error("bad point: equation left != right");if(!M.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function T(M,w,b,C,D){return b=new I(n.mul(b.X,M),b.Y,b.Z),w=Fs(C,w),b=Fs(D,b),w.add(b)}const k=class k{constructor(w,b,C){l(this,"X");l(this,"Y");l(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",C),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:C}=w||{};if(!w||!n.isValid(b)||!n.isValid(C))throw new Error("invalid affine point");if(w instanceof k)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(C)?k.ZERO:new k(b,C,n.ONE)}static fromBytes(w){const b=k.fromAffine(g(Y(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return k.fromBytes(vr(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return U.createCache(this,w),b||this.multiply(Gs),this}assertValidity(){N(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){L(w);const{X:b,Y:C,Z:D}=this,{X:R,Y:A,Z:O}=w,P=n.eql(n.mul(b,O),n.mul(R,D)),F=n.eql(n.mul(C,O),n.mul(A,D));return P&&F}negate(){return new k(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,C=n.mul(b,Gs),{X:D,Y:R,Z:A}=this;let O=n.ZERO,P=n.ZERO,F=n.ZERO,z=n.mul(D,D),re=n.mul(R,R),j=n.mul(A,A),K=n.mul(D,R);return K=n.add(K,K),F=n.mul(D,A),F=n.add(F,F),O=n.mul(w,F),P=n.mul(C,j),P=n.add(O,P),O=n.sub(re,P),P=n.add(re,P),P=n.mul(O,P),O=n.mul(K,O),F=n.mul(C,F),j=n.mul(w,j),K=n.sub(z,j),K=n.mul(w,K),K=n.add(K,F),F=n.add(z,z),z=n.add(F,z),z=n.add(z,j),z=n.mul(z,K),P=n.add(P,z),j=n.mul(R,A),j=n.add(j,j),z=n.mul(j,K),O=n.sub(O,z),F=n.mul(j,re),F=n.add(F,F),F=n.add(F,F),new k(O,P,F)}add(w){L(w);const{X:b,Y:C,Z:D}=this,{X:R,Y:A,Z:O}=w;let P=n.ZERO,F=n.ZERO,z=n.ZERO;const re=i.a,j=n.mul(i.b,Gs);let K=n.mul(b,R),ce=n.mul(C,A),fe=n.mul(D,O),Ee=n.add(b,C),we=n.add(R,A);Ee=n.mul(Ee,we),we=n.add(K,ce),Ee=n.sub(Ee,we),we=n.add(b,D);let Me=n.add(R,O);return we=n.mul(we,Me),Me=n.add(K,fe),we=n.sub(we,Me),Me=n.add(C,D),P=n.add(A,O),Me=n.mul(Me,P),P=n.add(ce,fe),Me=n.sub(Me,P),z=n.mul(re,we),P=n.mul(j,fe),z=n.add(P,z),P=n.sub(ce,z),z=n.add(ce,z),F=n.mul(P,z),ce=n.add(K,K),ce=n.add(ce,K),fe=n.mul(re,fe),we=n.mul(j,we),ce=n.add(ce,fe),fe=n.sub(K,fe),fe=n.mul(re,fe),we=n.add(we,fe),K=n.mul(ce,we),F=n.add(F,K),K=n.mul(Me,we),P=n.mul(Ee,P),P=n.sub(P,K),K=n.mul(Ee,ce),z=n.mul(Me,z),z=n.add(z,K),new k(P,F,z)}subtract(w){return this.add(w.negate())}is0(){return this.equals(k.ZERO)}multiply(w){const{endo:b}=t;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let C,D;const R=A=>U.cached(this,A,O=>_r(k,O));if(b){const{k1neg:A,k1:O,k2neg:P,k2:F}=x(w),{p:z,f:re}=R(O),{p:j,f:K}=R(F);D=re.add(K),C=T(b.beta,z,j,A,P)}else{const{p:A,f:O}=R(w);C=A,D=O}return _r(k,[C,D])[0]}multiplyUnsafe(w){const{endo:b}=t,C=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===xt||C.is0())return k.ZERO;if(w===Tn)return C;if(U.hasCache(this))return this.multiply(w);if(b){const{k1neg:D,k1:R,k2neg:A,k2:O}=x(w),{p1:P,p2:F}=ny(k,C,R,O);return T(b.beta,P,F,D,A)}else return U.unsafe(C,w)}toAffine(w){return _(this,w)}isTorsionFree(){const{isTorsionFree:w}=t;return o===Tn?!0:w?w(k,this):U.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=t;return o===Tn?this:w?w(k,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return jt(w,"isCompressed"),this.assertValidity(),p(k,this,w)}toHex(w=!0){return Er(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(k,"BASE",new k(i.Gx,i.Gy,n.ONE)),l(k,"ZERO",new k(n.ZERO,n.ONE,n.ZERO)),l(k,"Fp",n),l(k,"Fn",s);let I=k;const B=s.BITS,U=new _l(I,t.endo?Math.ceil(B/2):B);return I.BASE.precompute(8),I}function Yl(r){return Uint8Array.of(r?2:3)}function Xl(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function hw(r,t={}){const{Fn:e}=r,n=t.randomBytes||Sr,s=Object.assign(Xl(r.Fp,e),{seed:vl(e.ORDER)});function i(p){try{const g=e.fromBytes(p);return e.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:y,publicKeyUncompressed:m}=s;try{const S=p.length;return g===!0&&S!==y||g===!1&&S!==m?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return ty(Y(p,s.seed,"seed"),e.ORDER)}function c(p,g=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(g)}function u(p){const{secretKey:g,publicKey:y,publicKeyUncompressed:m}=s;if(!_s(p)||"_lengths"in e&&e._lengths||g===y)return;const S=Y(p,void 0,"key").length;return S===y||S===m}function d(p,g,y=!0){if(u(p)===!0)throw new Error("first arg must be private key");if(u(g)===!1)throw new Error("second arg must be public key");const m=e.fromBytes(p);return r.fromBytes(g).multiply(m).toBytes(y)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},f=Oo(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:f,Point:r,utils:h,lengths:s})}function fw(r,t,e={}){Is(t),Sn(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||Sr,s=e.hmac||((w,b)=>Hs(t,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p}=hw(r,e),g={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},y=a*Gl<i.ORDER;function m(w){const b=a>>Tn;return w>b}function S(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function v(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){Jo(b);const C=p.signature,D=b==="compact"?C:b==="recovered"?C+1:void 0;return Y(w,D)}class L{constructor(b,C,D){l(this,"r");l(this,"s");l(this,"recovery");if(this.r=S("r",b),this.s=S("s",C),D!=null){if(v(),![0,1,2,3].includes(D))throw new Error("invalid recovery id");this.recovery=D}Object.freeze(this)}static fromBytes(b,C=g.format){E(b,C);let D;if(C==="der"){const{r:P,s:F}=zt.toSig(Y(b));return new L(P,F)}C==="recovered"&&(D=b[0],C="compact",b=b.subarray(1));const R=p.signature/2,A=b.subarray(0,R),O=b.subarray(R,R*2);return new L(o.fromBytes(A),o.fromBytes(O),D)}static fromHex(b,C){return this.fromBytes(vr(b),C)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new L(this.r,this.s,b)}recoverPublicKey(b){const{r:C,s:D}=this,R=this.assertRecovery(),A=R===2||R===3?C+a:C;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const O=i.toBytes(A),P=r.fromBytes(pt(Yl((R&1)===0),O)),F=o.inv(A),z=_(Y(b,void 0,"msgHash")),re=o.create(-z*F),j=o.create(D*F),K=r.BASE.multiplyUnsafe(re).add(P.multiplyUnsafe(j));if(K.is0())throw new Error("invalid recovery: point at infinify");return K.assertValidity(),K}hasHighS(){return m(this.s)}toBytes(b=g.format){if(Jo(b),b==="der")return vr(zt.hexFromSig(this));const{r:C,s:D}=this,R=o.toBytes(C),A=o.toBytes(D);return b==="recovered"?(v(),pt(Uint8Array.of(this.assertRecovery()),R,A)):pt(R,A)}toHex(b){return Er(this.toBytes(b))}}const x=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const C=ks(b),D=b.length*8-c;return D>0?C>>BigInt(D):C},_=e.bits2int_modN||function(b){return o.create(x(b))},N=Po(c);function T(w){return Cr("num < 2^"+c,w,xt,N),o.toBytes(w)}function I(w,b){return Y(w,void 0,"message"),b?Y(t(w),void 0,"prehashed message"):w}function B(w,b,C){const{lowS:D,prehash:R,extraEntropy:A}=jo(C,g);w=I(w,R);const O=_(w),P=o.fromBytes(b);if(!o.isValidNot0(P))throw new Error("invalid private key");const F=[T(P),T(O)];if(A!=null&&A!==!1){const K=A===!0?n(p.secretKey):A;F.push(Y(K,void 0,"extraEntropy"))}const z=pt(...F),re=O;function j(K){const ce=x(K);if(!o.isValidNot0(ce))return;const fe=o.inv(ce),Ee=r.BASE.multiply(ce).toAffine(),we=o.create(Ee.x);if(we===xt)return;const Me=o.create(fe*o.create(re+we*P));if(Me===xt)return;let Gi=(Ee.x===we?0:2)|Number(Ee.y&Tn),is=Me;return D&&m(Me)&&(is=o.neg(Me),Gi^=1),new L(we,is,y?void 0:Gi)}return{seed:z,k2sig:j}}function U(w,b,C={}){const{seed:D,k2sig:R}=B(w,b,C);return Kp(t.outputLen,o.BYTES,s)(D,R).toBytes(C.format)}function k(w,b,C,D={}){const{lowS:R,prehash:A,format:O}=jo(D,g);if(C=Y(C,void 0,"publicKey"),b=I(b,A),!_s(w)){const P=w instanceof L?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+P)}E(w,O);try{const P=L.fromBytes(w,O),F=r.fromBytes(C);if(R&&P.hasHighS())return!1;const{r:z,s:re}=P,j=_(b),K=o.inv(re),ce=o.create(j*K),fe=o.create(z*K),Ee=r.BASE.multiplyUnsafe(ce).add(F.multiplyUnsafe(fe));return Ee.is0()?!1:o.create(Ee.x)===z}catch{return!1}}function M(w,b,C={}){const{prehash:D}=jo(C,g);return b=I(b,D),L.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p,Point:r,sign:U,verify:k,recoverPublicKey:M,Signature:L,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ea={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},gw={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Ql=BigInt(2);function mw(r){const t=ea.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,d=u*u*r%t,h=be(d,e,t)*d%t,f=be(h,e,t)*d%t,p=be(f,Ql,t)*u%t,g=be(p,s,t)*p%t,y=be(g,i,t)*g%t,m=be(y,a,t)*y%t,S=be(m,c,t)*m%t,v=be(S,a,t)*y%t,E=be(v,e,t)*d%t,L=be(E,o,t)*g%t,x=be(L,n,t)*u%t,_=be(x,Ql,t);if(!ta.eql(ta.sqr(_),r))throw new Error("Cannot find square root");return _}const ta=Os(ea.p,{sqrt:mw}),Ys=fw(dw(ea,{Fp:ta,endo:gw}),xr);function pw(r,t,e,n){var i;const s=Hc.digest(e instanceof Uint8Array?e:e.subarray());if(Uo(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),Ys.verify(t,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new kl(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),Ys.verify(t,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new kl(String(o))}}class yw{constructor(t){l(this,"type","secp256k1");l(this,"raw");l(this,"_key");this._key=bw(t),this.raw=ww(this._key)}toMultihash(){return pr.digest(At(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Le.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:ze(this.raw,t.raw)}verify(t,e,n){return pw(this._key,e,t,n)}}function Zl(r){return new yw(r)}function ww(r){return Ys.Point.fromBytes(r).toBytes()}function bw(r){try{return Ys.Point.fromBytes(r),r}catch(t){throw new to(String(t))}}async function Ew(r,t){return Iy()}function qt(r,t){const{Type:e,Data:n}=In.decode(r),s=n??new Uint8Array;switch(e){case Re.RSA:return iw(s,t);case Re.Ed25519:return Fl(s);case Re.secp256k1:return Zl(s);case Re.ECDSA:return Jc(s);default:throw new fs}}function vw(r){const{Type:t,Data:e}=In.decode(r.digest),n=e??new Uint8Array;switch(t){case Re.Ed25519:return Fl(n);case Re.secp256k1:return Zl(n);case Re.ECDSA:return Jc(n);default:throw new fs}}function At(r){return In.encode({Type:Re[r.type],Data:r.raw})}const Jl=Symbol.for("nodejs.util.inspect.custom"),Sw=114;class na{constructor(t){l(this,"type");l(this,"multihash");l(this,"publicKey");l(this,"string");l(this,Of,!0);this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Le.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return me.createV1(Sw,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(t==null)return!1;if(t instanceof Uint8Array)return ze(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(((e=t==null?void 0:t.toMultihash())==null?void 0:e.bytes)!=null)return ze(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(Of=lo,Jl)](){return`PeerId(${this.toString()})`}}class jl extends na{constructor(e){super({...e,type:"RSA"});l(this,"type","RSA");l(this,"publicKey");this.publicKey=e.publicKey}}class eu extends na{constructor(e){super({...e,type:"Ed25519"});l(this,"type","Ed25519");l(this,"publicKey");this.publicKey=e.publicKey}}class tu extends na{constructor(e){super({...e,type:"secp256k1"});l(this,"type","secp256k1");l(this,"publicKey");this.publicKey=e.publicKey}}const xw=2336;class nu{constructor(t){l(this,"type","url");l(this,"multihash");l(this,"publicKey");l(this,"url");l(this,Ff,!0);this.url=t.toString(),this.multihash=pr.digest(G(this.url))}[(Bf=Jl,Ff=lo,Bf)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return me.createV1(xw,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=Z(t)),t.toString()===this.toString())}}const Aw=114,ru=2336;function ct(r,t){let e;if(r.charAt(0)==="1"||r.charAt(0)==="Q")e=gr(Le.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return Mr(me.parse(r));throw new W('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return kr(e)}function Rr(r){if(r.type==="Ed25519")return new eu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new tu({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new jl({multihash:r.toCID().multihash,publicKey:r});throw new fs}function Cw(r){return Rr(r.publicKey)}function kr(r){if(Iw(r))return new jl({multihash:r});if(_w(r))try{const t=vw(r);if(t.type==="Ed25519")return new eu({multihash:r,publicKey:t});if(t.type==="secp256k1")return new tu({multihash:r,publicKey:t})}catch{const e=Z(r.digest);return new nu(new URL(e))}throw new Ac("Supplied PeerID Multihash is invalid")}function Mr(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==Aw&&r.code!==ru)throw new xc("Supplied PeerID CID is invalid");if(r.code===ru){const t=Z(r.multihash.digest);return new nu(new URL(t))}return kr(r.multihash)}function _w(r){return r.code===pr.code}function Iw(r){return r.code===Hc.code}async function Tw(r){var t,e;if(r.connectionProtector===null&&((e=(t=globalThis.process)==null?void 0:t.env)==null?void 0:e.LIBP2P_FORCE_PNET)!=null)throw new W("Private network is enforced, but no protector was provided");return r}const Ln=1e3,Dn=Ln*60,Pn=Dn*60,on=Pn*24,Nr=on*7,Rn=on*365.25,Or=Rn/12;function Lw(r,t){if(typeof r=="string")return Dw(r);if(typeof r=="number")return kw(r,t);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var su=Lw;function Dw(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(t!=null&&t.groups))return NaN;let{value:e,unit:n="ms"}=t.groups,s=parseFloat(e),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Rn;case"months":case"month":case"mo":return s*Or;case"weeks":case"week":case"w":return s*Nr;case"days":case"day":case"d":return s*on;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Pn;case"minutes":case"minute":case"mins":case"min":case"m":return s*Dn;case"seconds":case"second":case"secs":case"sec":case"s":return s*Ln;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Pw(r){let t=Math.abs(r);return t>=Rn?`${Math.round(r/Rn)}y`:t>=Or?`${Math.round(r/Or)}mo`:t>=Nr?`${Math.round(r/Nr)}w`:t>=on?`${Math.round(r/on)}d`:t>=Pn?`${Math.round(r/Pn)}h`:t>=Dn?`${Math.round(r/Dn)}m`:t>=Ln?`${Math.round(r/Ln)}s`:`${r}ms`}function Rw(r){let t=Math.abs(r);return t>=Rn?an(r,t,Rn,"year"):t>=Or?an(r,t,Or,"month"):t>=Nr?an(r,t,Nr,"week"):t>=on?an(r,t,on,"day"):t>=Pn?an(r,t,Pn,"hour"):t>=Dn?an(r,t,Dn,"minute"):t>=Ln?an(r,t,Ln,"second"):`${r} ms`}function kw(r,t){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return t!=null&&t.long?Rw(r):Pw(r)}function an(r,t,e,n){let s=t>=e*1.5;return`${Math.round(r/e)} ${n}${s?"s":""}`}function Mw(r){e.debug=e,e.default=e,e.coerce=c,e.disable=i,e.enable=s,e.enabled=o,e.humanize=su,e.destroy=u,Object.keys(r).forEach(d=>{e[d]=r[d]}),e.names=[],e.skips=[],e.formatters={};function t(d){let h=0;for(let f=0;f<d.length;f++)h=(h<<5)-h+d.charCodeAt(f),h|=0;return e.colors[Math.abs(h)%e.colors.length]}e.selectColor=t;function e(d){let h,f=null,p,g;function y(...m){if(!y.enabled)return;const S=y,v=Number(new Date),E=v-(h||v);S.diff=E,S.prev=h,S.curr=v,h=v,m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let L=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(_,N)=>{if(_==="%%")return"%";L++;const T=e.formatters[N];if(typeof T=="function"){const I=m[L];_=T.call(S,I),m.splice(L,1),L--}return _}),e.formatArgs.call(S,m),(S.log||e.log).apply(S,m)}return y.namespace=d,y.useColors=e.useColors(),y.color=e.selectColor(d),y.extend=n,y.destroy=e.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(p!==e.namespaces&&(p=e.namespaces,g=e.enabled(d)),g),set:m=>{f=m}}),typeof e.init=="function"&&e.init(y),y}function n(d,h){const f=e(this.namespace+(typeof h>"u"?":":h)+d);return f.log=this.log,f}function s(d){e.save(d),e.namespaces=d,e.names=[],e.skips=[];let h;const f=(typeof d=="string"?d:"").split(/[\s,]+/),p=f.length;for(h=0;h<p;h++)f[h]&&(d=f[h].replace(/\*/g,".*?"),d[0]==="-"?e.skips.push(new RegExp("^"+d.substr(1)+"$")):e.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...e.names.map(a),...e.skips.map(a).map(h=>"-"+h)].join(",");return e.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,f;for(h=0,f=e.skips.length;h<f;h++)if(e.skips[h].test(d))return!1;for(h=0,f=e.names.length;h<f;h++)if(e.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return e.setupFormatters(e.formatters),e.enable(e.load()),e}var Nw={};const yt=qw(),Ow=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Fw(){var r,t,e,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((e=(t=document.documentElement)==null?void 0:t.style)==null?void 0:e.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function Bw(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+su(this.diff),!this.useColors)return;const t="color: "+this.color;r.splice(1,0,t,"color: inherit");let e=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(e++,s==="%c"&&(n=e))}),r.splice(n,0,t)}const $w=console.debug??console.log??(()=>{});function Uw(r){try{r?yt==null||yt.setItem("debug",r):yt==null||yt.removeItem("debug")}catch{}}function zw(){let r;try{r=yt==null?void 0:yt.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Nw.DEBUG),r}function qw(){try{return localStorage}catch{}}function Kw(r){r.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}const je=Mw({formatArgs:Bw,save:Uw,load:zw,useColors:Fw,setupFormatters:Kw,colors:Ow,storage:yt,log:$w});je.formatters.b=r=>r==null?"undefined":Le.baseEncode(r),je.formatters.t=r=>r==null?"undefined":Rt.baseEncode(r),je.formatters.m=r=>r==null?"undefined":Kc.baseEncode(r),je.formatters.p=r=>r==null?"undefined":r.toString(),je.formatters.c=r=>r==null?"undefined":r.toString(),je.formatters.k=r=>r==null?"undefined":r.toString(),je.formatters.a=r=>r==null?"undefined":r.toString(),je.formatters.e=r=>{if(r==null)return"undefined";const t=au(r.message),e=au(r.stack);return t!=null&&e!=null?e.includes(t)?e:`${t}
${e}`:e??t??r.toString()};function Vw(r){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=r,t.destroy=()=>!0,t.extend=()=>t,t}function iu(){return{forComponent(r){return ou(r)}}}function ou(r){let t=Vw(`${r}:trace`);return je.enabled(`${r}:trace`)&&je.names.map(e=>e.toString()).find(e=>e.includes(":trace"))!=null&&(t=je(`${r}:trace`)),Object.assign(je(r),{error:je(`${r}:error`),trace:t,newScope:e=>ou(`${r}:${e}`)})}function au(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function Fr(r,t){const e={[Symbol.iterator]:()=>e,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:t(s)}}};return e}function ra(r){const t=gr(Le.decode(`z${r}`));return kr(t)}class kn{constructor(t){l(this,"map");if(this.map=new Map,t!=null)for(const[e,n]of t.entries())this.map.set(e.toString(),{key:e,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return Fr(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,n)=>{t(e.value,e.key,this)})}get(t){var e;return(e=this.map.get(t.toString()))==null?void 0:e.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return Fr(this.map.values(),t=>t.key)}values(){return Fr(this.map.values(),t=>t.value)}get size(){return this.map.size}}class Mn{constructor(t){l(this,"set");if(this.set=new Set,t!=null)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return Fr(this.set.entries(),t=>{const e=ra(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const n=ra(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return Fr(this.set.values(),t=>ra(t))}intersection(t){const e=new Mn;for(const n of t)this.has(n)&&e.add(n);return e}difference(t){const e=new Mn;for(const n of this)t.has(n)||e.add(n);return e}union(t){const e=new Mn;for(const n of t)e.add(n);for(const n of this)e.add(n);return e}}const sa={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},cu={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},lu=new globalThis.TextEncoder;function Ww(r,t){const e=sa[t];let n=cu[t];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(t,n*e);return n}function Hw(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=sa[t];let s=cu[t],i=r;for(;i.length>0;){const o=lu.encodeInto(i,e);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(e[a]),s=BigInt.asUintN(t,s*n)}return s}function Gw(r,{size:t=32,utf8Buffer:e}={}){if(!sa[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return Hw(r,t,e);r=lu.encode(r)}return Ww(r,t)}const ia={hash:r=>Number(Gw(r,{size:32})),hashV:(r,t)=>Yw(ia.hash(r,t))};function Yw(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),G(t,"base16")}const uu=64;class cn{constructor(t,e,n,s=2){l(this,"fp");l(this,"h");l(this,"seed");if(s>uu)throw new TypeError("Invalid Fingerprint Size");const i=e.hashV(t,n),o=ae(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return(t==null?void 0:t.fp)instanceof Uint8Array?ze(this.fp,t.fp):!1}}function Xs(r,t){return Math.floor(Math.random()*(t-r))+r}class Qs{constructor(t){l(this,"contents");this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof cn))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof cn))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof cn))throw new TypeError("Invalid Fingerprint");const e=Xs(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof cn))throw new TypeError("Invalid Fingerprint");const e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}}const Xw=500;class du{constructor(t){l(this,"bucketSize");l(this,"filterSize");l(this,"fingerprintSize");l(this,"buckets");l(this,"count");l(this,"hash");l(this,"seed");this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??ia,this.seed=t.seed??Xs(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=G(t));const e=new cn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new Qs(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new Qs(this.bucketSize)),this.buckets[n].add(e)||this.buckets[s].add(e))return this.count++,!0;const i=[n,s];let o=i[Xs(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new Qs(this.bucketSize));for(let a=0;a<Xw;a++){const c=this.buckets[o].swap(e);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new Qs(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(t){var o,a;typeof t=="string"&&(t=G(t));const e=new cn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(e))??!1;if(s)return s;const i=(n^e.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(e))??!1}remove(t){var a,c;typeof t=="string"&&(t=G(t));const e=new cn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(e))??!1;if(s)return this.count--,s;const i=(n^e.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(e))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const Qw={1:.5,2:.84,4:.95,8:.98};function Zw(r=.001){return r>.002?2:r>1e-5?4:8}function Jw(r,t=.001){const e=Zw(t),n=Qw[e],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),uu);return{filterSize:s,bucketSize:e,fingerprintSize:i}}class jw{constructor(t){l(this,"filterSize");l(this,"bucketSize");l(this,"fingerprintSize");l(this,"scale");l(this,"filterSeries");l(this,"hash");l(this,"seed");this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??ia,this.seed=t.seed??Xs(0,Math.pow(2,10)),this.filterSeries=[new du({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=G(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new du({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=G(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=G(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}}function Br(r,t=.001,e){return new jw({...Jw(r,t)})}function pe(r){var s,i,o,a,c,u;const t=r.getComponents(),e={};let n=0;if(((s=t[n])==null?void 0:s.name)==="ip6zone"&&(e.zone=`${t[n].value}`,n++),t[n].name==="ip4"||t[n].name==="ip6"||t[n].name==="dns"||t[n].name==="dns4"||t[n].name==="dns6"?(e.type=t[n].name,e.host=t[n].value,n++):t[n].name==="dnsaddr"&&(e.type=t[n].name,e.host=`_dnsaddr.${t[n].value}`,n++),(((i=t[n])==null?void 0:i.name)==="tcp"||((o=t[n])==null?void 0:o.name)==="udp")&&(e.protocol=t[n].name==="tcp"?"tcp":"udp",e.port=parseInt(`${t[n].value}`),n++),((a=t[n])==null?void 0:a.name)==="ipcidr"&&(e.type==="ip4"?e.cidr=parseInt(`${t[n].value}`):e.type==="ip6"&&(e.cidr=`${t[n].value}`),n++),e.type==null||e.host==null)throw new W(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=t[n])==null?void 0:c.name)==="tls"&&((u=t[n+1])==null?void 0:u.name)==="sni"&&(e.sni=t[n+1].value,n+=2),e}class eb{constructor(){l(this,"index",0);l(this,"input","")}new(t){return this.index=0,this.input=t,this}readAtomically(t){const e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){const e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{const e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const f=Number.parseInt(h,t);if(!Number.isNaN(f))return f});if(d===void 0)break;if(i*=t,i+=d,i>u||(o+=1,e!==void 0&&o>e))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const t=new Uint8Array(4);for(let e=0;e<t.length;e++){const n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){const t=e=>{for(let n=0;n<e.length/2;n++){const s=n*2;if(n<e.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return e[s]=o[0],e[s+1]=o[1],e[s+2]=o[2],e[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];e[s]=i>>8,e[s+1]=i&255}return[e.length,!1]};return this.readAtomically(()=>{const e=new Uint8Array(16),[n,s]=t(e);if(n===16)return e;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=t(i.subarray(0,o));return e.set(i.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const hu=45,tb=15,Nn=new eb;function fu(r){if(!(r.length>tb))return Nn.new(r).parseWith(()=>Nn.readIPv4Addr())}function gu(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>hu))return Nn.new(r).parseWith(()=>Nn.readIPv6Addr())}function oa(r,t=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>hu)return;const e=Nn.new(r).parseWith(()=>Nn.readIPAddr());if(e)return t&&e.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,e[0],e[1],e[2],e[3]]):e}function nb(r,t,e){let n=0;for(const s of r)if(!(n<t)){if(n>e)break;if(s!==255)return!1;n++}return!0}function rb(r,t,e,n){let s=0;for(const i of r)if(!(s<e)){if(s>n)break;if(i!==t[s])return!1;s++}return!0}function sb(r){switch(r.length){case $r:return r.join(".");case Ur:{const t=[];for(let e=0;e<r.length;e++)e%2===0&&t.push(r[e].toString(16).padStart(2,"0")+r[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function ib(r){let t=0;for(let[e,n]of r.entries()){if(n===255){t+=8;continue}for(;n&128;)t++,n=n<<1;if(n&128)return-1;for(let s=e+1;s<r.length;s++)if(r[s]!=0)return-1;break}return t}function ob(r){let t="0x";for(const e of r)t+=(e>>4).toString(16)+(e&15).toString(16);return t}const $r=4,Ur=16,ab=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function mu(r,t){t.length===Ur&&r.length===$r&&nb(t,0,11)&&(t=t.slice(12)),t.length===$r&&r.length===Ur&&rb(r,ab,0,11)&&(r=r.slice(12));const e=r.length;if(e!=t.length)throw new Error("Failed to mask ip");const n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=r[s]&t[s];return n}function cb(r,t){if(typeof t=="string"&&(t=oa(t)),t==null)throw new Error("Invalid ip");if(t.length!==r.network.length)return!1;for(let e=0;e<t.length;e++)if((r.network[e]&r.mask[e])!==(t[e]&r.mask[e]))return!1;return!0}function lb(r){const[t,e]=r.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+r);let n=$r,s=fu(t);if(s==null&&(n=Ur,s=gu(t),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(e,10);if(Number.isNaN(i)||String(i).length!==e.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=pu(i,8*n);return{network:mu(s,o),mask:o}}function pu(r,t){if(t!==8*$r&&t!==8*Ur)throw new Error("Invalid CIDR mask");if(r<0||r>t)throw new Error("Invalid CIDR mask");const e=t/8,n=new Uint8Array(e);for(let s=0;s<e;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class yu{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=lb(t));else{const n=oa(t);if(n==null)throw new Error("Failed to parse network");e=String(e);const s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>n.length*8){const i=oa(e);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=pu(s,8*n.length);this.network=mu(n,this.mask)}}contains(t){return cb({network:this.network,mask:this.mask},t)}toString(){const t=ib(this.mask),e=t!==-1?String(t):ob(this.mask);return sb(this.network)+"/"+e}}function ub(r,t){return new yu(r).contains(t)}function db(r){try{const t=pe(r);switch(t.type){case"ip6":return ub("2000::/3",t.host);default:return!1}}catch{return!1}}function hb(r){try{const t=pe(r);switch(t.type){case"ip4":return t.host.startsWith("169.254.");case"ip6":return t.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function fb(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function aa(r){try{const t=pe(r);switch(t.type){case"ip4":case"ip6":return fb(t.host);default:return!1}}catch{return!1}}function lt(r){try{return pe(r),!0}catch{return!1}}function On(r){return!!fu(r)}function wu(r){return!!gu(r)}var gb=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function bu(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Eu;(function(){var r,t,e,n,s,i,o,a;a=function(c){var u,d,h,f;return u=(c&255<<24)>>>24,d=(c&255<<16)>>>16,h=(c&65280)>>>8,f=c&255,[u,d,h,f].join(".")},o=function(c){var u,d,h,f,p,g;for(u=[],h=f=0;f<=3&&c.length!==0;h=++f){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=t(c),p=g[0],d=g[1],c=c.substring(d),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},n=e("0"),i=e("a"),s=e("A"),t=function(c){var u,d,h,f,p;for(f=0,u=10,d="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,u=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<c.length;){if("0"<=c[h]&&c[h]<=d)f=f*u+(e(c[h])-n)>>>0;else if(u===16)if("a"<=c[h]&&c[h]<="f")f=f*u+(10+e(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")f=f*u+(10+e(c[h])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[f,h]},r=function(){function c(u,d){var h,f,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=f=32;f>=0;h=--f)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var d,h,f;for(f=o(this.first),h=o(this.last),d=0;f<=h;)u(a(f),f,d),d++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Eu=r}).call(gb);const mb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(r=>new Eu(r));function ca(r){for(const t of mb)if(t.contains(r))return!0;return!1}function pb(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function yb(r){const t=r.split(":");if(t.length<2)return!1;const e=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return ca(s)}function wb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function bb(r){const t=r.split(":"),e=t[t.length-1];return ca(e)}function Eb(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function la(r){if(On(r))return ca(r);if(pb(r))return yb(r);if(wb(r))return bb(r);if(wu(r))return Eb(r)}function Fn(r){try{const t=pe(r);switch(t.type){case"ip4":case"ip6":return la(t.host)??!1;default:return t.host==="localhost"}}catch{return!1}}function nt(){const r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}class vu{constructor(t){l(this,"buffer");l(this,"mask");l(this,"top");l(this,"btm");l(this,"next");if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}}class ua{constructor(t={}){l(this,"size");l(this,"hwm");l(this,"head");l(this,"tail");this.hwm=t.splitLimit??16,this.head=new vu(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return(t==null?void 0:t.byteLength)!=null?t.byteLength:1}push(t){if((t==null?void 0:t.value)!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new vu(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return(t==null?void 0:t.value)!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}let vb=class extends Error{constructor(e,n){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function Zs(r={}){return Sb(e=>{const n=e.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function Sb(r,t){t=t??{};let e=t.onEnd,n=new ua,s,i,o,a=nt();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,S)=>{i=v=>{i=null,n.push(v);try{m(r(n))}catch(E){S(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=nt()})}},u=m=>i!=null?i(m):(n.push(m),s),d=m=>(n=new ua,i!=null?i({error:m}):(n.push({error:m}),s)),h=m=>{if(o)return s;if((t==null?void 0:t.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:m})},f=m=>o?s:(o=!0,m!=null?d(m):u({done:!0})),p=()=>(n=new ua,f(),{done:!0}),g=m=>(f(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:h,end:f,get readableLength(){return n.size},onEmpty:async m=>{const S=m==null?void 0:m.signal;if(S==null||S.throwIfAborted(),n.isEmpty())return;let v,E;S!=null&&(v=new Promise((L,x)=>{E=()=>{x(new vb)},S.addEventListener("abort",E)}));try{await Promise.race([a.promise,v])}finally{E!=null&&S!=null&&(S==null||S.removeEventListener("abort",E))}}},e==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(m){return y.throw(m),e!=null&&(e(m),e=void 0),{done:!0}},return(){return y.return(),e!=null&&(e(),e=void 0),{done:!0}},push:h,end(m){return y.end(m),e!=null&&(e(m),e=void 0),s},get readableLength(){return y.readableLength},onEmpty:m=>y.onEmpty(m)},s}class Su extends Error{constructor(t){super(t),this.name="TimeoutError"}}let xb=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}};const xu=r=>globalThis.DOMException===void 0?new xb(r):new DOMException(r),Au=r=>{const t=r.reason===void 0?xu("This operation was aborted."):r.reason;return t instanceof Error?t:xu(t)};function Cu(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const u=new Promise((d,h)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:p}=t;p.aborted&&h(Au(p)),a=()=>{h(Au(p))},p.addEventListener("abort",a,{once:!0})}if(e===Number.POSITIVE_INFINITY){r.then(d,h);return}const f=new Su;o=i.setTimeout.call(void 0,()=>{if(n){try{d(n())}catch(p){h(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?d():s instanceof Error?h(s):(f.message=s??`Promise timed out after ${e} milliseconds`,h(f))},e),(async()=>{try{d(await r)}catch(p){h(p)}})()}).finally(()=>{u.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Ab=r=>{const t=r.addEventListener||r.on||r.addListener,e=r.removeEventListener||r.off||r.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(r),removeListener:e.bind(r)}};function Cb(r,t,e){let n;const s=new Promise((i,o)=>{var p;if(e={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=e.signal)==null||p.throwIfAborted();const a=[t].flat(),c=[],{addListener:u,removeListener:d}=Ab(r),h=async(...g)=>{const y=e.multiArgs?g:g[0];if(e.filter)try{if(!await e.filter(y))return}catch(m){n(),o(m);return}c.push(y),e.count===c.length&&(n(),i(c))},f=(...g)=>{n(),o(e.rejectionMultiArgs?g:g[0])};n=()=>{for(const g of a)d(g,h);for(const g of e.rejectionEvents)a.includes(g)||d(g,f)};for(const g of a)u(g,h);for(const g of e.rejectionEvents)a.includes(g)||u(g,f);e.signal&&e.signal.addEventListener("abort",()=>{f(e.signal.reason)},{once:!0}),e.resolveImmediately&&i(c)});if(s.cancel=n,typeof e.timeout=="number"){const i=Cu(s,{milliseconds:e.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function $e(r,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};const n=Cb(r,t,e),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function Js(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class _b extends Error{constructor(e="Rate limit exceeded",n){super(e);l(this,"remainingPoints");l(this,"msBeforeNext");l(this,"consumedPoints");l(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}let Ib=(mc=class extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}},l(mc,"name","QueueFullError"),mc),js=(pc=class extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError")}},l(pc,"name","UnexpectedEOFError"),pc);class _u extends Error{constructor(){super(...arguments);l(this,"name","MaxEarlyStreamsError")}}l(_u,"name","MaxEarlyStreamsError");class Iu extends Error{constructor(){super(...arguments);l(this,"name","StreamClosedError")}}l(Iu,"name","StreamClosedError");function Tb(r){return r.reason}async function ei(r,t,e){if(t==null)return r;const n=Tb;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}let Lb=class{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=nt(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new ft)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}};function Db(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let Pb=class{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=Db(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new ft),this.cleanup())}async join(t={}){var n;const e=new Lb(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await ei(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}},Tu=class extends Ge{constructor(e={}){var n;super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"paused");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,e.metricName!=null&&((n=e.metrics)==null||n.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=e.sort,this.queue=[],this.emitEmpty=Js(this.emitEmpty.bind(this),1),this.emitIdle=Js(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Ib;const s=new Pb(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new ft)}),this.clear()}async onEmpty(e){this.size!==0&&await $e(this,"empty",e)}async onSizeLessThan(e,n){this.size<e||await $e(this,"next",{...n,filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await $e(this,"idle",e)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Zs({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new ft("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}};const Rb=Math.pow(2,20)*4;class da extends Ge{constructor(e){super();l(this,"status");l(this,"timeline");l(this,"inactivityTimeout");l(this,"maxReadBufferLength");l(this,"maxWriteBufferLength");l(this,"log");l(this,"direction");l(this,"maxMessageSize");l(this,"readStatus");l(this,"writeStatus");l(this,"remoteReadStatus");l(this,"remoteWriteStatus");l(this,"writableNeedsDrain");l(this,"readBuffer");l(this,"writeBuffer");l(this,"sendingData");l(this,"onDrainPromise");this.status="open",this.log=e.log,this.direction=e.direction??"outbound",this.inactivityTimeout=e.inactivityTimeout??12e4,this.maxReadBufferLength=e.maxReadBufferLength??Rb,this.maxWriteBufferLength=e.maxWriteBufferLength,this.maxMessageSize=e.maxMessageSize,this.readBuffer=new Q,this.writeBuffer=new Q,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new Iu)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(e){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),ei(this.onDrainPromise.promise,e==null?void 0:e.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const e=Zs(),n=o=>{e.push(o.data)};this.addEventListener("message",n);const s=o=>{e.end(o.error)};this.addEventListener("close",s);const i=()=>{e.end()};this.addEventListener("remoteCloseWrite",i);try{yield*e}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(e){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Zt(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",e.byteLength),this.writeBuffer.append(e),this.processSendQueue()}abort(e){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",e),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(e)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Ng(e))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zt("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zt("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.append(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Zt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.prepend(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(e){if(e.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(e),this.dispatchReadBuffer()}}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const e=new no;this.dispatchEvent(new Og(e))}onTransportClosed(e){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),e!=null?this.abort(e):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new gs))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let e=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){e=!1;break}const o=this.writeBuffer.sublist(0,i),a=new Q(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(e=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!e)break}return e||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),e}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const e=this.readBuffer.sublist();this.readBuffer.consume(e.byteLength),this.dispatchEvent(new Mg(e))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new ro(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new ro(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Lu extends da{constructor(e){super(e);l(this,"remoteAddr");l(this,"metricPrefix");l(this,"metrics");this.metricPrefix=e.metricPrefix??"",this.metrics=e.metrics,this.remoteAddr=e.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(e){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"drain",{...e,rejectionEvents:["close"]})),await this.sendClose(e),this.onTransportClosed())}}function kb(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Du extends Ge{constructor(e,n){super();l(this,"streams");l(this,"protocol");l(this,"status");l(this,"log");l(this,"maConn");l(this,"streamOptions");l(this,"earlyStreams");l(this,"maxEarlyStreams");l(this,"metrics");this.maConn=e,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=e.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(e){const n=this.maConn.send(e);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(e){this.status==="closed"||this.status==="closing"||(this.status="closing",await ei(Promise.all([...this.streams].map(async n=>{await n.close(e)})),e==null?void 0:e.signal),this.status="closed")}abort(e){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(e)}),this.status="closed")}onTransportClosed(e){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(e)})}catch(n){this.abort(n)}this.status="closed"}async createStream(e){if(this.status!=="open")throw new bn;let n=this.onCreateStream({...this.streamOptions,...e});return kb(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(e){if(this.streams.push(e),this.cleanUpStream(e),this.listenerCount("stream")===0){this.earlyStreams.push(e),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new _u(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:e})}cleanUpStream(e){var s;const n=i=>{var a,c,u;const o=this.streams.findIndex(d=>d===e);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${e.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${e.direction}_stream_abort`]:!0}):(u=this.metrics)==null||u.increment({[`${e.direction}_stream_end`]:!0})};e.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${e.direction}_stream`]:!0})}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Pu extends da{constructor(e){super(e);l(this,"id");l(this,"protocol");this.id=e.id,this.protocol=e.protocol??""}async close(e){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await $e(this,"drain",{...e,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(e),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(e){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(e),this.readStatus="closed",this.log("closed readable end gracefully"))}}function ln(r){const t=new globalThis.AbortController;function e(){t.abort();for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}for(const i of r){if((i==null?void 0:i.aborted)===!0){e();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",e)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}const s=t.signal;return s.clear=n,s}class ha{constructor(t){l(this,"movingAverage");l(this,"variance");l(this,"deviation");l(this,"forecast");l(this,"timeSpan");l(this,"previousTime");this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(this.previousTime!=null){const n=this.alpha(e,this.previousTime),s=t-this.movingAverage,i=n*s;this.movingAverage=n*t+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=t;this.previousTime=e}}const Mb=1.2,Nb=2,Ob=5e3,Fb=6e4,Bb=5e3;class $b{constructor(t={}){l(this,"success");l(this,"failure");l(this,"next");l(this,"metric");l(this,"timeoutMultiplier");l(this,"failureMultiplier");l(this,"minTimeout");l(this,"maxTimeout");var n;const e=t.interval??Bb;this.success=new ha(e),this.failure=new ha(e),this.next=new ha(e),this.failureMultiplier=t.failureMultiplier??Nb,this.timeoutMultiplier=t.timeoutMultiplier??Mb,this.minTimeout=t.minTimeout??Ob,this.maxTimeout=t.maxTimeout??Fb,t.metricName!=null&&(this.metric=(n=t.metrics)==null?void 0:n.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){let e=Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier));e<this.minTimeout&&(e=this.minTimeout),e>this.maxTimeout&&(e=this.maxTimeout);const n=AbortSignal.timeout(e),s=ln([t.signal,n]);return s.start=Date.now(),s.timeout=e,s}cleanUp(t){var n,s;const e=Date.now()-t.start;t.aborted?(this.failure.push(e),this.next.push(e*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:e})):(this.success.push(e),this.next.push(e),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:e}))}}class et extends Error{constructor(){super(...arguments);l(this,"name","InvalidMultiaddrError")}}l(et,"name","InvalidMultiaddrError");class Bn extends Error{constructor(){super(...arguments);l(this,"name","ValidationError")}}l(Bn,"name","ValidationError");class Ru extends Error{constructor(){super(...arguments);l(this,"name","InvalidParametersError")}}l(Ru,"name","InvalidParametersError");class ku extends Error{constructor(){super(...arguments);l(this,"name","UnknownProtocolError")}}l(ku,"name","UnknownProtocolError");const ti=4,$n=6,Mu=273,Ub=33,Un=41,fa=42,ga=43,Nu=53,Ou=54,Fu=55,Bu=56,zb=132,qb=301,Kb=302,$u=400,V=421,Vb=444,Wb=445,Hb=446,Gb=447,zn=448,ni=449,Yb=454,Uu=460,zu=461,qu=465,zr=466,qn=480,Xb=481,ma=443,pa=477,Ku=478,Qb=479,Zb=277,Jb=275,jb=276,Vu=280,qr=281,Kn=290,Wu=777;function Hu(r){return t=>Z(t,r)}function Gu(r){return t=>G(t,r)}function Kr(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Vn(r){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(t)}function e0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=G(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Vn(n);return kt([e,s],e.length+s.length)}function t0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=Rt.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Vn(n);return kt([e,s],e.length+s.length)}function Yu(r){const t=r.subarray(0,r.length-2),e=r.subarray(r.length-2),n=Z(t,"base32"),s=Kr(e);return`${n}:${s}`}const Xu=function(r){r=r.toString().trim();const t=new Uint8Array(4);return r.split(/\./g).forEach((e,n)=>{const s=parseInt(e,10);if(isNaN(s)||s<0||s>255)throw new et("Invalid byte value in IP address");t[n]=s}),t},n0=function(r){let t=0;r=r.toString().trim();const e=r.split(":",8);let n;for(n=0;n<e.length;n++){const i=On(e[n]);let o;i&&(o=Xu(e[n]),e[n]=Z(o.subarray(0,2),"base16")),o!=null&&++n<8&&e.splice(n,0,Z(o.subarray(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);const i=[n,1];for(n=9-e.length;n>0;n--)i.push("0");e.splice.apply(e,i)}const s=new Uint8Array(t+16);for(n=0;n<e.length;n++){e[n]===""&&(e[n]="0");const i=parseInt(e[n],16);if(isNaN(i)||i<0||i>65535)throw new et("Invalid byte value in IP address");s[t++]=i>>8&255,s[t++]=i&255}return s},r0=function(r){if(r.byteLength!==4)throw new et("IPv4 address was incorrect length");const t=[];for(let e=0;e<r.byteLength;e++)t.push(r[e]);return t.join(".")},s0=function(r){if(r.byteLength!==16)throw new et("IPv6 address was incorrect length");const t=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;t.push(o)}const e=t.join(":");try{const n=new URL(`http://[${e}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new et(`Invalid IPv6 address "${e}"`)}};function i0(r){try{const t=new URL(`http://[${r}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new et(`Invalid IPv6 address "${r}"`)}}const ya=Object.values(yo).map(r=>r.decoder),o0=function(){let r=ya[0].or(ya[1]);return ya.slice(2).forEach(t=>r=r.or(t)),r}();function a0(r){return o0.decode(r)}function c0(r){return t=>r.encoder.encode(t)}function l0(r){if(parseInt(r).toString()!==r)throw new Bn("Value must be an integer")}function u0(r){if(r<0)throw new Bn("Value must be a positive integer, or zero")}function d0(r){return t=>{if(t>r)throw new Bn(`Value must be smaller than or equal to ${r}`)}}function h0(...r){return t=>{for(const e of r)e(t)}}const ri=h0(l0,u0,d0(65535)),Ue=-1;class f0{constructor(){l(this,"protocolsByCode",new Map);l(this,"protocolsByName",new Map)}getProtocol(t){let e;if(typeof t=="string"?e=this.protocolsByName.get(t):e=this.protocolsByCode.get(t),e==null)throw new ku(`Protocol ${t} was unknown`);return e}addProtocol(t){var e;this.protocolsByCode.set(t.code,t),this.protocolsByName.set(t.name,t),(e=t.aliases)==null||e.forEach(n=>{this.protocolsByName.set(n,t)})}removeProtocol(t){var n;const e=this.protocolsByCode.get(t);e!=null&&(this.protocolsByCode.delete(e.code),this.protocolsByName.delete(e.name),(n=e.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const Wn=new f0;[{code:ti,name:"ip4",size:32,valueToBytes:Xu,bytesToValue:r0,validate:r=>{if(!On(r))throw new Bn(`Invalid IPv4 address "${r}"`)}},{code:$n,name:"tcp",size:16,valueToBytes:Vn,bytesToValue:Kr,validate:ri},{code:Mu,name:"udp",size:16,valueToBytes:Vn,bytesToValue:Kr,validate:ri},{code:Ub,name:"dccp",size:16,valueToBytes:Vn,bytesToValue:Kr,validate:ri},{code:Un,name:"ip6",size:128,valueToBytes:n0,bytesToValue:s0,stringToValue:i0,validate:r=>{if(!wu(r))throw new Bn(`Invalid IPv6 address "${r}"`)}},{code:fa,name:"ip6zone",size:Ue},{code:ga,name:"ipcidr",size:8,bytesToValue:Hu("base10"),valueToBytes:Gu("base10")},{code:Nu,name:"dns",size:Ue},{code:Ou,name:"dns4",size:Ue},{code:Fu,name:"dns6",size:Ue},{code:Bu,name:"dnsaddr",size:Ue},{code:zb,name:"sctp",size:16,valueToBytes:Vn,bytesToValue:Kr,validate:ri},{code:qb,name:"udt"},{code:Kb,name:"utp"},{code:$u,name:"unix",size:Ue,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:V,name:"p2p",aliases:["ipfs"],size:Ue,bytesToValue:Hu("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?Gu("base58btc")(r):me.parse(r).multihash.bytes},{code:Vb,name:"onion",size:96,bytesToValue:Yu,valueToBytes:e0},{code:Wb,name:"onion3",size:296,bytesToValue:Yu,valueToBytes:t0},{code:Hb,name:"garlic64",size:Ue},{code:Gb,name:"garlic32",size:Ue},{code:zn,name:"tls"},{code:ni,name:"sni",size:Ue},{code:Yb,name:"noise"},{code:Uu,name:"quic"},{code:zu,name:"quic-v1"},{code:qu,name:"webtransport"},{code:zr,name:"certhash",size:Ue,bytesToValue:c0(Vc),valueToBytes:a0},{code:qn,name:"http"},{code:Xb,name:"http-path",size:Ue,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:ma,name:"https"},{code:pa,name:"ws"},{code:Ku,name:"wss"},{code:Qb,name:"p2p-websocket-star"},{code:Zb,name:"p2p-stardust"},{code:Jb,name:"p2p-webrtc-star"},{code:jb,name:"p2p-webrtc-direct"},{code:Vu,name:"webrtc-direct"},{code:qr,name:"webrtc"},{code:Kn,name:"p2p-circuit"},{code:Wu,name:"memory",size:Ue}].forEach(r=>{Wn.addProtocol(r)});function g0(r){var n;const t=[];let e=0;for(;e<r.length;){const s=Lr(r,e),i=Wn.getProtocol(s),o=Pe(s),a=w0(i,r,e+o);let c=0;a>0&&i.size===Ue&&(c=Pe(a));const u=o+c+a,d={code:s,name:i.name,bytes:r.subarray(e,e+u)};if(a>0){const h=e+o+c,f=r.subarray(h,h+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,f))??Z(f)}t.push(d),e+=u}return t}function m0(r){var n;let t=0;const e=[];for(const s of r){if(s.bytes==null){const i=Wn.getProtocol(s.code),o=Pe(s.code);let a,c=0,u=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??G(s.value),c=a.byteLength,i.size===Ue&&(u=Pe(c)));const d=new Uint8Array(o+u+c);let h=0;qs(s.code,d,h),h+=o,a!=null&&(i.size===Ue&&(qs(c,d,h),h+=u),d.set(a,h)),s.bytes=d}e.push(s.bytes),t+=s.bytes.byteLength}return kt(e,t)}function p0(r){var i;if(r.charAt(0)!=="/")throw new et('String multiaddr must start with "/"');const t=[];let e="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(e==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const u=Wn.getProtocol(s);if(e==="protocol"){if(u.size==null||u.size===0){t.push({code:u.code,name:u.name}),n="",s="",e="protocol";continue}else if(c)throw new et(`Component ${s} was missing value`);e="value"}else if(e==="value"){const d={code:u.code,name:u.name};if(u.size!=null&&u.size!==0){if(n==="")throw new et(`Component ${s} was missing value`);d.value=((i=u.stringToValue)==null?void 0:i.call(u,n))??n}t.push(d),n="",s="",e="protocol"}}}if(s!==""&&n!=="")throw new et("Incomplete multiaddr");return t}function y0(r){return`/${r.flatMap(t=>{var n;if(t.value==null)return t.name;const e=Wn.getProtocol(t.code);if(e==null)throw new et(`Unknown protocol code ${t.code}`);return[t.name,((n=e.valueToString)==null?void 0:n.call(e,t.value))??t.value]}).join("/")}`}function w0(r,t,e){return r.size==null||r.size===0?0:r.size>0?r.size/8:Lr(t,e)}const b0=Symbol.for("nodejs.util.inspect.custom"),Qu=Symbol.for("@multiformats/multiaddr");function E0(r){if(r==null&&(r="/"),si(r))return r.getComponents();if(r instanceof Uint8Array)return g0(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),p0(r);if(Array.isArray(r))return r;throw new et("Must be a string, Uint8Array, Component[], or another Multiaddr")}const nr=class nr{constructor(t="/",e={}){l(this,$f,!0);ge(this,ht);ge(this,er);ge(this,tr);ye(this,ht,E0(t)),e.validate!==!1&&v0(this)}get bytes(){return $(this,tr)==null&&ye(this,tr,m0($(this,ht))),$(this,tr)}toString(){return $(this,er)==null&&ye(this,er,y0($(this,ht))),$(this,er)}toJSON(){return this.toString()}getComponents(){return[...$(this,ht).map(t=>({...t}))]}encapsulate(t){const e=new nr(t);return new nr([...$(this,ht),...e.getComponents()],{validate:!1})}decapsulate(t){const e=t.toString(),n=this.toString(),s=n.lastIndexOf(e);if(s<0)throw new Ru(`Address ${this.toString()} does not contain subaddress: ${e}`);return new nr(n.slice(0,s),{validate:!1})}decapsulateCode(t){let e;for(let n=$(this,ht).length-1;n>-1;n--)if($(this,ht)[n].code===t){e=n;break}return new nr($(this,ht).slice(0,e),{validate:!1})}equals(t){return ze(this.bytes,t.bytes)}[($f=Qu,b0)](){return`Multiaddr(${this.toString()})`}};ht=new WeakMap,er=new WeakMap,tr=new WeakMap;let wa=nr;function v0(r){r.getComponents().forEach(t=>{var n;const e=Wn.getProtocol(t.code);t.value!=null&&((n=e.validate)==null||n.call(e,t.value))})}function si(r){return!!(r!=null&&r[Qu])}function X(r){return new wa(r)}let Zu=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function Ju(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new Zu(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new Zu(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class S0{constructor(){l(this,"readNext");l(this,"haveNext");l(this,"ended");l(this,"nextResult");l(this,"error");this.ended=!1,this.readNext=nt(),this.haveNext=nt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=nt(),t}async throw(t){return this.ended=!0,this.error=t,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=nt(),await Ju(this.readNext.promise,e==null?void 0:e.signal,e)}}function x0(){return new S0}function A0(r){return r[Symbol.asyncIterator]!=null}async function C0(r,t,e){try{await Promise.all(r.map(async n=>{for await(const s of n)await t.push(s,{signal:e}),e.throwIfAborted()})),await t.end(void 0,{signal:e})}catch(n){await t.end(n,{signal:e}).catch(()=>{})}}async function*_0(r){const t=new AbortController,e=x0();C0(r,e,t.signal).catch(()=>{});try{yield*e}finally{t.abort()}}function*I0(r){for(const t of r)yield*t}function ba(...r){const t=[];for(const e of r)A0(e)||t.push(e);return t.length===r.length?I0(t):_0(r)}const T0=4194304;class Ea extends Error{constructor(){super(...arguments);l(this,"name","UnwrappedError")}}l(Ea,"name","UnwrappedError");let ju=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}},L0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}},D0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function P0(r){return typeof(r==null?void 0:r.closeRead)=="function"}function R0(r){return typeof(r==null?void 0:r.close)=="function"}function va(r){return P0(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:R0(r)?r.status!=="open":!1}function k0(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function ed(r,t){const e=(t==null?void 0:t.maxBufferSize)??T0,n=new Q;let s,i=!1;if(!k0(r))throw new W("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>e){const h=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${h} > ${e}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const u={readBuffer:n,async read(d){if(i===!0)throw new Ea("Stream was unwrapped");if(va(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new js(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await ei(s.promise,d==null?void 0:d.signal),va(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const f=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<f){if(va(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,f),new js(`Unexpected EOF - stream closed while reading ${n.byteLength}/${f} bytes`);return u.read(d)}const p=n.sublist(0,f);return n.consume(f),p},async write(d,h){if(i===!0)throw new Ea("Stream was unwrapped");r.send(d)||await $e(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function Vr(r,t={}){const e=ed(r,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=Pe(t.maxDataLength));const n=(t==null?void 0:t.lengthDecoder)??Lr,s=(t==null?void 0:t.lengthEncoder)??Tr;return{async read(o){let a=-1;const c=new Q;for(;;){const d=await e.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new ju("Invalid message length");if((t==null?void 0:t.maxLengthLength)!=null&&c.byteLength>t.maxLengthLength)throw new D0(`Message length length too long - ${c.byteLength} > ${t.maxLengthLength}`);if(a>-1)break}if((t==null?void 0:t.maxDataLength)!=null&&a>t.maxDataLength)throw new L0(`Message length too long - ${a} > ${t.maxDataLength}`);const u=await e.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new js(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new js(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await e.write(new Q(s(o.byteLength),o),a)},async writeV(o,a){const c=new Q(...o.flatMap(u=>[s(u.byteLength),u]));await e.write(c,a)},unwrap(){return e.unwrap()}}}function un(r,t){const e=Vr(r,t),n={read:async(s,i)=>{const o=await e.read(i);return s.decode(o)},write:async(s,i,o)=>{await e.write(i.encode(s),o)},writeV:async(s,i,o)=>{await e.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>e.unwrap()};return n}const M0=1024*1024*4,N0=1024*1024*4;class O0{constructor(t={}){l(this,"buffer");l(this,"maxBufferSize");l(this,"lengthDecoder");l(this,"maxDataLength");l(this,"encodingLength");this.buffer=new Q,this.maxBufferSize=t.maxBufferSize??M0,this.maxDataLength=t.maxDataLength??N0,this.lengthDecoder=t.lengthDecoder??Lr,this.encodingLength=t.encodingLength??Pe}*decode(t){if(this.buffer.append(t),this.buffer.byteLength>this.maxBufferSize)throw new W(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let e;try{e=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(e<0||e>this.maxDataLength)throw new ju("Invalid message length");const n=this.encodingLength(e),s=n+e;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const F0=8,Sa=1024*1024*4;class B0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}}class td extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}}class $0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class nd extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError");l(this,"code","ERR_UNEXPECTED_EOF")}}function rd(r){return r[Symbol.asyncIterator]!=null}function sd(r,t){if(r.byteLength>t)throw new td("Message length too long")}const ii=r=>{const t=Pe(r),e=gt(t);return Tr(r,e),ii.bytes=t,e};ii.bytes=0;function oi(r,t){t=t??{};const e=t.lengthEncoder??ii,n=(t==null?void 0:t.maxDataLength)??Sa;function*s(i){sd(i,n);const o=e(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return rd(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}oi.single=(r,t)=>{t=t??{};const e=t.lengthEncoder??ii,n=(t==null?void 0:t.maxDataLength)??Sa;return sd(r,n),new Q(e(r.byteLength),r)};var dn;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(dn||(dn={}));const xa=r=>{const t=Lr(r);return xa.bytes=Pe(t),t};xa.bytes=0;function Aa(r,t){const e=new Q;let n=dn.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??xa,o=(t==null?void 0:t.maxLengthLength)??F0,a=(t==null?void 0:t.maxDataLength)??Sa;function*c(){for(;e.byteLength>0;){if(n===dn.LENGTH)try{if(s=i(e),s<0)throw new B0("Invalid message length");if(s>a)throw new td("Message length too long");const u=i.bytes;e.consume(u),(t==null?void 0:t.onLength)!=null&&t.onLength(s),n=dn.DATA}catch(u){if(u instanceof RangeError){if(e.byteLength>o)throw new $0("Message length length too long");break}throw u}if(n===dn.DATA){if(e.byteLength<s)break;const u=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(u),yield u,n=dn.LENGTH}}}return rd(r)?async function*(){for await(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new nd("Unexpected end of input")}():function*(){for(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new nd("Unexpected end of input")}()}Aa.fromReader=(r,t)=>{let e=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return Aa(n,{...t??{},onLength:i=>{e=i}})};class Ca extends Tu{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}}let U0=class extends Tu{constructor(t={}){super({...t,sort:(e,n)=>e.options.priority>n.options.priority?-1:e.options.priority<n.options.priority?1:0})}};class z0{constructor(t={}){l(this,"memoryStorage");l(this,"points");l(this,"duration");l(this,"blockDuration");l(this,"keyPrefix");this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new q0}consume(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,e,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+e&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new _b("Rate limit exceeded",o);return o}penalty(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(t,e){const n=e*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(t),s,e),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(t,e,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(t),e,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return e!=null&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return(t==null?void 0:t.customDuration)!=null&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class q0{constructor(){l(this,"storage");this.storage=new Map}incrby(t,e,n){const s=this.storage.get(t);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=e,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(t,e,n)}return this.set(t,e,n)}set(t,e,n){const s=n*1e3,i=this.storage.get(t);i!=null&&clearTimeout(i.timeoutId);const o={value:e,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(t,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(t)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(e!=null)return{remainingPoints:0,msBeforeNext:e.expiresAt!=null?e.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}delete(t){const e=this.storage.get(t);return e!=null?(e.timeoutId!=null&&clearTimeout(e.timeoutId),this.storage.delete(t),!0):!1}}function K0(r,t,e){let n,s,i=!1;function o(){const u={signal:s.signal};if((e==null?void 0:e.timeout)!=null){const d=ln([s.signal,AbortSignal.timeout(e.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,t))})}const a=Js(o,(e==null?void 0:e.debounce)??100);let c=!1;return{setInterval:u=>{t!==u&&(t=u,n!=null&&(clearTimeout(n),n=setTimeout(o,t)))},setTimeout:u=>{e??(e={}),e.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(e==null?void 0:e.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,t))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class V0 extends Map{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Ct(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new V0({name:t,metrics:e}):n=new Map,n}class W0{constructor(t,e){l(this,"filter");this.filter=Br(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){var e,n;(n=(e=this.filter).remove)==null||n.call(e,t.toMultihash().bytes)}}function H0(r,t=.001){return new W0(r,t)}class G0 extends kn{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Y0(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new G0({name:t,metrics:e}):n=new kn,n}var ai;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&e.payload.byteLength>0&&(n.uint32(26),n.bytes(e.payload)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={publicKey:ae(0),payloadType:ae(0),payload:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=e.bytes();break}case 5:{i.signature=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(ai||(ai={}));class X0 extends Error{constructor(t="Invalid signature"){super(t),this.name="InvalidSignatureError"}}const Xt=class Xt{constructor(t){l(this,"publicKey");l(this,"payloadType");l(this,"payload");l(this,"signature");l(this,"marshaled");const{publicKey:e,payloadType:n,payload:s,signature:i}=t;this.publicKey=e,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=ai.encode({publicKey:At(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(t){return t==null?!1:ze(this.marshal(),t.marshal())}async validate(t,e){const n=id(t,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,e)}};l(Xt,"createFromProtobuf",t=>{const e=ai.decode(t),n=qt(e.publicKey);return new Xt({publicKey:n,payloadType:e.payloadType,payload:e.payload,signature:e.signature})}),l(Xt,"seal",async(t,e,n)=>{if(e==null)throw new Error("Missing private key");const s=t.domain,i=t.codec,o=t.marshal(),a=id(s,i,o),c=await e.sign(a.subarray(),n);return new Xt({publicKey:e.publicKey,payloadType:i,payload:o,signature:c})}),l(Xt,"openAndCertify",async(t,e,n)=>{const s=Xt.createFromProtobuf(t);if(!await s.validate(e,n))throw new X0("Envelope signature is not valid for the given domain");return s});let hn=Xt;const id=(r,t,e)=>{const n=G(r),s=Tr(n.byteLength),i=Tr(t.length),o=Tr(e.length);return new Q(s,n,i,t,o,e)},Q0="libp2p-peer-record",Z0=Uint8Array.from([3,1]);var ci;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.peerId!=null&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),e.seq!=null&&e.seq!==0n&&(n.uint32(16),n.uint64(e.seq)),e.addresses!=null)for(const i of e.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={peerId:ae(0),seq:0n,addresses:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.peerId=e.bytes();break}case 2:{i.seq=e.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new St('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(ci||(ci={}));function J0(r,t){const e=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==t.length?!1:(t.sort(e),r.sort(e).every((n,s)=>t[s].equals(n)))}const Dt=class Dt{constructor(t){l(this,"peerId");l(this,"multiaddrs");l(this,"seqNumber");l(this,"domain",Dt.DOMAIN);l(this,"codec",Dt.CODEC);l(this,"marshaled");const{peerId:e,multiaddrs:n,seqNumber:s}=t;this.peerId=e,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=ci.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(t){return!(!(t instanceof Dt)||!this.peerId.equals(t.peerId)||this.seqNumber!==t.seqNumber||!J0(this.multiaddrs,t.multiaddrs))}};l(Dt,"createFromProtobuf",t=>{const e=ci.decode(t),n=kr(gr(e.peerId)),s=(e.addresses??[]).map(o=>X(o.multiaddr)),i=e.seq;return new Dt({peerId:n,multiaddrs:s,seqNumber:i})}),l(Dt,"DOMAIN",Q0),l(Dt,"CODEC",Z0);let _t=Dt;function j0(r){return r[Symbol.asyncIterator]!=null}function _a(r){if(j0(r))return(async()=>{const e=[];for await(const n of r)e.push(n);return e})();const t=[];for(const e of r)t.push(e);return t}let Hn=(yc=class extends Error{constructor(e="The operation was aborted",...n){super(e,...n);l(this,"name","AbortError")}},l(yc,"name","AbortError"),yc);async function Ia(r,t,e,n){const s=new Hn(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(e==null?void 0:e.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){La(e,"abort",h),La(r,t,u),La(r,i,d)}const u=f=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,f))===!1)return}catch(g){c(),a(g);return}c(),o(f)},d=f=>{if(c(),f instanceof Error){a(f);return}a(f.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};Ta(e,"abort",h),Ta(r,t,u),Ta(r,i,d)})}function Ta(r,t,e){r!=null&&(od(r)?r.addEventListener(t,e):r.addListener(t,e))}function La(r,t,e){r!=null&&(od(r)?r.removeEventListener(t,e):r.removeListener(t,e))}function od(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class ad extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}l(ad,"name","QueueFullError");class eE{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new Hn)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}}function tE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class nE{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=tE(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new Hn),this.cleanup())}async join(t={}){var n;const e=new eE(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await Ju(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}}function cd(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class ld extends Ge{constructor(e={}){super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"autoStart");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=cd(this.emitEmpty.bind(this),1),this.emitIdle=cd(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new ad;const s=new nE(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Hn)}),this.clear()}async onEmpty(e){this.size!==0&&await Ia(this,"empty",e==null?void 0:e.signal)}async onSizeLessThan(e,n){this.size<e||await Ia(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Ia(this,"idle",e==null?void 0:e.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Zs({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail.result)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new Hn("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}}const ud="lock:worker:request-read",dd="lock:worker:abort-read-request",hd="lock:worker:release-read",fd="lock:master:grant-read",gd="lock:master:error-read",md="lock:worker:request-write",pd="lock:worker:abort-write-request",yd="lock:worker:release-write",wd="lock:master:grant-write",bd="lock:master:error-write",Ed="lock:worker:finalize",vd="mortice",rE={singleProcess:!1},Sd=(r,t,e,n,s,i,o,a,c)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(e,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{t.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(h=>{const f=p=>{if((p==null?void 0:p.data)==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===d.identifier&&(t.removeEventListener("message",f),h())};t.addEventListener("message",f)})},onError:h=>{t.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===Ed&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},sE=(r=10)=>Math.random().toString().substring(2,r+2);class iE{constructor(t){l(this,"name");l(this,"channel");this.name=t,this.channel=new BroadcastChannel(vd)}readLock(t){return this.sendRequest(ud,dd,fd,gd,hd,t)}writeLock(t){return this.sendRequest(md,pd,wd,bd,yd,t)}finalize(){this.channel.postMessage({type:Ed,name:this.name}),this.channel.close()}async sendRequest(t,e,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=sE();return this.channel.postMessage({type:t,identifier:a,name:this.name}),new Promise((u,d)=>{var p;const h=()=>{this.channel.postMessage({type:e,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",h,{once:!0});const f=g=>{var y,m,S,v;if(((y=g.data)==null?void 0:y.identifier)===a&&(((m=g.data)==null?void 0:m.type)===n&&(this.channel.removeEventListener("message",f),(S=o==null?void 0:o.signal)==null||S.removeEventListener("abort",h),u(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),g.data.type===s)){this.channel.removeEventListener("message",f),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const E=new Error;g.data.error!=null&&(E.message=g.data.error.message,E.name=g.data.error.name,E.stack=g.data.error.stack),d(E)}};this.channel.addEventListener("message",f)})}}const oE=r=>{if(r=Object.assign({},rE,r),!!globalThis.document||r.singleProcess){const e=new BroadcastChannel(vd),n=new Ge;return e.addEventListener("message",Sd(n,e,"requestReadLock","abortReadLockRequest",ud,dd,gd,hd,fd)),e.addEventListener("message",Sd(n,e,"requestWriteLock","abortWriteLockRequest",md,pd,bd,yd,wd)),n}return new iE(r.name)},fn=new Map;let Wr;function xd(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function aE(r){if(Wr==null&&(Wr=oE(r),!xd(Wr))){const t=Wr;t.addEventListener("requestReadLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=fn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortReadLockRequest",a)})}),t.addEventListener("requestWriteLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=fn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortWriteLockRequest",a)})}),t.addEventListener("finalizeRequest",e=>{const n=e.detail.name,s=fn.get(n);s!=null&&s.finalize()})}return Wr}async function Da(r,t){var o;let e,n;const s=new Promise((a,c)=>{e=a,n=c}),i=()=>{n(new Hn)};return(o=t==null?void 0:t.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{e(()=>{var c;(c=t==null?void 0:t.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:t==null?void 0:t.signal}).catch(a=>{n(a)}),s}const cE=(r,t)=>{let e=fn.get(r);if(e!=null)return e;const n=aE(t);if(xd(n))return e=n,fn.set(r,e),e;const s=new ld({concurrency:1});let i;return e={async readLock(o){if(i!=null)return Da(i,o);i=new ld({concurrency:t.concurrency,autoStart:!1});const a=i,c=Da(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Da(s,o)},finalize:()=>{fn.delete(r)},queue:s},fn.set(r,e),t.autoFinalize===!0&&s.addEventListener("idle",()=>{e.finalize()},{once:!0}),e},lE={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function uE(r){const t=Object.assign({},lE,r);return cE(t.name,t)}const dE=36e5,hE=216e5;var gn;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(e){let n;e.codec=()=>(n==null&&(n=Ce((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),ui.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var u;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=ui.codec().decode(s,s.uint32(),{limits:(u=o.limits)==null?void 0:u.value});break}default:{s.skipType(d&7);break}}}return a})),n),e.encode=s=>Ae(s,e.codec()),e.decode=(s,i)=>xe(s,e.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.addresses!=null)for(const i of e.addresses)n.uint32(10),li.codec().encode(i,n);if(e.protocols!=null)for(const i of e.protocols)n.uint32(18),n.string(i);if(e.publicKey!=null&&(n.uint32(34),n.bytes(e.publicKey)),e.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),e.metadata!=null&&e.metadata.size!==0)for(const[i,o]of e.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(e.tags!=null&&e.tags.size!==0)for(const[i,o]of e.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);e.updated!=null&&(n.uint32(64),n.uint64Number(e.updated)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c,u,d,h,f;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const p=e.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new St('Decode error - map field "addresses" had too many elements');i.addresses.push(li.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((u=s.limits)==null?void 0:u.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new St('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 4:{i.publicKey=e.bytes();break}case 5:{i.peerRecordEnvelope=e.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new ql('Decode error - map field "metadata" had too many elements');const g=r.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(g.key,g.value);break}case 7:{if(((h=s.limits)==null?void 0:h.tags)!=null&&i.tags.size===s.limits.tags)throw new ql('Decode error - map field "tags" had too many elements');const g=r.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:(f=s.limits)==null?void 0:f.tags$value}});i.tags.set(g.key,g.value);break}case 8:{i.updated=e.uint64Number();break}default:{e.skipType(p&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(gn||(gn={}));var li;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.multiaddr!=null&&e.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(e.multiaddr)),e.isCertified!=null&&(n.uint32(16),n.bool(e.isCertified)),e.observed!=null&&(n.uint32(24),n.uint64Number(e.observed)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={multiaddr:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.multiaddr=e.bytes();break}case 2:{i.isCertified=e.bool();break}case 3:{i.observed=e.uint64Number();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(li||(li={}));var ui;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.value!=null&&e.value!==0&&(n.uint32(8),n.uint32(e.value)),e.expiry!=null&&(n.uint32(16),n.uint64(e.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={value:0},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.value=e.uint32();break}case 2:{i.expiry=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(ui||(ui={}));function fE(r,t){if(r.publicKey!=null||t.publicKey==null)return r;let e;r.type==="RSA"&&(e=r.toMultihash());const n=qt(t.publicKey,e);return Rr(n)}function gE(r,t,e){const n=gn.decode(t);return Hr(r,n,e)}function Hr(r,t,e){const n=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...t,id:fE(r,t),addresses:t.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-e).map(({multiaddr:i,isCertified:o})=>({multiaddr:X(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function mE(r,t){return pE(r.addresses,t.addresses)&&yE(r.protocols,t.protocols)&&wE(r.publicKey,t.publicKey)&&bE(r.peerRecordEnvelope,t.peerRecordEnvelope)&&EE(r.metadata,t.metadata)&&vE(r.tags,t.tags)}function pE(r,t){return Cd(r,t,(e,n)=>!(e.isCertified!==n.isCertified||!ze(e.multiaddr,n.multiaddr)))}function yE(r,t){return Cd(r,t,(e,n)=>e===n)}function wE(r,t){return Ad(r,t)}function bE(r,t){return Ad(r,t)}function EE(r,t){return _d(r,t,(e,n)=>ze(e,n))}function vE(r,t){return _d(r,t,(e,n)=>e.value===n.value&&e.expiry===n.expiry)}function Ad(r,t){return r==null&&t==null?!0:r!=null&&t!=null?ze(r,t):!1}function Cd(r,t,e){if(r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(!e(r[n],t[n]))return!1;return!0}function _d(r,t,e){if(r.size!==t.size)return!1;for(const[n,s]of r.entries()){const i=t.get(n);if(i==null||!e(s,i))return!1}return!0}const It="/",Id=new TextEncoder().encode(It),di=Id[0];class qe{constructor(t,e){l(this,"_buf");if(typeof t=="string")this._buf=G(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==di)throw new Error("Invalid key")}toString(t="utf8"){return Z(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new qe(t.join(It))}static random(){return new qe(Math.random().toString().substring(2))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new qe(t):typeof t.uint8Array=="function"?new qe(t.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Id),this._buf[0]!==di){const t=new Uint8Array(this._buf.byteLength+1);t.fill(di,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===di;)this._buf=this._buf.subarray(0,-1)}less(t){const e=this.list(),n=t.list();for(let s=0;s<e.length;s++){if(n.length<s+1)return!1;const i=e[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return e.length<n.length}reverse(){return qe.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(It).slice(1)}type(){return SE(this.baseNamespace())}name(){return xE(this.baseNamespace())}instance(t){return new qe(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(It)||(t+=It),t+=this.type(),new qe(t)}parent(){const t=this.list();return t.length===1?new qe(It):new qe(t.slice(0,-1).join(It))}child(t){return this.toString()===It?t:t.toString()===It?this:new qe(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return qe.withNamespaces([...this.namespaces(),...AE(t.map(e=>e.namespaces()))])}}function SE(r){const t=r.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function xE(r){const t=r.split(":");return t[t.length-1]}function AE(r){return[].concat(...r)}const Td="/peers/";function hi(r){if(!hr(r)||r.type==null)throw new W("Invalid PeerId");const t=r.toCID().toString();return new qe(`${Td}${t}`)}async function CE(r,t,e,n,s){const i=new Map;for(const o of e){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=X(o.multiaddr)),!si(o.multiaddr))throw new W("Multiaddr was invalid");if(!await t(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var u;const c=(u=a.getComponents().find(d=>d.code===V))==null?void 0:u.value;return r.equals(c)&&(a=a.decapsulate(X(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function Pa(r,t,e,n){var f,p;if(t==null)throw new W("Invalid PeerData");if(t.publicKey!=null&&r.publicKey!=null&&!t.publicKey.equals(r.publicKey))throw new W("publicKey bytes do not match peer id publicKey bytes");const s=(f=n.existingPeer)==null?void 0:f.peer;if(s!=null&&!r.equals(s.id))throw new W("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,u=s==null?void 0:s.peerRecordEnvelope;if(e==="patch"){if((t.multiaddrs!=null||t.addresses!=null)&&(i=[],t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses)),t.protocols!=null&&(o=new Set(t.protocols)),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);a=fi(g,{validate:Ld})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags);c=fi(g,{validate:Dd,map:Pd})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}if(e==="merge"){if(t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses),t.protocols!=null&&(o=new Set([...o,...t.protocols])),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[y,m]of g)m==null?a.delete(y):a.set(y,m);a=fi([...a.entries()],{validate:Ld})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),y=new Map(c);for(const[m,S]of g)S==null?y.delete(m):y.set(m,S);c=fi([...y.entries()],{validate:Dd,map:Pd})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=At(s.id.publicKey):t.publicKey!=null?d=At(t.publicKey):r.publicKey!=null&&(d=At(r.publicKey));const h={addresses:await CE(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((g,y)=>g.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(g=>{var y,m,S;g.observed=((S=(m=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:m.find(v=>ze(v.multiaddr,v.multiaddr)))==null?void 0:S.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function fi(r,t){var n;const e=new Map;for(const[s,i]of r)i!=null&&t.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&e.set(s,((n=t.map)==null?void 0:n.call(t,s,i))??i);return e}function Ld(r,t){if(typeof r!="string")throw new W("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new W("Metadata value must be a Uint8Array")}function Dd(r,t){if(typeof r!="string")throw new W("Tag name must be a string");if(t.value!=null){if(parseInt(`${t.value}`,10)!==t.value)throw new W("Tag value must be an integer");if(t.value<0||t.value>100)throw new W("Tag value must be between 0-100")}if(t.ttl!=null){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new W("Tag ttl must be an integer");if(t.ttl<0)throw new W("Tag ttl must be between greater than 0")}}function Pd(r,t){let e;t.expiry!=null&&(e=t.expiry),t.ttl!=null&&(e=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return e!=null&&(n.expiry=e),n}function Rd(r){const t=r.toString().split("/")[2],e=me.parse(t,Rt);return Mr(e)}function Ra(r,t,e){const n=Rd(r);return gE(n,t,e)}function _E(r,t){return{prefix:Td,filters:(r.filters??[]).map(e=>({key:n,value:s})=>e(Ra(n,s,t))),orders:(r.orders??[]).map(e=>(n,s)=>e(Ra(n.key,n.value,t),Ra(s.key,s.value,t)))}}class IE{constructor(t,e={}){ge(this,Ze);l(this,"peerId");l(this,"datastore");l(this,"locks");l(this,"addressFilter");l(this,"log");l(this,"maxAddressAge");l(this,"maxPeerAge");this.log=t.logger.forComponent("libp2p:peer-store"),this.peerId=t.peerId,this.datastore=t.datastore,this.addressFilter=e.addressFilter,this.locks=Y0({name:"libp2p_peer_store_locks",metrics:t.metrics}),this.maxAddressAge=e.maxAddressAge??dE,this.maxPeerAge=e.maxPeerAge??hE}getLock(t){let e=this.locks.get(t);return e==null&&(e={refs:0,lock:uE({name:t.toString(),singleProcess:!0})},this.locks.set(t,e)),e.refs++,e}maybeRemoveLock(t,e){e.refs--,e.refs===0&&(e.lock.finalize(),this.locks.delete(t))}async getReadLock(t,e){const n=this.getLock(t);try{const s=await n.lock.readLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async getWriteLock(t,e){const n=this.getLock(t);try{const s=await n.lock.writeLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async has(t,e){try{return await this.load(t,e),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(t,e){this.peerId.equals(t)||await this.datastore.delete(hi(t),e)}async load(t,e){const n=hi(t),s=await this.datastore.get(n,e),i=gn.decode(s);if(H(this,Ze,Qi).call(this,t,i))throw await this.datastore.delete(n,e),new so;return Hr(t,i,this.peerId.equals(t)?1/0:this.maxAddressAge)}async save(t,e,n){const s=await H(this,Ze,Yi).call(this,t,n),i=await Pa(t,e,"patch",{...n,addressFilter:this.addressFilter});return H(this,Ze,Xi).call(this,t,i,s)}async patch(t,e,n){const s=await H(this,Ze,Yi).call(this,t,n),i=await Pa(t,e,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return H(this,Ze,Xi).call(this,t,i,s)}async merge(t,e,n){const s=await H(this,Ze,Yi).call(this,t,n),i=await Pa(t,e,"merge",{addressFilter:this.addressFilter,existingPeer:s});return H(this,Ze,Xi).call(this,t,i,s)}async*all(t){for await(const{key:e,value:n}of this.datastore.query(_E(t??{},this.maxAddressAge),t)){const s=Rd(e);if(s.equals(this.peerId))continue;const i=gn.decode(n);if(H(this,Ze,Qi).call(this,s,i)){await this.datastore.delete(e,t);continue}yield Hr(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Ze=new WeakSet,Yi=async function(t,e){try{const n=hi(t),s=await this.datastore.get(n,e),i=gn.decode(s);if(H(this,Ze,Qi).call(this,t,i))throw await this.datastore.delete(n,e),new so;return{peerPB:i,peer:Hr(t,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},Xi=async function(t,e,n,s){e.updated=Date.now();const i=gn.encode(e);return await this.datastore.put(hi(t),i,s),{peer:Hr(t,e,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!mE(e,n.peerPB)}},Qi=function(t,e){if(e.updated==null)return!0;if(this.peerId.equals(t))return!1;const n=e.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=e.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0},Uf=Symbol.toStringTag;class TE{constructor(t,e={}){ge(this,rr);l(this,"store");l(this,"events");l(this,"peerId");l(this,"log");l(this,Uf,"@libp2p/peer-store");this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new IE(t,e)}async forEach(t,e){for await(const n of this.store.all(e))t(n)}async all(t){return _a(this.store.all(t))}async delete(t,e){const n=await this.store.getReadLock(t,e);try{await this.store.delete(t,e)}finally{n()}}async has(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.has(t,e)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.load(t,e)}finally{n==null||n()}}async getInfo(t,e){const n=await this.get(t,e);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.save(t,e,n);return H(this,rr,Zi).call(this,t,i),i.peer}finally{s==null||s()}}async patch(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.patch(t,e,n);return H(this,rr,Zi).call(this,t,i),i.peer}finally{s==null||s()}}async merge(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.merge(t,e,n);return H(this,rr,Zi).call(this,t,i),i.peer}finally{s==null||s()}}async consumePeerRecord(t,e,n){const s=hr(e)?e:hr(e==null?void 0:e.expectedPeer)?e.expectedPeer:void 0,i=hr(e)||e===void 0?n:e,o=await hn.openAndCertify(t,_t.DOMAIN,i),a=Mr(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=_t.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((u==null?void 0:u.peerRecordEnvelope)!=null){const d=hn.createFromProtobuf(u.peerRecordEnvelope),h=_t.createFromProtobuf(d.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:t,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}rr=new WeakSet,Zi=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};function LE(r,t={}){return new TE(r,t)}const sr=class sr extends Error{constructor(e="Not Found"){super(e);l(this,"name",sr.name);l(this,"code",sr.code)}};l(sr,"name","NotFoundError"),l(sr,"code","ERR_NOT_FOUND");let ka=sr;function DE(r){return r[Symbol.asyncIterator]!=null}function kd(r){if(DE(r))return(async()=>{for await(const t of r);})();for(const t of r);}function PE(r){const[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[e](){return this}}}function RE(r){return r[Symbol.asyncIterator]!=null}function Gn(r,t){let e=0;if(RE(r))return async function*(){for await(const c of r)await t(c,e++)&&(yield c)}();const n=PE(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await t(c,e++)&&(yield c)}();const a=t;return function*(){o===!0&&(yield s);for(const c of n)a(c,e++)&&(yield c)}()}function kE(r){return r[Symbol.asyncIterator]!=null}function Md(r,t){return kE(r)?async function*(){yield*(await _a(r)).sort(t)}():function*(){yield*_a(r).sort(t)}()}function ME(r){return r[Symbol.asyncIterator]!=null}function Nd(r,t){return ME(r)?async function*(){let e=0;if(!(t<1)){for await(const n of r)if(yield n,e++,e===t)return}}():function*(){let e=0;if(!(t<1)){for(const n of r)if(yield n,e++,e===t)return}}()}class NE{put(t,e,n){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:n,value:s}of t)await this.put(n,s,e),yield n}async*getMany(t,e={}){for await(const n of t)yield{key:n,value:await this.get(n,e)}}async*deleteMany(t,e={}){for await(const n of t)await this.delete(n,e),yield n}batch(){let t=[],e=[];return{put(n,s){t.push({key:n,value:s})},delete(n){e.push(n)},commit:async n=>{await kd(this.putMany(t,n)),t=[],await kd(this.deleteMany(e,n)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let n=this._all(t,e);if(t.prefix!=null){const s=t.prefix;n=Gn(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>Gn(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>Md(s,i),n)),t.offset!=null){let s=0;const i=t.offset;n=Gn(n,()=>s++>=i)}return t.limit!=null&&(n=Nd(n,t.limit)),n}queryKeys(t,e){let n=this._allKeys(t,e);if(t.prefix!=null){const s=t.prefix;n=Gn(n,i=>i.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>Gn(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>Md(s,i),n)),t.offset!=null){const s=t.offset;let i=0;n=Gn(n,()=>i++>=s)}return t.limit!=null&&(n=Nd(n,t.limit)),n}}class OE extends NE{constructor(){super();l(this,"data");this.data=new Map}put(e,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(e.toString(),n),e}get(e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(e.toString());if(s==null)throw new ka;return s}has(e,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(e.toString())}delete(e,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(e.toString())}*_all(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new qe(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new qe(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const ue=r=>({match:t=>{const e=t[0];return e==null||e.code!==r||e.value!=null?!1:t.slice(1)}}),q=(r,t)=>({match:e=>{const n=e[0];return(n==null?void 0:n.code)!==r||n.value==null||t!=null&&n.value!==t?!1:e.slice(1)}}),FE=r=>({match:t=>r.match(t)===!1?t:!1}),J=r=>({match:t=>{const e=r.match(t);return e===!1?t:e}}),Ke=(...r)=>({match:t=>{let e;for(const n of r){const s=n.match(t);s!==!1&&(e==null||s.length<e.length)&&(e=s)}return e??!1}}),ie=(...r)=>({match:t=>{for(const e of r){const n=e.match(t);if(n===!1)return!1;t=n}return t}});function de(...r){function t(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function e(s){return t(s)!==!1}function n(s){const i=t(s);return i===!1?!1:i.length===0}return{matchers:r,matches:e,exactMatch:n}}const BE=q(V),$E=de(BE),gi=q(Ou),mi=q(Fu),pi=q(Bu),Ma=q(Nu);de(gi,J(q(V))),de(mi,J(q(V))),de(pi,J(q(V))),de(Ke(Ma,pi,gi,mi),J(q(V)));const Od=ie(q(ti),J(q(ga))),Fd=ie(J(q(fa)),q(Un),J(q(ga))),Na=Ke(Od,Fd),mn=Ke(Na,Ma,gi,mi,pi),UE=de(Ke(Na,ie(Ke(Ma,pi,gi,mi),J(q(V))))),Bd=de(Od),$d=de(Fd);de(Na);const Oa=ie(mn,q($n)),Gr=ie(mn,q(Mu)),yi=de(ie(Oa,J(q(V))));de(Gr);const Fa=ie(Gr,ue(Uu),J(q(V))),wi=ie(Gr,ue(zu),J(q(V))),zE=Ke(Fa,wi);de(Fa);const qE=de(wi),Ba=Ke(mn,Oa,Gr,Fa,wi),Ud=Ke(ie(Ba,ue(pa),J(q(V)))),bi=de(Ud),zd=Ke(ie(Ba,ue(Ku),J(q(V))),ie(Ba,ue(zn),J(q(ni)),ue(pa),J(q(V)))),$a=de(zd),qd=ie(Gr,ue(Vu),J(q(zr)),J(q(zr)),J(q(V))),Kd=de(qd),Vd=ie(wi,ue(qu),J(q(zr)),J(q(zr)),J(q(V))),Wd=de(Vd),Ei=Ke(Ud,zd,ie(Oa,J(q(V))),ie(zE,J(q(V))),ie(mn,J(q(V))),qd,Vd,q(V)),Ua=de(Ei),KE=ie(J(Ei),ue(Kn),FE(ue(qr)),J(q(V))),Yn=de(KE),VE=Ke(ie(Ei,ue(Kn),ue(qr),J(q(V))),ie(Ei,ue(qr),J(q(V))),ie(ue(qr),J(q(V)))),za=de(VE),WE=Ke(ie(mn,q($n),ue(qn),J(q(V))),ie(mn,ue(qn),J(q(V))));de(WE);const HE=ie(mn,Ke(ie(q($n,"443"),ue(qn)),ie(q($n),ue(ma)),ie(q($n),ue(zn),ue(qn)),ie(ue(zn),ue(qn)),ue(zn),ue(ma)),J(q(V)));de(HE);const GE=Ke(ie(q(Wu),J(q(V))));de(GE);const YE=Ke(ie(q($u),J(q(V))));de(YE);const Hd=864e13;class XE{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Ct({name:"libp2p_address_manager_dns_mappings",metrics:t.metrics})}has(t){const e=pe(t);let n=e.host;(e.type==="ip4"||e.type==="ip6")&&e.sni!=null&&(n=e.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(t,e){e.forEach(n=>{this.log("add DNS mapping %s to %s",n,t);const s=la(n)===!0;this.mappings.set(n,{domain:t,verified:s,expires:s?Hd-Date.now():0,lastVerified:s?Hd-Date.now():void 0})})}remove(t){const e=pe(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===e.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(t){const e=[];for(let n=0;n<t.length;n++){const s=t[n].multiaddr;if(!lt(s))continue;const i=pe(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(t.splice(n,1),n--,e.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return e}maybeAddSNIComponent(t,e){var s;const n=t.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===zn&&((s=n[i+1])==null?void 0:s.code)!==ni)return n.splice(i+1,0,{name:"sni",code:ni,value:e}),X(n)}confirm(t,e){const n=pe(t);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+e,a.lastVerified=Date.now());return i}unconfirm(t,e){const n=pe(t);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+e);return i}}class QE{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Ct({name:"libp2p_address_manager_ip_mappings",metrics:t.metrics})}has(t){const e=pe(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===e.host)return!0;return!1}add(t,e,n,s=e,i="tcp"){const o=`${t}-${e}-${i}`,a=this.mappings.get(o)??[],c={internalIp:t,internalPort:e,externalIp:n,externalPort:s,externalFamily:On(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(t){const e=pe(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===e.host&&a.externalPort===e.port&&a.protocol===e.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,e.host,e.port,e.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(t){const e=[];for(const{multiaddr:n}of t){if(!lt(n))continue;const s=pe(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)e.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return e}maybeOverrideIp(t,e,n,s,i){const o=t.getComponents(),a=o.findIndex(u=>u.code===ti||u.code===Un),c=o.findIndex(u=>u.name===s);return a>-1&&c>-1?(o[a].value=e,o[a].code=n===4?ti:Un,o[c].value=`${i}`,X(o)):t}confirm(t,e){if(!lt(t))return!1;const n=pe(t);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+e,o.lastVerified=Date.now());return s}unconfirm(t,e){if(!lt(t))return!1;const n=pe(t);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+e)}return s}}const ZE={maxObservedAddresses:10};class JE{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Ct({name:"libp2p_address_manager_observed_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??ZE.maxObservedAddresses}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(Fn(t)||hb(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:X(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var n;const e=((n=this.addresses.get(t.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),e}confirm(t,e){const n=t.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const jE={maxObservedAddresses:10};class ev{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Ct({name:"libp2p_address_manager_transport_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??jE.maxObservedAddresses}get(t,e){if(Fn(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const n=this.toKey(t);let s=this.addresses.get(n);return s==null&&(s={verified:!lt(t),expires:0},this.addresses.set(n,s)),{multiaddr:t,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var s;const e=this.toKey(t),n=((s=this.addresses.get(e))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(e),n}confirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+e,this.addresses.set(n,s),i}toKey(t){if(!lt(t))return t.toString();const e=pe(t);return`${e.host}-${e.port}-${e.protocol}`}}const Gd=6e4,Yd={addressVerificationTTL:Gd*10,addressVerificationRetry:Gd*5},tv=r=>r;function qa(r,t){var n;const e=(n=r.getComponents().findLast(s=>s.code===V))==null?void 0:n.value;return e!=null&&ct(e).equals(t)&&(r=r.decapsulate(X(`/p2p/${t.toString()}`))),r}zf=Symbol.toStringTag;class nv{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"listen");l(this,"announce");l(this,"appendAnnounce");l(this,"announceFilter");l(this,"observed");l(this,"dnsMappings");l(this,"ipMappings");l(this,"transportAddresses");l(this,"observedAddressFilter");l(this,"addressVerificationTTL");l(this,"addressVerificationRetry");l(this,zf,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new JE(t,e),this.dnsMappings=new XE(t,e),this.ipMappings=new QE(t,e),this.transportAddresses=new ev(t,e),this.announceFilter=e.announceFilter??tv,this.observedAddressFilter=Br(1024),this.addressVerificationTTL=e.addressVerificationTTL??Yd.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??Yd.addressVerificationRetry,this._updatePeerStoreAddresses=Js(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(e=>{var n;return((n=e.getComponents().findLast(s=>s.code===V))==null?void 0:n.value)===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e});this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(e=>{this.log.error("error updating addresses - %e",e)})}getListenAddrs(){return Array.from(this.listen).map(t=>X(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>X(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>X(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=pe(t);let n;switch(e.type){case"ip4":{n=`${e.host}:${e.port}`;break}case"ip6":{n=`[${e.host}]:${e.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),t=qa(t,this.components.peerId),!this.ipMappings.has(t)&&(this.dnsMappings.has(t)||this.observed.add(t)))}confirmObservedAddr(t,e){t=qa(t,this.components.peerId);let n=!0;((e==null?void 0:e.type)==="transport"||this.transportAddresses.has(t))&&!this.transportAddresses.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="dns-mapping"||this.dnsMappings.has(t))&&!this.dnsMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="ip-mapping"||this.ipMappings.has(t))&&!this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="observed"||this.observed.has(t))&&(this.maybeUpgradeToIPMapping(t)?(this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=qa(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(e.map(n=>{const s=X(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(t)}),t.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];e=e.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),e=e.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(X(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.add(t,e,n,s,i),this.observed.removePrefixed(`/ip${On(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.remove(X(`/ip${On(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t)||!lt(t))return!1;const e=pe(t);if(e.type!=="ip4"||la(e.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>bi.exactMatch(i)||$a.exactMatch(i),i=>yi.exactMatch(i),i=>qE.exactMatch(i)];for(const i of s){if(!i(t))continue;const o=n.filter(u=>u.getAddrs().filter(d=>pe(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!aa(u)).pop();if(a==null)continue;const c=pe(a);return c.port==null?!1:(this.observed.remove(t),this.ipMappings.add(c.host,c.port,e.host,e.port,e.protocol),!0)}return!1}}var Xd;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(Xd||(Xd={}));class rv extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class sv extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class Ka extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class Qd extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class iv extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class ov extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class av extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class Zd extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class cv extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class lv extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class uv extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class dv extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class hv extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class vi extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class Si extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class fv extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class gv extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}class mv{constructor(t={}){l(this,"components",{});l(this,"_started",!1);this.components={};for(const[e,n]of Object.entries(t))this.components[e]=n;this.components.logger==null&&(this.components.logger=iu())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(e=>ho(e)).map(async e=>{var n;await((n=e[t])==null?void 0:n.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const pv=["metrics","connectionProtector","dns"],yv=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function wv(r={}){const t=new mv(r);return new Proxy(t,{get(n,s,i){if(typeof s=="string"&&!yv.includes(s)){const o=t.components[s];if(o==null&&!pv.includes(s))throw new rv(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?t.components[s]=i:Reflect.set(n,s,i),!0}})}function bv(r){const t={};for(const e of Object.values(r.components))for(const n of Ev(e))t[n]=!0;for(const e of Object.values(r.components))for(const n of vv(e))if(t[n]!==!0)throw new sv(`Service "${Sv(e)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function Ev(r){return Array.isArray(r==null?void 0:r[bt])?r[bt]:[]}function vv(r){return Array.isArray(r==null?void 0:r[ps])?r[ps]:[]}function Sv(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function xv(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=t=>bi.matches(t)?!0:Fn(t)),r}class he extends Event{constructor(e,n){super(e);l(this,"type");l(this,"detail");this.type=e,this.detail=n}}function Jd(r){var n;if(hr(r))return{peerId:r,multiaddrs:[]};let t=Array.isArray(r)?r:[r],e;if(t.length>0){const s=(n=t[0].getComponents().findLast(i=>i.code===V))==null?void 0:n.value;e=s==null?void 0:ct(s),t.forEach(i=>{var a;if(!si(i))throw new ds("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===V))==null?void 0:a.value;if(o==null){if(e!=null)throw new W("Multiaddrs must all have the same peer id or have no peer id")}else{const c=ct(o);if((e==null?void 0:e.equals(c))!==!0)throw new W("Multiaddrs must all have the same peer id or have no peer id")}})}return t=t.filter(s=>!$E.exactMatch(s)),{peerId:e,multiaddrs:t}}const Av=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function Cv(r,t){var s;const e=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(t==null?void 0:t.closableProtocols)??Av;if(!(e.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(t))}catch(i){r==null||r.abort(i)}}function Va(r){const t=pe(r);let e=t.cidr;if(t.type!=="ip4"&&t.type!=="ip6")throw new W(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(e==null)switch(t.type){case"ip4":{e=32;break}case"ip6":{e=128;break}default:throw new W(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new yu(t.host,e)}function jd(r){return!Yn.exactMatch(r)}function eh(r,t,e){if(r==null||t==null)return;const n=t.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||e==null)return n;if(!e.some(i=>jd(i)))return n}class _v{constructor(t,e={}){l(this,"connectionManager");l(this,"peerStore");l(this,"allow");l(this,"events");l(this,"log");this.allow=(e.allow??[]).map(n=>Va(n)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections - %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",e,n),e<=n)return;const s=new kn;for(const c of t){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,f)=>h+f.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(t,s),o=Math.max(e-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(lt(c.remoteAddr)){const h=pe(c.remoteAddr);return d.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await Cv(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(t,e){return t.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=e.get(n.remotePeer)??0,o=e.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const th=1e4,nh=1e3,Iv=1e4,xi=1e4,rh=25,Tv=5,Lv=10,Dv=5,Pv="last-dial-failure",Rv="last-dial-success",sh=500,kv=32,Mv=100,ih=50;function Nv(r,t){const e=yi.exactMatch(r.multiaddr),n=yi.exactMatch(t.multiaddr);if(e&&!n)return-1;if(!e&&n)return 1;const s=$a.exactMatch(r.multiaddr),i=$a.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=bi.exactMatch(r.multiaddr),a=bi.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=za.exactMatch(r.multiaddr),u=za.exactMatch(t.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const d=Kd.exactMatch(r.multiaddr),h=Kd.exactMatch(t.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const f=Wd.exactMatch(r.multiaddr),p=Wd.exactMatch(t.multiaddr);return f&&!p?-1:!f&&p?1:0}function Ov(r,t){const e=aa(r.multiaddr),n=aa(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Fv(r,t){const e=Fn(r.multiaddr),n=Fn(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Bv(r,t){return r.isCertified&&!t.isCertified?-1:!r.isCertified&&t.isCertified?1:0}function $v(r,t){const e=Yn.exactMatch(r.multiaddr),n=Yn.exactMatch(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Uv(r){return r.sort(Nv).sort(Bv).sort($v).sort(Fv).sort(Ov)}var oh={exports:{}};(function(r){var t=Object.prototype.hasOwnProperty,e="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(e=!1));function s(c,u,d){this.fn=c,this.context=u,this.once=d||!1}function i(c,u,d,h,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||c,f),g=e?e+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)t.call(d,h)&&u.push(e?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=e?e+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var f=0,p=h.length,g=new Array(p);f<p;f++)g[f]=h[f].fn;return g},a.prototype.listenerCount=function(u){var d=e?e+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,f,p,g){var y=e?e+u:u;if(!this._events[y])return!1;var m=this._events[y],S=arguments.length,v,E;if(m.fn){switch(m.once&&this.removeListener(u,m.fn,void 0,!0),S){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,d),!0;case 3:return m.fn.call(m.context,d,h),!0;case 4:return m.fn.call(m.context,d,h,f),!0;case 5:return m.fn.call(m.context,d,h,f,p),!0;case 6:return m.fn.call(m.context,d,h,f,p,g),!0}for(E=1,v=new Array(S-1);E<S;E++)v[E-1]=arguments[E];m.fn.apply(m.context,v)}else{var L=m.length,x;for(E=0;E<L;E++)switch(m[E].once&&this.removeListener(u,m[E].fn,void 0,!0),S){case 1:m[E].fn.call(m[E].context);break;case 2:m[E].fn.call(m[E].context,d);break;case 3:m[E].fn.call(m[E].context,d,h);break;case 4:m[E].fn.call(m[E].context,d,h,f);break;default:if(!v)for(x=1,v=new Array(S-1);x<S;x++)v[x-1]=arguments[x];m[E].fn.apply(m[E].context,v)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,f){var p=e?e+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===d&&(!f||g.once)&&(!h||g.context===h)&&o(this,p);else{for(var y=0,m=[],S=g.length;y<S;y++)(g[y].fn!==d||f&&!g[y].once||h&&g[y].context!==h)&&m.push(g[y]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=e?e+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,r.exports=a})(oh);var zv=oh.exports;const qv=bu(zv);function Kv(r,t,e){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;e(r[o],t)<=0?(n=++o,s-=i+1):s=i}return n}class Vv{constructor(){ge(this,rt,[])}enqueue(t,e){e={priority:0,...e};const n={priority:e.priority,id:e.id,run:t};if(this.size===0||$(this,rt)[this.size-1].priority>=e.priority){$(this,rt).push(n);return}const s=Kv($(this,rt),n,(i,o)=>o.priority-i.priority);$(this,rt).splice(s,0,n)}setPriority(t,e){const n=$(this,rt).findIndex(i=>i.id===t);if(n===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[s]=$(this,rt).splice(n,1);this.enqueue(s.run,{priority:e,id:t})}dequeue(){const t=$(this,rt).shift();return t==null?void 0:t.run}filter(t){return $(this,rt).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return $(this,rt).length}}rt=new WeakMap;class Wv extends qv{constructor(e){var n,s;super();ge(this,te);ge(this,ir);ge(this,or);ge(this,Qt,0);ge(this,es);ge(this,ar);ge(this,ts,0);ge(this,st);ge(this,cr);ge(this,He);ge(this,ns);ge(this,it,0);ge(this,lr);ge(this,Pt);ge(this,rs);ge(this,Wi,1n);l(this,"timeout");if(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Vv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=e.intervalCap)==null?void 0:n.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=e.interval)==null?void 0:s.toString())??""}\` (${typeof e.interval})`);ye(this,ir,e.carryoverConcurrencyCount),ye(this,or,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),ye(this,es,e.intervalCap),ye(this,ar,e.interval),ye(this,He,new e.queueClass),ye(this,ns,e.queueClass),this.concurrency=e.concurrency,this.timeout=e.timeout,ye(this,rs,e.throwOnTimeout===!0),ye(this,Pt,e.autoStart===!1)}get concurrency(){return $(this,lr)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);ye(this,lr,e),H(this,te,ji).call(this)}setPriority(e,n){$(this,He).setPriority(e,n)}async add(e,n={}){return n.id??(n.id=(os(this,Wi)._++).toString()),n={timeout:this.timeout,throwOnTimeout:$(this,rs),...n},new Promise((s,i)=>{$(this,He).enqueue(async()=>{var o;os(this,it)._++;try{(o=n.signal)==null||o.throwIfAborted(),os(this,Qt)._++;let a=e({signal:n.signal});n.timeout&&(a=Cu(Promise.resolve(a),{milliseconds:n.timeout})),n.signal&&(a=Promise.race([a,H(this,te,Dg).call(this,n.signal)]));const c=await a;s(c),this.emit("completed",c)}catch(a){if(a instanceof Su&&!n.throwOnTimeout){s();return}i(a),this.emit("error",a)}finally{H(this,te,Ig).call(this)}},n),this.emit("add"),H(this,te,Ji).call(this)})}async addAll(e,n){return Promise.all(e.map(async s=>this.add(s,n)))}start(){return $(this,Pt)?(ye(this,Pt,!1),H(this,te,ji).call(this),this):this}pause(){ye(this,Pt,!0)}clear(){ye(this,He,new($(this,ns)))}async onEmpty(){$(this,He).size!==0&&await H(this,te,eo).call(this,"empty")}async onSizeLessThan(e){$(this,He).size<e||await H(this,te,eo).call(this,"next",()=>$(this,He).size<e)}async onIdle(){$(this,it)===0&&$(this,He).size===0||await H(this,te,eo).call(this,"idle")}get size(){return $(this,He).size}sizeBy(e){return $(this,He).filter(e).length}get pending(){return $(this,it)}get isPaused(){return $(this,Pt)}}ir=new WeakMap,or=new WeakMap,Qt=new WeakMap,es=new WeakMap,ar=new WeakMap,ts=new WeakMap,st=new WeakMap,cr=new WeakMap,He=new WeakMap,ns=new WeakMap,it=new WeakMap,lr=new WeakMap,Pt=new WeakMap,rs=new WeakMap,Wi=new WeakMap,te=new WeakSet,Cg=function(){return $(this,or)||$(this,Qt)<$(this,es)},_g=function(){return $(this,it)<$(this,lr)},Ig=function(){os(this,it)._--,H(this,te,Ji).call(this),this.emit("next")},Tg=function(){H(this,te,Ec).call(this),H(this,te,bc).call(this),ye(this,cr,void 0)},Lg=function(){const e=Date.now();if($(this,st)===void 0){const n=$(this,ts)-e;if(n<0)ye(this,Qt,$(this,ir)?$(this,it):0);else return $(this,cr)===void 0&&ye(this,cr,setTimeout(()=>{H(this,te,Tg).call(this)},n)),!0}return!1},Ji=function(){if($(this,He).size===0)return $(this,st)&&clearInterval($(this,st)),ye(this,st,void 0),this.emit("empty"),$(this,it)===0&&this.emit("idle"),!1;if(!$(this,Pt)){const e=!$(this,te,Lg);if($(this,te,Cg)&&$(this,te,_g)){const n=$(this,He).dequeue();return n?(this.emit("active"),n(),e&&H(this,te,bc).call(this),!0):!1}}return!1},bc=function(){$(this,or)||$(this,st)!==void 0||(ye(this,st,setInterval(()=>{H(this,te,Ec).call(this)},$(this,ar))),ye(this,ts,Date.now()+$(this,ar)))},Ec=function(){$(this,Qt)===0&&$(this,it)===0&&$(this,st)&&(clearInterval($(this,st)),ye(this,st,void 0)),ye(this,Qt,$(this,ir)?$(this,it):0),H(this,te,ji).call(this)},ji=function(){for(;H(this,te,Ji).call(this););},Dg=async function(e){return new Promise((n,s)=>{e.addEventListener("abort",()=>{s(e.reason)},{once:!0})})},eo=async function(e,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(e,i),s())};this.on(e,i)})};function ah(r){const t=[Kt.A];return r==null?t:Array.isArray(r)?r.length===0?t:r:[r]}const ch=60;function lh(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(t=>({name:t.name,type:Kt[t.type]})),Answer:(r.Answer??r.answers??[]).map(t=>({name:t.name,type:Kt[t.type],TTL:t.TTL??t.ttl??ch,data:t.data instanceof Uint8Array?Z(t.data):t.data}))}}const Hv=4;function uh(r,t={}){const e=new Wv({concurrency:t.queryConcurrency??Hv});return async(n,s={})=>{var a;const i=new URLSearchParams;i.set("name",n),ah(s.types).forEach(c=>{i.append("type",Kt[c])}),(a=s.onProgress)==null||a.call(s,new he("dns:query",n));const o=await e.add(async()=>{var d;const c=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const u=lh(await c.json());return(d=s.onProgress)==null||d.call(s,new he("dns:response",u)),u},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function Gv(){return[uh("https://cloudflare-dns.com/dns-query"),uh("https://dns.google/resolve")]}var Yv=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,e=Object.create(null),n=Object.create(null);function s(i,o){e[i]=o,t++,t>=r&&(t=0,n=e,e=Object.create(null))}return{has:function(i){return e[i]!==void 0||n[i]!==void 0},remove:function(i){e[i]!==void 0&&(e[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=e[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){e[i]!==void 0?e[i]=o:s(i,o)},clear:function(){e=Object.create(null),n=Object.create(null)}}};const Xv=bu(Yv);class Qv{constructor(t){l(this,"lru");this.lru=Xv(t)}get(t,e){let n=!0;const s=[];for(const i of e){const o=this.getAnswers(t,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return lh({answers:s})}getAnswers(t,e){const n=`${t.toLowerCase()}-${e}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Kt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(t,e){const n=`${t.toLowerCase()}-${e.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(e.TTL??ch)*1e3,value:e}),this.lru.set(n,s)}remove(t,e){const n=`${t.toLowerCase()}-${e}`;this.lru.remove(n)}clear(){this.lru.clear()}}function Zv(r){return new Qv(r)}const Jv=1e3;class jv{constructor(t){l(this,"resolvers");l(this,"cache");this.resolvers={},this.cache=Zv(t.cacheSize??Jv),Object.entries(t.resolvers??{}).forEach(([e,n])=>{Array.isArray(n)||(n=[n]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=n}),this.resolvers["."]==null&&(this.resolvers["."]=Gv())}async query(t,e={}){var c,u,d;const n=ah(e.types),s=e.cached!==!1?this.cache.get(t,n):void 0;if(s!=null)return(c=e.onProgress)==null||c.call(e,new he("dns:cache",s)),s;const i=`${t.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((u=e.signal)==null?void 0:u.aborted)===!0)break;try{const f=await h(t,{...e,types:n});for(const p of f.Answer)this.cache.add(t,p);return f}catch(f){a.push(f),(d=e.onProgress)==null||d.call(e,new he("dns:error",f))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${t} ${n} failed`)}}var Kt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Kt||(Kt={}));function eS(r={}){return new jv(r)}class tS{constructor(){l(this,"dns")}canResolve(t){return t.getComponents().some(({name:e})=>e==="dnsaddr")}async resolve(t,e){var c,u;const n=(c=t.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[t];const i=await this.getDNS(e).query(`_dnsaddr.${n}`,{signal:e==null?void 0:e.signal,types:[Kt.TXT]}),o=(u=t.getComponents().find(d=>d.name==="p2p"))==null?void 0:u.value,a=[];for(const d of i.Answer){const h=d.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(X(h)))}return a}getDNS(t){return t.dns!=null?t.dns:(this.dns==null&&(this.dns=eS()),this.dns)}}const dh=new tS;async function hh(r,t,e){const n=e.depth??0;if(n>(e.maxRecursiveDepth??kv))throw new gv("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(t))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,e);for(const c of a)i.push(...await hh(c,t,{...e,depth:n+1}))}return s===!1&&i.push(r),i}const Yr={maxParallelDials:ih,maxDialQueueLength:sh,maxPeerAddrsToDial:rh,dialTimeout:th,resolvers:{dnsaddr:dh}};class nS{constructor(t,e={}){l(this,"queue");l(this,"components");l(this,"addressSorter");l(this,"maxPeerAddrsToDial");l(this,"maxDialQueueLength");l(this,"dialTimeout");l(this,"shutDownController");l(this,"connections");l(this,"log");l(this,"resolvers");this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??Yr.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??Yr.maxDialQueueLength,this.dialTimeout=e.dialTimeout??Yr.dialTimeout,this.connections=e.connections??new kn,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.resolvers=e.resolvers??Yr.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new U0({concurrency:e.maxParallelDials??Yr.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==ft.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var o,a,c;const{peerId:n,multiaddrs:s}=Jd(t);if(n!=null&&e.force!==!0){const u=eh(n,this.connections.get(n),s);if(u!=null)return this.log("already connected to %a",u.remoteAddr),(o=e.onProgress)==null||o.call(e,new he("dial-queue:already-connected")),u}const i=this.queue.queue.find(u=>{if((n==null?void 0:n.equals(u.options.peerId))===!0)return!0;const d=u.options.multiaddrs;if(d==null)return!1;for(const h of s)if(d.has(h.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const u of s)i.options.multiaddrs.add(u.toString());return(a=e.onProgress)==null||a.call(e,new he("dial-queue:already-in-dial-queue")),i.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new dr("Dial queue is full");return this.log("creating dial target for %p",n,s.map(u=>u.toString())),(c=e.onProgress)==null||c.call(e,new he("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var h;(h=u.onProgress)==null||h.call(u,new he("dial-queue:start-dial"));const d=ln([this.shutDownController.signal,u.signal]);try{return await this.dialPeer(u,d)}finally{d.clear()}},{peerId:n,priority:e.priority??mh,multiaddrs:new Set(s.map(u=>u.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var d;const n=t.peerId,s=t.multiaddrs,i=new Set;let o=t.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const h=[],f=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...f]);const p=await this.calculateMultiaddrs(n,f,{...t,signal:e});for(const g of p){if(i.has(g.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",g.multiaddr,n);continue}h.push(g)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(g=>g.multiaddr.toString())),(d=t==null?void 0:t.onProgress)==null||d.call(t,new he("dial-queue:calculated-addresses",h));for(const g of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new dr("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(g.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",g.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[Rv]:G(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}return y}catch(y){if(this.log.error("dial failed to %a - %e",g.multiaddr,y),i.add(g.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[Pv]:G(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}if(e.aborted)throw new kg(y.message);u.push(y)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,n={}){var h,f;const s=[...e].map(p=>({multiaddr:X(p),isCertified:!1}));if(t!=null){if(this.components.peerId.equals(t))throw new dr("Tried to dial self");if(await((f=(h=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(h,t))===!0)throw new Zd("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",t);try{const p=await this.components.peerStore.get(t);s.push(...p.addresses),this.log("loaded multiaddrs for %p",t,s.map(({multiaddr:g})=>g.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",t);try{const p=await this.components.peerRouting.findPeer(t,n);this.log("found multiaddrs for %p in the peer routing",t,s.map(({multiaddr:g})=>g.toString())),s.push(...p.multiaddrs.map(g=>({multiaddr:g,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,p)}}}let i=(await Promise.all(s.map(async p=>{const g=await hh(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return g.length===1&&g[0].equals(p.multiaddr)?p:g.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(t!=null){const p=`/p2p/${t.toString()}`;i=i.map(g=>{const y=g.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:g.multiaddr.encapsulate(p),isCertified:g.isCertified}:g})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const g=(y=p.multiaddr.getComponents().findLast(m=>m.code===V))==null?void 0:y.value;return t!=null&&g!=null?t.equals(g):!0}),a=new Map;for(const p of o){const g=p.multiaddr.toString(),y=a.get(g);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(g,p)}const c=[...a.values()];if(c.length===0)throw new uv("The dial request has no valid addresses");const u=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||u.push(p);const d=this.addressSorter==null?Uv(u):u.sort(this.addressSorter);if(d.length===0)throw new Zd("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const n=await this.calculateMultiaddrs(void 0,new Set(t.map(s=>s.toString())),e);return e.runOnLimitedConnection===!1?n.find(s=>!Yn.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}const rS=Object.prototype.toString,sS=r=>rS.call(r)==="[object Error]",iS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function oS(r){if(!(r&&sS(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:e,stack:n}=r;return e==="Load failed"?n===void 0||"__sentry_captured__"in r:e.startsWith("error sending request for url")?!0:iS.has(e)}function aS(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function Ai(r,t,{min:e=0,allowInfinity:n=!1}={}){if(t!==void 0){if(typeof t!="number"||Number.isNaN(t))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(t))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(t<e)throw new TypeError(`Expected \`${r}\` to be â‰¥ ${e}.`)}}class cS extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,{message:t}=t):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}function lS(r,t){const e=Math.max(1,r+1),n=t.randomize?Math.random()+1:1;let s=Math.round(n*t.minTimeout*t.factor**(e-1));return s=Math.min(s,t.maxTimeout),s}function fh(r,t){return Number.isFinite(t)?t-(performance.now()-r):t}async function uS({error:r,attemptNumber:t,retriesConsumed:e,startTime:n,options:s}){var p,g,y;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof cS)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-e):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:t,retriesLeft:o,retriesConsumed:e});if(await s.onFailedAttempt(c),fh(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(c),d=fh(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!oS(i)){if(u)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!u)return(g=s.signal)==null||g.throwIfAborted(),!1;const h=lS(e,s),f=Math.min(h,d);return f>0&&await new Promise((m,S)=>{var L,x;const v=()=>{var _;clearTimeout(E),(_=s.signal)==null||_.removeEventListener("abort",v),S(s.signal.reason)},E=setTimeout(()=>{var _;(_=s.signal)==null||_.removeEventListener("abort",v),m()},f);s.unref&&((L=E.unref)==null||L.call(E)),(x=s.signal)==null||x.addEventListener("abort",v,{once:!0})}),(y=s.signal)==null||y.throwIfAborted(),!0}async function dS(r,t={}){var i,o,a;if(t={...t},aS(t.retries),Object.hasOwn(t,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");t.retries??(t.retries=10),t.factor??(t.factor=2),t.minTimeout??(t.minTimeout=1e3),t.maxTimeout??(t.maxTimeout=Number.POSITIVE_INFINITY),t.maxRetryTime??(t.maxRetryTime=Number.POSITIVE_INFINITY),t.randomize??(t.randomize=!1),t.onFailedAttempt??(t.onFailedAttempt=()=>{}),t.shouldRetry??(t.shouldRetry=()=>!0),t.shouldConsumeRetry??(t.shouldConsumeRetry=()=>!0),Ai("factor",t.factor,{min:0,allowInfinity:!1}),Ai("minTimeout",t.minTimeout,{min:0,allowInfinity:!1}),Ai("maxTimeout",t.maxTimeout,{min:0,allowInfinity:!0}),Ai("maxRetryTime",t.maxRetryTime,{min:0,allowInfinity:!0}),t.factor>0||(t.factor=1),(i=t.signal)==null||i.throwIfAborted();let e=0,n=0;const s=performance.now();for(;!Number.isFinite(t.retries)||n<=t.retries;){e++;try{(o=t.signal)==null||o.throwIfAborted();const c=await r(e);return(a=t.signal)==null||a.throwIfAborted(),c}catch(c){await uS({error:c,attemptNumber:e,retriesConsumed:n,startTime:s,options:t})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class hS{constructor(t,e={}){l(this,"log");l(this,"queue");l(this,"started");l(this,"peerStore");l(this,"retries");l(this,"retryInterval");l(this,"backoffFactor");l(this,"connectionManager");l(this,"events");this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new Ca({concurrency:e.maxParallelReconnects??Dv,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);gh(e)&&(this.queue.has(t)||this.queue.add(async n=>{await dS(async s=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",t,n);const s={};[...e.tags.keys()].forEach(i=>{i.startsWith(uo)&&(s[i]=void 0)}),await this.peerStore.merge(t,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>gh(e)]});await Promise.all(t.map(async e=>{await this.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(t=>{this.log.error("error reconnect to peers after start - %e",t)})}stop(){this.started=!1,this.queue.abort()}}function gh(r){for(const t of r.tags.keys())if(t.startsWith(uo))return!0;return!1}const mh=50,Wa={maxConnections:Mv,inboundConnectionThreshold:Tv,maxIncomingPendingConnections:Lv};qf=Symbol.toStringTag;class fS{constructor(t,e={}){l(this,"started");l(this,"connections");l(this,"allow");l(this,"deny");l(this,"maxIncomingPendingConnections");l(this,"incomingPendingConnections");l(this,"outboundPendingConnections");l(this,"maxConnections");l(this,"dialQueue");l(this,"reconnectQueue");l(this,"connectionPruner");l(this,"inboundConnectionRateLimiter");l(this,"peerStore");l(this,"metrics");l(this,"events");l(this,"log");l(this,"peerId");l(this,qf,"@libp2p/connection-manager");var n;if(this.maxConnections=e.maxConnections??Wa.maxConnections,this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");this.connections=new kn,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(s=>Va(X(s))),this.deny=(e.deny??[]).map(s=>Va(X(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??Wa.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new z0({points:e.inboundConnectionThreshold??Wa.inboundConnectionThreshold,duration:1}),this.connectionPruner=new _v({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{allow:(n=e.allow)==null?void 0:n.map(s=>X(s))}),this.dialQueue=new nS(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??ih,maxDialQueueLength:e.maxDialQueueLength??sh,maxPeerAddrsToDial:e.maxPeerAddrsToDial??rh,dialTimeout:e.dialTimeout??th,resolvers:e.resolvers??{dnsaddr:dh},connections:this.connections}),this.reconnectQueue=new hS({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,n;(t=this.metrics)==null||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(e=this.metrics)==null||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const u of a.streams){const d=`${u.direction} ${u.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[u,d]of Object.entries(c))s[u]=s[u]??[],s[u].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((u,d)=>u-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Tc(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Lc(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const n of e)t.push(Promise.all([$e(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(t){if(this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");let e=!1;t<this.maxConnections&&(e=!0),this.maxConnections=t,e&&this.connectionPruner.maybePruneConnections()}onConnect(t){this._onConnect(t).catch(e=>{this.log.error("could not connect - %e",e)})}async _onConnect(t){const{detail:e}=t;if(!this.started){await e.close();return}if(e.status!=="open")return;const n=e.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(e),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,n=e.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==e.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(t){if(t!=null)return this.connections.get(t)??[];let e=[];for(const n of this.connections.values())e=e.concat(n);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var n,s;if(!this.started)throw new ur("Not started");this.outboundPendingConnections++;try{(n=e.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=Jd(t);if(this.peerId.equals(i))throw new io("Can not dial self");if(i!=null&&e.force!==!0){this.log("dial %p",i);const d=eh(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=e.onProgress)==null||s.call(e,new he("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(t,{...e,priority:e.priority??mh});if(a.status!=="open")throw new us("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let u=!1;for(const d of c)if(d.id===a.id&&(u=!0),e.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new ds("Duplicate multiaddr connection")),d;return u||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(t,e,n={}){return(await this.openConnection(t,n)).newStream(e,n)}async closeConnections(t,e={}){const n=this.connections.get(t)??[];await Promise.all(n.map(async s=>{try{await Promise.all([$e(s,"close",e),s.close(e)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(t){if(this.deny.some(s=>{if(lt(t.remoteAddr)){const i=pe(t.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(s=>{if(lt(t.remoteAddr)){const i=pe(t.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(lt(t.remoteAddr)){const s=pe(t.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(n=>X(n))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}const gS=1e4,mS="1.0.0",pS="ping",yS="ipfs",ph=32,wS=!0;Vf=Symbol.toStringTag,Kf=bt;class bS{constructor(t,e={}){l(this,"protocol");l(this,"components");l(this,"log");l(this,"heartbeatInterval");l(this,"pingIntervalMs");l(this,"abortController");l(this,"timeout");l(this,"abortConnectionOnPingFailure");l(this,Vf,"@libp2p/connection-monitor");l(this,Kf,["@libp2p/connection-monitor"]);this.components=t,this.protocol=`/${e.protocolPrefix??yS}/${pS}/${mS}`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??gS,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??wS,this.timeout=new $b({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var n;let e=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await t.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=ed(i);e=Date.now(),await Promise.all([o.write(Vl(ph),{signal:s}),o.read({bytes:ph,signal:s})]),t.rtt=Date.now()-e,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;t.rtt=(Date.now()-e)/2}}).catch(e=>{this.log.error("error during heartbeat - %e",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;(t=this.abortController)==null||t.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}Wf=Symbol.toStringTag;class ES{constructor(t,e){l(this,"routers");l(this,"started");l(this,"components");l(this,Wf,"@libp2p/content-routing");var n,s,i,o,a;this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()}),getAttributesFromYieldedValue:(c,u)=>({...u,providers:[...Array.isArray(u.providers)?u.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(this.routers.length===0)throw new Ka("No content routers available");const n=this,s=new Mn;for await(const i of ba(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(t,e))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(t,e={}){if(this.routers.length===0)throw new Ka("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(t,e)}))}async cancelReprovide(t,e={}){if(this.routers.length===0)throw new Ka("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(t,e)}))}async put(t,e,n){if(!this.isStarted())throw new ur;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(t,e,n)}))}async get(t,e){if(!this.isStarted())throw new ur;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(t,e)))}}const Ci=globalThis.CustomEvent??Event;async function*vS(r,t={}){let e=t.concurrency??1/0;e<1&&(e=1/0);const n=t.ordered??!1,s=new EventTarget,i=[];let o=nt(),a=nt(),c=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of r){if(i.length===e&&(o=nt(),await o.promise),d)break;const y={done:!1};i.push(y),g().then(m=>{y.done=!0,y.ok=!0,y.value=m,s.dispatchEvent(new Ci("task-complete"))},m=>{y.done=!0,y.err=m,s.dispatchEvent(new Ci("task-complete"))})}c=!0,s.dispatchEvent(new Ci("task-complete"))}catch(g){u=g,s.dispatchEvent(new Ci("task-complete"))}});function h(){var g;return n?(g=i[0])==null?void 0:g.done:!!i.find(y=>y.done)}function*f(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw d=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;h();)for(let g=0;g<i.length;g++)if(i[g].done){const y=i[g];if(i.splice(g,1),g--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(h()||(a=nt(),await a.promise),u!=null||(n?yield*f():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}Hf=Symbol.toStringTag;class SS{constructor(t,e={}){l(this,"log");l(this,"peerId");l(this,"peerStore");l(this,"routers");l(this,Hf,"@libp2p/peer-routing");var n,s;this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:Z(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(this.routers.length===0)throw new Qd("No peer routers available");if(t.toString()===this.peerId.toString())throw new iv("Should not try to find self");const n=this,s=ba(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),i;throw new so}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new Qd("No peer routers available");const n=this,s=Br(1024);for await(const i of vS(async function*(){const o=ba(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(t,e)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...e,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}function xS(r){return r.reason}async function Ha(r,t,e){if(t==null)return r;const n=xS;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}class AS extends(Yf=Ge,Gf=Symbol.toStringTag,Yf){constructor(e){super();l(this,"peerRouting");l(this,"log");l(this,"walking");l(this,"walkers");l(this,"shutdownController");l(this,"walkController");l(this,"needNext");l(this,Gf,"@libp2p/random-walk");this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){var s,i;this.walking||this.startWalk(),this.walkers++;const n=ln([this.shutdownController.signal,e==null?void 0:e.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=nt(),yield(await $e(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=ln([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Vl(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await Ha(this.needNext.promise,e)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const yh=32,wh=64;Xf=Symbol.toStringTag;class CS{constructor(t){l(this,"log");l(this,"topologies");l(this,"handlers");l(this,"components");l(this,"middleware");l(this,Xf,"@libp2p/registrar");var e;this.components=t,this.log=t.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(e=t.metrics)==null||e.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=Ct({name:"libp2p_registrar_protocol_handlers",metrics:t.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(e==null)throw new ov(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return e==null?[]:[...e.values()]}async handle(t,e,n){if(this.handlers.has(t)&&(n==null?void 0:n.force)!==!0)throw new av(`Handler already registered for protocol ${t}`);this.handlers.set(t,{handler:e,options:{maxInboundStreams:yh,maxOutboundStreams:wh,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]},n)}async unhandle(t,e){(Array.isArray(t)?t:[t]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},e)}async register(t,e){if(e==null)throw new W("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(t);return s==null&&(s=new Map,this.topologies.set(t,s)),s.set(n,e),n}unregister(t){for(const[e,n]of this.topologies.entries())n.has(t)&&(n.delete(t),n.size===0&&this.topologies.delete(e))}use(t,e){this.middleware.set(t,e)}unuse(t){this.middleware.delete(t)}getMiddleware(t){return this.middleware.get(t)??[]}async _onDisconnect(t){const e=t.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(e,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e))!==!1&&((u=a.filter)==null||u.remove(e),await((d=a.onDisconnect)==null?void 0:d.call(a,e)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",e,s)}}async _onPeerUpdate(t){const{peer:e,previous:n}=t.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!e.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e.id))!==!1&&((u=a.filter)==null||u.remove(e.id),await((d=a.onDisconnect)==null?void 0:d.call(a,e.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",e.id,i)}}async _onPeerIdentify(t){const e=t.detail.protocols,n=t.detail.connection,s=t.detail.peerId;try{for(const i of e){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((u=a.filter)==null||u.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}Qf=Symbol.toStringTag;class _S{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"transports");l(this,"listeners");l(this,"faultTolerance");l(this,"started");l(this,Qf,"@libp2p/transport-manager");this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=Ct({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Ct({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??ms.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(e==null)throw new W("Transport must have a valid tag");if(this.transports.has(e))throw new W(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,n]of this.listeners)for(this.log("closing listeners for %s",e);n.length>0;){const s=n.pop();s!=null&&t.push(s.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var s;const n=this.dialTransportForMultiaddr(t);if(n==null)throw new fv(`No transport available for address ${String(t)}`);return(s=e==null?void 0:e.onProgress)==null||s.call(e,new he("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const n of e)t=[...t,...n.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values())if(e.dialFilter([t]).length>0)return e}listenTransportForMultiaddr(t){for(const e of this.transports.values())if(e.listenFilter([t]).length>0)return e}async listen(t){if(!this.isStarted())throw new ur("Not started");if(t==null||t.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(i=>{e.errors.set(i.toString(),new cv)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(t);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(f=>f===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),Bd.matches(c)?e.ipv4.attempts++:$d.matches(c)&&e.ipv6.attempts++,n.push(u.listen(c).then(()=>{e.errors.delete(c.toString()),Bd.matches(c)&&e.ipv4.success++,$d.matches(c)&&e.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,h),e.errors.set(c.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(e)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===ms.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new lv(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...e.errors.entries()].map(([i,o])=>`
  ${i}: ${`${IS(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(t){if(t.ipv4.attempts===0||t.ipv6.attempts===0)return!1;const e=t.ipv4.attempts===t.ipv4.success,n=t.ipv6.success===0;return e&&n}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const n=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const s=e.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}function IS(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const pn="/multistream/1.0.0",bh=1024,TS=G(`
`);async function Ga(r,t){const n=(await r.read(t)).subarray();if(n.byteLength===0||n[n.length-1]!==TS[0])throw new ot("Missing newline");return Z(n).trimEnd()}async function Ya(r,t,e={}){if(t=Array.isArray(t)?[...t]:[t],t.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=Vr(r,{...e,maxDataLength:bh});for(let i=0;i<t.length;i++){const o=t[i];let a;if(i===0){n.trace('write ["%s", "%s"]',pn,o);const c=G(`${pn}
`),u=G(`${o}
`);if(await s.writeV([c,u],e),n.trace("reading multistream-select header"),a=await Ga(s,e),n.trace('read "%s"',a),a!==pn){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(G(`${o}
`),e);if(n.trace("reading protocol response"),a=await Ga(s,e),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new Cc(`Protocol selection failed - could not negotiate ${t}`)}async function Xa(r,t,e={}){t=Array.isArray(t)?t:[t];const n=r.log.newScope("mss:handle"),s=Vr(r,{...e,maxDataLength:bh,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await Ga(s,e);if(n.trace('read "%s"',i),i===pn){n.trace('respond with "%s" for "%s"',pn,i),await s.write(G(`${pn}
`),e),n.trace('responded with "%s" for "%s"',pn,i);continue}if(t.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(G(`${i}
`),e),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new Q(...t.map(a=>oi.single(G(`${a}
`))),G(`
`));n.trace('respond with "%s" for %s',t,i),await s.write(o,e),n.trace('responded with "%s" for %s',t,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(G(`na
`),e),n('responded with "na" for "%s"',i)}}class LS extends(jf=Ge,Jf=Symbol.toStringTag,Zf=le,jf){constructor(e,n){super();l(this,"id");l(this,"remoteAddr");l(this,"remotePeer");l(this,"direction");l(this,"timeline");l(this,"direct");l(this,"multiplexer");l(this,"encryption");l(this,"limits");l(this,"log");l(this,"maConn");l(this,"muxer");l(this,"components");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"closeTimeout");l(this,Jf,"Connection");l(this,Zf,!0);l(this,"newStream",async(e,n={})=>{var i;if(this.muxer==null)throw new vi("Connection is not multiplexed");if(this.muxer.status!=="open")throw new us(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new us(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new oo("Cannot open protocol stream on limited connection");Array.isArray(e)||(e=[e]),this.log.trace("starting new stream for protocols %s",e);const s=await this.muxer.createStream({...n,protocol:e.length===1?e[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,e);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const u=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:u}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",e),s.protocol=await Ya(s,e,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=RS(s.protocol,this.components.registrar,n),a=Eh(s.protocol,"outbound",this);if(a>o){const u=new ao(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(u),u}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,e,o),o}});this.components=e,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??xi,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??xi,this.closeTimeout=n.closeTimeout??nh,this.direct=jd(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===V)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new gs(s.local,s.error))})}get streams(){var e;return((e=this.muxer)==null?void 0:e.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(e){var i;const n=e.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await Xa(n,h,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=PS(n.protocol,this.components.registrar);if(Eh(n.protocol,"inbound",this)>o)throw new _c(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:u}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&u.runOnLimitedConnection!==!0)throw new oo("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(h,f,p)=>{await c(h,f),p(h,f)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(e,n,s){for(let i=0;i<s.length;i++){const o=s[i];e.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const u=o(e,n,(d,h)=>{e=d,n=h,a()});u instanceof Promise&&u.catch(c)}catch(u){c(u)}}),e.log.trace("ran middleware",i,o)}return e}async close(e={}){var n;if(this.log("closing connection to %a",this.remoteAddr),e.signal==null){const s=AbortSignal.timeout(this.closeTimeout);e={...e,signal:s}}await((n=this.muxer)==null?void 0:n.close(e)),await this.maConn.close(e)}abort(e){var n;(n=this.muxer)==null||n.abort(e),this.maConn.abort(e)}}function DS(r,t){return new LS(r,t)}function PS(r,t){try{const{options:e}=t.getHandler(r);if(e.maxInboundStreams!=null)return e.maxInboundStreams}catch(e){if(e.name!=="UnhandledProtocolError")throw e}return yh}function RS(r,t,e={}){try{const{options:n}=t.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return e.maxOutboundStreams??wh}function Eh(r,t,e){let n=0;return e.streams.forEach(s=>{s.direction===t&&s.protocol===r&&n++}),n}eg=Symbol.toStringTag;class kS{constructor(t,e){l(this,"components");l(this,"connectionEncrypters");l(this,"streamMuxers");l(this,"inboundUpgradeTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"events");l(this,"metrics");l(this,"connectionCloseTimeout");l(this,eg,"@libp2p/upgrader");var n,s,i,o;this.components=t,this.connectionEncrypters=Ct({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),e.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Ct({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),e.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??Iv,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??xi,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??xi,this.connectionCloseTimeout=e.connectionCloseTimeout??nh,this.events=t.events,this.metrics={dials:(n=t.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=t.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=t.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(t,...e){const n=this.components.connectionGater[t];if(n==null)return;if(await n.apply(this.components.connectionGater,e)===!0)throw new dv(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return ln([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(e.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(t),!n)throw new hv("Connection denied");await Ha(this.shouldBlockConnection("denyInboundConnection",t),s),await this._performUpgrade(t,"inbound",{...e,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=t.remoteAddr.getComponents().findLast(d=>d.code===V))==null?void 0:s.value;let c;a!=null&&(c=ct(a),await Ha(this.shouldBlockConnection("denyOutboundConnection",c,t),e.signal));let u="outbound";return e.initiator===!1&&(u="inbound"),await this._performUpgrade(t,u,e)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(t,e,n){var h,f,p,g;let s=t,i,o,a,c;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(t.log=t.log.newScope(`${e}:${u}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(t.log("protecting the %s connection",e),s=await y.protect(s,n))}try{if(MS(n)){if(n.remotePeer==null)throw new ds(`${e} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(f=t.remoteAddr.getComponents().findLast(S=>S.code===V))==null?void 0:f.value;let m;y!=null&&(m=ct(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new he(`upgrader:encrypt-${e}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(e==="inbound"?this._encryptInbound(s,{...n,remotePeer:m}):this._encryptOutbound(s,{...n,remotePeer:m}))}if(i.equals(this.components.peerId)){const y=new io("Can not dial self");throw t.abort(y),y}await this.shouldBlockConnection(e==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,t),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((g=n==null?void 0:n.onProgress)==null||g.call(n,new he(`upgrader:multiplex-${e}-connection`)),o=await(e==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw t.log.error("failed to upgrade %s connection %s %a - %e",e,e==="inbound"?"from":"to",t.remoteAddr,y),y}o!=null&&(t.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(e==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,t);const d=this._createConnection({id:u,cryptoProtocol:c,direction:e,maConn:t,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(t){const e=DS(this.components,{...t,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return e.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:e})}),this.events.safeDispatchEvent("connection:open",{detail:e}),e}async _encryptInbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{const s=await Xa(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Si(`no crypto module found for ${s}`);return t.log("encrypting inbound connection using %s",s),{...await i.secureInbound(t,e),protocol:s}}catch(s){throw new Si(s.message)}}async _encryptOutbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",n);const s=await Ya(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Si(`no crypto module found for ${s}`);return t.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(t,e),protocol:s}}catch(s){throw new Si(s.message)}}async _multiplexOutbound(t,e,n){const s=Array.from(e.keys());t.log("outbound selecting muxer %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await Ya(t,s,n),o=e.get(i);if(o==null)throw new vi(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing outbound connection - %e",i),new vi(String(i))}}async _multiplexInbound(t,e,n){const s=Array.from(e.keys());t.log("inbound handling muxers %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await Xa(t,s,n),o=e.get(i);if(o==null)throw new vi(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function MS(r){return r.skipEncryption===!0}const vh="3.0.6",Sh="js-libp2p";function NS(r,t){return`${r??Sh}/${t??vh} browser/${globalThis.navigator.userAgent}`}class OS extends Ge{constructor(e){var d,h,f,p,g,y,m,S,v,E,L;super();ge(this,ss);l(this,"peerId");l(this,"peerStore");l(this,"contentRouting");l(this,"peerRouting");l(this,"metrics");l(this,"services");l(this,"logger");l(this,"status");l(this,"components");l(this,"log");this.status="stopped";const n=new Ge,s=n.dispatchEvent.bind(n);n.dispatchEvent=x=>{const _=s(x),N=this.dispatchEvent(new CustomEvent(x.type,{detail:x.detail}));return _||N},this.peerId=e.peerId,this.logger=e.logger??iu(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=e.nodeInfo)==null?void 0:d.name)??Sh,o=((h=e.nodeInfo)==null?void 0:h.version)??vh,a=this.components=wv({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:o,userAgent:((f=e.nodeInfo)==null?void 0:f.userAgent)??NS(i,o)},logger:this.logger,events:n,datastore:e.datastore??new OE,connectionGater:xv(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",LE(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),a.events.addEventListener("peer:update",x=>{if(x.detail.previous==null){const _={id:x.detail.peer.id,multiaddrs:x.detail.peer.addresses.map(N=>N.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:_})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(a)),this.components.upgrader=new kS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((x,_)=>this.configureComponent(`connection-encryption-${_}`,x(this.components))),streamMuxers:(e.streamMuxers??[]).map((x,_)=>this.configureComponent(`stream-muxers-${_}`,x(this.components))),inboundUpgradeTimeout:(p=e.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(g=e.connectionManager)==null?void 0:g.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=e.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=e.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new _S(this.components,e.transportManager)),this.configureComponent("connectionManager",new fS(this.components,e.connectionManager)),((S=e.connectionMonitor)==null?void 0:S.enabled)!==!1&&this.configureComponent("connectionMonitor",new bS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new CS(this.components)),this.configureComponent("addressManager",new nv(this.components,e.addresses));const c=(e.peerRouters??[]).map((x,_)=>this.configureComponent(`peer-router-${_}`,x(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new SS(this.components,{routers:c}));const u=(e.contentRouters??[]).map((x,_)=>this.configureComponent(`content-router-${_}`,x(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new ES(this.components,{routers:u})),this.configureComponent("randomWalk",new AS(this.components)),(e.peerDiscovery??[]).forEach((x,_)=>{this.configureComponent(`peer-discovery-${_}`,x(this.components)).addEventListener("peer",T=>{H(this,ss,vc).call(this,T)})}),(v=e.transports)==null||v.forEach((x,_)=>{this.components.transportManager.add(this.configureComponent(`transport-${_}`,x(this.components)))}),e.services!=null)for(const x of Object.keys(e.services)){const _=e.services[x],N=_(this.components);if(N==null){this.log.error("service factory %s returned null or undefined instance",x);continue}this.services[x]=N,this.configureComponent(x,N),N[ve]!=null&&(this.log("registering service %s for content routing",x),u.push(N[ve])),N[Ic]!=null&&(this.log("registering service %s for peer routing",x),c.push(N[Ic])),N[co]!=null&&(this.log("registering service %s for peer discovery",x),(L=(E=N[co]).addEventListener)==null||L.call(E,"peer",T=>{H(this,ss,vc).call(this,T)}))}bv(a)}configureComponent(e,n){return n==null&&this.log.error("component %s was null or undefined",e),this.components[e]=n,n}async start(){var e,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(e=this.components).beforeStart)==null?void 0:n.call(e)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var e,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(e=this.components).beforeStop)==null?void 0:n.call(e)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Mn;for(const n of this.components.connectionManager.getConnections())e.add(n.remotePeer);return Array.from(e)}async dial(e,n={}){return this.components.connectionManager.openConnection(e,{priority:75,...n})}async dialProtocol(e,n,s={}){if(n==null)throw new W("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new W("no protocols were provided to open a stream");return this.components.connectionManager.openStream(e,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,n={}){var s;si(e)&&(e=ct(((s=e.getComponents().findLast(i=>i.code===V))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(e,n)}async getPublicKey(e,n={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const a=await this.peerStore.get(e,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=kt([G("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=qt(i);return await this.peerStore.patch(e,{publicKey:o},n),o}async handle(e,n,s){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(e,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(e,n,s){return this.components.registrar.register(e,n,s)}unregister(e){this.components.registrar.unregister(e)}use(e,n){this.components.registrar.use(e,Array.isArray(n)?n:[n])}unuse(e){this.components.registrar.unuse(e)}async isDialable(e,n={}){return this.components.connectionManager.isDialable(e,n)}}ss=new WeakSet,vc=function(e){const{detail:n}=e;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function FS(r={}){r.privateKey??(r.privateKey=await Ew());const t=new OS({...await Tw(r),peerId:Cw(r.privateKey)});return r.start!==!1&&await t.start(),t}var Xe;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let t;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(t||(t={})),function(n){n.codec=()=>_n(t)}(r.Flag||(r.Flag={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(Xe||(Xe={}));const BS=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const $S=2*1024*1024,xh=16*1024;function US(r=xh){const t=Pe(r-Pe(r)),e=1+Pe(Object.keys(Xe.Flag).length-1),n=1,s=r-t-e-n,i=Pe(s);return t+e+n+i}const zS=US(),qS=1e4,Ah="/webrtc",Qa="/webrtc-signaling/0.0.1";function KS(r){return r.reason}async function VS(r,t,e){if(t==null)return r;const n=KS;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}var Ch=function(r,t,e){if(e||arguments.length===2)for(var n=0,s=t.length,i;n<s;n++)(i||!(n in t))&&(i||(i=Array.prototype.slice.call(t,0,n)),i[n]=t[n]);return r.concat(i||Array.prototype.slice.call(t))},WS=function(){function r(t,e,n){this.name=t,this.version=e,this.os=n,this.type="browser"}return r}(),HS=function(){function r(t){this.version=t,this.type="node",this.name="node",this.os=process.platform}return r}(),GS=function(){function r(t,e,n,s){this.name=t,this.version=e,this.os=n,this.bot=s,this.type="bot-device"}return r}(),YS=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),XS=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),QS=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,ZS=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,_h=3,JS=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",QS]],Ih=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function jS(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new XS:typeof navigator<"u"?t1(navigator.userAgent):r1()}function e1(r){return r!==""&&JS.reduce(function(t,e){var n=e[0],s=e[1];if(t)return t;var i=s.exec(r);return!!i&&[n,i]},!1)}function t1(r){var t=e1(r);if(!t)return null;var e=t[0],n=t[1];if(e==="searchbot")return new YS;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<_h&&(s=Ch(Ch([],s,!0),s1(_h-s.length),!0)):s=[];var i=s.join("."),o=n1(r),a=ZS.exec(r);return a&&a[1]?new GS(e,i,o,a[1]):new WS(e,i,o)}function n1(r){for(var t=0,e=Ih.length;t<e;t++){var n=Ih[t],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function r1(){var r=typeof process<"u"&&process.version;return r?new HS(process.version.slice(1)):null}function s1(r){for(var t=[],e=0;e<r;e++)t.push("0");return t}const Th=jS(),i1=Th!=null&&Th.name==="firefox";async function Lh(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??BS.map(t=>({urls:[t]})),r}class o1 extends Pu{constructor(e){super({...e,maxMessageSize:(e.maxMessageSize??xh)-zS});l(this,"channel");l(this,"incomingData");l(this,"maxBufferedAmount");l(this,"receivedFinAck");l(this,"finAckTimeout");this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=Zs(),this.maxBufferedAmount=e.maxBufferedAmount??$S,this.finAckTimeout=e.finAckTimeout??qS,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=s=>{const i=s.error;this.log.trace("received datachannel error event - %e",i),this.abort(i)},this.channel.onmessage=async s=>{this.log("incoming message %d bytes",s.data.byteLength);const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const s of Aa(this.incomingData))this.processIncomingProtobuf(s)}).catch(s=>{this.log.error("error processing incoming data channel messages - %e",s)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),$e(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(s=>{this.abort(s.error??s)}))}sendNewStream(){}_sendMessage(e){if(this.channel.readyState!=="open")throw new Zt(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),i1){this.channel.send(e.subarray());return}for(const n of e)this.channel.send(n)}sendData(e){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(oi.single(Xe.encode({message:e.subarray()}))),{sentBytes:e.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(e){var n;try{this.log.error("sending reset - %e",e),this._sendFlag(Xe.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(e)}catch(s){this.log.error("failed to send reset - %e",s)}}async sendCloseWrite(e){var i;this._sendFlag(Xe.Flag.FIN),(i=e==null?void 0:e.signal)==null||i.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(e==null?void 0:e.signal)??AbortSignal.timeout(this.finAckTimeout),s=[$e(this.channel,"close",{signal:n}),$e(this.channel,"error",{signal:n})];await Promise.any([VS(this.receivedFinAck.promise,n),...s]).finally(()=>{s.forEach(o=>o.cancel())})}async sendCloseRead(e){var n;this._sendFlag(Xe.Flag.STOP_SENDING),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}processIncomingProtobuf(e){var s,i;const n=Xe.decode(e);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new Q(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===Xe.Flag.FIN&&(this._sendFlag(Xe.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===Xe.Flag.RESET&&((s=this.receivedFinAck)==null||s.reject(new no("The stream was reset")),this.onRemoteReset()),n.flag===Xe.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===Xe.Flag.FIN_ACK&&((i=this.receivedFinAck)==null||i.resolve()))}_sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const n=Xe.encode({flag:e}),s=oi.single(n);try{return this._sendMessage(s),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}sendPause(){}sendResume(){}}function Dh(r){const{channel:t,direction:e,isHandshake:n}=r;return new o1({...r,id:`${t.id}`,log:r.log.newScope(`${n===!0?"handshake":e}:${t.id}`),protocol:""})}class Ph{constructor(t){l(this,"protocol");l(this,"peerConnection");l(this,"metrics");l(this,"dataChannelOptions");l(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??Ah,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(t){this.earlyDataChannels.push(t.channel)}createStreamMuxer(t){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new a1(t,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class a1 extends Du{constructor(e,n){super(e,{...n,name:"muxer"});l(this,"peerConnection");l(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??Ah,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:s})=>{this.onDataChannel(s)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(s=>{s.close()});return}n.earlyDataChannels.forEach(s=>{this.onDataChannel(s)})})}onDataChannel(e){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",e.id,e.protocol,e.readyState),e.label==="init"){this.log.trace("closing init channel %d",e.id),e.close();return}const n=Dh({...this.streamOptions,...this.dataChannelOptions,channel:e,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(e){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,e==null?void 0:e.protocol),Dh({...e,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class c1 extends Lu{constructor(e){super(e);l(this,"peerConnection");this.peerConnection=e.peerConnection;const n=e.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(e){return{sentBytes:e.byteLength,canSendMore:!0}}async sendClose(e){var n;this.peerConnection.close(),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const Rh=r=>new c1(r),kh=globalThis.RTCPeerConnection,Mh=globalThis.RTCSessionDescription,l1=globalThis.RTCIceCandidate;class u1 extends Error{constructor(t){super(`WebRTC transport error: ${t}`),this.name="WebRTCTransportError"}}class Vt extends u1{constructor(t="SDP handshake failed"){super(t),this.name="SDPHandshakeFailedError"}}var ut;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let t;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(t||(t={})),function(n){n.codec=()=>_n(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(ut||(ut={}));const Nh=async(r,t,e)=>{var n,s,i,o;try{const a=Promise.withResolvers();for(d1(r,a);;){const c=await Promise.race([a.promise,t.read({signal:e.signal})]);if(c==null){(n=e.signal)==null||n.throwIfAborted();break}if(c.type!==ut.Type.ICE_CANDIDATE)throw new ot("ICE candidate message expected");const u=JSON.parse(c.data??"null");if(u===""||u===null){(s=e.onProgress)==null||s.call(e,new he("webrtc:end-of-ice-candidates")),e.log.trace("end-of-candidates received");continue}const d=new l1(u);e.log.trace("%s received new ICE candidate %o",e.direction,u);try{(i=e.onProgress)==null||i.call(e,new he("webrtc:add-ice-candidate",d.candidate)),await r.addIceCandidate(d)}catch(h){e.log.error("%s bad candidate received %o - %e",e.direction,u,h)}}}catch(a){if(e.log.error("%s error parsing ICE candidate - %e",e.direction,a),((o=e.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function d1(r,t){if(r.connectionState==="connected"){t.resolve();return}r.onconnectionstatechange=e=>{switch(r.connectionState){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new Sc(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function Oh(r){let t;for(const e of r.getComponents())e.name==="p2p"&&(t=ct(e.value??""));if(t==null)throw new ds("Remote peerId must be present in multiaddr");return t}async function h1({rtcConfiguration:r,dataChannel:t,signal:e,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:d,targetPeer:h}=m1(s);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",d);const f=i.getConnections(h);let p;f.length===0?(u==null||u(new he("webrtc:dial-relay")),p=await o.dial(d,{signal:e,onProgress:u})):(u==null||u(new he("webrtc:reuse-relay-connection")),p=f[0]),u==null||u(new he("webrtc:open-signaling-stream"));const g=await p.newStream(Qa,{signal:e,runOnLimitedConnection:!0}),y=un(g).pb(ut),m=new kh(r);m.addEventListener("connectionstatechange",()=>{switch(m.connectionState){case"closed":m.close();break}});const S=new Ph({peerConnection:m,dataChannelOptions:t});try{const v=m.createDataChannel("init");m.onicecandidate=({candidate:_})=>{if(m.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(_==null||(_==null?void 0:_.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const N=JSON.stringify((_==null?void 0:_.toJSON())??null);a.trace("initiator sending ICE candidate %o",_),y.write({type:ut.Type.ICE_CANDIDATE,data:N},{signal:e}).catch(T=>{a.error("error sending ICE candidate - %e",T)})},m.onicecandidateerror=_=>{a.error("initiator ICE candidate error",_)};const E=await m.createOffer().catch(_=>{throw a.error("could not execute createOffer - %e",_),new Vt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",E.sdp),u==null||u(new he("webrtc:send-sdp-offer")),await y.write({type:ut.Type.SDP_OFFER,data:E.sdp},{signal:e}),await m.setLocalDescription(E).catch(_=>{throw a.error("could not execute setLocalDescription - %e",_),new Vt("Failed to set localDescription")}),u==null||u(new he("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await y.read({signal:e});if(L.type!==ut.Type.SDP_ANSWER)throw new Vt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const x=new Mh({type:"answer",sdp:L.data});return await m.setRemoteDescription(x).catch(_=>{throw a.error("could not execute setRemoteDescription - %e",_),new Vt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u==null||u(new he("webrtc:read-ice-candidates")),await Nh(m,y,{direction:"initiator",signal:e,log:a,onProgress:u}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await $e(v,"open",{signal:e})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await $e(v,"close",{signal:e}),u==null||u(new he("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:e}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:m,muxerFactory:S}}catch(v){throw a.error("outgoing signaling error - %e",v),m.close(),g.abort(v),v}finally{m.onicecandidate=null,m.onicecandidateerror=null}}const Fh=de(Ua.matchers[0],ue(Kn));class Za extends Ge{constructor(e,n){super();l(this,"transportManager");l(this,"shutdownController");l(this,"events");this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(s=>Fh.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof Za)).map(e=>e.getAddrs().filter(n=>Fh.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function f1(r,t,{peerConnection:e,signal:n,log:s}){s.trace("new inbound signaling stream");const i=un(r).pb(ut);try{e.onicecandidate=({candidate:h})=>{if(e.connectionState==="connected"){s.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){s.trace("recipient detected end of ICE candidates");return}const f=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",f),i.write({type:ut.Type.ICE_CANDIDATE,data:f},{signal:n}).catch(p=>{s.error("error sending ICE candidate - %e",p)})},s.trace("recipient read SDP offer");const c=await i.read({signal:n});if(c.type!==ut.Type.SDP_OFFER)throw new Vt(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);s.trace("recipient received SDP offer %s",c.data);const u=new Mh({type:"offer",sdp:c.data});await e.setRemoteDescription(u).catch(h=>{throw s.error("could not execute setRemoteDescription - %e",h),new Vt("Failed to set remoteDescription")});const d=await e.createAnswer().catch(h=>{throw s.error("could not execute createAnswer - %e",h),new Vt("Failed to create answer")});s.trace("recipient send SDP answer %s",d.sdp),await i.write({type:ut.Type.SDP_ANSWER,data:d.sdp},{signal:n}),await e.setLocalDescription(d).catch(h=>{throw s.error("could not execute setLocalDescription - %e",h),new Vt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await Nh(e,i,{direction:"recipient",signal:n,log:s})}catch(c){if(e.connectionState!=="connected")throw s.error("error while handling signaling stream from peer %a - %e",t.remoteAddr,c),e.close(),c;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",t.remoteAddr,c)}const o=Oh(t.remoteAddr),a=X(`/webrtc/p2p/${o}`);return s.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}sg=Dc,rg=Symbol.toStringTag,ng=bt,tg=ps;class g1{constructor(t,e={}){l(this,"components");l(this,"init");l(this,"log");l(this,"_started",!1);l(this,"metrics");l(this,"shutdownController");l(this,sg,!0);l(this,rg,"@libp2p/webrtc");l(this,ng,["@libp2p/transport"]);l(this,tg,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=t,this.init=e,this.log=t.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(Qa,(t,e)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(t,e,n).catch(s=>{this.log.error("failed to handle incoming connect from %p - %e",e.remotePeer,s)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Qa),this._started=!1}createListener(t){return new Za(this.components,{shutdownController:this.shutdownController})}listenFilter(t){return t.filter(za.exactMatch)}dialFilter(t){return this.listenFilter(t)}async dial(t,e){var c;this.log.trace("dialing address: %a",t);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await h1({rtcConfiguration:await Lh(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:t,dataChannelOptions:this.init.dataChannel,signal:e.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:e.onProgress}),o=Rh({peerConnection:s,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await e.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:Oh(t),muxerFactory:i,onProgress:e.onProgress,signal:e.signal});return this._closeOnShutdown(s,o),a}async _onProtocol(t,e,n){var o;const s=new kh(await Lh(this.init.rtcConfiguration));s.addEventListener("connectionstatechange",()=>{switch(s.connectionState){case"closed":s.close();break}});const i=new Ph({peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await f1(t,e,{peerConnection:s,signal:n,log:this.log});await t.close({signal:n});const u=Rh({peerConnection:s,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(u,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:i,signal:n}),this._closeOnShutdown(s,u)}catch(a){throw this.log.error("incoming signaling error - %e",a),s.close(),t.abort(a),a}}_closeOnShutdown(t,e){const n=()=>{e.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",s)})};this.shutdownController.signal.addEventListener("abort",n),t.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function m1(r){const t=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(t==null)throw new W("Destination peer id was missing");return{circuitAddress:X(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:ct(t)}}const Xr=65535,Bh=Xr-16,Qr=!!((og=(ig=globalThis.process)==null?void 0:ig.env)!=null&&og.DUMP_SESSION_KEYS),$h=16;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function p1(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ja(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function ja(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ve(r,t,e=""){const n=p1(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Uh(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function y1(r,t){Ve(r,void 0,"output");const e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Wt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function Xn(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function w1(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const b1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function E1(r,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(r,t)}function v1(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}const S1=(r,t)=>{function e(n,...s){if(Ve(n,void 0,"key"),!b1)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const d=s[0];Ve(d,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const i=r.tagLength;i&&s[1]!==void 0&&Ve(s[1],void 0,"AAD");const o=t(n,...s),a=(d,h)=>{if(h!==void 0){if(d!==2)throw new Error("cipher output not supported");Ve(h,void 0,"output")}};let c=!1;return{encrypt(d,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ve(d),a(o.encrypt.length,h),o.encrypt(d,h)},decrypt(d,h){if(Ve(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return a(o.decrypt.length,h),o.decrypt(d,h)}}}return Object.assign(e,r),e};function zh(r,t,e=!0){if(t===void 0)return new Uint8Array(r);if(t.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+t.length);if(e&&!A1(t))throw new Error("invalid output, must be aligned");return t}function x1(r,t,e){Ja(e);const n=new Uint8Array(16),s=w1(n);return s.setBigUint64(0,BigInt(t),e),s.setBigUint64(8,BigInt(r),e),n}function A1(r){return r.byteOffset%4===0}function _i(r){return Uint8Array.from(r)}const qh=r=>Uint8Array.from(r.split(""),t=>t.charCodeAt(0)),C1=qh("expand 16-byte k"),_1=qh("expand 32-byte k"),I1=Wt(C1),T1=Wt(_1);function ee(r,t){return r<<t|r>>>32-t}function tc(r){return r.byteOffset%4===0}const Ii=64,L1=16,Kh=2**32-1,Vh=Uint32Array.of();function D1(r,t,e,n,s,i,o,a){const c=s.length,u=new Uint8Array(Ii),d=Wt(u),h=tc(s)&&tc(i),f=h?Wt(s):Vh,p=h?Wt(i):Vh;for(let g=0;g<c;o++){if(r(t,e,n,d,o,a),o>=Kh)throw new Error("arx: counter overflow");const y=Math.min(Ii,c-g);if(h&&y===Ii){const m=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let S=0,v;S<L1;S++)v=m+S,p[v]=f[v]^d[S];g+=Ii;continue}for(let m=0,S;m<y;m++)S=g+m,i[S]=s[S]^u[m];g+=y}}function P1(r,t){const{allowShortKeys:e,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=E1({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof r!="function")throw new Error("core must be a function");return ja(s),ja(o),Ja(i),Ja(e),(a,c,u,d,h=0)=>{Ve(a,void 0,"key"),Ve(c,void 0,"nonce"),Ve(u,void 0,"data");const f=u.length;if(d===void 0&&(d=new Uint8Array(f)),Ve(d,void 0,"output"),ja(h),h<0||h>=Kh)throw new Error("arx: counter overflow");if(d.length<f)throw new Error(`arx: output (${d.length}) is shorter than data (${f})`);const p=[];let g=a.length,y,m;if(g===32)p.push(y=_i(a)),m=T1;else if(g===16&&e)y=new Uint8Array(32),y.set(a),y.set(a,16),m=I1,p.push(y);else throw Ve(a,32,"arx key"),new Error("invalid key size");tc(c)||p.push(c=_i(c));const S=Wt(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,S,Wt(c.subarray(0,16)),S),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const E=Wt(c);return D1(r,m,S,E,u,d,h,o),Xn(...p),d}}function ke(r,t){return r[t++]&255|(r[t++]&255)<<8}class R1{constructor(t){l(this,"blockLen",16);l(this,"outputLen",16);l(this,"buffer",new Uint8Array(16));l(this,"r",new Uint16Array(10));l(this,"h",new Uint16Array(10));l(this,"pad",new Uint16Array(8));l(this,"pos",0);l(this,"finished",!1);t=_i(Ve(t,32,"key"));const e=ke(t,0),n=ke(t,2),s=ke(t,4),i=ke(t,6),o=ke(t,8),a=ke(t,10),c=ke(t,12),u=ke(t,14);this.r[0]=e&8191,this.r[1]=(e>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=ke(t,16+2*d)}process(t,e,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],d=o[3],h=o[4],f=o[5],p=o[6],g=o[7],y=o[8],m=o[9],S=ke(t,e+0),v=ke(t,e+2),E=ke(t,e+4),L=ke(t,e+6),x=ke(t,e+8),_=ke(t,e+10),N=ke(t,e+12),T=ke(t,e+14);let I=i[0]+(S&8191),B=i[1]+((S>>>13|v<<3)&8191),U=i[2]+((v>>>10|E<<6)&8191),k=i[3]+((E>>>7|L<<9)&8191),M=i[4]+((L>>>4|x<<12)&8191),w=i[5]+(x>>>1&8191),b=i[6]+((x>>>14|_<<2)&8191),C=i[7]+((_>>>11|N<<5)&8191),D=i[8]+((N>>>8|T<<8)&8191),R=i[9]+(T>>>5|s),A=0,O=A+I*a+B*(5*m)+U*(5*y)+k*(5*g)+M*(5*p);A=O>>>13,O&=8191,O+=w*(5*f)+b*(5*h)+C*(5*d)+D*(5*u)+R*(5*c),A+=O>>>13,O&=8191;let P=A+I*c+B*a+U*(5*m)+k*(5*y)+M*(5*g);A=P>>>13,P&=8191,P+=w*(5*p)+b*(5*f)+C*(5*h)+D*(5*d)+R*(5*u),A+=P>>>13,P&=8191;let F=A+I*u+B*c+U*a+k*(5*m)+M*(5*y);A=F>>>13,F&=8191,F+=w*(5*g)+b*(5*p)+C*(5*f)+D*(5*h)+R*(5*d),A+=F>>>13,F&=8191;let z=A+I*d+B*u+U*c+k*a+M*(5*m);A=z>>>13,z&=8191,z+=w*(5*y)+b*(5*g)+C*(5*p)+D*(5*f)+R*(5*h),A+=z>>>13,z&=8191;let re=A+I*h+B*d+U*u+k*c+M*a;A=re>>>13,re&=8191,re+=w*(5*m)+b*(5*y)+C*(5*g)+D*(5*p)+R*(5*f),A+=re>>>13,re&=8191;let j=A+I*f+B*h+U*d+k*u+M*c;A=j>>>13,j&=8191,j+=w*a+b*(5*m)+C*(5*y)+D*(5*g)+R*(5*p),A+=j>>>13,j&=8191;let K=A+I*p+B*f+U*h+k*d+M*u;A=K>>>13,K&=8191,K+=w*c+b*a+C*(5*m)+D*(5*y)+R*(5*g),A+=K>>>13,K&=8191;let ce=A+I*g+B*p+U*f+k*h+M*d;A=ce>>>13,ce&=8191,ce+=w*u+b*c+C*a+D*(5*m)+R*(5*y),A+=ce>>>13,ce&=8191;let fe=A+I*y+B*g+U*p+k*f+M*h;A=fe>>>13,fe&=8191,fe+=w*d+b*u+C*c+D*a+R*(5*m),A+=fe>>>13,fe&=8191;let Ee=A+I*m+B*y+U*g+k*p+M*f;A=Ee>>>13,Ee&=8191,Ee+=w*h+b*d+C*u+D*c+R*a,A+=Ee>>>13,Ee&=8191,A=(A<<2)+A|0,A=A+O|0,O=A&8191,A=A>>>13,P+=A,i[0]=O,i[1]=P,i[2]=F,i[3]=z,i[4]=re,i[5]=j,i[6]=K,i[7]=ce,i[8]=fe,i[9]=Ee}finalize(){const{h:t,pad:e}=this,n=new Uint16Array(10);let s=t[1]>>>13;t[1]&=8191;for(let a=2;a<10;a++)t[a]+=s,s=t[a]>>>13,t[a]&=8191;t[0]+=s*5,s=t[0]>>>13,t[0]&=8191,t[1]+=s,s=t[1]>>>13,t[1]&=8191,t[2]+=s,n[0]=t[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=t[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)t[a]=t[a]&i|n[a];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let o=t[0]+e[0];t[0]=o&65535;for(let a=1;a<8;a++)o=(t[a]+e[a]|0)+(o>>>16)|0,t[a]=o&65535;Xn(n)}update(t){Uh(this),Ve(t),t=_i(t);const{buffer:e,blockLen:n}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(t,i);continue}e.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(e,0,!1),this.pos=0)}return this}destroy(){Xn(this.h,this.r,this.buffer,this.pad)}digestInto(t){Uh(this),y1(t,this),this.finished=!0;const{buffer:e,h:n}=this;let{pos:s}=this;if(s){for(e[s++]=1;s<16;s++)e[s]=0;this.process(e,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)t[i++]=n[o]>>>0,t[i++]=n[o]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}}function k1(r){const t=(n,s)=>r(s).update(n).digest(),e=r(new Uint8Array(32));return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=n=>r(n),t}const M1=k1(r=>new R1(r));function N1(r,t,e,n,s,i=20){let o=r[0],a=r[1],c=r[2],u=r[3],d=t[0],h=t[1],f=t[2],p=t[3],g=t[4],y=t[5],m=t[6],S=t[7],v=s,E=e[0],L=e[1],x=e[2],_=o,N=a,T=c,I=u,B=d,U=h,k=f,M=p,w=g,b=y,C=m,D=S,R=v,A=E,O=L,P=x;for(let z=0;z<i;z+=2)_=_+B|0,R=ee(R^_,16),w=w+R|0,B=ee(B^w,12),_=_+B|0,R=ee(R^_,8),w=w+R|0,B=ee(B^w,7),N=N+U|0,A=ee(A^N,16),b=b+A|0,U=ee(U^b,12),N=N+U|0,A=ee(A^N,8),b=b+A|0,U=ee(U^b,7),T=T+k|0,O=ee(O^T,16),C=C+O|0,k=ee(k^C,12),T=T+k|0,O=ee(O^T,8),C=C+O|0,k=ee(k^C,7),I=I+M|0,P=ee(P^I,16),D=D+P|0,M=ee(M^D,12),I=I+M|0,P=ee(P^I,8),D=D+P|0,M=ee(M^D,7),_=_+U|0,P=ee(P^_,16),C=C+P|0,U=ee(U^C,12),_=_+U|0,P=ee(P^_,8),C=C+P|0,U=ee(U^C,7),N=N+k|0,R=ee(R^N,16),D=D+R|0,k=ee(k^D,12),N=N+k|0,R=ee(R^N,8),D=D+R|0,k=ee(k^D,7),T=T+M|0,A=ee(A^T,16),w=w+A|0,M=ee(M^w,12),T=T+M|0,A=ee(A^T,8),w=w+A|0,M=ee(M^w,7),I=I+B|0,O=ee(O^I,16),b=b+O|0,B=ee(B^b,12),I=I+B|0,O=ee(O^I,8),b=b+O|0,B=ee(B^b,7);let F=0;n[F++]=o+_|0,n[F++]=a+N|0,n[F++]=c+T|0,n[F++]=u+I|0,n[F++]=d+B|0,n[F++]=h+U|0,n[F++]=f+k|0,n[F++]=p+M|0,n[F++]=g+w|0,n[F++]=y+b|0,n[F++]=m+C|0,n[F++]=S+D|0,n[F++]=v+R|0,n[F++]=E+A|0,n[F++]=L+O|0,n[F++]=x+P|0}const O1=P1(N1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),F1=new Uint8Array(16),Wh=(r,t)=>{r.update(t);const e=t.length%16;e&&r.update(F1.subarray(e))},B1=new Uint8Array(32);function Hh(r,t,e,n,s){s!==void 0&&Ve(s,void 0,"AAD");const i=r(t,e,B1),o=x1(n.length,s?s.length:0,!0),a=M1.create(i);s&&Wh(a,s),Wh(a,n),a.update(o);const c=a.digest();return Xn(i,o),c}const Gh=S1({blockSize:64,nonceLength:12,tagLength:16},(r=>(t,e,n)=>({encrypt(i,o){const a=i.length;o=zh(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(t,e,c,c,1);const u=Hh(r,t,e,c,n);return o.set(u,a),Xn(u),o},decrypt(i,o){o=zh(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Hh(r,t,e,a,n);if(!v1(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(t,e,o,o,1),Xn(u),o}}))(O1));function $1(r,t,e){return Is(r),e===void 0&&(e=new Uint8Array(r.outputLen)),Hs(r,e,t)}const nc=Uint8Array.of(0),Yh=Uint8Array.of();function U1(r,t,e,n=32){Is(r),Mt(n,"length");const s=r.outputLen;if(n>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(n/s);e===void 0?e=Yh:Y(e,void 0,"info");const o=new Uint8Array(i*s),a=Hs.create(r,t),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let d=0;d<i;d++)nc[0]=d+1,c.update(d===0?Yh:u).update(e).update(nc).digestInto(u),o.set(u,s*d),a._cloneInto(c);return a.destroy(),c.destroy(),Jt(u,nc),o.slice(0,n)}const z1={hashSHA256(r){return xr(r.subarray())},getHKDF(r,t){const e=$1(xr,t,r),s=U1(xr,e,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=zs.utils.randomSecretKey();return{publicKey:zs.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:zs.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,t){return zs.getSharedSecret(r.subarray(),t.subarray())},chaCha20Poly1305Encrypt(r,t,e,n){return Gh(n,t,e).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,t,e,n,s){return Gh(n,t,e).decrypt(r.subarray(),s)}};function q1(r){return{generateKeypair:r.generateX25519KeyPair,dh:(t,e)=>r.generateX25519SharedKey(t.privateKey,e).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const Ti=r=>{const t=gt(2);return t[0]=r>>8,t[1]=r,t};Ti.bytes=2;const Li=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let t=0;return t+=r[0]<<8,t+=r[1],t}return r.getUint16(0)};Li.bytes=2;function K1(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function Xh(r,t){!t.enabled||!Qr||(r?(t(`LOCAL_STATIC_PUBLIC_KEY ${Z(r.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${Z(r.privateKey,"hex")}`)):t("Missing local static keys."))}function Qh(r,t){!t.enabled||!Qr||(r?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Z(r.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Z(r.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function V1(r,t){!t.enabled||!Qr||t(r?`REMOTE_STATIC_PUBLIC_KEY ${Z(r.subarray(),"hex")}`:"Missing remote static public key.")}function Zh(r,t){!t.enabled||!Qr||t(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Z(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function Jh(r,t,e){!e.enabled||!Qr||(e(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&Z(r.k,"hex")}`),e(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&Z(t.k,"hex")}`))}const Hi=class Hi extends Error{constructor(e="Invalid crypto exchange"){super(e);l(this,"code");this.code=Hi.code}};l(Hi,"code","ERR_INVALID_CRYPTO_EXCHANGE");let Zr=Hi;const W1=0,H1=4294967295,G1="Cipherstate has reached maximum n, a new handshake must be performed";class Y1{constructor(t=W1){l(this,"n");l(this,"bytes");l(this,"view");this.n=t,this.bytes=ae(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>H1)throw new Error(G1)}}const Qn=ae(0);class Di{constructor(t,e=void 0,n=0){l(this,"k");l(this,"n");l(this,"crypto");this.crypto=t,this.k=e,this.n=new Y1(n)}hasKey(){return!!this.k}encryptWithAd(t,e){if(!this.hasKey())return e;this.n.assertValue();const n=this.crypto.encrypt(e,this.n.getBytes(),t,this.k);return this.n.increment(),n}decryptWithAd(t,e,n){if(!this.hasKey())return e;this.n.assertValue();const s=this.crypto.decrypt(e,this.n.getBytes(),t,this.k,n);return this.n.increment(),s}}class X1{constructor(t,e){l(this,"cs");l(this,"ck");l(this,"h");l(this,"crypto");this.crypto=t;const n=G(e,"utf-8");this.h=Z1(t,n),this.ck=this.h,this.cs=new Di(t)}mixKey(t){const[e,n]=this.crypto.hkdf(this.ck,t);this.ck=e,this.cs=new Di(this.crypto,n)}mixHash(t){this.h=this.crypto.hash(new Q(this.h,t))}encryptAndHash(t){const e=this.cs.encryptWithAd(this.h,t);return this.mixHash(e),e}decryptAndHash(t){const e=this.cs.decryptWithAd(this.h,t);return this.mixHash(t),e}split(){const[t,e]=this.crypto.hkdf(this.ck,Qn);return[new Di(this.crypto,t),new Di(this.crypto,e)]}}class Q1{constructor(t){l(this,"ss");l(this,"s");l(this,"e");l(this,"rs");l(this,"re");l(this,"initiator");l(this,"crypto");const{crypto:e,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=t;this.crypto=e,this.ss=new X1(e,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const t=this.crypto.generateKeypair();return this.ss.mixHash(t.publicKey),this.e=t,t.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(t,e=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(t.byteLength<e+32)throw new Error("message is not long enough");this.re=t.sublist(e,e+32),this.ss.mixHash(this.re)}readS(t,e=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(t.byteLength<e+n)throw new Error("message is not long enough");const s=t.sublist(e,e+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class jh extends Q1{writeMessageA(t){return new Q(this.writeE(),this.ss.encryptAndHash(t))}writeMessageB(t){const e=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new Q(e,n,this.ss.encryptAndHash(t))}writeMessageC(t){const e=this.writeS();return this.writeSE(),new Q(e,this.ss.encryptAndHash(t))}readMessageA(t){try{return this.readE(t),this.ss.decryptAndHash(t.sublist(32))}catch(e){throw new Zr(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(t){try{this.readE(t),this.readEE();const e=this.readS(t,32);return this.readES(),this.ss.decryptAndHash(t.sublist(32+e))}catch(e){throw new Zr(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(t){try{const e=this.readS(t);return this.readSE(),this.ss.decryptAndHash(t.sublist(e))}catch(e){throw new Zr(`handshake stage 2 validation fail: ${e.message}`)}}}function Z1(r,t){if(t.length<=32){const e=ae(32);return e.set(t),e}else return r.hash(t)}var Pi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.webtransportCerthashes!=null)for(const i of e.webtransportCerthashes)n.uint32(10),n.bytes(i);if(e.streamMuxers!=null)for(const i of e.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new St('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(e.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new St('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(e.string());break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Pi||(Pi={}));var Ri;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.identityKey!=null&&e.identityKey.byteLength>0&&(n.uint32(10),n.bytes(e.identityKey)),e.identitySig!=null&&e.identitySig.byteLength>0&&(n.uint32(18),n.bytes(e.identitySig)),e.extensions!=null&&(n.uint32(34),Pi.codec().encode(e.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={identityKey:ae(0),identitySig:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.identityKey=e.bytes();break}case 2:{i.identitySig=e.bytes();break}case 4:{i.extensions=Pi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Ri||(Ri={}));async function ef(r,t,e){const n=await r.sign(nf(t));return Ri.encode({identityKey:At(r.publicKey),identitySig:n,extensions:e})}async function tf(r,t,e){try{const n=Ri.decode(r),s=qt(n.identityKey);if((e==null?void 0:e.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${e}`);if(!t)throw new Error("Remote static does not exist");const i=nf(t);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new ls(n.message)}}function nf(r){const t=G("noise-libp2p-static-key:");return r instanceof Uint8Array?kt([t,r],t.length+r.length):(r.prepend(t),r)}class J1 extends da{constructor(e,n,s){super({log:e.log,inactivityTimeout:e.inactivityTimeout,maxReadBufferLength:e.maxReadBufferLength,direction:e.direction});l(this,"stream");l(this,"handshake");l(this,"metrics");l(this,"decoder");this.stream=e,this.handshake=n,this.metrics=s,this.decoder=new O0({lengthDecoder:Li,maxBufferSize:16*1024*1024,encodingLength:()=>2});const i=u=>{try{for(const d of this.decoder.decode(u.data))this.onData(this.decrypt(d))}catch(d){this.abort(d)}};this.stream.addEventListener("message",i);const o=u=>{u.error!=null?u.local===!0?this.abort(u.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(e){var s;const n=new Q;for(let i=0;i<e.byteLength;i+=Bh){let o=i+Bh;o>e.byteLength&&(o=e.byteLength);let a;e instanceof Uint8Array?a=this.handshake.encrypt(e.subarray(i,o)):a=this.handshake.encrypt(e.sublist(i,o)),(s=this.metrics)==null||s.encryptedPackets.increment(),n.append(Ti(a.byteLength)),n.append(a)}return n}decrypt(e){var s,i;const n=new Q;for(let o=0;o<e.byteLength;o+=Xr){let a=o+Xr;if(a>e.byteLength&&(a=e.byteLength),a-$h<o)throw new Error("Invalid chunk");let c;e instanceof Uint8Array?c=e.subarray(o,a):c=e.sublist(o,a);const u=e.subarray(o,a-$h);try{const d=this.handshake.decrypt(c,u);(s=this.metrics)==null||s.decryptedPackets.increment(),n.append(d)}catch(d){throw(i=this.metrics)==null||i.decryptErrors.increment(),d}}return n}close(e){return this.stream.close(e)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(e){this.stream.abort(e)}sendData(e){return{sentBytes:e.byteLength,canSendMore:this.stream.send(this.encrypt(e))}}}function rf(r,t,e){return new J1(r,t,e)}async function j1(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await ef(i,a.publicKey,u),h=new jh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});Xh(h.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(Qn),t),e.trace("Stage 0 - Initiator finished sending first message."),Qh(h.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=h.readMessageB(await n.read(t));e.trace("Stage 1 - Initiator received the message."),Zh(h.re,e),V1(h.rs,e),e.trace("Initiator going to check remote's signature...");const p=await tf(f,h.rs,c);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(d),t),e.trace("Stage 2 - Initiator sent message with signed payload.");const[g,y]=h.ss.split();return Jh(g,y,e),{payload:p,encrypt:m=>g.encryptWithAd(Qn,m),decrypt:(m,S)=>y.decryptWithAd(Qn,m,S)}}async function ex(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await ef(i,a.publicKey,u),h=new jh({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});Xh(h.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),e.trace("Stage 0 - Responder received first message."),Zh(h.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(d),t),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),Qh(h.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const f=h.readMessageC(await n.read(t));e.trace("Stage 2 - Responder received the message, finished handshake.");const p=await tf(f,h.rs,c),[g,y]=h.ss.split();return Jh(g,y,e),{payload:p,encrypt:m=>y.encryptWithAd(Qn,m),decrypt:(m,S)=>g.decryptWithAd(Qn,m,S)}}cg=Symbol.toStringTag,ag=bt;class tx{constructor(t,e={}){l(this,"protocol","/noise");l(this,"crypto");l(this,"prologue");l(this,"staticKey");l(this,"extensions");l(this,"metrics");l(this,"components");l(this,"log");l(this,cg,"@chainsafe/libp2p-noise");l(this,ag,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=e,{metrics:a}=t;this.components=t,this.log=t.logger.forComponent("libp2p:noise");const c=i??z1;this.crypto=q1(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?K1(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ae(0)}async secureOutbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=Vr(t,{lengthEncoder:Ti,lengthDecoder:Li,maxDataLength:Xr}),i=await this.performHandshakeInitiator(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=qt(i.payload.identityKey);return{connection:rf(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:Rr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}getStreamMuxer(t){if(t==null||t.length===0)return;const e=this.components.upgrader.getStreamMuxers();if(e!=null)for(const n of t){const s=e.get(n);if(s!=null)return s}if(t.length)throw new Rg("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=Vr(t,{lengthEncoder:Ti,lengthDecoder:Li,maxDataLength:Xr}),i=await this.performHandshakeResponder(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=qt(i.payload.identityKey);return{connection:rf(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:Rr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}async performHandshakeInitiator(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await j1({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}async performHandshakeResponder(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await ex({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}}function nx(r={}){return t=>new tx(t,r)}function rx(r){return t=>new g1(t,r)}function sx(r){return r.reason}async function sf(r,t,e){if(t==null)return r;const n=sx;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}var _e;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(_e||(_e={}));var oe;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(oe||(oe={})),Object.values(oe).filter(r=>typeof r!="string");const ix=0;var tt;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(tt||(tt={}));const yn=12;class Jr extends Error{constructor(e,n){super(e);l(this,"reason");this.name="ProtocolError",this.reason=n}}l(Jr,"name","ProtocolError");function ox(r){return(r==null?void 0:r.reason)!==null}class wn extends Jr{constructor(t="The frame was invalid"){super(t,tt.ProtocolError),this.name="InvalidFrameError"}}l(wn,"name","InvalidFrameError");class of extends Jr{constructor(t="Un-requested ping error"){super(t,tt.ProtocolError),this.name="UnRequestedPingError"}}l(of,"name","UnRequestedPingError");class af extends Jr{constructor(t="Not matching ping error"){super(t,tt.ProtocolError),this.name="NotMatchingPingError"}}l(af,"name","NotMatchingPingError");class cf extends Jr{constructor(t="Receive window exceeded"){super(t,tt.ProtocolError),this.name="ReceiveWindowExceededError"}}l(cf,"name","ReceiveWindowExceededError");const lf=256*1024,ax=16*1024*1024,ki={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function cx(r){var t,e,n,s,i,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new W("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new W("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new W("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new W("MaxMessageSize must be greater than a kilobyte");if(((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)!=null&&((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)<lf)throw new W("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.initialStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new W("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new W("MaxStreamWindowSize must be less than equal MAX_UINT32")}function lx(r){return r.header.type===_e.Data&&r.data!==null}const uf=2**24;function ux(r){if(r[0]!==ix)throw new wn("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*uf+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*uf+(r[9]<<16)+(r[10]<<8)+r[11]}}class dx{constructor(){l(this,"buffer");this.buffer=new Q}*emitFrames(t){for(this.buffer.append(t);;){const e=this.readFrame();if(e===void 0)break;yield e}}readFrame(){let t=yn;if(this.buffer.byteLength<yn)return;const e=ux(this.buffer.subarray(0,yn));if(e.type===_e.Data){if(t+=e.length,this.buffer.byteLength<t)return;const n=this.buffer.sublist(yn,t);return this.buffer.consume(t),{header:e,data:n}}return this.buffer.consume(t),{header:e}}}function df(r){const t=new Uint8Array(yn);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var Qe;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(Qe||(Qe={}));class hx extends Pu{constructor(e){const n=e.initialStreamWindowSize??lf;super({...e,maxMessageSize:n-yn});l(this,"streamId");l(this,"state");l(this,"sendWindowCapacity");l(this,"recvWindow");l(this,"recvWindowCapacity");l(this,"maxStreamWindowSize");l(this,"epochStart");l(this,"getRTT");l(this,"sendFrame");this.streamId=e.streamId,this.state=e.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=e.maxStreamWindowSize??ax,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame;const s=()=>{this.state=Qe.Finished};this.addEventListener("close",s)}sendData(e){var o,a;const n=e.byteLength;let s=0,i=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);e.byteLength>0;){if(this.sendWindowCapacity===0){i=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",s,n);break}const c=Math.min(this.sendWindowCapacity,e.byteLength),u=this.getSendFlags(),d=e.sublist(0,c);e.consume(c);const h=this.sendFrame({type:_e.Data,flag:u,streamID:this.streamId,length:c},d);if(this.sendWindowCapacity-=c,s+=c,!h){i=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",s,n);break}}return{sentBytes:s,canSendMore:i}}async sendReset(){this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|oe.FIN;this.sendFrame({type:_e.WindowUpdate,flag:e,streamID:this.streamId,length:0})}async sendCloseRead(e){var n;(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendPause(){this.state=Qe.Paused}sendResume(){this.state=Qe.Established,this.sendWindowUpdate()}handleWindowUpdate(e){var n;this.processFlags(e.header.flag),this.sendWindowCapacity+=e.header.length,this.maxMessageSize=this.sendWindowCapacity-yn,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",e.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(e){if(!lx(e))throw new wn("Frame was not data frame");if(this.processFlags(e.header.flag),this.recvWindowCapacity<e.header.length)throw new cf("Receive window exceeded");this.recvWindowCapacity-=e.header.length,this.onData(e.data),this.sendWindowUpdate()}processFlags(e){(e&oe.ACK)===oe.ACK&&this.state===Qe.SYNSent&&(this.state=Qe.Established),(e&oe.FIN)===oe.FIN&&this.onRemoteCloseWrite(),(e&oe.RST)===oe.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case Qe.Init:return this.state=Qe.SYNSent,oe.SYN;case Qe.SYNReceived:return this.state=Qe.Established,oe.ACK;default:return 0}}sendWindowUpdate(){if(this.state===Qe.Paused){this.epochStart=Date.now();return}const e=this.getSendFlags(),n=Date.now(),s=this.getRTT();if(e===0&&s>-1&&n-this.epochStart<=s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:_e.WindowUpdate,flag:e,streamID:this.streamId,length:i})}}function hf(r){return{type:_e[r.type],flags:[(r.flag&oe.SYN)===oe.SYN?"SYN":void 0,(r.flag&oe.ACK)===oe.ACK?"ACK":void 0,(r.flag&oe.FIN)===oe.FIN?"FIN":void 0,(r.flag&oe.RST)===oe.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const ff="/yamux/1.0.0";ug=Symbol.toStringTag,lg=bt;class fx{constructor(t={}){l(this,"protocol",ff);l(this,"_init");l(this,ug,"@chainsafe/libp2p-yamux");l(this,lg,["@libp2p/stream-multiplexing"]);this._init=t}createStreamMuxer(t){return new gx(t,{...this._init})}}class gx extends Du{constructor(e,n={}){super(e,{...n,protocol:ff,name:"yamux"});l(this,"nextStreamID");l(this,"nextPingID");l(this,"activePing");l(this,"rtt");l(this,"client");l(this,"localGoAway");l(this,"remoteGoAway");l(this,"numInboundStreams");l(this,"numOutboundStreams");l(this,"decoder");l(this,"keepAlive");l(this,"enableKeepAlive");l(this,"keepAliveInterval");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");this.client=e.direction==="outbound",cx(n),this.enableKeepAlive=n.enableKeepAlive??ki.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??ki.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??ki.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??ki.maxOutboundStreams,this.decoder=new dx,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=K0(async s=>{try{await this.ping(s)}catch(i){this.log.error("ping error: %s",i)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(e){for(const n of this.decoder.emitFrames(e))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new bn("Muxer closed locally");const e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new ao("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",e);const n=this._newStream(e,Qe.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(e){if(this.remoteGoAway!==void 0)throw new bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new bn("Muxer closed locally");if(this.activePing!=null)return sf(this.activePing.promise,e==null?void 0:e.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await sf(this.activePing.promise,e==null?void 0:e.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(e={}){var n;if(this.status==="open")try{const s=(e==null?void 0:e.reason)??tt.NormalTermination;this.log.trace("muxer close reason=%s",tt[s]),await super.close(e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}abort(e){var n;if(this.status==="open")try{super.abort(e);let s=tt.InternalError;ox(e)&&(s=e.reason),this.log.error("muxer abort reason=%s error=%s",s,e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var e;try{super.onTransportClosed()}finally{(e=this.keepAlive)==null||e.stop()}}_newStream(e,n,s){if(this.streams.find(o=>o.streamId===e)!=null)throw new W("Stream already exists with that id");const i=new hx({...this.streamOptions,id:`${e}`,streamId:e,state:n,direction:s,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${s}:${e}`),getRTT:this.getRTT.bind(this)});return i.addEventListener("close",()=>{this.closeStream(e)},{once:!0}),i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(e){const{streamID:n,type:s,length:i}=e.header;if(this.log.trace("received frame %o",hf(e.header)),n===0)switch(s){case _e.Ping:{this.handlePing(e.header);return}case _e.GoAway:{this.handleGoAway(i);return}default:throw new wn("Invalid frame type")}else switch(e.header.type){case _e.Data:case _e.WindowUpdate:{this.handleStreamMessage(e);return}default:throw new wn("Invalid frame type")}}handlePing(e){if(e.flag===oe.SYN)this.log.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,oe.ACK);else if(e.flag===oe.ACK)this.log.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new wn("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new of("ping not requested");if(this.activePing.id!==e)throw new af("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(e){this.log.trace("received GoAway reason=%s",tt[e]??"unknown"),this.remoteGoAway=e,e===tt.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(e){const{streamID:n,flag:s,type:i}=e.header;(s&oe.SYN)===oe.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(i){case _e.WindowUpdate:{o.handleWindowUpdate(e);return}case _e.Data:{o.handleData(e);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new W("Both endpoints are clients");if(this.streams.find(s=>s.streamId===e))return;if(this.log.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:_e.WindowUpdate,flag:oe.RST,streamID:e,length:0});return}const n=this._newStream(e,Qe.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(e,n){let s;if(e.type===_e.Data){if(n==null)throw new wn("Invalid frame");s=new Q(df(e),n)}else s=df(e);return this.log.trace("sending frame %o",hf(e)),this.send(s)}sendPing(e,n=oe.SYN){n===oe.SYN?this.log.trace("sending ping request pingId=%s",e):this.log.trace("sending ping response pingId=%s",e),this.sendFrame({type:_e.Ping,flag:n,streamID:0,length:e})}sendGoAway(e=tt.NormalTermination){this.log("sending GoAway reason=%s",tt[e]),this.localGoAway=e,this.sendFrame({type:_e.GoAway,flag:0,streamID:0,length:e})}}function mx(r={}){return()=>new fx(r)}const px="0.1.0",yx="id",wx="1.0.0",bx=1024*8;var Mi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.protocolVersion!=null&&(n.uint32(42),n.string(e.protocolVersion)),e.agentVersion!=null&&(n.uint32(50),n.string(e.agentVersion)),e.publicKey!=null&&(n.uint32(10),n.bytes(e.publicKey)),e.listenAddrs!=null)for(const i of e.listenAddrs)n.uint32(18),n.bytes(i);if(e.observedAddr!=null&&(n.uint32(34),n.bytes(e.observedAddr)),e.protocols!=null)for(const i of e.protocols)n.uint32(26),n.string(i);e.signedPeerRecord!=null&&(n.uint32(66),n.bytes(e.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 5:{i.protocolVersion=e.string();break}case 6:{i.agentVersion=e.string();break}case 1:{i.publicKey=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new St('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(e.bytes());break}case 4:{i.observedAddr=e.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new St('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 8:{i.signedPeerRecord=e.bytes();break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Mi||(Mi={}));const Tt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:bx,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function Ex(r){if(r!=null&&r.length>0)try{return X(r)}catch{}}async function vx(r,t,e,n,s){if(e("received identify from %p",n.remotePeer),s==null)throw new ot("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:X(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=qt(s.publicKey);if(!Rr(c).equals(n.remotePeer))throw new ot("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){e.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const u=await hn.openAndCertify(c,_t.DOMAIN);let d=_t.createFromProtobuf(u.payload);const h=Mr(u.publicKey.toCID());if(!d.peerId.equals(h))throw new ot("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(d.peerId))throw new ot("signing key does not match remote PeerId");let f;try{f=await r.get(d.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(f!=null&&(i.metadata=f.metadata,f.peerRecordEnvelope!=null)){const p=hn.createFromProtobuf(f.peerRecordEnvelope),g=_t.createFromProtobuf(p.payload);g.seqNumber>=d.seqNumber&&(e("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,d.seqNumber),d=g,c=f.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=d.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:d.seqNumber,addresses:d.multiaddrs}}else e("%p did not send a signed peer record",n.remotePeer);if(e.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=G(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=G(s.protocolVersion)),e.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>X(c)),observedAddr:s.observedAddr==null?void 0:X(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}class Sx{constructor(t,e){l(this,"host");l(this,"components");l(this,"protocol");l(this,"started");l(this,"timeout");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");l(this,"maxMessageSize");l(this,"maxObservedAddresses");l(this,"runOnLimitedConnection");l(this,"log");this.protocol=e.protocol,this.started=!1,this.components=t,this.log=e.log,this.timeout=e.timeout??Tt.timeout,this.maxInboundStreams=e.maxInboundStreams??Tt.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??Tt.maxOutboundStreams,this.maxMessageSize=e.maxMessageSize??Tt.maxMessageSize,this.maxObservedAddresses=e.maxObservedAddresses??Tt.maxObservedAddresses,this.runOnLimitedConnection=e.runOnLimitedConnection??Tt.runOnLimitedConnection,this.host={protocolVersion:`${e.protocolPrefix??Tt.protocolPrefix}/${px}`,agentVersion:t.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:G(this.host.agentVersion),ProtocolVersion:G(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}class xx extends(hg=Sx,dg=bt,hg){constructor(e,n={}){super(e,{...n,protocol:`/${n.protocolPrefix??Tt.protocolPrefix}/${yx}/${wx}`,log:e.logger.forComponent("libp2p:identify")});l(this,dg,["@libp2p/identify"]);(n.runOnConnectionOpen??Tt.runOnConnectionOpen)&&e.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(()=>{})})}async _identify(e,n={}){let s,i;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",e.remoteAddr);try{s=await e.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),i=s.log.newScope("identify");const o=un(s,{maxDataLength:this.maxMessageSize}).pb(Mi),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw i==null||i.error("identify failed - %e",o),s==null||s.abort(o),o}}async identify(e,n={}){const s=await this._identify(e,n),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new ot("Public key was missing from identify message");const c=qt(i),u=Mr(c.toCID());if(!e.remotePeer.equals(u))throw new ot("Identified peer does not match the expected peer");if(this.components.peerId.equals(u))throw new ot("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",u,o),vx(this.components.peerStore,this.components.events,this.log,e,s)}maybeAddObservedAddress(e){const n=Ex(e);if(n==null||(this.log.trace("our observed address was %a",n),Fn(n)))return;const s=n.getComponents();if((s[0].code===Un||s[0].code===fa&&s[1].code===Un)&&!db(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}yi.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(e,n){const s=e.log.newScope("identify");s("responding to identify");const i=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:i}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(V));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new _t({peerId:this.components.peerId,multiaddrs:a});c=(await hn.seal(h,this.components.privateKey,{signal:i})).marshal().subarray()}let u=n.remoteAddr.bytes;UE.matches(n.remoteAddr)||(u=void 0);const d=un(e).pb(Mi);s("send response"),await d.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:At(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:u,protocols:o.protocols},{signal:i}),s("close write"),await d.unwrap().unwrap().close({signal:i})}}function Ax(r={}){return t=>new xx(t,r)}const Cx=1,gf=5e3,_x=100,Ni=`${uo}-circuit-relay`;BigInt(1<<17);const Oi="/libp2p/circuit/relay/0.2.0/hop",mf="/libp2p/circuit/relay/0.2.0/stop",pf=300,Ix=4096,Tx=.001;var Zn;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(t||(t={})),function(n){n.codec=()=>_n(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Jn.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),Fi.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),jn.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),We.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u,d;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const h=n.uint32();switch(h>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Jn.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.reservation=Fi.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.reservation});break}case 4:{o.limit=jn.codec().decode(n,n.uint32(),{limits:(d=i.limits)==null?void 0:d.limit});break}case 5:{o.status=We.codec().decode(n);break}default:{n.skipType(h&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(Zn||(Zn={}));var Lt;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(t||(t={})),function(n){n.codec=()=>_n(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Ce((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),Jn.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),jn.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),We.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const d=n.uint32();switch(d>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=Jn.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.limit=jn.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.limit});break}case 4:{o.status=We.codec().decode(n);break}default:{n.skipType(d&7);break}}}return o})),e),r.encode=n=>Ae(n,r.codec()),r.decode=(n,s)=>xe(n,r.codec(),s)})(Lt||(Lt={}));var Jn;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.id!=null&&e.id.byteLength>0&&(n.uint32(10),n.bytes(e.id)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={id:ae(0),addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new St('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Jn||(Jn={}));var Fi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.expire!=null&&e.expire!==0n&&(n.uint32(8),n.uint64(e.expire)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);e.voucher!=null&&(n.uint32(26),$i.codec().encode(e.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={expire:0n,addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.expire=e.uint64();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new St('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}case 3:{i.voucher=$i.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.voucher});break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Fi||(Fi={}));var jn;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.duration!=null&&(n.uint32(8),n.uint32(e.duration)),e.data!=null&&(n.uint32(16),n.uint64(e.data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.duration=e.uint32();break}case 2:{i.data=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(jn||(jn={}));var We;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(We||(We={}));var rc;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(rc||(rc={})),function(r){r.codec=()=>_n(rc)}(We||(We={}));var Bi;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.relay!=null&&e.relay.byteLength>0&&(n.uint32(10),n.bytes(e.relay)),e.peer!=null&&e.peer.byteLength>0&&(n.uint32(18),n.bytes(e.peer)),e.expiration!=null&&e.expiration!==0n&&(n.uint32(24),n.uint64(e.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={relay:ae(0),peer:ae(0),expiration:0n},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.relay=e.bytes();break}case 2:{i.peer=e.bytes();break}case 3:{i.expiration=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})(Bi||(Bi={}));var $i;(function(r){let t;r.codec=()=>(t==null&&(t=Ce((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&(n.uint32(26),Bi.codec().encode(e.payload,n)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={publicKey:ae(0),payloadType:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=Bi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.payload});break}case 5:{i.signature=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>Ae(e,r.codec()),r.decode=(e,n)=>xe(e,r.codec(),n)})($i||($i={}));class sc extends Error{constructor(){super(...arguments);l(this,"name","HadEnoughRelaysError")}}l(sc,"name","HadEnoughRelaysError");class yf extends Error{constructor(){super(...arguments);l(this,"name","DoubleRelayError")}}l(yf,"name","DoubleRelayError");class wf extends Error{constructor(){super(...arguments);l(this,"name","RelayQueueFullError")}}l(wf,"name","RelayQueueFullError");function bf(r){const t=r*BigInt(1e3),e=new Date().getTime();return Number(t-BigInt(e))}class Ef{constructor(t){l(this,"expires");l(this,"bytes");(t==null?void 0:t.duration)!=null&&(t==null?void 0:t.duration)!==0&&(this.expires=Date.now()+t.duration*1e3),this.bytes=t==null?void 0:t.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(t){this.bytes!=null&&(this.bytes-=BigInt(t.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const t={};if(this.bytes!=null){const e=this;Object.defineProperty(t,"bytes",{get(){return e.bytes}})}if(this.expires!=null){const e=this;Object.defineProperty(t,"seconds",{get(){return Math.round(((e.expires??0)-Date.now())/1e3)}})}return t}}const vf=de(ie(Ua.matchers[0],ue(Kn))),Sf=de(ue(Kn));class Lx extends Ge{constructor(e,n={}){super();l(this,"components");l(this,"started");l(this,"running");l(this,"topologyId");l(this,"log");l(this,"discoveryController");l(this,"filter");l(this,"queue");this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=n.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Oi,{filter:this.filter,onConnect:e=>{var n,s;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,(n=this.queue)==null?void 0:n.size,(s=this.queue)==null?void 0:s.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var s;this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[i=>i.protocols.includes(Oi)],orders:[()=>Math.random()<.5?1:-1,(i,o)=>{const a=xf(i),c=xf(o);return a>c?-1:c>a?1:0}]});for(const i of e)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",e.length);const n=this.queue=new Ca({concurrency:5});this.log("start random walk");for await(const i of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",i.id),n.has(i.id)){this.log.trace("random peer %p was already in queue",i.id);continue}if(((s=this.components.connectionManager.getConnections(i.id))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",i.id);continue}if(!await this.components.connectionManager.isDialable(i.multiaddrs)){this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(o=>o.toString()));continue}n.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await n.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,n.size,n.running),n.add(this.dialPeer,{peerId:i.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",i.id,o)})}this.log("stop random walk"),await n.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",e)}))}stopDiscovery(){var e,n;this.log("stop discovery"),this.running=!1,(e=this.discoveryController)==null||e.abort(),(n=this.queue)==null||n.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p",e.detail.id),this.maybeDialPeer(e).catch(n=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,n)})}async maybeDialPeer(e){var i,o;if(this.queue==null)return;const n=e.detail.id,s=e.detail.multiaddrs;if(this.queue.has(n)){this.log.trace("random peer %p was already in queue",n);return}if(((i=this.components.connectionManager.getConnections(n))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",n);return}if(!await this.components.connectionManager.isDialable(s)){this.log.trace("random peer %p was not dialable",n);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",e.detail.id,a)})}async dialPeer({peerId:e,signal:n}){const s=ln([AbortSignal.timeout(5e3),n]);try{await this.components.connectionManager.openConnection(e,{signal:s})}finally{s.clear()}}}function xf(r){const t=r.metadata.get("last-dial-success");return t==null?0:new Date(Z(t)).getTime()}class Dx extends Ge{constructor(e,n={}){super();l(this,"connectionManager");l(this,"addressManager");l(this,"reservationStore");l(this,"listeningAddrs");l(this,"log");l(this,"listenTimeout");l(this,"reservationId");l(this,"relay");l(this,"_onRemoveRelayPeer",e=>{var n,s;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,(n=this.relay)==null?void 0:n.equals(e.detail.relay)),((s=this.relay)==null?void 0:s.equals(e.detail.relay))===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(i=>{this.addressManager.removeObservedAddr(i)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});l(this,"_onAddRelayPeer",e=>{const{details:n}=e.detail;n.type!=="configured"&&n.id===this.reservationId&&this.addedRelay(e.detail)});this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=n.listenTimeout??gf,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(Sf.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(vf.exactMatch(e)){this.log("listen on specific relay server %a",e);const n=AbortSignal.timeout(this.listenTimeout),s=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(s,{signal:n});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const o=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(o)}}else throw new hs(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(n=>X(n).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(n=>{this.addressManager.confirmObservedAddr(n,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Px(r){return new Dx(r)}const Rx="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let kx=(r=21)=>{let t="",e=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)t+=Rx[e[r]&63];return t};const Mx=60*1e3*10,Nx=60*1e3*5,Ox=30*1e3;class Fx extends Ge{constructor(e,n){super();ge(this,Je);l(this,"peerId");l(this,"connectionManager");l(this,"peerStore");l(this,"events");l(this,"reserveQueue");l(this,"reservations");l(this,"pendingReservations");l(this,"maxReservationQueueLength");l(this,"reservationCompletionTimeout");l(this,"started");l(this,"log");l(this,"relayFilter");this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new kn,this.pendingReservations=[],this.maxReservationQueueLength=(n==null?void 0:n.maxReservationQueueLength)??_x,this.reservationCompletionTimeout=(n==null?void 0:n.reservationCompletionTimeout)??gf,this.started=!1,this.relayFilter=Br(100),this.reserveQueue=new Ca({concurrency:(n==null?void 0:n.reservationConcurrency)??Cx,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",s=>{[...this.reservations.values()].find(o=>o.connection===s.detail.id)!=null&&H(this,Je,as).call(this,s.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",s.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[n=>n.tags.has(Ni)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async n=>{await this.peerStore.merge(n.id,{tags:{[Ni]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async n=>this.addRelay(n.id,"discovered"))),H(this,Je,cs).call(this)}).catch(e=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=kx();return this.pendingReservations.push(e),H(this,Je,cs).call(this),e}async addRelay(e,n){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new hs("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new wf("The reservation queue is full");const s=this.reserveQueue.find(e);if(s!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),s.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new hs("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const o=this.reservations.get(e);if(o!=null){const y=this.connectionManager.getConnections(e);let m=!1;if(y.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),y.map(S=>S.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&bf(o.reservation.expire)>Mx)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:o};await H(this,Je,as).call(this,e)}if(n==="discovered"&&this.pendingReservations.length===0)throw new sc("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(e,{signal:a});if(Yn.matches(c.remoteAddr))throw new yf("not creating reservation over relayed connection");const u=await H(this,Je,Pg).call(this,c,{signal:a}),d=bf(u.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+d).toString());const h=Math.min(Math.max(d-Nx,Ox),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,n).catch(async y=>{this.log.error("could not refresh reservation to relay %p - %e",e,y),await H(this,Je,as).call(this,e)}).catch(y=>{this.log.error("could not remove expired reservation to relay %p - %e",e,y)})},h);let p;if(n==="discovered"){const y=this.pendingReservations.pop();if(y==null)throw new sc("Made reservation on relay but did not need any more discovered relays");p={timeout:f,reservation:u,type:n,connection:c.id,id:y}}else p={timeout:f,reservation:u,type:n,connection:c.id};this.reservations.set(e,p),await this.peerStore.merge(e,{tags:{[Ni]:{value:1,ttl:d}}}),H(this,Je,cs).call(this);const g={relay:e,details:p};return this.safeDispatchEvent("relay:created-reservation",{detail:g}),g}catch(o){throw n==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),H(this,Je,as).call(this,e).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,a)}),o}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var n;return(n=this.reservations.get(e))==null?void 0:n.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((n,s)=>(s.type===e&&n++,n),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}Je=new WeakSet,Pg=async function(e,n){var u;(u=n.signal)==null||u.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const s=await e.newStream(Oi,n),o=un(s).pb(Zn);this.log.trace("send RESERVE to %p",e.remotePeer),await o.write({type:Zn.Type.RESERVE},n);let a;try{this.log.trace("reading response from %p",e.remotePeer),a=await o.read(n)}catch(d){throw s.abort(d),d}finally{s.status!=="closed"&&await s.close(n)}if(this.log.trace("read response %s",a.status),a.status===We.OK&&a.reservation!=null){const d=new Set;d.add(e.remoteAddr.toString());for(const h of a.reservation.addrs){let f=X(h);f.getComponents().find(p=>p.code===V)==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=X(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),d.add(f.toString())}return a.reservation.addrs=[...d].map(h=>X(h).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},as=async function(e){const n=this.reservations.get(e);n!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(n.timeout),this.reservations.delete(e),n.type==="discovered"&&this.pendingReservations.push(n.id),await this.peerStore.merge(e,{tags:{[Ni]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:n}}),H(this,Je,cs).call(this))},cs=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Br(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class Bx extends Lu{constructor(e){super({...e,direction:e.stream.direction});l(this,"stream");l(this,"init");this.init=e,this.stream=e.stream,this.stream.addEventListener("close",n=>{this.onTransportClosed(n.error)}),this.stream.addEventListener("remoteCloseWrite",n=>{this.onRemoteCloseWrite(),this.close().catch(s=>{this.abort(s)})}),this.stream.addEventListener("message",n=>{var s;(s=e.onDataRead)==null||s.call(e,n.data),this.onData(n.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(e){var n,s;return(s=(n=this.init).onDataWrite)==null||s.call(n,e),{sentBytes:e.byteLength,canSendMore:this.stream.send(e)}}async sendClose(e){await this.stream.close(e)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function Af(r){return new Bx(r)}const $x=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(X)}catch{return!1}return!0},Cf={maxInboundStopStreams:pf,maxOutboundStopStreams:pf};class Ux{constructor(t,e={}){l(this,"components");l(this,"discovery");l(this,"reservationStore");l(this,"maxInboundStopStreams");l(this,"maxOutboundStopStreams");l(this,"started");l(this,"log");l(this,"shutdownController");l(this,pg,"@libp2p/circuit-relay-v2-transport");l(this,mg,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);l(this,fg,!0);this.components=t,this.log=t.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=e.maxInboundStopStreams??Cf.maxInboundStopStreams,this.maxOutboundStopStreams=e.maxOutboundStopStreams??Cf.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Lx(t,{filter:e.discoveryFilter??H0(Ix,Tx)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",n.detail,s)})}),this.reservationStore=new Fx(t,e),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var n;(n=this.discovery)==null||n.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var n;(n=this.discovery)==null||n.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[(pg=Symbol.toStringTag,mg=bt,gg=ps,fg=Dc,gg)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(mf,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await Tc(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await Lc(this.discovery,this.reservationStore),await this.components.registrar.unhandle(mf),this.started=!1}async dial(t,e){var p,g,y,m,S,v,E,L;const n=t.toString().split("/p2p-circuit"),s=X(n[0]),i=X(n[n.length-1]),o=(p=s.getComponents().find(x=>x.code===V))==null?void 0:p.value,a=(g=i.getComponents().find(x=>x.code===V))==null?void 0:g.value;if(o==null||a==null){const x=`ircuit relay dial to ${t.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${x}`),new dr(`C${x}`)}const c=ct(o),u=ct(a);let h=this.components.connectionManager.getConnections(c)[0];h==null?(await this.components.peerStore.merge(c,{multiaddrs:[s]}),(y=e.onProgress)==null||y.call(e,new he("circuit-relay:open-connection")),h=await this.components.connectionManager.openConnection(c,e)):(m=e.onProgress)==null||m.call(e,new he("circuit-relay:reuse-connection"));let f;try{(S=e.onProgress)==null||S.call(e,new he("circuit-relay:open-hop-stream")),f=await h.newStream(Oi,e);const x=un(f).pb(Zn);(v=e.onProgress)==null||v.call(e,new he("circuit-relay:write-connect-message")),await x.write({type:Zn.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[X(i).bytes]}},e),(E=e.onProgress)==null||E.call(e,new he("circuit-relay:read-connect-response"));const _=await x.read(e);if(_.status!==We.OK)throw new ot(`failed to connect via relay with status ${((L=_==null?void 0:_.status)==null?void 0:L.toString())??"undefined"}`);const N=new Ef(_.limit),T=Af({stream:x.unwrap().unwrap(),remoteAddr:t,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:N.onData,onDataWrite:N.onData,log:f.log.newScope("circuit-relay:connection")}),I=await this.components.upgrader.upgradeOutbound(T,{...e,limits:N.getLimits()});return I.log("outbound relayed connection established to %p with limits %o, over connection %s",I.remotePeer,_.limit??"none",h.id),I}catch(x){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",u,c,x),f==null||f.abort(x),x}}createListener(t){return Px({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>vf.exactMatch(e)||Sf.exactMatch(e))}dialFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>Yn.exactMatch(e))}async onStop(t,e){var s,i;const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(p){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",p)}const o=un(t).pb(Lt),a=await o.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await o.write({type:Lt.Type.STATUS,status:We.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(a.type!==Lt.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:Lt.Type.STATUS,status:We.UNEXPECTED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(!$x(a)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:Lt.Type.STATUS,status:We.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const c=kr(gr(a.peer.id));if(await((i=(s=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:i.call(s,e.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await o.write({type:Lt.Type.STATUS,status:We.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await o.write({type:Lt.Type.STATUS,status:We.OK},{signal:n});const u=new Ef(a.limit),d=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),h=this.components.addressManager.getAddresses()[0],f=Af({stream:o.unwrap().unwrap(),remoteAddr:d,localAddr:h,onDataRead:u.onData,onDataWrite:u.onData,log:t.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(f,{limits:u.getLimits(),signal:n}),f.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",e.id)}finally{n==null||n.clear()}}}function zx(r={}){return t=>new Ux(t,r)}const qx="bootstrap",Kx=50,Vx=1e3;class _f extends(Eg=Ge,bg=co,wg=Symbol.toStringTag,yg=bt,Eg){constructor(e,n={list:[]}){if(n.list==null||n.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();l(this,"log");l(this,"timer");l(this,"list");l(this,"timeout");l(this,"components");l(this,"_init");l(this,bg,this);l(this,wg,"@libp2p/bootstrap");l(this,yg,["@libp2p/peer-discovery"]);this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=n.timeout??Vx,this.list=n.list.map(s=>X(s)).filter(s=>{var o;return Ua.matches(s)?((o=s.getComponents().findLast(a=>a.code===V))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",s),!1)}).map(s=>{var i;return{id:ct(((i=s.getComponents().findLast(o=>o.code===V))==null?void 0:i.value)??""),multiaddrs:[s]}}),this._init=n}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error("failed to discover bootstrap peers - %e",e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??qx]:{value:this._init.tagValue??Kx,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not dial bootstrap peer %p - %e",e.id,n)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}l(_f,"tag","bootstrap");function Wx(r){return t=>new _f(t,r)}const If=location.hostname.split(".")[0],Hx=location.pathname==="/"||location.pathname===""?`${If}.github.io`:location.pathname.split("/")[1],dt=`${If}/${Hx}`,ic=`https://api.github.com/repos/${dt}/contents/data/state.json`,oc="gitchain_github_access_token",Ui=`https://api.github.com/repos/${dt}/issues`,Tf="/gitchain/tx/1.0.0",Ht="data/server-peer.json",Gx=5*60*1e3;let Gt=null,zi=!1,Lf=null;function Df(r,t,e,n){const s=`${r}${t}${e}${JSON.stringify(n)}`;return CryptoJS.SHA256(s).toString()}function Yx(){const r=new Date().toISOString();return{index:0,previousHash:"0",timestamp:r,transactions:[],hash:Df(0,"0",r,[])}}function Pf(r){return JSON.stringify(r,Object.keys(r).sort())}function ac(r){const e=sha3.keccak256(r).match(/.{2}/g);if(!e)throw new Error("Failed to parse hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}function Xx(r){const t=new Uint8Array(r.length/2);for(let e=0;e<r.length;e+=2)t[e/2]=parseInt(r.substr(e,2),16);return t}function jr(r){return Array.from(r,t=>t.toString(16).padStart(2,"0")).join("")}function cc(r){try{const t=ac(Pf({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})),e=Xx(r.signature);if(e.length!==65)return!1;const n=jr(e.slice(0,32)),s=jr(e.slice(32,64)),i=e[64]-27,o=new ec("secp256k1"),a=jr(t),c={r:n,s},u=o.recoverPubKey(a,c,i),d=ac(u.encode("array",!0).slice(1));return`0x${jr(d.slice(-20))}`.toLowerCase()===r.from.toLowerCase()}catch{return!1}}async function Qx(r,t){const e=jr(ac(Pf({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})));return cc(r)?(t.nonces[r.from]||0)+1!==r.nonce?{valid:!1,txid:e}:r.from.toLowerCase()!==ne.toLowerCase()&&(t.balances[r.from]||0)<r.amount?{valid:!1,txid:e}:!/^0x[a-fA-F0-9]{40}$/.test(r.from)||!/^0x[a-fA-F0-9]{40}$/.test(r.to)?{valid:!1,txid:e}:(t.pending.push(r),{valid:!0,txid:e}):{valid:!1,txid:e}}async function Zx(r){if(r.pending.length===0)return null;const t=[],e={...r.balances},n={...r.nonces};for(const u of r.pending)cc(u)&&(n[u.from]||0)+1===u.nonce&&(u.from.toLowerCase()===ne.toLowerCase()||(e[u.from]||0)>=u.amount)&&(u.from.toLowerCase()!==ne.toLowerCase()&&(e[u.from]=(e[u.from]||0)-u.amount),e[u.to]=(e[u.to]||0)+u.amount,n[u.from]=u.nonce,t.push(u));if(t.length===0)return r.pending=[],null;const s=r.chain.length,i=r.chain.length>0?r.chain[r.chain.length-1].hash:"0",o=new Date().toISOString(),a=Df(s,i,o,t),c={index:s,previousHash:i,timestamp:o,transactions:t,hash:a};return r.chain.push(c),r.pending=[],r.balances=e,r.nonces=n,s}function Yt(){var t;let r=localStorage.getItem(oc);if(!r){if(r=(t=document.getElementById("githubAccessToken"))==null?void 0:t.value,!r)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(oc,r)}return console.log("Retrieved GitHub access token"),r}async function Jx(r){console.log("Entering initP2P, isHost:",r),zi=r;try{console.log("Creating libp2p node..."),Gt=await FS({addresses:{listen:["/webrtc","/p2p-circuit"]},transports:[zx({hop:{enabled:!1}}),rx({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncrypters:[nx()],streamMuxers:[mx()],peerDiscovery:[Wx({list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbX7TbXrHRQHh2","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqduuO5wL","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76C42gEOzRVzYVdigitaltA5dyxuEXsBC","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp"]})],services:{identify:Ax()},connectionGater:{denyDialMultiaddr:async()=>!1}}),console.log("Starting libp2p node..."),await Gt.start(),console.log("libp2p started, peerId:",Gt.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(e=>setTimeout(e,1e3)),Gt.addEventListener("peer:connect",e=>{console.log("Connected to peer:",e.detail.toString())}),console.log("Registering protocol handler for:",Tf),await Gt.handle(Tf,async({stream:e,connection:n})=>{console.log("Incoming TX stream from",n.remotePeer.toString());const s=await e2(e);try{const i=JSON.parse(s);if(cc(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:dt,txn:i}),a=await fetch(Ui,{method:"POST",headers:{Authorization:`token ${Yt()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}e.close()}),zi&&(console.log("Host mode: Advertising peer info"),await Rf(),console.log("Setting interval for periodic peer advertising"),setInterval(Rf,Gx),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await jx()})),console.log("initP2P completed successfully")}catch(t){console.error("Failed to initialize P2P:",t),zi&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function Rf(r=3,t=1e3){if(console.log("Entering advertiseServerPeer, retries:",r),!zi||!Gt)return console.log("Not in host mode or libp2p not initialized"),!1;const e=Gt.peerId.toString(),n=Gt.getMultiaddrs().map(a=>a.toString()),s={peerId:e,multiaddrs:n,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===Lf)return console.log("No change in peer info, skipping update"),!0;Lf=i;const o=Yt();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=r;a++){console.log(`Attempt ${a}/${r} to advertise peer info`);try{console.log("Fetching SHA for",Ht);const c=await kf(Ht);console.log("SHA:",c||"none (new file)");const u={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(u.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${dt}/contents/${Ht}`);const d=await fetch(`https://api.github.com/repos/${dt}/contents/${Ht}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(u)});if(d.ok)return console.log("Advertised peer info successfully"),!0;{const h=await d.text();if(console.error(`Attempt ${a}/${r} - Failed to advertise peer: ${d.status} ${h}`),(d.status===403||d.status===429)&&(console.log(`Retrying after ${t}ms due to ${d.status}`),a<r)){await new Promise(f=>setTimeout(f,t));continue}throw new Error(`HTTP ${d.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${r} - Error advertising peer:`,c),a===r)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(u=>setTimeout(u,t))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function jx(){console.log("Entering deleteServerPeerFile");const r=Yt();if(!r){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",Ht);const t=await kf(Ht);if(!t){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",Ht);const e=await fetch(`https://api.github.com/repos/${dt}/contents/${Ht}`,{method:"DELETE",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:t})});e.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",e.status,await e.text())}catch(t){console.error("Error deleting peer file:",t)}}async function kf(r){console.log("Entering getFileSha for",r);const t=Yt();if(!t)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${dt}/contents/${r}?ref=main`);const e=await fetch(`https://api.github.com/repos/${dt}/contents/${r}?ref=main`,{headers:{Authorization:`token ${t}`,Accept:"application/vnd.github.v3+json"}});if(e.ok){const n=await e.json();return console.log("SHA retrieved:",n.sha),n.sha}return e.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${r}: ${e.status} ${await e.text()}`),null)}catch(e){return console.error(`Error fetching SHA for ${r}:`,e),null}}async function e2(r){console.log("Reading stream to string");const t=[];for await(const s of r.source)t.push(s);const e=kt(t),n=Z(e);return console.log("Stream read complete, length:",n.length),n}async function qi(){console.log("Entering fetchState");const r=Yt();if(!r)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",ic);const t=await fetch(`${ic}?ref=main`,{headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json"}});if(!t.ok){if(t.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",t.status,await t.text()),new Error(`Error fetching state: ${t.statusText}`)}const e=await t.json(),n=JSON.parse(atob(e.content));return console.log("State fetched, chain length:",n.chain.length),{content:n,sha:e.sha}}catch(t){return console.error("Error fetching state:",t),null}}async function Ki(r,t,e,n=3){console.log("Entering updateState, message:",e);const s=Yt();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(r,null,2));try{const o={message:e,content:i,branch:"main"};t&&(o.sha=t),console.log("Sending PUT request to update state");const a=await fetch(ic,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&n>0){console.log("Conflict detected, retrying...");const c=await qi();if(!c)throw new Error("Failed to refetch");return Ki(r,c.sha,e,n-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function Vi(r,t,e){console.log("Entering closeIssueWithComment, issue:",r);const n=Yt();if(!n){console.log("No PAT available for closing issue");return}const s=e&&t!==null?`Confirmed in block ${t}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${dt}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${dt})`;console.log("Creating comment for issue:",r),await fetch(`${Ui}/${r}/comments`,{method:"POST",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",r),await fetch(`${Ui}/${r}`,{method:"PATCH",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function t2(){console.log("Entering processTxns");const r=document.getElementById("output"),t=document.getElementById("processingMessage");t.classList.add("visible");let e=await qi(),n=e==null?void 0:e.content;if(!n){if(console.log("No state found, initializing"),n={chain:[Yx()],pending:[],balances:{[ne]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await Ki(n,null,"Initialize state")){console.log("Failed to initialize state"),r.textContent+=`
Failed to initialize.`,t.classList.remove("visible");return}e=await qi(),n=e.content}console.log("Fetching open issues");const i=await(await fetch(`${Ui}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${Yt()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=n.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(n.lastProcessedDate))continue;let c;try{const g=JSON.parse(a.body);if(g.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await Vi(a.number,null,!1);continue}if(g.repo!==dt){console.log("Skipping issue from wrong repo:",a.number),await Vi(a.number,null,!1);continue}c=g.txn}catch{console.log("Invalid issue body, closing:",a.number),await Vi(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:u,txid:d}=await Qx(c,n);console.log(`Transaction ID: ${d}, valid: ${u}`);const h=u?await Zx(n):null;if(await Vi(a.number,h,u),u&&h!==null?(console.log(`Transaction ID: ${d} settled in block ${h}`),r.textContent+=`
Processed txn ${d} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),r.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await Ki(n,e.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),r.textContent+=`
Failed to update state after issue #${a.number}`,t.classList.remove("visible");return}e=await qi(),n=e.content;const p=a.created_at;new Date(p)>new Date(o)&&(o=p)}o!==n.lastProcessedDate&&(console.log("Updating last processed date:",o),n.lastProcessedDate=o,await Ki(n,e.sha,"Update last processed date")),console.log("processTxns completed"),t.classList.remove("visible")}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(oc)?(console.log("PAT found, initializing P2P as host"),Jx(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{t2()},15e3)})})();
