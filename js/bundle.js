var Bm=Object.defineProperty;var Lc=r=>{throw TypeError(r)};var $m=(r,t,e)=>t in r?Bm(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var l=(r,t,e)=>$m(r,typeof t!="symbol"?t+"":t,e),no=(r,t,e)=>t.has(r)||Lc("Cannot "+e);var D=(r,t,e)=>(no(r,t,"read from private field"),e?e.call(r):t.get(r)),oe=(r,t,e)=>t.has(r)?Lc("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(r):t.set(r,e),le=(r,t,e,n)=>(no(r,t,"write to private field"),n?n.call(r,e):t.set(r,e),e),z=(r,t,e)=>(no(r,t,"access private method"),e);var Sn=(r,t,e,n)=>({set _(s){le(r,t,s,e)},get _(){return D(r,t,n)}});const Ys="0x097efb2a92bc5205e1615db52338a118f1619f3f",Um=Symbol.for("@libp2p/connection"),Dc=Symbol.for("@libp2p/content-routing");var ko;let Fr=(ko=class extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}},l(ko,"name","AbortError"),ko);class od extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}l(od,"name","UnexpectedPeerError");var Mo;let zm=(Mo=class extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},l(Mo,"name","InvalidCryptoExchangeError"),Mo);var No;let G=(No=class extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},l(No,"name","InvalidParametersError"),No);class Ma extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}l(Ma,"name","InvalidPublicKeyError");class Xs extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}l(Xs,"name","ConnectionClosedError");class ad extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}l(ad,"name","ConnectionFailedError");class In extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}l(In,"name","MuxerClosedError");class Na extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}l(Na,"name","StreamResetError");class jt extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}l(jt,"name","StreamStateError");class qo extends Error{constructor(t="The stream buffer was full"){super(t),this.name="StreamBufferError"}}l(qo,"name","StreamBufferError");var Oo;let Ko=(Oo=class extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}},l(Oo,"name","NotFoundError"),Oo);class Oa extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}l(Oa,"name","InvalidPeerIdError");var Fo;let Oi=(Fo=class extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}},l(Fo,"name","InvalidMultiaddrError"),Fo);class cd extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}l(cd,"name","InvalidCIDError");class ld extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}l(ld,"name","InvalidMultihashError");class ud extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}l(ud,"name","UnsupportedProtocolError");class it extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}l(it,"name","InvalidMessageError");var Bo;let qm=(Bo=class extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}},l(Bo,"name","TimeoutError"),Bo);class Br extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}l(Br,"name","NotStartedError");class Tr extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}l(Tr,"name","DialError");class Zs extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}l(Zs,"name","ListenError");class Vo extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}l(Vo,"name","LimitedConnectionError");class dd extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}l(dd,"name","TooManyInboundProtocolStreamsError");class Fa extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}l(Fa,"name","TooManyOutboundProtocolStreamsError");class Fi extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}l(Fi,"name","UnsupportedKeyTypeError");class Km extends Event{constructor(e,n){super("message",n);l(this,"data");this.data=e}}class Bi extends Event{constructor(e,n,s){super("close",s);l(this,"error");l(this,"local");this.error=n,this.local=e}}class Vm extends Bi{constructor(t,e){super(!0,t,e)}}class Wm extends Bi{constructor(t,e){super(!1,t,e)}}const Wo=Symbol.for("@libp2p/peer-discovery"),Ba=Symbol.for("@libp2p/peer-id");function Lr(r){return!!(r!=null&&r[Ba])}const Pc=Symbol.for("@libp2p/peer-routing"),$a="keep-alive";function Ua(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function hd(...r){const t=[];for(const e of r)Ua(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function fd(...r){const t=[];for(const e of r)Ua(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}const md=Symbol.for("@libp2p/transport");var Qs;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Qs||(Qs={}));var dt;class Ze extends EventTarget{constructor(){super();oe(this,dt,new Map)}listenerCount(e){const n=D(this,dt).get(e);return n==null?0:n.length}addEventListener(e,n,s){super.addEventListener(e,n,s);let i=D(this,dt).get(e);i==null&&(i=[],D(this,dt).set(e,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(e,n,s){super.removeEventListener(e.toString(),n??null,s);let i=D(this,dt).get(e);i!=null&&(i=i.filter(({callback:o})=>o!==n),D(this,dt).set(e,i))}dispatchEvent(e){const n=super.dispatchEvent(e);let s=D(this,dt).get(e.type);return s==null||(s=s.filter(({once:i})=>!i),D(this,dt).set(e.type,s)),n}safeDispatchEvent(e,n={}){return this.dispatchEvent(new CustomEvent(e,n))}}dt=new WeakMap;const Lt=Symbol.for("@libp2p/service-capabilities"),Js=Symbol.for("@libp2p/service-dependencies");function Hm(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function $i(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Gm(r){return new TextEncoder().encode(r)}function Ym(r){return new TextDecoder().decode(r)}function Xm(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function h(m){if(m instanceof Uint8Array||(ArrayBuffer.isView(m)?m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength):Array.isArray(m)&&(m=Uint8Array.from(m))),!(m instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(m.length===0)return"";for(var y=0,g=0,S=0,v=m.length;S!==v&&m[S]===0;)S++,y++;for(var E=(v-S)*d+1>>>0,L=new Uint8Array(E);S!==v;){for(var x=m[S],_=0,O=E-1;(x!==0||_<g)&&O!==-1;O--,_++)x+=256*L[O]>>>0,L[O]=x%a>>>0,x=x/a>>>0;if(x!==0)throw new Error("Non-zero carry");g=_,S++}for(var T=E-g;T!==E&&L[T]===0;)T++;for(var I=c.repeat(y);T<E;++T)I+=r.charAt(L[T]);return I}function f(m){if(typeof m!="string")throw new TypeError("Expected String");if(m.length===0)return new Uint8Array;var y=0;if(m[y]!==" "){for(var g=0,S=0;m[y]===c;)g++,y++;for(var v=(m.length-y)*u+1>>>0,E=new Uint8Array(v);m[y];){var L=e[m.charCodeAt(y)];if(L===255)return;for(var x=0,_=v-1;(L!==0||x<S)&&_!==-1;_--,x++)L+=a*E[_]>>>0,E[_]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");S=x,y++}if(m[y]!==" "){for(var O=v-S;O!==v&&E[O]===0;)O++;for(var T=new Uint8Array(g+(v-O)),I=g;O!==v;)T[I++]=E[O++];return T}}}function p(m){var y=f(m);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:h,decodeUnsafe:f,decode:p}}var Zm=Xm,Qm=Zm;class Jm{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}let jm=class{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseDecode");l(this,"prefixCodePoint");this.name=t,this.prefix=e;const s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return gd(this,t)}};class eg{constructor(t){l(this,"decoders");this.decoders=t}or(t){return gd(this,t)}decode(t){const e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function gd(r,t){return new eg({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}class tg{constructor(t,e,n,s){l(this,"name");l(this,"prefix");l(this,"baseEncode");l(this,"baseDecode");l(this,"encoder");l(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Jm(t,e,n),this.decoder=new jm(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function Ui({name:r,prefix:t,encode:e,decode:n}){return new tg(r,t,e,n)}function es({name:r,prefix:t,alphabet:e}){const{encode:n,decode:s}=Qm(e,r);return Ui({prefix:t,name:r,encode:n,decode:i=>$i(s(i))})}function ng(r,t,e,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const d=t[r[u]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|d,o+=e,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=e||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function rg(r,t,e){const n=t[t.length-1]==="=",s=(1<<e)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function sg(r){const t={};for(let e=0;e<r.length;++e)t[r[e]]=e;return t}function Re({name:r,prefix:t,bitsPerChar:e,alphabet:n}){const s=sg(n);return Ui({prefix:t,name:r,encode(i){return rg(i,n,e)},decode(i){return ng(i,s,e,r)}})}const Te=es({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),ig=es({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),og=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Te,base58flickr:ig},Symbol.toStringTag,{value:"Module"})),Vt=Re({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ag=Re({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),cg=Re({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),lg=Re({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ug=Re({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),dg=Re({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),hg=Re({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),fg=Re({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),mg=Re({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),gg=Object.freeze(Object.defineProperty({__proto__:null,base32:Vt,base32hex:ug,base32hexpad:hg,base32hexpadupper:fg,base32hexupper:dg,base32pad:cg,base32padupper:lg,base32upper:ag,base32z:mg},Symbol.toStringTag,{value:"Module"})),Os=es({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),pg=es({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),yg=Object.freeze(Object.defineProperty({__proto__:null,base36:Os,base36upper:pg},Symbol.toStringTag,{value:"Module"}));var wg=pd,Rc=128,bg=-128,Eg=Math.pow(2,31);function pd(r,t,e){t=t||[],e=e||0;for(var n=e;r>=Eg;)t[e++]=r&255|Rc,r/=128;for(;r&bg;)t[e++]=r&255|Rc,r>>>=7;return t[e]=r|0,pd.bytes=e-n+1,t}var vg=Ho,Sg=128,kc=127;function Ho(r,n){var e=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw Ho.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&kc)<<s:(o&kc)*Math.pow(2,s),s+=7}while(o>=Sg);return Ho.bytes=i-n,e}var xg=Math.pow(2,7),Ag=Math.pow(2,14),Cg=Math.pow(2,21),_g=Math.pow(2,28),Ig=Math.pow(2,35),Tg=Math.pow(2,42),Lg=Math.pow(2,49),Dg=Math.pow(2,56),Pg=Math.pow(2,63),Rg=function(r){return r<xg?1:r<Ag?2:r<Cg?3:r<_g?4:r<Ig?5:r<Tg?6:r<Lg?7:r<Dg?8:r<Pg?9:10},kg={encode:wg,decode:vg,encodingLength:Rg},js=kg;function Go(r,t=0){return[js.decode(r,t),js.decode.bytes]}function ei(r,t,e=0){return js.encode(r,t,e),t}function ti(r){return js.encodingLength(r)}function zi(r,t){const e=t.byteLength,n=ti(r),s=n+ti(e),i=new Uint8Array(s+e);return ei(r,i,0),ei(e,i,n),i.set(t,s),new za(r,e,t,i)}function ts(r){const t=$i(r),[e,n]=Go(t),[s,i]=Go(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new za(e,s,o,t)}function Mg(r,t){if(r===t)return!0;{const e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&Hm(r.bytes,e.bytes)}}class za{constructor(t,e,n,s){l(this,"code");l(this,"size");l(this,"digest");l(this,"bytes");this.code=t,this.size=e,this.digest=n,this.bytes=s}}function Mc(r,t){const{bytes:e,version:n}=r;switch(n){case 0:return Og(e,Yo(r),t??Te.encoder);default:return Fg(e,Yo(r),t??Vt.encoder)}}const Nc=new WeakMap;function Yo(r){const t=Nc.get(r);if(t==null){const e=new Map;return Nc.set(r,e),e}return t}var bu;class me{constructor(t,e,n,s){l(this,"code");l(this,"version");l(this,"multihash");l(this,"bytes");l(this,"/");l(this,bu,"CID");this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==gr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Bg)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return me.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,n=zi(t,e);return me.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return me.equals(this,t)}static equals(t,e){const n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Mg(t.multihash,n.multihash)}toString(t){return Mc(this,t)}toJSON(){return{"/":Mc(this)}}link(){return this}[(bu=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof me)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:n,code:s,multihash:i,bytes:o}=e;return new me(n,s,i,o??Oc(n,s,i.bytes))}else if(e[$g]===!0){const{version:n,multihash:s,code:i}=e,o=ts(s);return me.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==gr)throw new Error(`Version 0 CID must use dag-pb (code: ${gr}) block encoding`);return new me(t,e,n,n.bytes)}case 1:{const s=Oc(t,e,n.bytes);return new me(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return me.create(0,gr,t)}static createV1(t,e){return me.create(1,t,e)}static decode(t){const[e,n]=me.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=me.inspectBytes(t),n=e.size-e.multihashSize,s=$i(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=s.subarray(e.multihashSize-e.digestSize),o=new za(e.multihashCode,e.digestSize,i,s);return[e.version===0?me.createV0(o):me.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const n=()=>{const[h,f]=Go(t.subarray(e));return e+=f,h};let s=n(),i=gr;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=e,a=n(),c=n(),u=e+c,d=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:u}}static parse(t,e){const[n,s]=Ng(t,e),i=me.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Yo(i).set(n,t),i}}function Ng(r,t){switch(r[0]){case"Q":{const e=t??Te;return[Te.prefix,e.decode(`${Te.prefix}${r}`)]}case Te.prefix:{const e=t??Te;return[Te.prefix,e.decode(r)]}case Vt.prefix:{const e=t??Vt;return[Vt.prefix,e.decode(r)]}case Os.prefix:{const e=t??Os;return[Os.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Og(r,t,e){const{prefix:n}=e;if(n!==Te.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const s=t.get(n);if(s==null){const i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Fg(r,t,e){const{prefix:n}=e,s=t.get(n);if(s==null){const i=e.encode(r);return t.set(n,i),i}else return s}const gr=112,Bg=18;function Oc(r,t,e){const n=ti(r),s=n+ti(t),i=new Uint8Array(s+e.byteLength);return ei(r,i,0),ei(t,i,n),i.set(e,s),i}const $g=Symbol.for("@ipld/js-cid/CID"),yd=0,Ug="identity",wd=$i;function zg(r,t){if((t==null?void 0:t.truncate)!=null&&t.truncate!==r.byteLength){if(t.truncate<0||t.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t.truncate)}return zi(yd,wd(r))}const ns={code:yd,name:Ug,encode:wd,digest:zg};function Ke(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function ae(r=0){return new Uint8Array(r)}function pt(r=0){return new Uint8Array(r)}function Ht(r,t){t==null&&(t=r.reduce((s,i)=>s+i.length,0));const e=pt(t);let n=0;for(const s of r)e.set(s,n),n+=s.length;return e}const bd=Symbol.for("@achingbrain/uint8arraylist");function Fc(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(const n of r){const s=e+n.byteLength;if(t<s)return{buf:n,index:t-e};e=s}throw new RangeError("index is out of bounds")}function fs(r){return!!(r!=null&&r[bd])}var Eu;class j{constructor(...t){l(this,"bufs");l(this,"length");l(this,Eu,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(Eu=bd,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(const n of t)if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.push(n);else if(fs(n))e+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(const n of t.reverse())if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.unshift(n);else if(fs(n))e+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){const e=Fc(this.bufs,t);return e.buf[e.index]}set(t,e){const n=Fc(this.bufs,t);n.buf[n.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let n=0;n<t.length;n++)this.set(e+n,t[n]);else if(fs(t))for(let n=0;n<t.length;n++)this.set(e+n,t.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){const{bufs:n,length:s}=this._subList(t,e);return Ht(n,s)}subarray(t,e){const{bufs:n,length:s}=this._subList(t,e);return n.length===1?n[0]:Ht(n,s)}sublist(t,e){const{bufs:n,length:s}=this._subList(t,e),i=new j;return i.length=s,i.bufs=[...n],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const u=t>=a&&t<c,d=e>a&&e<=c;if(u&&d){if(t===a&&e===c){n.push(o);break}const h=t-a;n.push(o.subarray(h,h+(e-t)));break}if(u){if(t===0){n.push(o);continue}n.push(o.subarray(t-a));continue}if(d){if(e===c){n.push(o);break}n.push(o.subarray(0,e-a));break}n.push(o)}return{bufs:n,length:e-t}}indexOf(t,e=0){if(!fs(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,u=n.byteLength-1;let d;for(let h=e;h<=c;h+=d){d=0;for(let f=u;f>=0;f--){const p=this.get(h+f);if(n[f]!==p){d=Math.max(1,f-a[p]);break}}if(d===0)return h}return-1}getInt8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){const n=pt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,e),this.write(n,t)}getInt16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,e)}setInt16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,e,n),this.write(s,t)}getInt32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,e)}setInt32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,e,n),this.write(s,t)}getBigInt64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,e)}setBigInt64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,e,n),this.write(s,t)}getUint8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){const n=pt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,e),this.write(n,t)}getUint16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,e)}setUint16(t,e,n){const s=ae(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,e,n),this.write(s,t)}getUint32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,e)}setUint32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,e,n),this.write(s,t)}getBigUint64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,e)}setBigUint64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,e,n),this.write(s,t)}getFloat32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,e)}setFloat32(t,e,n){const s=ae(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,e,n),this.write(s,t)}getFloat64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,e)}setFloat64(t,e,n){const s=ae(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,e,n),this.write(s,t)}equals(t){if(t==null||!(t instanceof j)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!Ke(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){const n=new j;return n.bufs=t,e==null&&(e=t.reduce((s,i)=>s+i.byteLength,0)),n.length=e,n}}const qg=es({prefix:"9",name:"base10",alphabet:"0123456789"}),Kg=Object.freeze(Object.defineProperty({__proto__:null,base10:qg},Symbol.toStringTag,{value:"Module"})),Vg=Re({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Wg=Re({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Hg=Object.freeze(Object.defineProperty({__proto__:null,base16:Vg,base16upper:Wg},Symbol.toStringTag,{value:"Module"})),Gg=Re({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Yg=Object.freeze(Object.defineProperty({__proto__:null,base2:Gg},Symbol.toStringTag,{value:"Module"})),Ed=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Xg=Ed.reduce((r,t,e)=>(r[e]=t,r),[]),Zg=Ed.reduce((r,t,e)=>{const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Qg(r){return r.reduce((t,e)=>(t+=Xg[e],t),"")}function Jg(r){const t=[];for(const e of r){const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);const s=Zg[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}const jg=Ui({prefix:"ðŸš€",name:"base256emoji",encode:Qg,decode:Jg}),ep=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:jg},Symbol.toStringTag,{value:"Module"})),vd=Re({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),tp=Re({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Sd=Re({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),np=Re({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),rp=Object.freeze(Object.defineProperty({__proto__:null,base64:vd,base64pad:tp,base64url:Sd,base64urlpad:np},Symbol.toStringTag,{value:"Module"})),sp=Re({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ip=Object.freeze(Object.defineProperty({__proto__:null,base8:sp},Symbol.toStringTag,{value:"Module"})),op=Ui({prefix:"\0",name:"identity",encode:r=>Ym(r),decode:r=>Gm(r)}),ap=Object.freeze(Object.defineProperty({__proto__:null,identity:op},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const cp=20;function lp({name:r,code:t,encode:e,minDigestLength:n,maxDigestLength:s}){return new up(r,t,e,n,s)}class up{constructor(t,e,n,s,i){l(this,"name");l(this,"code");l(this,"encode");l(this,"minDigestLength");l(this,"maxDigestLength");this.name=t,this.code=e,this.encode=n,this.minDigestLength=s??cp,this.maxDigestLength=i}digest(t,e){if((e==null?void 0:e.truncate)!=null){if(e.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&e.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const n=this.encode(t);return n instanceof Uint8Array?Bc(n,this.code,e==null?void 0:e.truncate):n.then(s=>Bc(s,this.code,e==null?void 0:e.truncate))}else throw Error("Unknown type, must be binary type")}}function Bc(r,t,e){if(e!=null&&e!==r.byteLength){if(e>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e)}return zi(t,r)}function dp(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}const xd=lp({name:"sha2-256",code:18,encode:dp("SHA-256")}),Xo={...ap,...Yg,...ip,...Kg,...Hg,...gg,...yg,...og,...rp,...ep};function Ad(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}const $c=Ad("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ro=Ad("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);const t=pt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),Cd={utf8:$c,"utf-8":$c,hex:Xo.base16,latin1:ro,ascii:ro,binary:ro,...Xo};function X(r,t="utf8"){const e=Cd[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function J(r,t="utf8"){const e=Cd[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}const hp=parseInt("11111",2),Zo=parseInt("10000000",2),fp=parseInt("01111111",2),Uc={0:pr,1:pr,2:mp,3:yp,4:wp,5:pp,6:gp,16:pr,22:pr,48:pr};function qi(r,t={offset:0}){const e=r[t.offset]&hp;if(t.offset++,Uc[e]!=null)return Uc[e](r,t);throw new Error("No decoder for tag "+e)}function rs(r,t){let e=0;if((r[t.offset]&Zo)===Zo){const n=r[t.offset]&fp;let s="0x";t.offset++;for(let i=0;i<n;i++,t.offset++)s+=r[t.offset].toString(16).padStart(2,"0");e=parseInt(s,16)}else e=r[t.offset],t.offset++;return e}function pr(r,t){rs(r,t);const e=[];for(;!(t.offset>=r.byteLength);){const n=qi(r,t);if(n===null)break;e.push(n)}return e}function mp(r,t){const e=rs(r,t),n=t.offset,s=t.offset+e,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return t.offset+=e,Uint8Array.from(i)}function gp(r,t){const e=rs(r,t),n=t.offset+e,s=r[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const u=r[t.offset];if(t.offset++,c.push(u&127),u<128){c.reverse();let d=0;for(let h=0;h<c.length;h++)d+=c[h]<<h*7;a+=`.${d}`,c=[]}}return a}function pp(r,t){return t.offset++,null}function yp(r,t){const e=rs(r,t),n=r[t.offset];t.offset++;const s=r.subarray(t.offset,t.offset+e-1);if(t.offset+=e,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function wp(r,t){const e=rs(r,t),n=r.subarray(t.offset,t.offset+e);return t.offset+=e,n}function bp(r){let t=r.toString(16);t.length%2===1&&(t="0"+t);const e=new j;for(let n=0;n<t.length;n+=2)e.append(Uint8Array.from([parseInt(`${t[n]}${t[n+1]}`,16)]));return e}function qa(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const t=bp(r.byteLength);return new j(Uint8Array.from([t.byteLength|Zo]),t)}function Qo(r){const t=new j,e=128;return(r.subarray()[0]&e)===e&&t.append(Uint8Array.from([0])),t.append(r),new j(Uint8Array.from([2]),qa(t),t)}function _d(r){const t=Uint8Array.from([0]),e=new j(t,r);return new j(Uint8Array.from([3]),qa(e),e)}function Dr(r,t=48){const e=new j;for(const n of r)e.append(n);return new j(Uint8Array.from([t]),qa(e),e)}async function Ep(r,t,e,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const vp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Sp=Uint8Array.from([6,5,43,129,4,0,34]),xp=Uint8Array.from([6,5,43,129,4,0,35]),Ap={ext:!0,kty:"EC",crv:"P-256"},Cp={ext:!0,kty:"EC",crv:"P-384"},_p={ext:!0,kty:"EC",crv:"P-521"},so=32,io=48,oo=66;function Id(r){const t=qi(r);return Ip(t)}function Ip(r){const t=r[1][1][0],e=1;let n,s;if(t.byteLength===so*2+1)return n=J(t.subarray(e,e+so),"base64url"),s=J(t.subarray(e+so),"base64url"),new ao({...Ap,key_ops:["verify"],x:n,y:s});if(t.byteLength===io*2+1)return n=J(t.subarray(e,e+io),"base64url"),s=J(t.subarray(e+io),"base64url"),new ao({...Cp,key_ops:["verify"],x:n,y:s});if(t.byteLength===oo*2+1)return n=J(t.subarray(e,e+oo),"base64url"),s=J(t.subarray(e+oo),"base64url"),new ao({..._p,key_ops:["verify"],x:n,y:s});throw new G(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Tp(r){return Dr([Qo(Uint8Array.from([1])),Dr([Lp(r.crv)],160),Dr([_d(new j(Uint8Array.from([4]),X(r.x??"","base64url"),X(r.y??"","base64url")))],161)]).subarray()}function Lp(r){if(r==="P-256")return vp;if(r==="P-384")return Sp;if(r==="P-521")return xp;throw new G(`Invalid curve ${r}`)}class ao{constructor(t){l(this,"type","ECDSA");l(this,"jwk");l(this,"_raw");this.jwk=t}get raw(){return this._raw==null&&(this._raw=Tp(this.jwk)),this._raw}toMultihash(){return ns.digest(It(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Te.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}async verify(t,e,n){return Ep(this.jwk,e,t,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ki(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Gt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function Y(r,t,e=""){const n=Ki(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Vi(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Gt(r.outputLen),Gt(r.blockLen)}function ni(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Dp(r,t){Y(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function fn(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function co(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function ut(r,t){return r<<32-t|r>>>t}const Td=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Pp=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function ss(r){if(Y(r),Td)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=Pp[r[e]];return t}const wt={_0:48,_9:57,A:65,F:70,a:97,f:102};function zc(r){if(r>=wt._0&&r<=wt._9)return r-wt._0;if(r>=wt.A&&r<=wt.F)return r-(wt.A-10);if(r>=wt.a&&r<=wt.f)return r-(wt.a-10)}function $r(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Td)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=zc(r.charCodeAt(i)),a=zc(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function gt(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];Y(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function Ld(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function is(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(t==null?void 0:t.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Dd=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Rp(r,t,e){return r&t^~r&e}function kp(r,t,e){return r&t^r&e^t&e}class Pd{constructor(t,e,n,s){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=co(this.buffer)}update(t){ni(this),Y(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=co(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ni(this),Dp(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,fn(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)e[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=co(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,d[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const Rt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ke=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ms=BigInt(2**32-1),qc=BigInt(32);function Mp(r,t=!1){return t?{h:Number(r&ms),l:Number(r>>qc&ms)}:{h:Number(r>>qc&ms)|0,l:Number(r&ms)|0}}function Np(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=Mp(r[i],t);[n[i],s[i]]=[o,a]}return[n,s]}const Kc=(r,t,e)=>r>>>e,Vc=(r,t,e)=>r<<32-e|t>>>e,xn=(r,t,e)=>r>>>e|t<<32-e,An=(r,t,e)=>r<<32-e|t>>>e,gs=(r,t,e)=>r<<64-e|t>>>e-32,ps=(r,t,e)=>r>>>e-32|t<<64-e;function bt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Op=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Fp=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Bp=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),$p=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,Up=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),zp=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,qp=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),kt=new Uint32Array(64);class Kp extends Pd{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)kt[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=kt[h-15],p=kt[h-2],m=ut(f,7)^ut(f,18)^f>>>3,y=ut(p,17)^ut(p,19)^p>>>10;kt[h]=y+kt[h-7]+m+kt[h-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let h=0;h<64;h++){const f=ut(a,6)^ut(a,11)^ut(a,25),p=d+f+Rp(a,c,u)+qp[h]+kt[h]|0,y=(ut(n,2)^ut(n,13)^ut(n,22))+kp(n,s,i)|0;d=u,u=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){fn(kt)}destroy(){this.set(0,0,0,0,0,0,0,0),fn(this.buffer)}}class Vp extends Kp{constructor(){super(32);l(this,"A",Rt[0]|0);l(this,"B",Rt[1]|0);l(this,"C",Rt[2]|0);l(this,"D",Rt[3]|0);l(this,"E",Rt[4]|0);l(this,"F",Rt[5]|0);l(this,"G",Rt[6]|0);l(this,"H",Rt[7]|0)}}const Rd=Np(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Wp=Rd[0],Hp=Rd[1],Mt=new Uint32Array(80),Nt=new Uint32Array(80);class Gp extends Pd{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:d,Fh:h,Fl:f,Gh:p,Gl:m,Hh:y,Hl:g}=this;return[t,e,n,s,i,o,a,c,u,d,h,f,p,m,y,g]}set(t,e,n,s,i,o,a,c,u,d,h,f,p,m,y,g){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=d|0,this.Fh=h|0,this.Fl=f|0,this.Gh=p|0,this.Gl=m|0,this.Hh=y|0,this.Hl=g|0}process(t,e){for(let E=0;E<16;E++,e+=4)Mt[E]=t.getUint32(e),Nt[E]=t.getUint32(e+=4);for(let E=16;E<80;E++){const L=Mt[E-15]|0,x=Nt[E-15]|0,_=xn(L,x,1)^xn(L,x,8)^Kc(L,x,7),O=An(L,x,1)^An(L,x,8)^Vc(L,x,7),T=Mt[E-2]|0,I=Nt[E-2]|0,$=xn(T,I,19)^gs(T,I,61)^Kc(T,I,6),U=An(T,I,19)^ps(T,I,61)^Vc(T,I,6),M=Bp(O,U,Nt[E-7],Nt[E-16]),N=$p(M,_,$,Mt[E-7],Mt[E-16]);Mt[E]=N|0,Nt[E]=M|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:d,Eh:h,El:f,Fh:p,Fl:m,Gh:y,Gl:g,Hh:S,Hl:v}=this;for(let E=0;E<80;E++){const L=xn(h,f,14)^xn(h,f,18)^gs(h,f,41),x=An(h,f,14)^An(h,f,18)^ps(h,f,41),_=h&p^~h&y,O=f&m^~f&g,T=Up(v,x,O,Hp[E],Nt[E]),I=zp(T,S,L,_,Wp[E],Mt[E]),$=T|0,U=xn(n,s,28)^gs(n,s,34)^gs(n,s,39),M=An(n,s,28)^ps(n,s,34)^ps(n,s,39),N=n&i^n&a^i&a,w=s&o^s&c^o&c;S=y|0,v=g|0,y=p|0,g=m|0,p=h|0,m=f|0,{h,l:f}=bt(u|0,d|0,I|0,$|0),u=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=Op($,M,w);n=Fp(b,I,U,N),s=b|0}({h:n,l:s}=bt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=bt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=bt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:d}=bt(this.Dh|0,this.Dl|0,u|0,d|0),{h,l:f}=bt(this.Eh|0,this.El|0,h|0,f|0),{h:p,l:m}=bt(this.Fh|0,this.Fl|0,p|0,m|0),{h:y,l:g}=bt(this.Gh|0,this.Gl|0,y|0,g|0),{h:S,l:v}=bt(this.Hh|0,this.Hl|0,S|0,v|0),this.set(n,s,i,o,a,c,u,d,h,f,p,m,y,g,S,v)}roundClean(){fn(Mt,Nt)}destroy(){fn(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Yp extends Gp{constructor(){super(64);l(this,"Ah",ke[0]|0);l(this,"Al",ke[1]|0);l(this,"Bh",ke[2]|0);l(this,"Bl",ke[3]|0);l(this,"Ch",ke[4]|0);l(this,"Cl",ke[5]|0);l(this,"Dh",ke[6]|0);l(this,"Dl",ke[7]|0);l(this,"Eh",ke[8]|0);l(this,"El",ke[9]|0);l(this,"Fh",ke[10]|0);l(this,"Fl",ke[11]|0);l(this,"Gh",ke[12]|0);l(this,"Gl",ke[13]|0);l(this,"Hh",ke[14]|0);l(this,"Hl",ke[15]|0)}}const Pr=Ld(()=>new Vp,Dd(1)),Xp=Ld(()=>new Yp,Dd(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ka=BigInt(0),Jo=BigInt(1);function mn(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function kd(r){if(typeof r=="bigint"){if(!Fs(r))throw new Error("positive bigint expected, got "+r)}else Gt(r);return r}function ys(r){const t=kd(r).toString(16);return t.length&1?"0"+t:t}function Md(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ka:BigInt("0x"+r)}function Wi(r){return Md(ss(r))}function gn(r){return Md(ss(Ur(Y(r)).reverse()))}function Va(r,t){Gt(t),r=kd(r);const e=$r(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function Wa(r,t){return Va(r,t).reverse()}function Ur(r){return Uint8Array.from(r)}const Fs=r=>typeof r=="bigint"&&Ka<=r;function Zp(r,t,e){return Fs(r)&&Fs(t)&&Fs(e)&&t<=r&&r<e}function zr(r,t,e,n){if(!Zp(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Qp(r){let t;for(t=0;r>Ka;r>>=Jo,t+=1);return t}const Ha=r=>(Jo<<BigInt(r))-Jo;function Jp(r,t,e){if(Gt(r,"hashLen"),Gt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=g=>new Uint8Array(g),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),d=0;const h=()=>{c.fill(1),u.fill(0),d=0},f=(...g)=>e(u,gt(c,...g)),p=(g=s)=>{u=f(i,g),c=f(),g.length!==0&&(u=f(o,g),c=f())},m=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let g=0;const S=[];for(;g<t;){c=f();const v=c.slice();S.push(v),g+=c.length}return gt(...S)};return(g,S)=>{h(),p(g);let v;for(;!(v=S(m()));)p();return h(),v}}function lr(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(t,!1),s(e,!0)}function ri(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ge=BigInt(0),Pe=BigInt(1),tn=BigInt(2),Nd=BigInt(3),Od=BigInt(4),Fd=BigInt(5),jp=BigInt(7),Bd=BigInt(8),ey=BigInt(9),$d=BigInt(16);function be(r,t){const e=r%t;return e>=Ge?e:t+e}function we(r,t,e){let n=r;for(;t-- >Ge;)n*=n,n%=e;return n}function Wc(r,t){if(r===Ge)throw new Error("invert: expected non-zero number");if(t<=Ge)throw new Error("invert: expected positive modulus, got "+t);let e=be(r,t),n=t,s=Ge,i=Pe;for(;e!==Ge;){const a=n/e,c=n%e,u=s-i*a;n=e,e=c,s=i,i=u}if(n!==Pe)throw new Error("invert: does not exist");return be(s,t)}function Ga(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function Ud(r,t){const e=(r.ORDER+Pe)/Od,n=r.pow(t,e);return Ga(r,n,t),n}function ty(r,t){const e=(r.ORDER-Fd)/Bd,n=r.mul(t,tn),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,tn),s),a=r.mul(i,r.sub(o,r.ONE));return Ga(r,a,t),a}function ny(r){const t=Hi(r),e=zd(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+jp)/$d;return(a,c)=>{let u=a.pow(c,o),d=a.mul(u,n);const h=a.mul(u,s),f=a.mul(u,i),p=a.eql(a.sqr(d),c),m=a.eql(a.sqr(h),c);u=a.cmov(u,d,p),d=a.cmov(f,h,m);const y=a.eql(a.sqr(d),c),g=a.cmov(u,d,y);return Ga(a,g,c),g}}function zd(r){if(r<Nd)throw new Error("sqrt is not defined for small field");let t=r-Pe,e=0;for(;t%tn===Ge;)t/=tn,e++;let n=tn;const s=Hi(r);for(;Hc(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Ud;let i=s.pow(n,t);const o=(t+Pe)/tn;return function(c,u){if(c.is0(u))return u;if(Hc(c,u)!==1)throw new Error("Cannot find square root");let d=e,h=c.mul(c.ONE,i),f=c.pow(u,t),p=c.pow(u,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let m=1,y=c.sqr(f);for(;!c.eql(y,c.ONE);)if(m++,y=c.sqr(y),m===d)throw new Error("Cannot find square root");const g=Pe<<BigInt(d-m-1),S=c.pow(h,g);d=m,h=c.sqr(S),f=c.mul(f,h),p=c.mul(p,S)}return p}}function ry(r){return r%Od===Nd?Ud:r%Bd===Fd?ty:r%$d===ey?ny(r):zd(r)}const sy=(r,t)=>(be(r,t)&Pe)===Pe,iy=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function oy(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=iy.reduce((n,s)=>(n[s]="function",n),t);return lr(r,e),r}function ay(r,t,e){if(e<Ge)throw new Error("invalid exponent, negatives unsupported");if(e===Ge)return r.ONE;if(e===Pe)return t;let n=r.ONE,s=t;for(;e>Ge;)e&Pe&&(n=r.mul(n,s)),s=r.sqr(s),e>>=Pe;return n}function qd(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return t.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function Hc(r,t){const e=(r.ORDER-Pe)/tn,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function cy(r,t){t!==void 0&&Gt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ly{constructor(t,e={}){l(this,"ORDER");l(this,"BITS");l(this,"BYTES");l(this,"isLE");l(this,"ZERO",Ge);l(this,"ONE",Pe);l(this,"_lengths");l(this,"_sqrt");l(this,"_mod");var o;if(t<=Ge)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=(o=e.allowedLengths)==null?void 0:o.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=cy(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return be(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return Ge<=t&&t<this.ORDER}is0(t){return t===Ge}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&Pe)===Pe}neg(t){return be(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return be(t*t,this.ORDER)}add(t,e){return be(t+e,this.ORDER)}sub(t,e){return be(t-e,this.ORDER)}mul(t,e){return be(t*e,this.ORDER)}pow(t,e){return ay(this,t,e)}div(t,e){return be(t*Wc(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return Wc(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=ry(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Wa(t,this.BYTES):Va(t,this.BYTES)}fromBytes(t,e=!1){Y(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?gn(t):Wi(t);if(a&&(c=be(c,o)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return qd(this,t)}cmov(t,e,n){return n?e:t}}function Hi(r,t={}){return new ly(r,t)}function Kd(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function Vd(r){const t=Kd(r);return t+Math.ceil(t/2)}function uy(r,t,e=!1){Y(r);const n=r.length,s=Kd(t),i=Vd(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?gn(r):Wi(r),a=be(o,t-Pe)+Pe;return e?Wa(a,s):Va(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Hn=BigInt(0),nn=BigInt(1);function si(r,t){const e=t.negate();return r?e:t}function Rr(r,t){const e=qd(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function Wd(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function lo(r,t){Wd(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=Ha(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function Gc(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=nn);const u=t*n,d=u+Math.abs(a)-1,h=a===0,f=a<0,p=t%2!==0;return{nextN:c,offset:d,isZero:h,isNeg:f,isNegF:p,offsetF:u}}const uo=new WeakMap,Hd=new WeakMap;function ho(r){return Hd.get(r)||1}function Yc(r){if(r!==Hn)throw new Error("invalid wNAF")}class Gd{constructor(t,e){l(this,"BASE");l(this,"ZERO");l(this,"Fn");l(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Hn;)e&nn&&(n=n.add(s)),s=s.double(),e>>=nn;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=lo(e,this.bits),i=[];let o=t,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=lo(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:f,offsetF:p}=Gc(n,a,o);n=c,d?i=i.add(si(f,e[p])):s=s.add(si(h,e[u]))}return Yc(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=lo(t,this.bits);for(let o=0;o<i.windows&&n!==Hn;o++){const{nextN:a,offset:c,isZero:u,isNeg:d}=Gc(n,o,i);if(n=a,!u){const h=e[c];s=s.add(d?h.negate():h)}}return Yc(n),s}getPrecomputes(t,e,n){let s=uo.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),uo.set(e,s))),s}cached(t,e,n){const s=ho(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=ho(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){Wd(e,this.bits),Hd.set(t,e),uo.delete(t)}hasCache(t){return ho(t)!==1}}function dy(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>Hn||n>Hn;)e&nn&&(i=i.add(s)),n&nn&&(o=o.add(s)),s=s.double(),e>>=nn,n>>=nn;return{p1:i,p2:o}}function Xc(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return oy(t),t}else return Hi(r,{isLE:e})}function Yd(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>Hn))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Xc(t.p,e.Fp,n),i=Xc(t.n,e.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function Ya(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ot=BigInt(0),Ce=BigInt(1),fo=BigInt(2),hy=BigInt(8);function fy(r,t,e,n){const s=r.sqr(e),i=r.sqr(n),o=r.add(r.mul(t.a,s),i),a=r.add(r.ONE,r.mul(t.d,r.mul(s,i)));return r.eql(o,a)}function my(r,t={}){const e=Yd("edwards",r,t,t.FpFnLE),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o}=i;lr(t,{},{uvRatio:"function"});const a=fo<<BigInt(s.BYTES*8)-Ce,c=S=>n.create(S),u=t.uvRatio||((S,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(S,v))}}catch{return{isValid:!1,value:Ot}}});if(!fy(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(S,v,E=!1){const L=E?Ce:Ot;return zr("coordinate "+S,v,L,a),v}function h(S){if(!(S instanceof m))throw new Error("EdwardsPoint expected")}const f=ri((S,v)=>{const{X:E,Y:L,Z:x}=S,_=S.is0();v==null&&(v=_?hy:n.inv(x));const O=c(E*v),T=c(L*v),I=n.mul(x,v);if(_)return{x:Ot,y:Ce};if(I!==Ce)throw new Error("invZ was invalid");return{x:O,y:T}}),p=ri(S=>{const{a:v,d:E}=i;if(S.is0())throw new Error("bad point: ZERO");const{X:L,Y:x,Z:_,T:O}=S,T=c(L*L),I=c(x*x),$=c(_*_),U=c($*$),M=c(T*v),N=c($*c(M+I)),w=c(U+c(E*c(T*I)));if(N!==w)throw new Error("bad point: equation left != right (1)");const b=c(L*x),C=c(_*O);if(b!==C)throw new Error("bad point: equation left != right (2)");return!0}),g=class g{constructor(v,E,L,x){l(this,"X");l(this,"Y");l(this,"Z");l(this,"T");this.X=d("x",v),this.Y=d("y",E),this.Z=d("z",L,!0),this.T=d("t",x),Object.freeze(this)}static CURVE(){return i}static fromAffine(v){if(v instanceof g)throw new Error("extended point not allowed");const{x:E,y:L}=v||{};return d("x",E),d("y",L),new g(E,L,Ce,c(E*L))}static fromBytes(v,E=!1){const L=n.BYTES,{a:x,d:_}=i;v=Ur(Y(v,L,"point")),mn(E,"zip215");const O=Ur(v),T=v[L-1];O[L-1]=T&-129;const I=gn(O),$=E?a:n.ORDER;zr("point.y",I,Ot,$);const U=c(I*I),M=c(U-Ce),N=c(_*U-x);let{isValid:w,value:b}=u(M,N);if(!w)throw new Error("bad point: invalid y coordinate");const C=(b&Ce)===Ce,P=(T&128)!==0;if(!E&&b===Ot&&P)throw new Error("bad point: x=0 and x_0=1");return P!==C&&(b=c(-b)),g.fromAffine({x:b,y:I})}static fromHex(v,E=!1){return g.fromBytes($r(v),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,E=!0){return y.createCache(this,v),E||this.multiply(fo),this}assertValidity(){p(this)}equals(v){h(v);const{X:E,Y:L,Z:x}=this,{X:_,Y:O,Z:T}=v,I=c(E*T),$=c(_*x),U=c(L*T),M=c(O*x);return I===$&&U===M}is0(){return this.equals(g.ZERO)}negate(){return new g(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=i,{X:E,Y:L,Z:x}=this,_=c(E*E),O=c(L*L),T=c(fo*c(x*x)),I=c(v*_),$=E+L,U=c(c($*$)-_-O),M=I+O,N=M-T,w=I-O,b=c(U*N),C=c(M*w),P=c(U*w),k=c(N*M);return new g(b,C,k,P)}add(v){h(v);const{a:E,d:L}=i,{X:x,Y:_,Z:O,T}=this,{X:I,Y:$,Z:U,T:M}=v,N=c(x*I),w=c(_*$),b=c(T*L*M),C=c(O*U),P=c((x+_)*(I+$)-N-w),k=C-b,A=C+b,F=c(w-E*N),R=c(P*k),B=c(A*F),K=c(P*F),ne=c(k*A);return new g(R,B,ne,K)}subtract(v){return this.add(v.negate())}multiply(v){if(!s.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:L}=y.cached(this,v,x=>Rr(g,x));return Rr(g,[E,L])[0]}multiplyUnsafe(v,E=g.ZERO){if(!s.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===Ot?g.ZERO:this.is0()||v===Ce?this:y.unsafe(this,v,L=>Rr(g,L),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(v){return f(this,v)}clearCofactor(){return o===Ce?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:E}=this.toAffine(),L=n.toBytes(E);return L[L.length-1]|=v&Ce?128:0,L}toHex(){return ss(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(g,"BASE",new g(i.Gx,i.Gy,Ce,c(i.Gx*i.Gy))),l(g,"ZERO",new g(Ot,Ce,Ce,Ot)),l(g,"Fp",n),l(g,"Fn",s);let m=g;const y=new Gd(m,s.BITS);return m.BASE.precompute(8),m}function gy(r,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');lr(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=e,{BASE:s,Fp:i,Fn:o}=r,a=e.randomBytes||is,c=e.adjustScalarBytes||(T=>T),u=e.domain||((T,I,$)=>{if(mn($,"phflag"),I.length||$)throw new Error("Contexts/pre-hash are not supported");return T});function d(T){return o.create(gn(T))}function h(T){const I=E.secretKey;Y(T,E.secretKey,"secretKey");const $=Y(t(T),2*I,"hashedSecretKey"),U=c($.slice(0,I)),M=$.slice(I,2*I),N=d(U);return{head:U,prefix:M,scalar:N}}function f(T){const{head:I,prefix:$,scalar:U}=h(T),M=s.multiply(U),N=M.toBytes();return{head:I,prefix:$,scalar:U,point:M,pointBytes:N}}function p(T){return f(T).pointBytes}function m(T=Uint8Array.of(),...I){const $=gt(...I);return d(t(u($,Y(T,void 0,"context"),!!n)))}function y(T,I,$={}){T=Y(T,void 0,"message"),n&&(T=n(T));const{prefix:U,scalar:M,pointBytes:N}=f(I),w=m($.context,U,T),b=s.multiply(w).toBytes(),C=m($.context,b,N,T),P=o.create(w+C*M);if(!o.isValid(P))throw new Error("sign failed: invalid s");const k=gt(b,o.toBytes(P));return Y(k,E.signature,"result")}const g={zip215:!0};function S(T,I,$,U=g){const{context:M,zip215:N}=U,w=E.signature;T=Y(T,w,"signature"),I=Y(I,void 0,"message"),$=Y($,E.publicKey,"publicKey"),N!==void 0&&mn(N,"zip215"),n&&(I=n(I));const b=w/2,C=T.subarray(0,b),P=gn(T.subarray(b,w));let k,A,F;try{k=r.fromBytes($,N),A=r.fromBytes(C,N),F=s.multiplyUnsafe(P)}catch{return!1}if(!N&&k.isSmallOrder())return!1;const R=m(M,A.toBytes(),k.toBytes(),I);return A.add(k.multiplyUnsafe(R)).subtract(F).clearCofactor().is0()}const v=i.BYTES,E={secretKey:v,publicKey:v,signature:2*v,seed:v};function L(T=a(E.seed)){return Y(T,E.seed,"seed")}function x(T){return Ki(T)&&T.length===o.BYTES}function _(T,I){try{return!!r.fromBytes(T,I)}catch{return!1}}const O={getExtendedPublicKey:f,randomSecretKey:L,isValidSecretKey:x,isValidPublicKey:_,toMontgomery(T){const{y:I}=r.fromBytes(T),$=E.publicKey,U=$===32;if(!U&&$!==57)throw new Error("only defined for 25519 and 448");const M=U?i.div(Ce+I,Ce-I):i.div(I-Ce,I+Ce);return i.toBytes(M)},toMontgomerySecret(T){const I=E.secretKey;Y(T,I);const $=t(T.subarray(0,I));return c($).subarray(0,I)}};return Object.freeze({keygen:Ya(L,p),getPublicKey:p,sign:y,verify:S,utils:O,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yr=BigInt(0),Cn=BigInt(1),ws=BigInt(2);function py(r){return lr(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function yy(r){const t=py(r),{P:e,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=t,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||is,u=a?255:448,d=a?32:56,h=BigInt(a?9:5),f=BigInt(a?121665:39081),p=a?ws**BigInt(254):ws**BigInt(447),m=a?BigInt(8)*ws**BigInt(251)-Cn:BigInt(4)*ws**BigInt(445)-Cn,y=p+m+Cn,g=w=>be(w,e),S=v(h);function v(w){return Wa(g(w),d)}function E(w){const b=Ur(Y(w,d,"uCoordinate"));return a&&(b[31]&=127),g(gn(b))}function L(w){return gn(s(Ur(Y(w,d,"scalar"))))}function x(w,b){const C=$(E(b),L(w));if(C===yr)throw new Error("invalid private or public key received");return v(C)}function _(w){return x(w,S)}const O=_,T=x;function I(w,b,C){const P=g(w*(b-C));return b=g(b-P),C=g(C+P),{x_2:b,x_3:C}}function $(w,b){zr("u",w,yr,e),zr("scalar",b,p,y);const C=b,P=w;let k=Cn,A=yr,F=w,R=Cn,B=yr;for(let ne=BigInt(u-1);ne>=yr;ne--){const Q=C>>ne&Cn;B^=Q,{x_2:k,x_3:F}=I(B,k,F),{x_2:A,x_3:R}=I(B,A,R),B=Q;const W=k+A,ce=g(W*W),fe=k-A,ye=g(fe*fe),pe=ce-ye,_e=F+R,hs=F-R,mr=g(hs*W),_c=g(_e*fe),Ic=mr+_c,Tc=mr-_c;F=g(Ic*Ic),R=g(P*g(Tc*Tc)),k=g(ce*ye),A=g(pe*(ce+g(f*pe)))}({x_2:k,x_3:F}=I(B,k,F)),{x_2:A,x_3:R}=I(B,A,R);const K=i(A);return g(k*K)}const U={secretKey:d,publicKey:d,seed:d},M=(w=c(d))=>(Y(w,U.seed,"seed"),w),N={randomSecretKey:M};return Object.freeze({keygen:Ya(M,O),getSharedSecret:T,getPublicKey:O,scalarMult:x,scalarMultBase:_,utils:N,GuBytes:S.slice(),lengths:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wy=BigInt(1),Zc=BigInt(2),by=BigInt(3),Ey=BigInt(5),vy=BigInt(8),Gi=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Sy={p:Gi,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:vy,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Xd(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=Gi,a=r*r%i*r%i,c=we(a,Zc,i)*a%i,u=we(c,wy,i)*r%i,d=we(u,Ey,i)*u%i,h=we(d,t,i)*d%i,f=we(h,e,i)*h%i,p=we(f,n,i)*f%i,m=we(p,s,i)*p%i,y=we(m,s,i)*p%i,g=we(y,t,i)*d%i;return{pow_p_5_8:we(g,Zc,i)*r%i,b2:a}}function Zd(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const Qc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function xy(r,t){const e=Gi,n=be(t*t*t,e),s=be(n*n*t,e),i=Xd(r*s).pow_p_5_8;let o=be(r*n*i,e);const a=be(t*o*o,e),c=o,u=be(o*Qc,e),d=a===r,h=a===be(-r,e),f=a===be(-r*Qc,e);return d&&(o=c),(h||f)&&(o=u),sy(o,e)&&(o=be(-o,e)),{isValid:d||h,value:o}}const Ay=my(Sy,{uvRatio:xy});function Cy(r){return gy(Ay,Xp,Object.assign({adjustScalarBytes:Zd},r))}const ii=Cy({}),bs=(()=>{const r=Gi;return yy({P:r,type:"x25519",powPminus2:t=>{const{pow_p_5_8:e,b2:n}=Xd(t);return be(we(e,by,r)*n,r)},adjustScalarBytes:Zd})})();class Jc extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class _y extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const pn={get(r=globalThis){const t=r.crypto;if((t==null?void 0:t.subtle)==null)throw new _y("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},Qd=32,Xa=64,jo=32;let Pn;const Jd=(async()=>{try{return await pn.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Iy(){const r=ii.utils.randomSecretKey(),t=ii.getPublicKey(r);return{privateKey:My(r,t),publicKey:t}}async function Ty(r,t){let e;r.length===Xa?e=r.subarray(0,32):e=r;const n={crv:"Ed25519",kty:"OKP",x:J(r.subarray(32),"base64url"),d:J(e,"base64url"),ext:!0,key_ops:["sign"]},s=await pn.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await pn.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Ly(r,t){const e=r.subarray(0,jo);return ii.sign(t instanceof Uint8Array?t:t.subarray(),e)}async function Dy(r,t){return Pn==null&&(Pn=await Jd),Pn?Ty(r,t):Ly(r,t)}async function Py(r,t,e){if(r.buffer instanceof ArrayBuffer){const n=await pn.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await pn.get().subtle.verify({name:"Ed25519"},n,t,e instanceof Uint8Array?e:e.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Ry(r,t,e){return ii.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}async function ky(r,t,e){return Pn==null&&(Pn=await Jd),Pn?Py(r,t,e):Ry(r,t,e)}function My(r,t){const e=new Uint8Array(Xa);for(let n=0;n<jo;n++)e[n]=r[n],e[jo+n]=t[n];return e}function Za(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class jd{constructor(t){l(this,"type","Ed25519");l(this,"raw");this.raw=Qa(t,Qd)}toMultihash(){return ns.digest(It(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Te.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=ky(this.raw,e,t);return Za(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class Ny{constructor(t,e){l(this,"type","Ed25519");l(this,"raw");l(this,"publicKey");this.raw=Qa(t,Xa),this.publicKey=new jd(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}sign(t,e){var s,i;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const n=Dy(this.raw,t);return Za(n)?n.then(o=>{var a;return(a=e==null?void 0:e.signal)==null||a.throwIfAborted(),o}):((i=e==null?void 0:e.signal)==null||i.throwIfAborted(),n)}}function eh(r){return r=Qa(r,Qd),new jd(r)}async function Oy(){const{privateKey:r,publicKey:t}=Iy();return new Ny(r,t)}function Qa(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new G(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}const Fy=Math.pow(2,7),By=Math.pow(2,14),$y=Math.pow(2,21),Ja=Math.pow(2,28),ja=Math.pow(2,35),tc=Math.pow(2,42),nc=Math.pow(2,49),se=128,Oe=127;function Le(r){if(r<Fy)return 1;if(r<By)return 2;if(r<$y)return 3;if(r<Ja)return 4;if(r<ja)return 5;if(r<tc)return 6;if(r<nc)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function oi(r,t,e=0){switch(Le(r)){case 8:t[e++]=r&255|se,r/=128;case 7:t[e++]=r&255|se,r/=128;case 6:t[e++]=r&255|se,r/=128;case 5:t[e++]=r&255|se,r/=128;case 4:t[e++]=r&255|se,r>>>=7;case 3:t[e++]=r&255|se,r>>>=7;case 2:t[e++]=r&255|se,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function Uy(r,t,e=0){switch(Le(r)){case 8:t.set(e++,r&255|se),r/=128;case 7:t.set(e++,r&255|se),r/=128;case 6:t.set(e++,r&255|se),r/=128;case 5:t.set(e++,r&255|se),r/=128;case 4:t.set(e++,r&255|se),r>>>=7;case 3:t.set(e++,r&255|se),r>>>=7;case 2:t.set(e++,r&255|se),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function th(r,t){let e=r[t],n=0;if(n+=e&Oe,e<se||(e=r[t+1],n+=(e&Oe)<<7,e<se)||(e=r[t+2],n+=(e&Oe)<<14,e<se)||(e=r[t+3],n+=(e&Oe)<<21,e<se)||(e=r[t+4],n+=(e&Oe)*Ja,e<se)||(e=r[t+5],n+=(e&Oe)*ja,e<se)||(e=r[t+6],n+=(e&Oe)*tc,e<se)||(e=r[t+7],n+=(e&Oe)*nc,e<se))return n;throw new RangeError("Could not decode varint")}function zy(r,t){let e=r.get(t),n=0;if(n+=e&Oe,e<se||(e=r.get(t+1),n+=(e&Oe)<<7,e<se)||(e=r.get(t+2),n+=(e&Oe)<<14,e<se)||(e=r.get(t+3),n+=(e&Oe)<<21,e<se)||(e=r.get(t+4),n+=(e&Oe)*Ja,e<se)||(e=r.get(t+5),n+=(e&Oe)*ja,e<se)||(e=r.get(t+6),n+=(e&Oe)*tc,e<se)||(e=r.get(t+7),n+=(e&Oe)*nc,e<se))return n;throw new RangeError("Could not decode varint")}function kr(r,t,e=0){return t==null&&(t=pt(Le(r))),t instanceof Uint8Array?oi(r,t,e):Uy(r,t,e)}function os(r,t=0){return r instanceof Uint8Array?th(r,t):zy(r,t)}const rc=new Float32Array([-0]),zt=new Uint8Array(rc.buffer);function qy(r,t,e){rc[0]=r,t[e]=zt[0],t[e+1]=zt[1],t[e+2]=zt[2],t[e+3]=zt[3]}function Ky(r,t){return zt[0]=r[t],zt[1]=r[t+1],zt[2]=r[t+2],zt[3]=r[t+3],rc[0]}const sc=new Float64Array([-0]),Fe=new Uint8Array(sc.buffer);function Vy(r,t,e){sc[0]=r,t[e]=Fe[0],t[e+1]=Fe[1],t[e+2]=Fe[2],t[e+3]=Fe[3],t[e+4]=Fe[4],t[e+5]=Fe[5],t[e+6]=Fe[6],t[e+7]=Fe[7]}function Wy(r,t){return Fe[0]=r[t],Fe[1]=r[t+1],Fe[2]=r[t+2],Fe[3]=r[t+3],Fe[4]=r[t+4],Fe[5]=r[t+5],Fe[6]=r[t+6],Fe[7]=r[t+7],sc[0]}const Hy=BigInt(Number.MAX_SAFE_INTEGER),Gy=BigInt(Number.MIN_SAFE_INTEGER);class Be{constructor(t,e){l(this,"lo");l(this,"hi");this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return hn;if(t<Hy&&t>Gy)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>jc&&(s=0n,++n>jc&&(n=0n))),new Be(Number(s),Number(n))}static fromNumber(t){if(t===0)return hn;const e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Be(n,s)}static from(t){return typeof t=="number"?Be.fromNumber(t):typeof t=="bigint"?Be.fromBigInt(t):typeof t=="string"?Be.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new Be(t.low>>>0,t.high>>>0):hn}}const hn=new Be(0,0);hn.toBigInt=function(){return 0n};hn.zzEncode=hn.zzDecode=function(){return this};hn.length=function(){return 1};const jc=4294967296n;function Yy(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function Xy(r,t,e){if(e-t<1)return"";let s;const i=[];let o=0,a;for(;t<e;)a=r[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function nh(r,t,e){const n=e;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function nt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function Es(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}class Zy{constructor(t){l(this,"buf");l(this,"pos");l(this,"len");l(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,nt(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw nt(this,4);return Es(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw nt(this,4);return Es(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw nt(this,4);const t=Ky(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw nt(this,4);const t=Wy(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw nt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){const t=this.bytes();return Xy(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw nt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw nt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new Be(0,0);let e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw nt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw nt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw nt(this,8);const t=Es(this.buf,this.pos+=4),e=Es(this.buf,this.pos+=4);return new Be(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=th(this.buf,this.pos);return this.pos+=Le(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Qy(r){return new Zy(r instanceof Uint8Array?r:r.subarray())}function Ee(r,t,e){const n=Qy(r);return t.decode(n,void 0,e)}function Jy(r){let n,s=8192;return function(o){if(o<1||o>4096)return pt(o);s+o>8192&&(n=pt(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class vr{constructor(t,e,n){l(this,"fn");l(this,"len");l(this,"next");l(this,"val");this.fn=t,this.len=e,this.next=void 0,this.val=n}}function mo(){}class jy{constructor(t){l(this,"head");l(this,"tail");l(this,"len");l(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const ew=Jy();function tw(r){return globalThis.Buffer!=null?pt(r):ew(r)}class ea{constructor(){l(this,"len");l(this,"head");l(this,"tail");l(this,"states");this.len=0,this.head=new vr(mo,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new vr(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new rw((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(vs,10,Be.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=Be.fromBigInt(t);return this._push(vs,e.length(),e)}uint64Number(t){return this._push(oi,Le(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=Be.fromBigInt(t).zzEncode();return this._push(vs,e.length(),e)}sint64Number(t){const e=Be.fromNumber(t).zzEncode();return this._push(vs,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(go,1,t?1:0)}fixed32(t){return this._push(wr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=Be.fromBigInt(t);return this._push(wr,4,e.lo)._push(wr,4,e.hi)}fixed64Number(t){const e=Be.fromNumber(t);return this._push(wr,4,e.lo)._push(wr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(qy,4,t)}double(t){return this._push(Vy,8,t)}bytes(t){const e=t.length>>>0;return e===0?this._push(go,1,0):this.uint32(e)._push(sw,e,t)}string(t){const e=Yy(t);return e!==0?this.uint32(e)._push(nh,e,t):this._push(go,1,0)}fork(){return this.states=new jy(this),this.head=this.tail=new vr(mo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new vr(mo,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next;const e=tw(this.len);let n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}}function go(r,t,e){t[e]=r&255}function nw(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}class rw extends vr{constructor(e,n){super(nw,e,n);l(this,"next");this.next=void 0}}function vs(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function wr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function sw(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(ea.prototype.bytes=function(r){const t=r.length>>>0;return this.uint32(t),t>0&&this._push(iw,t,r),this},ea.prototype.string=function(r){const t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(ow,t,r),this});function iw(r,t,e){t.set(r,e)}function ow(r,t,e){r.length<40?nh(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(X(r),e)}function aw(){return new ea}function ve(r,t){const e=aw();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var ai;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(ai||(ai={}));function rh(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function ur(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const e=function(i,o){const a=t(i);o.int32(a)},n=function(i){const o=i.int32();return t(o)};return rh("enum",ai.VARINT,e,n)}function Se(r,t){return rh("message",ai.LENGTH_DELIMITED,r,t)}class Dt extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_LENGTH");l(this,"name","MaxLengthError")}}class el extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_SIZE");l(this,"name","MaxSizeError")}}var De;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(De||(De={}));var ta;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(ta||(ta={}));(function(r){r.codec=()=>ur(ta)})(De||(De={}));var Gn;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),De.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=De.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Gn||(Gn={}));var tl;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),De.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=De.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(tl||(tl={}));function sh(r){if(isNaN(r)||r<=0)throw new G("random bytes length must be a Number bigger than 0");return is(r)}class cw{constructor(t,e){l(this,"type","RSA");l(this,"jwk");l(this,"_raw");l(this,"_multihash");this.jwk=t,this._multihash=e}get raw(){return this._raw==null&&(this._raw=fw(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return me.createV1(114,this._multihash)}toString(){return Te.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){return pw(this.jwk,e,t,n)}}const lw=18,uw=1062,dw=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function hw(r){const t=qi(r[1],{offset:0});return{kty:"RSA",n:J(t[0],"base64url"),e:J(t[1],"base64url")}}function fw(r){if(r.n==null||r.e==null)throw new G("JWK was missing components");return Dr([dw,_d(Dr([Qo(X(r.n,"base64url")),Qo(X(r.e,"base64url"))]))]).subarray()}function mw(r,t){if(r.byteLength>=uw)throw new Ma("Key size is too large");const e=qi(r,{offset:0});return gw(e,r,t)}function gw(r,t,e){const n=hw(r);if(e==null){const s=Pr(Gn.encode({Type:De.RSA,Data:t}));e=zi(lw,s)}return new cw(n,e)}async function pw(r,t,e,n){var o,a;const s=await pn.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await pn.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,e instanceof Uint8Array?e:e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}class ih{constructor(t,e){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Vi(t),Y(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),fn(s)}update(t){return ni(this),this.iHash.update(t),this}digestInto(t){ni(this),Y(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Yi=(r,t,e)=>new ih(r,t).update(e).digest();Yi.create=(r,t)=>new ih(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nl=(r,t)=>(r+(r>=0?t:-t)/oh)/t;function yw(r,t,e){const[[n,s],[i,o]]=t,a=nl(o*r,e),c=nl(-s*r,e);let u=r-a*n-c*i,d=-a*s-c*o;const h=u<_t,f=d<_t;h&&(u=-u),f&&(d=-d);const p=Ha(Math.ceil(Qp(e)/2))+Rn;if(u<_t||u>=p||d<_t||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:f,k2:d}}function na(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function po(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return mn(e.lowS,"lowS"),mn(e.prehash,"prehash"),e.format!==void 0&&na(e.format),e}class ww extends Error{constructor(t=""){super(t)}}const Ft={Err:ww,_tlv:{encode:(r,t)=>{const{Err:e}=Ft;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=ys(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?ys(s.length/2|128):"";return ys(r)+i+s+t},decode(r,t){const{Err:e}=Ft;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+c);if(u.length!==c)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)o=o<<8|d;if(n+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=Ft;if(r<_t)throw new t("integer: negative integers are not allowed");let e=ys(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=Ft;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Wi(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=Ft,s=Y(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=Ft,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},_t=BigInt(0),Rn=BigInt(1),oh=BigInt(2),Ss=BigInt(3),bw=BigInt(4);function Ew(r,t={}){const e=Yd("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;lr(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=ch(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(N,w,b){const{x:C,y:P}=w.toAffine(),k=n.toBytes(C);if(mn(b,"isCompressed"),b){d();const A=!n.isOdd(P);return gt(ah(A),k)}else return gt(Uint8Array.of(4),k,n.toBytes(P))}function f(N){Y(N,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=u,C=N.length,P=N[0],k=N.subarray(1);if(C===w&&(P===2||P===3)){const A=n.fromBytes(k);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const F=y(A);let R;try{R=n.sqrt(F)}catch(ne){const Q=ne instanceof Error?": "+ne.message:"";throw new Error("bad point: is not on curve, sqrt error"+Q)}d();const B=n.isOdd(R);return(P&1)===1!==B&&(R=n.neg(R)),{x:A,y:R}}else if(C===b&&P===4){const A=n.BYTES,F=n.fromBytes(k.subarray(0,A)),R=n.fromBytes(k.subarray(A,A*2));if(!g(F,R))throw new Error("bad point: is not on curve");return{x:F,y:R}}else throw new Error(`bad point: got length ${C}, expected compressed=${w} or uncompressed=${b}`)}const p=t.toBytes||h,m=t.fromBytes||f;function y(N){const w=n.sqr(N),b=n.mul(w,N);return n.add(n.add(b,n.mul(N,i.a)),i.b)}function g(N,w){const b=n.sqr(w),C=y(N);return n.eql(b,C)}if(!g(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(i.a,Ss),bw),v=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(S,v)))throw new Error("bad curve params: a or b");function E(N,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${N}`);return w}function L(N){if(!(N instanceof I))throw new Error("Weierstrass Point expected")}function x(N){if(!c||!c.basises)throw new Error("no endo");return yw(N,c.basises,s.ORDER)}const _=ri((N,w)=>{const{X:b,Y:C,Z:P}=N;if(n.eql(P,n.ONE))return{x:b,y:C};const k=N.is0();w==null&&(w=k?n.ONE:n.inv(P));const A=n.mul(b,w),F=n.mul(C,w),R=n.mul(P,w);if(k)return{x:n.ZERO,y:n.ZERO};if(!n.eql(R,n.ONE))throw new Error("invZ was invalid");return{x:A,y:F}}),O=ri(N=>{if(N.is0()){if(t.allowInfinityPoint&&!n.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=N.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!g(w,b))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function T(N,w,b,C,P){return b=new I(n.mul(b.X,N),b.Y,b.Z),w=si(C,w),b=si(P,b),w.add(b)}const M=class M{constructor(w,b,C){l(this,"X");l(this,"Y");l(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",C),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:C}=w||{};if(!w||!n.isValid(b)||!n.isValid(C))throw new Error("invalid affine point");if(w instanceof M)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(C)?M.ZERO:new M(b,C,n.ONE)}static fromBytes(w){const b=M.fromAffine(m(Y(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return M.fromBytes($r(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return U.createCache(this,w),b||this.multiply(Ss),this}assertValidity(){O(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){L(w);const{X:b,Y:C,Z:P}=this,{X:k,Y:A,Z:F}=w,R=n.eql(n.mul(b,F),n.mul(k,P)),B=n.eql(n.mul(C,F),n.mul(A,P));return R&&B}negate(){return new M(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,C=n.mul(b,Ss),{X:P,Y:k,Z:A}=this;let F=n.ZERO,R=n.ZERO,B=n.ZERO,K=n.mul(P,P),ne=n.mul(k,k),Q=n.mul(A,A),W=n.mul(P,k);return W=n.add(W,W),B=n.mul(P,A),B=n.add(B,B),F=n.mul(w,B),R=n.mul(C,Q),R=n.add(F,R),F=n.sub(ne,R),R=n.add(ne,R),R=n.mul(F,R),F=n.mul(W,F),B=n.mul(C,B),Q=n.mul(w,Q),W=n.sub(K,Q),W=n.mul(w,W),W=n.add(W,B),B=n.add(K,K),K=n.add(B,K),K=n.add(K,Q),K=n.mul(K,W),R=n.add(R,K),Q=n.mul(k,A),Q=n.add(Q,Q),K=n.mul(Q,W),F=n.sub(F,K),B=n.mul(Q,ne),B=n.add(B,B),B=n.add(B,B),new M(F,R,B)}add(w){L(w);const{X:b,Y:C,Z:P}=this,{X:k,Y:A,Z:F}=w;let R=n.ZERO,B=n.ZERO,K=n.ZERO;const ne=i.a,Q=n.mul(i.b,Ss);let W=n.mul(b,k),ce=n.mul(C,A),fe=n.mul(P,F),ye=n.add(b,C),pe=n.add(k,A);ye=n.mul(ye,pe),pe=n.add(W,ce),ye=n.sub(ye,pe),pe=n.add(b,P);let _e=n.add(k,F);return pe=n.mul(pe,_e),_e=n.add(W,fe),pe=n.sub(pe,_e),_e=n.add(C,P),R=n.add(A,F),_e=n.mul(_e,R),R=n.add(ce,fe),_e=n.sub(_e,R),K=n.mul(ne,pe),R=n.mul(Q,fe),K=n.add(R,K),R=n.sub(ce,K),K=n.add(ce,K),B=n.mul(R,K),ce=n.add(W,W),ce=n.add(ce,W),fe=n.mul(ne,fe),pe=n.mul(Q,pe),ce=n.add(ce,fe),fe=n.sub(W,fe),fe=n.mul(ne,fe),pe=n.add(pe,fe),W=n.mul(ce,pe),B=n.add(B,W),W=n.mul(_e,pe),R=n.mul(ye,R),R=n.sub(R,W),W=n.mul(ye,ce),K=n.mul(_e,K),K=n.add(K,W),new M(R,B,K)}subtract(w){return this.add(w.negate())}is0(){return this.equals(M.ZERO)}multiply(w){const{endo:b}=t;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let C,P;const k=A=>U.cached(this,A,F=>Rr(M,F));if(b){const{k1neg:A,k1:F,k2neg:R,k2:B}=x(w),{p:K,f:ne}=k(F),{p:Q,f:W}=k(B);P=ne.add(W),C=T(b.beta,K,Q,A,R)}else{const{p:A,f:F}=k(w);C=A,P=F}return Rr(M,[C,P])[0]}multiplyUnsafe(w){const{endo:b}=t,C=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===_t||C.is0())return M.ZERO;if(w===Rn)return C;if(U.hasCache(this))return this.multiply(w);if(b){const{k1neg:P,k1:k,k2neg:A,k2:F}=x(w),{p1:R,p2:B}=dy(M,C,k,F);return T(b.beta,R,B,P,A)}else return U.unsafe(C,w)}toAffine(w){return _(this,w)}isTorsionFree(){const{isTorsionFree:w}=t;return o===Rn?!0:w?w(M,this):U.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=t;return o===Rn?this:w?w(M,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return mn(w,"isCompressed"),this.assertValidity(),p(M,this,w)}toHex(w=!0){return ss(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(M,"BASE",new M(i.Gx,i.Gy,n.ONE)),l(M,"ZERO",new M(n.ZERO,n.ONE,n.ZERO)),l(M,"Fp",n),l(M,"Fn",s);let I=M;const $=s.BITS,U=new Gd(I,t.endo?Math.ceil($/2):$);return I.BASE.precompute(8),I}function ah(r){return Uint8Array.of(r?2:3)}function ch(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function vw(r,t={}){const{Fn:e}=r,n=t.randomBytes||is,s=Object.assign(ch(r.Fp,e),{seed:Vd(e.ORDER)});function i(p){try{const m=e.fromBytes(p);return e.isValidNot0(m)}catch{return!1}}function o(p,m){const{publicKey:y,publicKeyUncompressed:g}=s;try{const S=p.length;return m===!0&&S!==y||m===!1&&S!==g?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return uy(Y(p,s.seed,"seed"),e.ORDER)}function c(p,m=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(m)}function u(p){const{secretKey:m,publicKey:y,publicKeyUncompressed:g}=s;if(!Ki(p)||"_lengths"in e&&e._lengths||m===y)return;const S=Y(p,void 0,"key").length;return S===y||S===g}function d(p,m,y=!0){if(u(p)===!0)throw new Error("first arg must be private key");if(u(m)===!1)throw new Error("second arg must be public key");const g=e.fromBytes(p);return r.fromBytes(m).multiply(g).toBytes(y)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},f=Ya(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:f,Point:r,utils:h,lengths:s})}function Sw(r,t,e={}){Vi(t),lr(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||is,s=e.hmac||((w,b)=>Yi(t,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p}=vw(r,e),m={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},y=a*oh<i.ORDER;function g(w){const b=a>>Rn;return w>b}function S(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function v(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){na(b);const C=p.signature,P=b==="compact"?C:b==="recovered"?C+1:void 0;return Y(w,P)}class L{constructor(b,C,P){l(this,"r");l(this,"s");l(this,"recovery");if(this.r=S("r",b),this.s=S("s",C),P!=null){if(v(),![0,1,2,3].includes(P))throw new Error("invalid recovery id");this.recovery=P}Object.freeze(this)}static fromBytes(b,C=m.format){E(b,C);let P;if(C==="der"){const{r:R,s:B}=Ft.toSig(Y(b));return new L(R,B)}C==="recovered"&&(P=b[0],C="compact",b=b.subarray(1));const k=p.signature/2,A=b.subarray(0,k),F=b.subarray(k,k*2);return new L(o.fromBytes(A),o.fromBytes(F),P)}static fromHex(b,C){return this.fromBytes($r(b),C)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new L(this.r,this.s,b)}recoverPublicKey(b){const{r:C,s:P}=this,k=this.assertRecovery(),A=k===2||k===3?C+a:C;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const F=i.toBytes(A),R=r.fromBytes(gt(ah((k&1)===0),F)),B=o.inv(A),K=_(Y(b,void 0,"msgHash")),ne=o.create(-K*B),Q=o.create(P*B),W=r.BASE.multiplyUnsafe(ne).add(R.multiplyUnsafe(Q));if(W.is0())throw new Error("invalid recovery: point at infinify");return W.assertValidity(),W}hasHighS(){return g(this.s)}toBytes(b=m.format){if(na(b),b==="der")return $r(Ft.hexFromSig(this));const{r:C,s:P}=this,k=o.toBytes(C),A=o.toBytes(P);return b==="recovered"?(v(),gt(Uint8Array.of(this.assertRecovery()),k,A)):gt(k,A)}toHex(b){return ss(this.toBytes(b))}}const x=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const C=Wi(b),P=b.length*8-c;return P>0?C>>BigInt(P):C},_=e.bits2int_modN||function(b){return o.create(x(b))},O=Ha(c);function T(w){return zr("num < 2^"+c,w,_t,O),o.toBytes(w)}function I(w,b){return Y(w,void 0,"message"),b?Y(t(w),void 0,"prehashed message"):w}function $(w,b,C){const{lowS:P,prehash:k,extraEntropy:A}=po(C,m);w=I(w,k);const F=_(w),R=o.fromBytes(b);if(!o.isValidNot0(R))throw new Error("invalid private key");const B=[T(R),T(F)];if(A!=null&&A!==!1){const W=A===!0?n(p.secretKey):A;B.push(Y(W,void 0,"extraEntropy"))}const K=gt(...B),ne=F;function Q(W){const ce=x(W);if(!o.isValidNot0(ce))return;const fe=o.inv(ce),ye=r.BASE.multiply(ce).toAffine(),pe=o.create(ye.x);if(pe===_t)return;const _e=o.create(fe*o.create(ne+pe*R));if(_e===_t)return;let hs=(ye.x===pe?0:2)|Number(ye.y&Rn),mr=_e;return P&&g(_e)&&(mr=o.neg(_e),hs^=1),new L(pe,mr,y?void 0:hs)}return{seed:K,k2sig:Q}}function U(w,b,C={}){const{seed:P,k2sig:k}=$(w,b,C);return Jp(t.outputLen,o.BYTES,s)(P,k).toBytes(C.format)}function M(w,b,C,P={}){const{lowS:k,prehash:A,format:F}=po(P,m);if(C=Y(C,void 0,"publicKey"),b=I(b,A),!Ki(w)){const R=w instanceof L?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+R)}E(w,F);try{const R=L.fromBytes(w,F),B=r.fromBytes(C);if(k&&R.hasHighS())return!1;const{r:K,s:ne}=R,Q=_(b),W=o.inv(ne),ce=o.create(Q*W),fe=o.create(K*W),ye=r.BASE.multiplyUnsafe(ce).add(B.multiplyUnsafe(fe));return ye.is0()?!1:o.create(ye.x)===K}catch{return!1}}function N(w,b,C={}){const{prehash:P}=po(C,m);return b=I(b,P),L.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p,Point:r,sign:U,verify:M,recoverPublicKey:N,Signature:L,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ic={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},xw={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},rl=BigInt(2);function Aw(r){const t=ic.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,d=u*u*r%t,h=we(d,e,t)*d%t,f=we(h,e,t)*d%t,p=we(f,rl,t)*u%t,m=we(p,s,t)*p%t,y=we(m,i,t)*m%t,g=we(y,a,t)*y%t,S=we(g,c,t)*g%t,v=we(S,a,t)*y%t,E=we(v,e,t)*d%t,L=we(E,o,t)*m%t,x=we(L,n,t)*u%t,_=we(x,rl,t);if(!ra.eql(ra.sqr(_),r))throw new Error("Cannot find square root");return _}const ra=Hi(ic.p,{sqrt:Aw}),Cw=Ew(ic,{Fp:ra,endo:xw}),ci=Sw(Cw,Pr);function _w(r,t,e,n){var i;const s=xd.digest(e instanceof Uint8Array?e:e.subarray());if(Za(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),ci.verify(t,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new Jc(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),ci.verify(t,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new Jc(String(o))}}class Iw{constructor(t){l(this,"type","secp256k1");l(this,"raw");l(this,"_key");this._key=Lw(t),this.raw=Tw(this._key)}toMultihash(){return ns.digest(It(this))}toCID(){return me.createV1(114,this.toMultihash())}toString(){return Te.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:Ke(this.raw,t.raw)}verify(t,e,n){return _w(this._key,e,t,n)}}function lh(r){return new Iw(r)}function Tw(r){return ci.Point.fromBytes(r).toBytes()}function Lw(r){try{return ci.Point.fromBytes(r),r}catch(t){throw new Ma(String(t))}}async function Dw(r,t){return Oy()}function Yt(r,t){const{Type:e,Data:n}=Gn.decode(r),s=n??new Uint8Array;switch(e){case De.RSA:return mw(s,t);case De.Ed25519:return eh(s);case De.secp256k1:return lh(s);case De.ECDSA:return Id(s);default:throw new Fi}}function Pw(r){const{Type:t,Data:e}=Gn.decode(r.digest),n=e??new Uint8Array;switch(t){case De.Ed25519:return eh(n);case De.secp256k1:return lh(n);case De.ECDSA:return Id(n);default:throw new Fi}}function It(r){return Gn.encode({Type:De[r.type],Data:r.raw})}const uh=Symbol.for("nodejs.util.inspect.custom"),Rw=114;var vu;class oc{constructor(t){l(this,"type");l(this,"multihash");l(this,"publicKey");l(this,"string");l(this,vu,!0);this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Te.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return me.createV1(Rw,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(t==null)return!1;if(t instanceof Uint8Array)return Ke(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(((e=t==null?void 0:t.toMultihash())==null?void 0:e.bytes)!=null)return Ke(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(vu=Ba,uh)](){return`PeerId(${this.toString()})`}}class dh extends oc{constructor(e){super({...e,type:"RSA"});l(this,"type","RSA");l(this,"publicKey");this.publicKey=e.publicKey}}class hh extends oc{constructor(e){super({...e,type:"Ed25519"});l(this,"type","Ed25519");l(this,"publicKey");this.publicKey=e.publicKey}}class fh extends oc{constructor(e){super({...e,type:"secp256k1"});l(this,"type","secp256k1");l(this,"publicKey");this.publicKey=e.publicKey}}const kw=2336;var Su,xu;class mh{constructor(t){l(this,"type","url");l(this,"multihash");l(this,"publicKey");l(this,"url");l(this,Su,!0);this.url=t.toString(),this.multihash=ns.digest(X(this.url))}[(xu=uh,Su=Ba,xu)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return me.createV1(kw,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=J(t)),t.toString()===this.toString())}}const Mw=114,sl=2336;function ct(r,t){let e;if(r.charAt(0)==="1"||r.charAt(0)==="Q")e=ts(Te.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return cs(me.parse(r));throw new G('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return as(e)}function qr(r){if(r.type==="Ed25519")return new hh({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new fh({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new dh({multihash:r.toCID().multihash,publicKey:r});throw new Fi}function Nw(r){return qr(r.publicKey)}function as(r){if(Fw(r))return new dh({multihash:r});if(Ow(r))try{const t=Pw(r);if(t.type==="Ed25519")return new hh({multihash:r,publicKey:t});if(t.type==="secp256k1")return new fh({multihash:r,publicKey:t})}catch{const e=J(r.digest);return new mh(new URL(e))}throw new ld("Supplied PeerID Multihash is invalid")}function cs(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==Mw&&r.code!==sl)throw new cd("Supplied PeerID CID is invalid");if(r.code===sl){const t=J(r.multihash.digest);return new mh(new URL(t))}return as(r.multihash)}function Ow(r){return r.code===ns.code}function Fw(r){return r.code===xd.code}async function Bw(r){var t,e;if(r.connectionProtector===null&&((e=(t=globalThis.process)==null?void 0:t.env)==null?void 0:e.LIBP2P_FORCE_PNET)!=null)throw new G("Private network is enforced, but no protector was provided");return r}const Yn=1e3,Xn=Yn*60,Zn=Xn*60,yn=Zn*24,Kr=yn*7,Qn=yn*365.25,Vr=Qn/12;function $w(r,t){if(typeof r=="string")return Uw(r);if(typeof r=="number")return Kw(r,t);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var gh=$w;function Uw(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(t!=null&&t.groups))return NaN;let{value:e,unit:n="ms"}=t.groups,s=parseFloat(e),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Qn;case"months":case"month":case"mo":return s*Vr;case"weeks":case"week":case"w":return s*Kr;case"days":case"day":case"d":return s*yn;case"hours":case"hour":case"hrs":case"hr":case"h":return s*Zn;case"minutes":case"minute":case"mins":case"min":case"m":return s*Xn;case"seconds":case"second":case"secs":case"sec":case"s":return s*Yn;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function zw(r){let t=Math.abs(r);return t>=Qn?`${Math.round(r/Qn)}y`:t>=Vr?`${Math.round(r/Vr)}mo`:t>=Kr?`${Math.round(r/Kr)}w`:t>=yn?`${Math.round(r/yn)}d`:t>=Zn?`${Math.round(r/Zn)}h`:t>=Xn?`${Math.round(r/Xn)}m`:t>=Yn?`${Math.round(r/Yn)}s`:`${r}ms`}function qw(r){let t=Math.abs(r);return t>=Qn?Qt(r,t,Qn,"year"):t>=Vr?Qt(r,t,Vr,"month"):t>=Kr?Qt(r,t,Kr,"week"):t>=yn?Qt(r,t,yn,"day"):t>=Zn?Qt(r,t,Zn,"hour"):t>=Xn?Qt(r,t,Xn,"minute"):t>=Yn?Qt(r,t,Yn,"second"):`${r} ms`}function Kw(r,t){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return t!=null&&t.long?qw(r):zw(r)}function Qt(r,t,e,n){let s=t>=e*1.5;return`${Math.round(r/e)} ${n}${s?"s":""}`}function Vw(r){e.debug=e,e.default=e,e.coerce=c,e.disable=i,e.enable=s,e.enabled=o,e.humanize=gh,e.destroy=u,Object.keys(r).forEach(d=>{e[d]=r[d]}),e.names=[],e.skips=[],e.formatters={};function t(d){let h=0;for(let f=0;f<d.length;f++)h=(h<<5)-h+d.charCodeAt(f),h|=0;return e.colors[Math.abs(h)%e.colors.length]}e.selectColor=t;function e(d){let h,f=null,p,m;function y(...g){if(!y.enabled)return;const S=y,v=Number(new Date),E=v-(h||v);S.diff=E,S.prev=h,S.curr=v,h=v,g[0]=e.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let L=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(_,O)=>{if(_==="%%")return"%";L++;const T=e.formatters[O];if(typeof T=="function"){const I=g[L];_=T.call(S,I),g.splice(L,1),L--}return _}),e.formatArgs.call(S,g),(S.log||e.log).apply(S,g)}return y.namespace=d,y.useColors=e.useColors(),y.color=e.selectColor(d),y.extend=n,y.destroy=e.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(p!==e.namespaces&&(p=e.namespaces,m=e.enabled(d)),m),set:g=>{f=g}}),typeof e.init=="function"&&e.init(y),y}function n(d,h){const f=e(this.namespace+(typeof h>"u"?":":h)+d);return f.log=this.log,f}function s(d){e.save(d),e.namespaces=d,e.names=[],e.skips=[];let h;const f=(typeof d=="string"?d:"").split(/[\s,]+/),p=f.length;for(h=0;h<p;h++)f[h]&&(d=f[h].replace(/\*/g,".*?"),d[0]==="-"?e.skips.push(new RegExp("^"+d.substr(1)+"$")):e.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...e.names.map(a),...e.skips.map(a).map(h=>"-"+h)].join(",");return e.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,f;for(h=0,f=e.skips.length;h<f;h++)if(e.skips[h].test(d))return!1;for(h=0,f=e.names.length;h<f;h++)if(e.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return e.setupFormatters(e.formatters),e.enable(e.load()),e}var Ww={};const mt=Jw(),Hw=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Gw(){var r,t,e,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((e=(t=document.documentElement)==null?void 0:t.style)==null?void 0:e.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function Yw(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+gh(this.diff),!this.useColors)return;const t="color: "+this.color;r.splice(1,0,t,"color: inherit");let e=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(e++,s==="%c"&&(n=e))}),r.splice(n,0,t)}const Xw=console.debug??console.log??(()=>{});function Zw(r){try{r?mt==null||mt.setItem("debug",r):mt==null||mt.removeItem("debug")}catch{}}function Qw(){let r;try{r=mt==null?void 0:mt.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Ww.DEBUG),r}function Jw(){try{return localStorage}catch{}}function jw(r){r.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}const Je=Vw({formatArgs:Yw,save:Zw,load:Qw,useColors:Gw,setupFormatters:jw,colors:Hw,storage:mt,log:Xw});Je.formatters.b=r=>r==null?"undefined":Te.baseEncode(r);Je.formatters.t=r=>r==null?"undefined":Vt.baseEncode(r);Je.formatters.m=r=>r==null?"undefined":vd.baseEncode(r);Je.formatters.p=r=>r==null?"undefined":r.toString();Je.formatters.c=r=>r==null?"undefined":r.toString();Je.formatters.k=r=>r==null?"undefined":r.toString();Je.formatters.a=r=>r==null?"undefined":r.toString();Je.formatters.e=r=>{if(r==null)return"undefined";const t=il(r.message),e=il(r.stack);return t!=null&&e!=null?e.includes(t)?e:`${t}
${e}`:e??t??r.toString()};function eb(r){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=r,t.destroy=()=>!0,t.extend=()=>t,t}function ph(){return{forComponent(r){return yh(r)}}}function yh(r){let t=eb(`${r}:trace`);return Je.enabled(`${r}:trace`)&&Je.names.map(e=>e.toString()).find(e=>e.includes(":trace"))!=null&&(t=Je(`${r}:trace`)),Object.assign(Je(r),{error:Je(`${r}:error`),trace:t,newScope:e=>yh(`${r}:${e}`)})}function il(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function Mr(r,t){const e={[Symbol.iterator]:()=>e,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:t(s)}}};return e}function yo(r){const t=ts(Te.decode(`z${r}`));return as(t)}class dr{constructor(t){l(this,"map");if(this.map=new Map,t!=null)for(const[e,n]of t.entries())this.map.set(e.toString(),{key:e,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return Mr(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,n)=>{t(e.value,e.key,this)})}get(t){var e;return(e=this.map.get(t.toString()))==null?void 0:e.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return Mr(this.map.values(),t=>t.key)}values(){return Mr(this.map.values(),t=>t.value)}get size(){return this.map.size}}class kn{constructor(t){l(this,"set");if(this.set=new Set,t!=null)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return Mr(this.set.entries(),t=>{const e=yo(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const n=yo(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return Mr(this.set.values(),t=>yo(t))}intersection(t){const e=new kn;for(const n of t)this.has(n)&&e.add(n);return e}difference(t){const e=new kn;for(const n of this)t.has(n)||e.add(n);return e}union(t){const e=new kn;for(const n of t)e.add(n);for(const n of this)e.add(n);return e}}const ac={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},wh={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},bh=new globalThis.TextEncoder;function tb(r,t){const e=ac[t];let n=wh[t];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(t,n*e);return n}function nb(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=ac[t];let s=wh[t],i=r;for(;i.length>0;){const o=bh.encodeInto(i,e);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(e[a]),s=BigInt.asUintN(t,s*n)}return s}function rb(r,{size:t=32,utf8Buffer:e}={}){if(!ac[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return nb(r,t,e);r=bh.encode(r)}return tb(r,t)}const cc={hash:r=>Number(rb(r,{size:32})),hashV:(r,t)=>sb(cc.hash(r,t))};function sb(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),X(t,"base16")}const Eh=64;class rn{constructor(t,e,n,s=2){l(this,"fp");l(this,"h");l(this,"seed");if(s>Eh)throw new TypeError("Invalid Fingerprint Size");const i=e.hashV(t,n),o=ae(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return(t==null?void 0:t.fp)instanceof Uint8Array?Ke(this.fp,t.fp):!1}}function li(r,t){return Math.floor(Math.random()*(t-r))+r}class xs{constructor(t){l(this,"contents");this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof rn))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof rn))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof rn))throw new TypeError("Invalid Fingerprint");const e=li(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof rn))throw new TypeError("Invalid Fingerprint");const e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}}const ib=500;class ol{constructor(t){l(this,"bucketSize");l(this,"filterSize");l(this,"fingerprintSize");l(this,"buckets");l(this,"count");l(this,"hash");l(this,"seed");this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??cc,this.seed=t.seed??li(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=X(t));const e=new rn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new xs(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new xs(this.bucketSize)),this.buckets[n].add(e)||this.buckets[s].add(e))return this.count++,!0;const i=[n,s];let o=i[li(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new xs(this.bucketSize));for(let a=0;a<ib;a++){const c=this.buckets[o].swap(e);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new xs(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(t){var o,a;typeof t=="string"&&(t=X(t));const e=new rn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(e))??!1;if(s)return s;const i=(n^e.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(e))??!1}remove(t){var a,c;typeof t=="string"&&(t=X(t));const e=new rn(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(e))??!1;if(s)return this.count--,s;const i=(n^e.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(e))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const ob={1:.5,2:.84,4:.95,8:.98};function ab(r=.001){return r>.002?2:r>1e-5?4:8}function cb(r,t=.001){const e=ab(t),n=ob[e],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),Eh);return{filterSize:s,bucketSize:e,fingerprintSize:i}}class lb{constructor(t){l(this,"filterSize");l(this,"bucketSize");l(this,"fingerprintSize");l(this,"scale");l(this,"filterSeries");l(this,"hash");l(this,"seed");this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??cc,this.seed=t.seed??li(0,Math.pow(2,10)),this.filterSeries=[new ol({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=X(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new ol({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=X(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=X(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}}function Wr(r,t=.001,e){return new lb({...cb(r,t)})}function ge(r){var s,i,o,a,c,u;const t=r.getComponents(),e={};let n=0;if(((s=t[n])==null?void 0:s.name)==="ip6zone"&&(e.zone=`${t[n].value}`,n++),t[n].name==="ip4"||t[n].name==="ip6"||t[n].name==="dns"||t[n].name==="dns4"||t[n].name==="dns6"?(e.type=t[n].name,e.host=t[n].value,n++):t[n].name==="dnsaddr"&&(e.type=t[n].name,e.host=`_dnsaddr.${t[n].value}`,n++),(((i=t[n])==null?void 0:i.name)==="tcp"||((o=t[n])==null?void 0:o.name)==="udp")&&(e.protocol=t[n].name==="tcp"?"tcp":"udp",e.port=parseInt(`${t[n].value}`),n++),((a=t[n])==null?void 0:a.name)==="ipcidr"&&(e.type==="ip4"?e.cidr=parseInt(`${t[n].value}`):e.type==="ip6"&&(e.cidr=`${t[n].value}`),n++),e.type==null||e.host==null)throw new G(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=t[n])==null?void 0:c.name)==="tls"&&((u=t[n+1])==null?void 0:u.name)==="sni"&&(e.sni=t[n+1].value,n+=2),e}class ub{constructor(){l(this,"index",0);l(this,"input","")}new(t){return this.index=0,this.input=t,this}readAtomically(t){const e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){const e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{const e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const f=Number.parseInt(h,t);if(!Number.isNaN(f))return f});if(d===void 0)break;if(i*=t,i+=d,i>u||(o+=1,e!==void 0&&o>e))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const t=new Uint8Array(4);for(let e=0;e<t.length;e++){const n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){const t=e=>{for(let n=0;n<e.length/2;n++){const s=n*2;if(n<e.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return e[s]=o[0],e[s+1]=o[1],e[s+2]=o[2],e[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];e[s]=i>>8,e[s+1]=i&255}return[e.length,!1]};return this.readAtomically(()=>{const e=new Uint8Array(16),[n,s]=t(e);if(n===16)return e;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=t(i.subarray(0,o));return e.set(i.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const vh=45,db=15,Jn=new ub;function Sh(r){if(!(r.length>db))return Jn.new(r).parseWith(()=>Jn.readIPv4Addr())}function xh(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>vh))return Jn.new(r).parseWith(()=>Jn.readIPv6Addr())}function sa(r,t=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>vh)return;const e=Jn.new(r).parseWith(()=>Jn.readIPAddr());if(e)return t&&e.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,e[0],e[1],e[2],e[3]]):e}function hb(r,t,e){let n=0;for(const s of r)if(!(n<t)){if(n>e)break;if(s!==255)return!1;n++}return!0}function fb(r,t,e,n){let s=0;for(const i of r)if(!(s<e)){if(s>n)break;if(i!==t[s])return!1;s++}return!0}function mb(r){switch(r.length){case Hr:return r.join(".");case Gr:{const t=[];for(let e=0;e<r.length;e++)e%2===0&&t.push(r[e].toString(16).padStart(2,"0")+r[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function gb(r){let t=0;for(let[e,n]of r.entries()){if(n===255){t+=8;continue}for(;n&128;)t++,n=n<<1;if(n&128)return-1;for(let s=e+1;s<r.length;s++)if(r[s]!=0)return-1;break}return t}function pb(r){let t="0x";for(const e of r)t+=(e>>4).toString(16)+(e&15).toString(16);return t}const Hr=4,Gr=16,yb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function Ah(r,t){t.length===Gr&&r.length===Hr&&hb(t,0,11)&&(t=t.slice(12)),t.length===Hr&&r.length===Gr&&fb(r,yb,0,11)&&(r=r.slice(12));const e=r.length;if(e!=t.length)throw new Error("Failed to mask ip");const n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=r[s]&t[s];return n}function wb(r,t){if(typeof t=="string"&&(t=sa(t)),t==null)throw new Error("Invalid ip");if(t.length!==r.network.length)return!1;for(let e=0;e<t.length;e++)if((r.network[e]&r.mask[e])!==(t[e]&r.mask[e]))return!1;return!0}function bb(r){const[t,e]=r.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+r);let n=Hr,s=Sh(t);if(s==null&&(n=Gr,s=xh(t),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(e,10);if(Number.isNaN(i)||String(i).length!==e.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=Ch(i,8*n);return{network:Ah(s,o),mask:o}}function Ch(r,t){if(t!==8*Hr&&t!==8*Gr)throw new Error("Invalid CIDR mask");if(r<0||r>t)throw new Error("Invalid CIDR mask");const e=t/8,n=new Uint8Array(e);for(let s=0;s<e;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class _h{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=bb(t));else{const n=sa(t);if(n==null)throw new Error("Failed to parse network");e=String(e);const s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>n.length*8){const i=sa(e);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=Ch(s,8*n.length);this.network=Ah(n,this.mask)}}contains(t){return wb({network:this.network,mask:this.mask},t)}toString(){const t=gb(this.mask),e=t!==-1?String(t):pb(this.mask);return mb(this.network)+"/"+e}}function Eb(r,t){return new _h(r).contains(t)}function vb(r){try{const t=ge(r);switch(t.type){case"ip6":return Eb("2000::/3",t.host);default:return!1}}catch{return!1}}function Sb(r){try{const t=ge(r);switch(t.type){case"ip4":return t.host.startsWith("169.254.");case"ip6":return t.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function xb(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function ia(r){try{const t=ge(r);switch(t.type){case"ip4":case"ip6":return xb(t.host);default:return!1}}catch{return!1}}function at(r){try{return ge(r),!0}catch{return!1}}function jn(r){return!!Sh(r)}function Ih(r){return!!xh(r)}var Ab=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Th(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Lh;(function(){var r,t,e,n,s,i,o,a;a=function(c){var u,d,h,f;return u=(c&255<<24)>>>24,d=(c&255<<16)>>>16,h=(c&65280)>>>8,f=c&255,[u,d,h,f].join(".")},o=function(c){var u,d,h,f,p,m;for(u=[],h=f=0;f<=3&&c.length!==0;h=++f){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}m=t(c),p=m[0],d=m[1],c=c.substring(d),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},n=e("0"),i=e("a"),s=e("A"),t=function(c){var u,d,h,f,p;for(f=0,u=10,d="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,u=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<c.length;){if("0"<=c[h]&&c[h]<=d)f=f*u+(e(c[h])-n)>>>0;else if(u===16)if("a"<=c[h]&&c[h]<="f")f=f*u+(10+e(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")f=f*u+(10+e(c[h])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[f,h]},r=function(){function c(u,d){var h,f,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=f=32;f>=0;h=--f)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var d,h,f;for(f=o(this.first),h=o(this.last),d=0;f<=h;)u(a(f),f,d),d++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),Lh=r}).call(Ab);const Cb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],_b=Cb.map(r=>new Lh(r));function lc(r){for(const t of _b)if(t.contains(r))return!0;return!1}function Ib(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function Tb(r){const t=r.split(":");if(t.length<2)return!1;const e=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return lc(s)}function Lb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function Db(r){const t=r.split(":"),e=t[t.length-1];return lc(e)}function Pb(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function uc(r){if(jn(r))return lc(r);if(Ib(r))return Tb(r);if(Lb(r))return Db(r);if(Ih(r))return Pb(r)}function er(r){try{const t=ge(r);switch(t.type){case"ip4":case"ip6":return uc(t.host)??!1;default:return t.host==="localhost"}}catch{return!1}}function tt(){const r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}class al{constructor(t){l(this,"buffer");l(this,"mask");l(this,"top");l(this,"btm");l(this,"next");if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}}class wo{constructor(t={}){l(this,"size");l(this,"hwm");l(this,"head");l(this,"tail");this.hwm=t.splitLimit??16,this.head=new al(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return(t==null?void 0:t.byteLength)!=null?t.byteLength:1}push(t){if((t==null?void 0:t.value)!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new al(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return(t==null?void 0:t.value)!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}let Rb=class extends Error{constructor(e,n){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function Xi(r={}){return kb(e=>{const n=e.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function kb(r,t){t=t??{};let e=t.onEnd,n=new wo,s,i,o,a=tt();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((g,S)=>{i=v=>{i=null,n.push(v);try{g(r(n))}catch(E){S(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=tt()})}},u=g=>i!=null?i(g):(n.push(g),s),d=g=>(n=new wo,i!=null?i({error:g}):(n.push({error:g}),s)),h=g=>{if(o)return s;if((t==null?void 0:t.objectMode)!==!0&&(g==null?void 0:g.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:g})},f=g=>o?s:(o=!0,g!=null?d(g):u({done:!0})),p=()=>(n=new wo,f(),{done:!0}),m=g=>(f(g),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:m,push:h,end:f,get readableLength(){return n.size},onEmpty:async g=>{const S=g==null?void 0:g.signal;if(S==null||S.throwIfAborted(),n.isEmpty())return;let v,E;S!=null&&(v=new Promise((L,x)=>{E=()=>{x(new Rb)},S.addEventListener("abort",E)}));try{await Promise.race([a.promise,v])}finally{E!=null&&S!=null&&(S==null||S.removeEventListener("abort",E))}}},e==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(g){return y.throw(g),e!=null&&(e(g),e=void 0),{done:!0}},return(){return y.return(),e!=null&&(e(),e=void 0),{done:!0}},push:h,end(g){return y.end(g),e!=null&&(e(g),e=void 0),s},get readableLength(){return y.readableLength},onEmpty:g=>y.onEmpty(g)},s}let Mb=class extends Error{constructor(t){super(t),this.name="TimeoutError"}},Nb=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}};const cl=r=>globalThis.DOMException===void 0?new Nb(r):new DOMException(r),ll=r=>{const t=r.reason===void 0?cl("This operation was aborted."):r.reason;return t instanceof Error?t:cl(t)};function Ob(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const u=new Promise((d,h)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:p}=t;p.aborted&&h(ll(p)),a=()=>{h(ll(p))},p.addEventListener("abort",a,{once:!0})}if(e===Number.POSITIVE_INFINITY){r.then(d,h);return}const f=new Mb;o=i.setTimeout.call(void 0,()=>{if(n){try{d(n())}catch(p){h(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?d():s instanceof Error?h(s):(f.message=s??`Promise timed out after ${e} milliseconds`,h(f))},e),(async()=>{try{d(await r)}catch(p){h(p)}})()}).finally(()=>{u.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Fb=r=>{const t=r.addEventListener||r.on||r.addListener,e=r.removeEventListener||r.off||r.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(r),removeListener:e.bind(r)}};function Bb(r,t,e){let n;const s=new Promise((i,o)=>{var p;if(e={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=e.signal)==null||p.throwIfAborted();const a=[t].flat(),c=[],{addListener:u,removeListener:d}=Fb(r),h=async(...m)=>{const y=e.multiArgs?m:m[0];if(e.filter)try{if(!await e.filter(y))return}catch(g){n(),o(g);return}c.push(y),e.count===c.length&&(n(),i(c))},f=(...m)=>{n(),o(e.rejectionMultiArgs?m:m[0])};n=()=>{for(const m of a)d(m,h);for(const m of e.rejectionEvents)a.includes(m)||d(m,f)};for(const m of a)u(m,h);for(const m of e.rejectionEvents)a.includes(m)||u(m,f);e.signal&&e.signal.addEventListener("abort",()=>{f(e.signal.reason)},{once:!0}),e.resolveImmediately&&i(c)});if(s.cancel=n,typeof e.timeout=="number"){const i=Ob(s,{milliseconds:e.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function $e(r,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};const n=Bb(r,t,e),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function ui(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class $b extends Error{constructor(e="Rate limit exceeded",n){super(e);l(this,"remainingPoints");l(this,"msBeforeNext");l(this,"consumedPoints");l(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}var $o;let Ub=($o=class extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}},l($o,"name","QueueFullError"),$o);var Uo;let di=(Uo=class extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError")}},l(Uo,"name","UnexpectedEOFError"),Uo);class Dh extends Error{constructor(){super(...arguments);l(this,"name","MaxEarlyStreamsError")}}l(Dh,"name","MaxEarlyStreamsError");class Ph extends Error{constructor(){super(...arguments);l(this,"name","StreamClosedError")}}l(Ph,"name","StreamClosedError");function zb(r){return r.reason}async function yt(r,t,e){if(t==null)return r;const n=zb;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}let qb=class{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=tt(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new Fr)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}};function Kb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let Vb=class{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=Kb(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new Fr),this.cleanup())}async join(t={}){var n;const e=new qb(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await yt(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}},Rh=class extends Ze{constructor(e={}){var n;super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"paused");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,e.metricName!=null&&((n=e.metrics)==null||n.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=e.sort,this.queue=[],this.emitEmpty=ui(this.emitEmpty.bind(this),1),this.emitIdle=ui(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Ub;const s=new Vb(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Fr)}),this.clear()}async onEmpty(e){this.size!==0&&await $e(this,"empty",e)}async onSizeLessThan(e,n){this.size<e||await $e(this,"next",{...n,filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await $e(this,"idle",e)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Xi({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new Fr("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}};const Wb=Math.pow(2,20)*4;class dc extends Ze{constructor(e){super();l(this,"status");l(this,"timeline");l(this,"inactivityTimeout");l(this,"maxReadBufferLength");l(this,"maxWriteBufferLength");l(this,"log");l(this,"direction");l(this,"maxMessageSize");l(this,"readStatus");l(this,"writeStatus");l(this,"remoteReadStatus");l(this,"remoteWriteStatus");l(this,"writableNeedsDrain");l(this,"readBuffer");l(this,"writeBuffer");l(this,"sendingData");l(this,"onDrainPromise");this.status="open",this.log=e.log,this.direction=e.direction??"outbound",this.inactivityTimeout=e.inactivityTimeout??12e4,this.maxReadBufferLength=e.maxReadBufferLength??Wb,this.maxWriteBufferLength=e.maxWriteBufferLength,this.maxMessageSize=e.maxMessageSize,this.readBuffer=new j,this.writeBuffer=new j,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new Ph)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(e){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),yt(this.onDrainPromise.promise,e==null?void 0:e.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const e=Xi(),n=o=>{e.push(o.data)};this.addEventListener("message",n);const s=o=>{e.end(o.error)};this.addEventListener("close",s);const i=()=>{e.end()};this.addEventListener("remoteCloseWrite",i);try{yield*e}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(e){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new jt(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",e.byteLength),this.writeBuffer.append(e),this.processSendQueue()}abort(e){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",e),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(e)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Vm(e))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new jt("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new jt("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new jt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.append(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new jt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.prepend(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(e){if(e.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(e),this.dispatchReadBuffer()}}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const e=new Na;this.dispatchEvent(new Wm(e))}onTransportClosed(e){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),e!=null?this.abort(e):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new Bi))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let e=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){e=!1;break}const o=this.writeBuffer.sublist(0,i),a=new j(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(e=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!e)break}return e||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),e}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const e=this.readBuffer.sublist();this.readBuffer.consume(e.byteLength),this.dispatchEvent(new Km(e))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new qo(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new qo(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class kh extends dc{constructor(e){super(e);l(this,"remoteAddr");l(this,"metricPrefix");l(this,"metrics");this.metricPrefix=e.metricPrefix??"",this.metrics=e.metrics,this.remoteAddr=e.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(e){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"drain",{...e,rejectionEvents:["close"]})),await this.sendClose(e),this.onTransportClosed())}}function Hb(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Mh extends Ze{constructor(e,n){super();l(this,"streams");l(this,"protocol");l(this,"status");l(this,"log");l(this,"maConn");l(this,"streamOptions");l(this,"earlyStreams");l(this,"maxEarlyStreams");l(this,"metrics");this.maConn=e,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=e.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(e){const n=this.maConn.send(e);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(e){this.status==="closed"||this.status==="closing"||(this.status="closing",await yt(Promise.all([...this.streams].map(async n=>{await n.close(e)})),e==null?void 0:e.signal),this.status="closed")}abort(e){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(e)}),this.status="closed")}onTransportClosed(e){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(e)})}catch(n){this.abort(n)}this.status="closed"}async createStream(e){if(this.status!=="open")throw new In;let n=this.onCreateStream({...this.streamOptions,...e});return Hb(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(e){if(this.streams.push(e),this.cleanUpStream(e),this.listenerCount("stream")===0){this.earlyStreams.push(e),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new Dh(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:e})}cleanUpStream(e){var s;const n=i=>{var a,c,u;const o=this.streams.findIndex(d=>d===e);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${e.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${e.direction}_stream_abort`]:!0}):(u=this.metrics)==null||u.increment({[`${e.direction}_stream_end`]:!0})};e.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${e.direction}_stream`]:!0})}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Nh extends dc{constructor(e){super(e);l(this,"id");l(this,"protocol");this.id=e.id,this.protocol=e.protocol??""}async close(e){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await $e(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await $e(this,"drain",{...e,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(e),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(e){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(e),this.readStatus="closed",this.log("closed readable end gracefully"))}}function wn(r){const t=new globalThis.AbortController;function e(){t.abort();for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}for(const i of r){if((i==null?void 0:i.aborted)===!0){e();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",e)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}const s=t.signal;return s.clear=n,s}class bo{constructor(t){l(this,"movingAverage");l(this,"variance");l(this,"deviation");l(this,"forecast");l(this,"timeSpan");l(this,"previousTime");this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(this.previousTime!=null){const n=this.alpha(e,this.previousTime),s=t-this.movingAverage,i=n*s;this.movingAverage=n*t+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=t;this.previousTime=e}}const Gb=1.2,Yb=2,Xb=5e3,Zb=6e4,Qb=5e3;class Jb{constructor(t={}){l(this,"success");l(this,"failure");l(this,"next");l(this,"metric");l(this,"timeoutMultiplier");l(this,"failureMultiplier");l(this,"minTimeout");l(this,"maxTimeout");var n;const e=t.interval??Qb;this.success=new bo(e),this.failure=new bo(e),this.next=new bo(e),this.failureMultiplier=t.failureMultiplier??Yb,this.timeoutMultiplier=t.timeoutMultiplier??Gb,this.minTimeout=t.minTimeout??Xb,this.maxTimeout=t.maxTimeout??Zb,t.metricName!=null&&(this.metric=(n=t.metrics)==null?void 0:n.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){let e=Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier));e<this.minTimeout&&(e=this.minTimeout),e>this.maxTimeout&&(e=this.maxTimeout);const n=AbortSignal.timeout(e),s=wn([t.signal,n]);return s.start=Date.now(),s.timeout=e,s}cleanUp(t){var n,s;const e=Date.now()-t.start;t.aborted?(this.failure.push(e),this.next.push(e*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:e})):(this.success.push(e),this.next.push(e),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:e}))}}class je extends Error{constructor(){super(...arguments);l(this,"name","InvalidMultiaddrError")}}l(je,"name","InvalidMultiaddrError");class tr extends Error{constructor(){super(...arguments);l(this,"name","ValidationError")}}l(tr,"name","ValidationError");class Oh extends Error{constructor(){super(...arguments);l(this,"name","InvalidParametersError")}}l(Oh,"name","InvalidParametersError");class Fh extends Error{constructor(){super(...arguments);l(this,"name","UnknownProtocolError")}}l(Fh,"name","UnknownProtocolError");const hi=4,Mn=6,Bh=273,jb=33,nr=41,hc=42,fc=43,$h=53,Uh=54,zh=55,qh=56,e0=132,t0=301,n0=302,Kh=400,H=421,r0=444,s0=445,i0=446,o0=447,Nn=448,fi=449,a0=454,Vh=460,Wh=461,Hh=465,Yr=466,On=480,c0=481,oa=443,mc=477,Gh=478,l0=479,u0=277,d0=275,h0=276,Yh=280,Nr=281,hr=290,Xh=777;function ul(r){return t=>J(t,r)}function dl(r){return t=>X(t,r)}function Sr(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function Tn(r){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(t)}function f0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=X(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Tn(n);return Ht([e,s],e.length+s.length)}function m0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=Vt.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=Tn(n);return Ht([e,s],e.length+s.length)}function hl(r){const t=r.subarray(0,r.length-2),e=r.subarray(r.length-2),n=J(t,"base32"),s=Sr(e);return`${n}:${s}`}const Zh=function(r){r=r.toString().trim();const t=new Uint8Array(4);return r.split(/\./g).forEach((e,n)=>{const s=parseInt(e,10);if(isNaN(s)||s<0||s>255)throw new je("Invalid byte value in IP address");t[n]=s}),t},g0=function(r){let t=0;r=r.toString().trim();const e=r.split(":",8);let n;for(n=0;n<e.length;n++){const i=jn(e[n]);let o;i&&(o=Zh(e[n]),e[n]=J(o.subarray(0,2),"base16")),o!=null&&++n<8&&e.splice(n,0,J(o.subarray(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);const i=[n,1];for(n=9-e.length;n>0;n--)i.push("0");e.splice.apply(e,i)}const s=new Uint8Array(t+16);for(n=0;n<e.length;n++){e[n]===""&&(e[n]="0");const i=parseInt(e[n],16);if(isNaN(i)||i<0||i>65535)throw new je("Invalid byte value in IP address");s[t++]=i>>8&255,s[t++]=i&255}return s},p0=function(r){if(r.byteLength!==4)throw new je("IPv4 address was incorrect length");const t=[];for(let e=0;e<r.byteLength;e++)t.push(r[e]);return t.join(".")},y0=function(r){if(r.byteLength!==16)throw new je("IPv6 address was incorrect length");const t=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;t.push(o)}const e=t.join(":");try{const n=new URL(`http://[${e}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new je(`Invalid IPv6 address "${e}"`)}};function w0(r){try{const t=new URL(`http://[${r}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new je(`Invalid IPv6 address "${r}"`)}}const Eo=Object.values(Xo).map(r=>r.decoder),b0=function(){let r=Eo[0].or(Eo[1]);return Eo.slice(2).forEach(t=>r=r.or(t)),r}();function E0(r){return b0.decode(r)}function v0(r){return t=>r.encoder.encode(t)}function S0(r){if(parseInt(r).toString()!==r)throw new tr("Value must be an integer")}function x0(r){if(r<0)throw new tr("Value must be a positive integer, or zero")}function A0(r){return t=>{if(t>r)throw new tr(`Value must be smaller than or equal to ${r}`)}}function C0(...r){return t=>{for(const e of r)e(t)}}const As=C0(S0,x0,A0(65535)),Me=-1;class _0{constructor(){l(this,"protocolsByCode",new Map);l(this,"protocolsByName",new Map)}getProtocol(t){let e;if(typeof t=="string"?e=this.protocolsByName.get(t):e=this.protocolsByCode.get(t),e==null)throw new Fh(`Protocol ${t} was unknown`);return e}addProtocol(t){var e;this.protocolsByCode.set(t.code,t),this.protocolsByName.set(t.name,t),(e=t.aliases)==null||e.forEach(n=>{this.protocolsByName.set(n,t)})}removeProtocol(t){var n;const e=this.protocolsByCode.get(t);e!=null&&(this.protocolsByCode.delete(e.code),this.protocolsByName.delete(e.name),(n=e.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const fr=new _0,I0=[{code:hi,name:"ip4",size:32,valueToBytes:Zh,bytesToValue:p0,validate:r=>{if(!jn(r))throw new tr(`Invalid IPv4 address "${r}"`)}},{code:Mn,name:"tcp",size:16,valueToBytes:Tn,bytesToValue:Sr,validate:As},{code:Bh,name:"udp",size:16,valueToBytes:Tn,bytesToValue:Sr,validate:As},{code:jb,name:"dccp",size:16,valueToBytes:Tn,bytesToValue:Sr,validate:As},{code:nr,name:"ip6",size:128,valueToBytes:g0,bytesToValue:y0,stringToValue:w0,validate:r=>{if(!Ih(r))throw new tr(`Invalid IPv6 address "${r}"`)}},{code:hc,name:"ip6zone",size:Me},{code:fc,name:"ipcidr",size:8,bytesToValue:ul("base10"),valueToBytes:dl("base10")},{code:$h,name:"dns",size:Me},{code:Uh,name:"dns4",size:Me},{code:zh,name:"dns6",size:Me},{code:qh,name:"dnsaddr",size:Me},{code:e0,name:"sctp",size:16,valueToBytes:Tn,bytesToValue:Sr,validate:As},{code:t0,name:"udt"},{code:n0,name:"utp"},{code:Kh,name:"unix",size:Me,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:H,name:"p2p",aliases:["ipfs"],size:Me,bytesToValue:ul("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?dl("base58btc")(r):me.parse(r).multihash.bytes},{code:r0,name:"onion",size:96,bytesToValue:hl,valueToBytes:f0},{code:s0,name:"onion3",size:296,bytesToValue:hl,valueToBytes:m0},{code:i0,name:"garlic64",size:Me},{code:o0,name:"garlic32",size:Me},{code:Nn,name:"tls"},{code:fi,name:"sni",size:Me},{code:a0,name:"noise"},{code:Vh,name:"quic"},{code:Wh,name:"quic-v1"},{code:Hh,name:"webtransport"},{code:Yr,name:"certhash",size:Me,bytesToValue:v0(Sd),valueToBytes:E0},{code:On,name:"http"},{code:c0,name:"http-path",size:Me,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:oa,name:"https"},{code:mc,name:"ws"},{code:Gh,name:"wss"},{code:l0,name:"p2p-websocket-star"},{code:u0,name:"p2p-stardust"},{code:d0,name:"p2p-webrtc-star"},{code:h0,name:"p2p-webrtc-direct"},{code:Yh,name:"webrtc-direct"},{code:Nr,name:"webrtc"},{code:hr,name:"p2p-circuit"},{code:Xh,name:"memory",size:Me}];I0.forEach(r=>{fr.addProtocol(r)});function T0(r){var n;const t=[];let e=0;for(;e<r.length;){const s=os(r,e),i=fr.getProtocol(s),o=Le(s),a=R0(i,r,e+o);let c=0;a>0&&i.size===Me&&(c=Le(a));const u=o+c+a,d={code:s,name:i.name,bytes:r.subarray(e,e+u)};if(a>0){const h=e+o+c,f=r.subarray(h,h+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,f))??J(f)}t.push(d),e+=u}return t}function L0(r){var n;let t=0;const e=[];for(const s of r){if(s.bytes==null){const i=fr.getProtocol(s.code),o=Le(s.code);let a,c=0,u=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??X(s.value),c=a.byteLength,i.size===Me&&(u=Le(c)));const d=new Uint8Array(o+u+c);let h=0;oi(s.code,d,h),h+=o,a!=null&&(i.size===Me&&(oi(c,d,h),h+=u),d.set(a,h)),s.bytes=d}e.push(s.bytes),t+=s.bytes.byteLength}return Ht(e,t)}function D0(r){var i;if(r.charAt(0)!=="/")throw new je('String multiaddr must start with "/"');const t=[];let e="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(e==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const u=fr.getProtocol(s);if(e==="protocol"){if(u.size==null||u.size===0){t.push({code:u.code,name:u.name}),n="",s="",e="protocol";continue}else if(c)throw new je(`Component ${s} was missing value`);e="value"}else if(e==="value"){const d={code:u.code,name:u.name};if(u.size!=null&&u.size!==0){if(n==="")throw new je(`Component ${s} was missing value`);d.value=((i=u.stringToValue)==null?void 0:i.call(u,n))??n}t.push(d),n="",s="",e="protocol"}}}if(s!==""&&n!=="")throw new je("Incomplete multiaddr");return t}function P0(r){return`/${r.flatMap(t=>{var n;if(t.value==null)return t.name;const e=fr.getProtocol(t.code);if(e==null)throw new je(`Unknown protocol code ${t.code}`);return[t.name,((n=e.valueToString)==null?void 0:n.call(e,t.value))??t.value]}).join("/")}`}function R0(r,t,e){return r.size==null||r.size===0?0:r.size>0?r.size/8:os(t,e)}const k0=Symbol.for("nodejs.util.inspect.custom"),Qh=Symbol.for("@multiformats/multiaddr");function M0(r){if(r==null&&(r="/"),Zi(r))return r.getComponents();if(r instanceof Uint8Array)return T0(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),D0(r);if(Array.isArray(r))return r;throw new je("Must be a string, Uint8Array, Component[], or another Multiaddr")}var Au,rt,Bn,$n;const Ln=class Ln{constructor(t="/",e={}){l(this,Au,!0);oe(this,rt);oe(this,Bn);oe(this,$n);le(this,rt,M0(t)),e.validate!==!1&&N0(this)}get bytes(){return D(this,$n)==null&&le(this,$n,L0(D(this,rt))),D(this,$n)}toString(){return D(this,Bn)==null&&le(this,Bn,P0(D(this,rt))),D(this,Bn)}toJSON(){return this.toString()}getComponents(){return[...D(this,rt).map(t=>({...t}))]}encapsulate(t){const e=new Ln(t);return new Ln([...D(this,rt),...e.getComponents()],{validate:!1})}decapsulate(t){const e=t.toString(),n=this.toString(),s=n.lastIndexOf(e);if(s<0)throw new Oh(`Address ${this.toString()} does not contain subaddress: ${e}`);return new Ln(n.slice(0,s),{validate:!1})}decapsulateCode(t){let e;for(let n=D(this,rt).length-1;n>-1;n--)if(D(this,rt)[n].code===t){e=n;break}return new Ln(D(this,rt).slice(0,e),{validate:!1})}equals(t){return Ke(this.bytes,t.bytes)}[(Au=Qh,k0)](){return`Multiaddr(${this.toString()})`}};rt=new WeakMap,Bn=new WeakMap,$n=new WeakMap;let aa=Ln;function N0(r){r.getComponents().forEach(t=>{var n;const e=fr.getProtocol(t.code);t.value!=null&&((n=e.validate)==null||n.call(e,t.value))})}function Zi(r){return!!(r!=null&&r[Qh])}function Z(r){return new aa(r)}let fl=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function O0(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new fl(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new fl(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class F0{constructor(){l(this,"readNext");l(this,"haveNext");l(this,"ended");l(this,"nextResult");l(this,"error");this.ended=!1,this.readNext=tt(),this.haveNext=tt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=tt(),t}async throw(t){return this.ended=!0,this.error=t,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=tt(),await O0(this.readNext.promise,e==null?void 0:e.signal,e)}}function B0(){return new F0}function $0(r){return r[Symbol.asyncIterator]!=null}async function U0(r,t,e){try{await Promise.all(r.map(async n=>{for await(const s of n)await t.push(s,{signal:e}),e.throwIfAborted()})),await t.end(void 0,{signal:e})}catch(n){await t.end(n,{signal:e}).catch(()=>{})}}async function*z0(r){const t=new AbortController,e=B0();U0(r,e,t.signal).catch(()=>{});try{yield*e}finally{t.abort()}}function*q0(r){for(const t of r)yield*t}function ca(...r){const t=[];for(const e of r)$0(e)||t.push(e);return t.length===r.length?q0(t):z0(r)}const K0=4194304;class la extends Error{constructor(){super(...arguments);l(this,"name","UnwrappedError")}}l(la,"name","UnwrappedError");let Jh=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}},V0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}},W0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function H0(r){return typeof(r==null?void 0:r.closeRead)=="function"}function G0(r){return typeof(r==null?void 0:r.close)=="function"}function vo(r){return H0(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:G0(r)?r.status!=="open":!1}function Y0(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function jh(r,t){const e=(t==null?void 0:t.maxBufferSize)??K0,n=new j;let s,i=!1;if(!Y0(r))throw new G("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>e){const h=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${h} > ${e}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const u={readBuffer:n,async read(d){if(i===!0)throw new la("Stream was unwrapped");if(vo(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new di(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await yt(s.promise,d==null?void 0:d.signal),vo(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const f=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<f){if(vo(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,f),new di(`Unexpected EOF - stream closed while reading ${n.byteLength}/${f} bytes`);return u.read(d)}const p=n.sublist(0,f);return n.consume(f),p},async write(d,h){if(i===!0)throw new la("Stream was unwrapped");r.send(d)||await $e(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function Xr(r,t={}){const e=jh(r,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=Le(t.maxDataLength));const n=(t==null?void 0:t.lengthDecoder)??os,s=(t==null?void 0:t.lengthEncoder)??kr;return{async read(o){let a=-1;const c=new j;for(;;){const d=await e.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new Jh("Invalid message length");if((t==null?void 0:t.maxLengthLength)!=null&&c.byteLength>t.maxLengthLength)throw new W0(`Message length length too long - ${c.byteLength} > ${t.maxLengthLength}`);if(a>-1)break}if((t==null?void 0:t.maxDataLength)!=null&&a>t.maxDataLength)throw new V0(`Message length too long - ${a} > ${t.maxDataLength}`);const u=await e.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new di(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new di(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await e.write(new j(s(o.byteLength),o),a)},async writeV(o,a){const c=new j(...o.flatMap(u=>[s(u.byteLength),u]));await e.write(c,a)},unwrap(){return e.unwrap()}}}function bn(r,t){const e=Xr(r,t),n={read:async(s,i)=>{const o=await e.read(i);return s.decode(o)},write:async(s,i,o)=>{await e.write(i.encode(s),o)},writeV:async(s,i,o)=>{await e.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>e.unwrap()};return n}const X0=1024*1024*4,Z0=1024*1024*4;class Q0{constructor(t={}){l(this,"buffer");l(this,"maxBufferSize");l(this,"lengthDecoder");l(this,"maxDataLength");l(this,"encodingLength");this.buffer=new j,this.maxBufferSize=t.maxBufferSize??X0,this.maxDataLength=t.maxDataLength??Z0,this.lengthDecoder=t.lengthDecoder??os,this.encodingLength=t.encodingLength??Le}*decode(t){if(this.buffer.append(t),this.buffer.byteLength>this.maxBufferSize)throw new G(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let e;try{e=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(e<0||e>this.maxDataLength)throw new Jh("Invalid message length");const n=this.encodingLength(e),s=n+e;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const J0=8,gc=1024*1024*4;class j0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}}class ef extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}}class eE extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class ml extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError");l(this,"code","ERR_UNEXPECTED_EOF")}}function tf(r){return r[Symbol.asyncIterator]!=null}function nf(r,t){if(r.byteLength>t)throw new ef("Message length too long")}const Qi=r=>{const t=Le(r),e=pt(t);return kr(r,e),Qi.bytes=t,e};Qi.bytes=0;function mi(r,t){t=t??{};const e=t.lengthEncoder??Qi,n=(t==null?void 0:t.maxDataLength)??gc;function*s(i){nf(i,n);const o=e(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return tf(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}mi.single=(r,t)=>{t=t??{};const e=t.lengthEncoder??Qi,n=(t==null?void 0:t.maxDataLength)??gc;return nf(r,n),new j(e(r.byteLength),r)};var en;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(en||(en={}));const pc=r=>{const t=os(r);return pc.bytes=Le(t),t};pc.bytes=0;function ua(r,t){const e=new j;let n=en.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??pc,o=(t==null?void 0:t.maxLengthLength)??J0,a=(t==null?void 0:t.maxDataLength)??gc;function*c(){for(;e.byteLength>0;){if(n===en.LENGTH)try{if(s=i(e),s<0)throw new j0("Invalid message length");if(s>a)throw new ef("Message length too long");const u=i.bytes;e.consume(u),(t==null?void 0:t.onLength)!=null&&t.onLength(s),n=en.DATA}catch(u){if(u instanceof RangeError){if(e.byteLength>o)throw new eE("Message length length too long");break}throw u}if(n===en.DATA){if(e.byteLength<s)break;const u=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(u),yield u,n=en.LENGTH}}}return tf(r)?async function*(){for await(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new ml("Unexpected end of input")}():function*(){for(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new ml("Unexpected end of input")}()}ua.fromReader=(r,t)=>{let e=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return ua(n,{...t??{},onLength:i=>{e=i}})};class yc extends Rh{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}}let tE=class extends Rh{constructor(t={}){super({...t,sort:(e,n)=>e.options.priority>n.options.priority?-1:e.options.priority<n.options.priority?1:0})}};class nE{constructor(t={}){l(this,"memoryStorage");l(this,"points");l(this,"duration");l(this,"blockDuration");l(this,"keyPrefix");this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new rE}consume(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,e,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+e&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new $b("Rate limit exceeded",o);return o}penalty(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(t,e){const n=e*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(t),s,e),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(t,e,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(t),e,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return e!=null&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return(t==null?void 0:t.customDuration)!=null&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class rE{constructor(){l(this,"storage");this.storage=new Map}incrby(t,e,n){const s=this.storage.get(t);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=e,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(t,e,n)}return this.set(t,e,n)}set(t,e,n){const s=n*1e3,i=this.storage.get(t);i!=null&&clearTimeout(i.timeoutId);const o={value:e,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(t,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(t)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(e!=null)return{remainingPoints:0,msBeforeNext:e.expiresAt!=null?e.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}delete(t){const e=this.storage.get(t);return e!=null?(e.timeoutId!=null&&clearTimeout(e.timeoutId),this.storage.delete(t),!0):!1}}function sE(r,t,e){let n,s,i=!1;function o(){const u={signal:s.signal};if((e==null?void 0:e.timeout)!=null){const d=wn([s.signal,AbortSignal.timeout(e.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,t))})}const a=ui(o,(e==null?void 0:e.debounce)??100);let c=!1;return{setInterval:u=>{t!==u&&(t=u,n!=null&&(clearTimeout(n),n=setTimeout(o,t)))},setTimeout:u=>{e??(e={}),e.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(e==null?void 0:e.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,t))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class iE extends Map{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Pt(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new iE({name:t,metrics:e}):n=new Map,n}class oE{constructor(t,e){l(this,"filter");this.filter=Wr(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){var e,n;(n=(e=this.filter).remove)==null||n.call(e,t.toMultihash().bytes)}}function aE(r,t=.001){return new oE(r,t)}class cE extends dr{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function lE(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new cE({name:t,metrics:e}):n=new dr,n}var gi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&e.payload.byteLength>0&&(n.uint32(26),n.bytes(e.payload)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={publicKey:ae(0),payloadType:ae(0),payload:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=e.bytes();break}case 5:{i.signature=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(gi||(gi={}));class uE extends Error{constructor(t="Invalid signature"){super(t),this.name="InvalidSignatureError"}}const Bt=class Bt{constructor(t){l(this,"publicKey");l(this,"payloadType");l(this,"payload");l(this,"signature");l(this,"marshaled");const{publicKey:e,payloadType:n,payload:s,signature:i}=t;this.publicKey=e,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=gi.encode({publicKey:It(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(t){return t==null?!1:Ke(this.marshal(),t.marshal())}async validate(t,e){const n=gl(t,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,e)}};l(Bt,"createFromProtobuf",t=>{const e=gi.decode(t),n=Yt(e.publicKey);return new Bt({publicKey:n,payloadType:e.payloadType,payload:e.payload,signature:e.signature})}),l(Bt,"seal",async(t,e,n)=>{if(e==null)throw new Error("Missing private key");const s=t.domain,i=t.codec,o=t.marshal(),a=gl(s,i,o),c=await e.sign(a.subarray(),n);return new Bt({publicKey:e.publicKey,payloadType:i,payload:o,signature:c})}),l(Bt,"openAndCertify",async(t,e,n)=>{const s=Bt.createFromProtobuf(t);if(!await s.validate(e,n))throw new uE("Envelope signature is not valid for the given domain");return s});let En=Bt;const gl=(r,t,e)=>{const n=X(r),s=kr(n.byteLength),i=kr(t.length),o=kr(e.length);return new j(s,n,i,t,o,e)},dE="libp2p-peer-record",hE=Uint8Array.from([3,1]);var pi;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.peerId!=null&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),e.seq!=null&&e.seq!==0n&&(n.uint32(16),n.uint64(e.seq)),e.addresses!=null)for(const i of e.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={peerId:ae(0),seq:0n,addresses:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.peerId=e.bytes();break}case 2:{i.seq=e.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Dt('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(pi||(pi={}));function fE(r,t){const e=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==t.length?!1:(t.sort(e),r.sort(e).every((n,s)=>t[s].equals(n)))}const xt=class xt{constructor(t){l(this,"peerId");l(this,"multiaddrs");l(this,"seqNumber");l(this,"domain",xt.DOMAIN);l(this,"codec",xt.CODEC);l(this,"marshaled");const{peerId:e,multiaddrs:n,seqNumber:s}=t;this.peerId=e,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=pi.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(t){return!(!(t instanceof xt)||!this.peerId.equals(t.peerId)||this.seqNumber!==t.seqNumber||!fE(this.multiaddrs,t.multiaddrs))}};l(xt,"createFromProtobuf",t=>{const e=pi.decode(t),n=as(ts(e.peerId)),s=(e.addresses??[]).map(o=>Z(o.multiaddr)),i=e.seq;return new xt({peerId:n,multiaddrs:s,seqNumber:i})}),l(xt,"DOMAIN",dE),l(xt,"CODEC",hE);let Tt=xt;function mE(r){return r[Symbol.asyncIterator]!=null}function da(r){if(mE(r))return(async()=>{const e=[];for await(const n of r)e.push(n);return e})();const t=[];for(const e of r)t.push(e);return t}var zo;let rr=(zo=class extends Error{constructor(e="The operation was aborted",...n){super(e,...n);l(this,"name","AbortError")}},l(zo,"name","AbortError"),zo);async function So(r,t,e,n){const s=new rr(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(e==null?void 0:e.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Ao(e,"abort",h),Ao(r,t,u),Ao(r,i,d)}const u=f=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,f))===!1)return}catch(m){c(),a(m);return}c(),o(f)},d=f=>{if(c(),f instanceof Error){a(f);return}a(f.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};xo(e,"abort",h),xo(r,t,u),xo(r,i,d)})}function xo(r,t,e){r!=null&&(rf(r)?r.addEventListener(t,e):r.addListener(t,e))}function Ao(r,t,e){r!=null&&(rf(r)?r.removeEventListener(t,e):r.removeListener(t,e))}function rf(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class sf extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}l(sf,"name","QueueFullError");let pl=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function gE(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new pl(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new pl(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class pE{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new rr)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}}function yE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class wE{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=yE(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new rr),this.cleanup())}async join(t={}){var n;const e=new pE(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await gE(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}}function yl(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class wl extends Ze{constructor(e={}){super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"autoStart");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=yl(this.emitEmpty.bind(this),1),this.emitIdle=yl(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new sf;const s=new wE(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new rr)}),this.clear()}async onEmpty(e){this.size!==0&&await So(this,"empty",e==null?void 0:e.signal)}async onSizeLessThan(e,n){this.size<e||await So(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await So(this,"idle",e==null?void 0:e.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Xi({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail.result)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new rr("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}}const of="lock:worker:request-read",af="lock:worker:abort-read-request",cf="lock:worker:release-read",lf="lock:master:grant-read",uf="lock:master:error-read",df="lock:worker:request-write",hf="lock:worker:abort-write-request",ff="lock:worker:release-write",mf="lock:master:grant-write",gf="lock:master:error-write",pf="lock:worker:finalize",yf="mortice",bE={singleProcess:!1},bl=(r,t,e,n,s,i,o,a,c)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(e,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{t.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(h=>{const f=p=>{if((p==null?void 0:p.data)==null)return;const m={type:p.data.type,name:p.data.name,identifier:p.data.identifier};m.type===a&&m.identifier===d.identifier&&(t.removeEventListener("message",f),h())};t.addEventListener("message",f)})},onError:h=>{t.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===pf&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},EE=(r=10)=>Math.random().toString().substring(2,r+2);class vE{constructor(t){l(this,"name");l(this,"channel");this.name=t,this.channel=new BroadcastChannel(yf)}readLock(t){return this.sendRequest(of,af,lf,uf,cf,t)}writeLock(t){return this.sendRequest(df,hf,mf,gf,ff,t)}finalize(){this.channel.postMessage({type:pf,name:this.name}),this.channel.close()}async sendRequest(t,e,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=EE();return this.channel.postMessage({type:t,identifier:a,name:this.name}),new Promise((u,d)=>{var p;const h=()=>{this.channel.postMessage({type:e,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",h,{once:!0});const f=m=>{var y,g,S,v;if(((y=m.data)==null?void 0:y.identifier)===a&&(((g=m.data)==null?void 0:g.type)===n&&(this.channel.removeEventListener("message",f),(S=o==null?void 0:o.signal)==null||S.removeEventListener("abort",h),u(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),m.data.type===s)){this.channel.removeEventListener("message",f),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const E=new Error;m.data.error!=null&&(E.message=m.data.error.message,E.name=m.data.error.name,E.stack=m.data.error.stack),d(E)}};this.channel.addEventListener("message",f)})}}const SE=r=>{if(r=Object.assign({},bE,r),!!globalThis.document||r.singleProcess){const e=new BroadcastChannel(yf),n=new Ze;return e.addEventListener("message",bl(n,e,"requestReadLock","abortReadLockRequest",of,af,uf,cf,lf)),e.addEventListener("message",bl(n,e,"requestWriteLock","abortWriteLockRequest",df,hf,gf,ff,mf)),n}return new vE(r.name)},sn=new Map;let br;function wf(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function xE(r){if(br==null&&(br=SE(r),!wf(br))){const t=br;t.addEventListener("requestReadLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=sn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortReadLockRequest",a)})}),t.addEventListener("requestWriteLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=sn.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortWriteLockRequest",a)})}),t.addEventListener("finalizeRequest",e=>{const n=e.detail.name,s=sn.get(n);s!=null&&s.finalize()})}return br}async function Co(r,t){var o;let e,n;const s=new Promise((a,c)=>{e=a,n=c}),i=()=>{n(new rr)};return(o=t==null?void 0:t.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{e(()=>{var c;(c=t==null?void 0:t.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:t==null?void 0:t.signal}).catch(a=>{n(a)}),s}const AE=(r,t)=>{let e=sn.get(r);if(e!=null)return e;const n=xE(t);if(wf(n))return e=n,sn.set(r,e),e;const s=new wl({concurrency:1});let i;return e={async readLock(o){if(i!=null)return Co(i,o);i=new wl({concurrency:t.concurrency,autoStart:!1});const a=i,c=Co(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,Co(s,o)},finalize:()=>{sn.delete(r)},queue:s},sn.set(r,e),t.autoFinalize===!0&&s.addEventListener("idle",()=>{e.finalize()},{once:!0}),e},CE={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function _E(r){const t=Object.assign({},CE,r);return AE(t.name,t)}const IE=36e5,TE=216e5;var on;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:ae(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),wi.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var u;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=wi.codec().decode(s,s.uint32(),{limits:(u=o.limits)==null?void 0:u.value});break}default:{s.skipType(d&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.addresses!=null)for(const i of e.addresses)n.uint32(10),yi.codec().encode(i,n);if(e.protocols!=null)for(const i of e.protocols)n.uint32(18),n.string(i);if(e.publicKey!=null&&(n.uint32(34),n.bytes(e.publicKey)),e.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),e.metadata!=null&&e.metadata.size!==0)for(const[i,o]of e.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(e.tags!=null&&e.tags.size!==0)for(const[i,o]of e.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);e.updated!=null&&(n.uint32(64),n.uint64Number(e.updated)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c,u,d,h,f;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const p=e.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new Dt('Decode error - map field "addresses" had too many elements');i.addresses.push(yi.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((u=s.limits)==null?void 0:u.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Dt('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 4:{i.publicKey=e.bytes();break}case 5:{i.peerRecordEnvelope=e.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new el('Decode error - map field "metadata" had too many elements');const m=r.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(m.key,m.value);break}case 7:{if(((h=s.limits)==null?void 0:h.tags)!=null&&i.tags.size===s.limits.tags)throw new el('Decode error - map field "tags" had too many elements');const m=r.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:(f=s.limits)==null?void 0:f.tags$value}});i.tags.set(m.key,m.value);break}case 8:{i.updated=e.uint64Number();break}default:{e.skipType(p&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(on||(on={}));var yi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.multiaddr!=null&&e.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(e.multiaddr)),e.isCertified!=null&&(n.uint32(16),n.bool(e.isCertified)),e.observed!=null&&(n.uint32(24),n.uint64Number(e.observed)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={multiaddr:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.multiaddr=e.bytes();break}case 2:{i.isCertified=e.bool();break}case 3:{i.observed=e.uint64Number();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(yi||(yi={}));var wi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.value!=null&&e.value!==0&&(n.uint32(8),n.uint32(e.value)),e.expiry!=null&&(n.uint32(16),n.uint64(e.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={value:0},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.value=e.uint32();break}case 2:{i.expiry=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(wi||(wi={}));function LE(r,t){if(r.publicKey!=null||t.publicKey==null)return r;let e;r.type==="RSA"&&(e=r.toMultihash());const n=Yt(t.publicKey,e);return qr(n)}function DE(r,t,e){const n=on.decode(t);return xr(r,n,e)}function xr(r,t,e){const n=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...t,id:LE(r,t),addresses:t.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-e).map(({multiaddr:i,isCertified:o})=>({multiaddr:Z(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function PE(r,t){return RE(r.addresses,t.addresses)&&kE(r.protocols,t.protocols)&&ME(r.publicKey,t.publicKey)&&NE(r.peerRecordEnvelope,t.peerRecordEnvelope)&&OE(r.metadata,t.metadata)&&FE(r.tags,t.tags)}function RE(r,t){return Ef(r,t,(e,n)=>!(e.isCertified!==n.isCertified||!Ke(e.multiaddr,n.multiaddr)))}function kE(r,t){return Ef(r,t,(e,n)=>e===n)}function ME(r,t){return bf(r,t)}function NE(r,t){return bf(r,t)}function OE(r,t){return vf(r,t,(e,n)=>Ke(e,n))}function FE(r,t){return vf(r,t,(e,n)=>e.value===n.value&&e.expiry===n.expiry)}function bf(r,t){return r==null&&t==null?!0:r!=null&&t!=null?Ke(r,t):!1}function Ef(r,t,e){if(r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(!e(r[n],t[n]))return!1;return!0}function vf(r,t,e){if(r.size!==t.size)return!1;for(const[n,s]of r.entries()){const i=t.get(n);if(i==null||!e(s,i))return!1}return!0}const Et="/",Sf=new TextEncoder().encode(Et),Cs=Sf[0];class Ue{constructor(t,e){l(this,"_buf");if(typeof t=="string")this._buf=X(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Cs)throw new Error("Invalid key")}toString(t="utf8"){return J(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new Ue(t.join(Et))}static random(){return new Ue(Math.random().toString().substring(2))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new Ue(t):typeof t.uint8Array=="function"?new Ue(t.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=Sf),this._buf[0]!==Cs){const t=new Uint8Array(this._buf.byteLength+1);t.fill(Cs,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Cs;)this._buf=this._buf.subarray(0,-1)}less(t){const e=this.list(),n=t.list();for(let s=0;s<e.length;s++){if(n.length<s+1)return!1;const i=e[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return e.length<n.length}reverse(){return Ue.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(Et).slice(1)}type(){return BE(this.baseNamespace())}name(){return $E(this.baseNamespace())}instance(t){return new Ue(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(Et)||(t+=Et),t+=this.type(),new Ue(t)}parent(){const t=this.list();return t.length===1?new Ue(Et):new Ue(t.slice(0,-1).join(Et))}child(t){return this.toString()===Et?t:t.toString()===Et?this:new Ue(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return Ue.withNamespaces([...this.namespaces(),...UE(t.map(e=>e.namespaces()))])}}function BE(r){const t=r.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function $E(r){const t=r.split(":");return t[t.length-1]}function UE(r){return[].concat(...r)}const xf="/peers/";function _s(r){if(!Lr(r)||r.type==null)throw new G("Invalid PeerId");const t=r.toCID().toString();return new Ue(`${xf}${t}`)}async function zE(r,t,e,n,s){const i=new Map;for(const o of e){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=Z(o.multiaddr)),!Zi(o.multiaddr))throw new G("Multiaddr was invalid");if(!await t(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var u;const c=(u=a.getComponents().find(d=>d.code===H))==null?void 0:u.value;return r.equals(c)&&(a=a.decapsulate(Z(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function _o(r,t,e,n){var f,p;if(t==null)throw new G("Invalid PeerData");if(t.publicKey!=null&&r.publicKey!=null&&!t.publicKey.equals(r.publicKey))throw new G("publicKey bytes do not match peer id publicKey bytes");const s=(f=n.existingPeer)==null?void 0:f.peer;if(s!=null&&!r.equals(s.id))throw new G("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,u=s==null?void 0:s.peerRecordEnvelope;if(e==="patch"){if((t.multiaddrs!=null||t.addresses!=null)&&(i=[],t.multiaddrs!=null&&i.push(...t.multiaddrs.map(m=>({isCertified:!1,multiaddr:m}))),t.addresses!=null&&i.push(...t.addresses)),t.protocols!=null&&(o=new Set(t.protocols)),t.metadata!=null){const m=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);a=Is(m,{validate:El})}if(t.tags!=null){const m=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags);c=Is(m,{validate:vl,map:Sl})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}if(e==="merge"){if(t.multiaddrs!=null&&i.push(...t.multiaddrs.map(m=>({isCertified:!1,multiaddr:m}))),t.addresses!=null&&i.push(...t.addresses),t.protocols!=null&&(o=new Set([...o,...t.protocols])),t.metadata!=null){const m=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[y,g]of m)g==null?a.delete(y):a.set(y,g);a=Is([...a.entries()],{validate:El})}if(t.tags!=null){const m=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),y=new Map(c);for(const[g,S]of m)S==null?y.delete(g):y.set(g,S);c=Is([...y.entries()],{validate:vl,map:Sl})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=It(s.id.publicKey):t.publicKey!=null?d=It(t.publicKey):r.publicKey!=null&&(d=It(r.publicKey));const h={addresses:await zE(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((m,y)=>m.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(m=>{var y,g,S;m.observed=((S=(g=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:g.find(v=>Ke(v.multiaddr,v.multiaddr)))==null?void 0:S.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function Is(r,t){var n;const e=new Map;for(const[s,i]of r)i!=null&&t.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&e.set(s,((n=t.map)==null?void 0:n.call(t,s,i))??i);return e}function El(r,t){if(typeof r!="string")throw new G("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new G("Metadata value must be a Uint8Array")}function vl(r,t){if(typeof r!="string")throw new G("Tag name must be a string");if(t.value!=null){if(parseInt(`${t.value}`,10)!==t.value)throw new G("Tag value must be an integer");if(t.value<0||t.value>100)throw new G("Tag value must be between 0-100")}if(t.ttl!=null){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new G("Tag ttl must be an integer");if(t.ttl<0)throw new G("Tag ttl must be between greater than 0")}}function Sl(r,t){let e;t.expiry!=null&&(e=t.expiry),t.ttl!=null&&(e=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return e!=null&&(n.expiry=e),n}function Af(r){const t=r.toString().split("/")[2],e=me.parse(t,Vt);return cs(e)}function Io(r,t,e){const n=Af(r);return DE(n,t,e)}function qE(r,t){return{prefix:xf,filters:(r.filters??[]).map(e=>({key:n,value:s})=>e(Io(n,s,t))),orders:(r.orders??[]).map(e=>(n,s)=>e(Io(n.key,n.value,t),Io(s.key,s.value,t)))}}var Xe,Bs,$s,Us;class KE{constructor(t,e={}){oe(this,Xe);l(this,"peerId");l(this,"datastore");l(this,"locks");l(this,"addressFilter");l(this,"log");l(this,"maxAddressAge");l(this,"maxPeerAge");this.log=t.logger.forComponent("libp2p:peer-store"),this.peerId=t.peerId,this.datastore=t.datastore,this.addressFilter=e.addressFilter,this.locks=lE({name:"libp2p_peer_store_locks",metrics:t.metrics}),this.maxAddressAge=e.maxAddressAge??IE,this.maxPeerAge=e.maxPeerAge??TE}getLock(t){let e=this.locks.get(t);return e==null&&(e={refs:0,lock:_E({name:t.toString(),singleProcess:!0})},this.locks.set(t,e)),e.refs++,e}maybeRemoveLock(t,e){e.refs--,e.refs===0&&(e.lock.finalize(),this.locks.delete(t))}async getReadLock(t,e){const n=this.getLock(t);try{const s=await n.lock.readLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async getWriteLock(t,e){const n=this.getLock(t);try{const s=await n.lock.writeLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async has(t,e){try{return await this.load(t,e),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(t,e){this.peerId.equals(t)||await this.datastore.delete(_s(t),e)}async load(t,e){const n=_s(t),s=await this.datastore.get(n,e),i=on.decode(s);if(z(this,Xe,Us).call(this,t,i))throw await this.datastore.delete(n,e),new Ko;return xr(t,i,this.peerId.equals(t)?1/0:this.maxAddressAge)}async save(t,e,n){const s=await z(this,Xe,Bs).call(this,t,n),i=await _o(t,e,"patch",{...n,addressFilter:this.addressFilter});return z(this,Xe,$s).call(this,t,i,s)}async patch(t,e,n){const s=await z(this,Xe,Bs).call(this,t,n),i=await _o(t,e,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return z(this,Xe,$s).call(this,t,i,s)}async merge(t,e,n){const s=await z(this,Xe,Bs).call(this,t,n),i=await _o(t,e,"merge",{addressFilter:this.addressFilter,existingPeer:s});return z(this,Xe,$s).call(this,t,i,s)}async*all(t){for await(const{key:e,value:n}of this.datastore.query(qE(t??{},this.maxAddressAge),t)){const s=Af(e);if(s.equals(this.peerId))continue;const i=on.decode(n);if(z(this,Xe,Us).call(this,s,i)){await this.datastore.delete(e,t);continue}yield xr(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Xe=new WeakSet,Bs=async function(t,e){try{const n=_s(t),s=await this.datastore.get(n,e),i=on.decode(s);if(z(this,Xe,Us).call(this,t,i))throw await this.datastore.delete(n,e),new Ko;return{peerPB:i,peer:xr(t,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},$s=async function(t,e,n,s){e.updated=Date.now();const i=on.encode(e);return await this.datastore.put(_s(t),i,s),{peer:xr(t,e,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!PE(e,n.peerPB)}},Us=function(t,e){if(e.updated==null)return!0;if(this.peerId.equals(t))return!1;const n=e.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=e.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0};var Cu,Un,zs;Cu=Symbol.toStringTag;class VE{constructor(t,e={}){oe(this,Un);l(this,"store");l(this,"events");l(this,"peerId");l(this,"log");l(this,Cu,"@libp2p/peer-store");this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new KE(t,e)}async forEach(t,e){for await(const n of this.store.all(e))t(n)}async all(t){return da(this.store.all(t))}async delete(t,e){const n=await this.store.getReadLock(t,e);try{await this.store.delete(t,e)}finally{n()}}async has(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.has(t,e)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.load(t,e)}finally{n==null||n()}}async getInfo(t,e){const n=await this.get(t,e);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.save(t,e,n);return z(this,Un,zs).call(this,t,i),i.peer}finally{s==null||s()}}async patch(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.patch(t,e,n);return z(this,Un,zs).call(this,t,i),i.peer}finally{s==null||s()}}async merge(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.merge(t,e,n);return z(this,Un,zs).call(this,t,i),i.peer}finally{s==null||s()}}async consumePeerRecord(t,e,n){const s=Lr(e)?e:Lr(e==null?void 0:e.expectedPeer)?e.expectedPeer:void 0,i=Lr(e)||e===void 0?n:e,o=await En.openAndCertify(t,Tt.DOMAIN,i),a=cs(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=Tt.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((u==null?void 0:u.peerRecordEnvelope)!=null){const d=En.createFromProtobuf(u.peerRecordEnvelope),h=Tt.createFromProtobuf(d.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:t,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}Un=new WeakSet,zs=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};function WE(r,t={}){return new VE(r,t)}const Dn=class Dn extends Error{constructor(e="Not Found"){super(e);l(this,"name",Dn.name);l(this,"code",Dn.code)}};l(Dn,"name","NotFoundError"),l(Dn,"code","ERR_NOT_FOUND");let ha=Dn;function HE(r){return r[Symbol.asyncIterator]!=null}function xl(r){if(HE(r))return(async()=>{for await(const t of r);})();for(const t of r);}function GE(r){const[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[e](){return this}}}function YE(r){return r[Symbol.asyncIterator]!=null}function _n(r,t){let e=0;if(YE(r))return async function*(){for await(const c of r)await t(c,e++)&&(yield c)}();const n=GE(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await t(c,e++)&&(yield c)}();const a=t;return function*(){o===!0&&(yield s);for(const c of n)a(c,e++)&&(yield c)}()}function XE(r){return r[Symbol.asyncIterator]!=null}function Al(r,t){return XE(r)?async function*(){yield*(await da(r)).sort(t)}():function*(){yield*da(r).sort(t)}()}function ZE(r){return r[Symbol.asyncIterator]!=null}function Cl(r,t){return ZE(r)?async function*(){let e=0;if(!(t<1)){for await(const n of r)if(yield n,e++,e===t)return}}():function*(){let e=0;if(!(t<1)){for(const n of r)if(yield n,e++,e===t)return}}()}class QE{put(t,e,n){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:n,value:s}of t)await this.put(n,s,e),yield n}async*getMany(t,e={}){for await(const n of t)yield{key:n,value:await this.get(n,e)}}async*deleteMany(t,e={}){for await(const n of t)await this.delete(n,e),yield n}batch(){let t=[],e=[];return{put(n,s){t.push({key:n,value:s})},delete(n){e.push(n)},commit:async n=>{await xl(this.putMany(t,n)),t=[],await xl(this.deleteMany(e,n)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let n=this._all(t,e);if(t.prefix!=null){const s=t.prefix;n=_n(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>_n(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>Al(s,i),n)),t.offset!=null){let s=0;const i=t.offset;n=_n(n,()=>s++>=i)}return t.limit!=null&&(n=Cl(n,t.limit)),n}queryKeys(t,e){let n=this._allKeys(t,e);if(t.prefix!=null){const s=t.prefix;n=_n(n,i=>i.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>_n(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>Al(s,i),n)),t.offset!=null){const s=t.offset;let i=0;n=_n(n,()=>i++>=s)}return t.limit!=null&&(n=Cl(n,t.limit)),n}}class JE extends QE{constructor(){super();l(this,"data");this.data=new Map}put(e,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(e.toString(),n),e}get(e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(e.toString());if(s==null)throw new ha;return s}has(e,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(e.toString())}delete(e,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(e.toString())}*_all(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new Ue(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new Ue(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const ue=r=>({match:t=>{const e=t[0];return e==null||e.code!==r||e.value!=null?!1:t.slice(1)}}),V=(r,t)=>({match:e=>{const n=e[0];return(n==null?void 0:n.code)!==r||n.value==null||t!=null&&n.value!==t?!1:e.slice(1)}}),jE=r=>({match:t=>r.match(t)===!1?t:!1}),ee=r=>({match:t=>{const e=r.match(t);return e===!1?t:e}}),Ve=(...r)=>({match:t=>{let e;for(const n of r){const s=n.match(t);s!==!1&&(e==null||s.length<e.length)&&(e=s)}return e??!1}}),ie=(...r)=>({match:t=>{for(const e of r){const n=e.match(t);if(n===!1)return!1;t=n}return t}});function he(...r){function t(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function e(s){return t(s)!==!1}function n(s){const i=t(s);return i===!1?!1:i.length===0}return{matchers:r,matches:e,exactMatch:n}}const ev=V(H),tv=he(ev),Ji=V(Uh),ji=V(zh),eo=V(qh),wc=V($h);he(Ji,ee(V(H)));he(ji,ee(V(H)));he(eo,ee(V(H)));he(Ve(wc,eo,Ji,ji),ee(V(H)));const Cf=ie(V(hi),ee(V(fc))),_f=ie(ee(V(hc)),V(nr),ee(V(fc))),bc=Ve(Cf,_f),vn=Ve(bc,wc,Ji,ji,eo),nv=he(Ve(bc,ie(Ve(wc,eo,Ji,ji),ee(V(H))))),_l=he(Cf),Il=he(_f);he(bc);const Ec=ie(vn,V(Mn)),ls=ie(vn,V(Bh)),bi=he(ie(Ec,ee(V(H))));he(ls);const vc=ie(ls,ue(Vh),ee(V(H))),to=ie(ls,ue(Wh),ee(V(H))),rv=Ve(vc,to);he(vc);const sv=he(to),fa=Ve(vn,Ec,ls,vc,to),If=Ve(ie(fa,ue(mc),ee(V(H)))),Ei=he(If),Tf=Ve(ie(fa,ue(Gh),ee(V(H))),ie(fa,ue(Nn),ee(V(fi)),ue(mc),ee(V(H)))),ma=he(Tf),Lf=ie(ls,ue(Yh),ee(V(Yr)),ee(V(Yr)),ee(V(H))),Tl=he(Lf),Df=ie(to,ue(Hh),ee(V(Yr)),ee(V(Yr)),ee(V(H))),Ll=he(Df),vi=Ve(If,Tf,ie(Ec,ee(V(H))),ie(rv,ee(V(H))),ie(vn,ee(V(H))),Lf,Df,V(H)),Sc=he(vi),iv=ie(ee(vi),ue(hr),jE(ue(Nr)),ee(V(H))),sr=he(iv),ov=Ve(ie(vi,ue(hr),ue(Nr),ee(V(H))),ie(vi,ue(Nr),ee(V(H))),ie(ue(Nr),ee(V(H)))),ga=he(ov),av=Ve(ie(vn,V(Mn),ue(On),ee(V(H))),ie(vn,ue(On),ee(V(H))));he(av);const cv=ie(vn,Ve(ie(V(Mn,"443"),ue(On)),ie(V(Mn),ue(oa)),ie(V(Mn),ue(Nn),ue(On)),ie(ue(Nn),ue(On)),ue(Nn),ue(oa)),ee(V(H)));he(cv);const lv=Ve(ie(V(Xh),ee(V(H))));he(lv);const uv=Ve(ie(V(Kh),ee(V(H))));he(uv);const Dl=864e13;class dv{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Pt({name:"libp2p_address_manager_dns_mappings",metrics:t.metrics})}has(t){const e=ge(t);let n=e.host;(e.type==="ip4"||e.type==="ip6")&&e.sni!=null&&(n=e.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(t,e){e.forEach(n=>{this.log("add DNS mapping %s to %s",n,t);const s=uc(n)===!0;this.mappings.set(n,{domain:t,verified:s,expires:s?Dl-Date.now():0,lastVerified:s?Dl-Date.now():void 0})})}remove(t){const e=ge(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===e.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(t){const e=[];for(let n=0;n<t.length;n++){const s=t[n].multiaddr;if(!at(s))continue;const i=ge(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(t.splice(n,1),n--,e.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return e}maybeAddSNIComponent(t,e){var s;const n=t.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===Nn&&((s=n[i+1])==null?void 0:s.code)!==fi)return n.splice(i+1,0,{name:"sni",code:fi,value:e}),Z(n)}confirm(t,e){const n=ge(t);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+e,a.lastVerified=Date.now());return i}unconfirm(t,e){const n=ge(t);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+e);return i}}class hv{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Pt({name:"libp2p_address_manager_ip_mappings",metrics:t.metrics})}has(t){const e=ge(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===e.host)return!0;return!1}add(t,e,n,s=e,i="tcp"){const o=`${t}-${e}-${i}`,a=this.mappings.get(o)??[],c={internalIp:t,internalPort:e,externalIp:n,externalPort:s,externalFamily:jn(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(t){const e=ge(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===e.host&&a.externalPort===e.port&&a.protocol===e.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,e.host,e.port,e.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(t){const e=[];for(const{multiaddr:n}of t){if(!at(n))continue;const s=ge(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)e.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return e}maybeOverrideIp(t,e,n,s,i){const o=t.getComponents(),a=o.findIndex(u=>u.code===hi||u.code===nr),c=o.findIndex(u=>u.name===s);return a>-1&&c>-1?(o[a].value=e,o[a].code=n===4?hi:nr,o[c].value=`${i}`,Z(o)):t}confirm(t,e){if(!at(t))return!1;const n=ge(t);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+e,o.lastVerified=Date.now());return s}unconfirm(t,e){if(!at(t))return!1;const n=ge(t);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+e)}return s}}const fv={maxObservedAddresses:10};class mv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Pt({name:"libp2p_address_manager_observed_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??fv.maxObservedAddresses}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(er(t)||Sb(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:Z(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var n;const e=((n=this.addresses.get(t.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),e}confirm(t,e){const n=t.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const gv={maxObservedAddresses:10};class pv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Pt({name:"libp2p_address_manager_transport_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??gv.maxObservedAddresses}get(t,e){if(er(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const n=this.toKey(t);let s=this.addresses.get(n);return s==null&&(s={verified:!at(t),expires:0},this.addresses.set(n,s)),{multiaddr:t,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var s;const e=this.toKey(t),n=((s=this.addresses.get(e))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(e),n}confirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+e,this.addresses.set(n,s),i}toKey(t){if(!at(t))return t.toString();const e=ge(t);return`${e.host}-${e.port}-${e.protocol}`}}const Pl=6e4,Rl={addressVerificationTTL:Pl*10,addressVerificationRetry:Pl*5},yv=r=>r;function To(r,t){var n;const e=(n=r.getComponents().findLast(s=>s.code===H))==null?void 0:n.value;return e!=null&&ct(e).equals(t)&&(r=r.decapsulate(Z(`/p2p/${t.toString()}`))),r}var _u;_u=Symbol.toStringTag;class wv{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"listen");l(this,"announce");l(this,"appendAnnounce");l(this,"announceFilter");l(this,"observed");l(this,"dnsMappings");l(this,"ipMappings");l(this,"transportAddresses");l(this,"observedAddressFilter");l(this,"addressVerificationTTL");l(this,"addressVerificationRetry");l(this,_u,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new mv(t,e),this.dnsMappings=new dv(t,e),this.ipMappings=new hv(t,e),this.transportAddresses=new pv(t,e),this.announceFilter=e.announceFilter??yv,this.observedAddressFilter=Wr(1024),this.addressVerificationTTL=e.addressVerificationTTL??Rl.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??Rl.addressVerificationRetry,this._updatePeerStoreAddresses=ui(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(e=>{var n;return((n=e.getComponents().findLast(s=>s.code===H))==null?void 0:n.value)===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e});this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(e=>{this.log.error("error updating addresses - %e",e)})}getListenAddrs(){return Array.from(this.listen).map(t=>Z(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>Z(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>Z(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=ge(t);let n;switch(e.type){case"ip4":{n=`${e.host}:${e.port}`;break}case"ip6":{n=`[${e.host}]:${e.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),t=To(t,this.components.peerId),!this.ipMappings.has(t)&&(this.dnsMappings.has(t)||this.observed.add(t)))}confirmObservedAddr(t,e){t=To(t,this.components.peerId);let n=!0;((e==null?void 0:e.type)==="transport"||this.transportAddresses.has(t))&&!this.transportAddresses.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="dns-mapping"||this.dnsMappings.has(t))&&!this.dnsMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="ip-mapping"||this.ipMappings.has(t))&&!this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="observed"||this.observed.has(t))&&(this.maybeUpgradeToIPMapping(t)?(this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=To(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(e.map(n=>{const s=Z(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(t)}),t.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];e=e.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),e=e.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(Z(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.add(t,e,n,s,i),this.observed.removePrefixed(`/ip${jn(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.remove(Z(`/ip${jn(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t)||!at(t))return!1;const e=ge(t);if(e.type!=="ip4"||uc(e.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>Ei.exactMatch(i)||ma.exactMatch(i),i=>bi.exactMatch(i),i=>sv.exactMatch(i)];for(const i of s){if(!i(t))continue;const o=n.filter(u=>u.getAddrs().filter(d=>ge(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!ia(u)).pop();if(a==null)continue;const c=ge(a);return c.port==null?!1:(this.observed.remove(t),this.ipMappings.add(c.host,c.port,e.host,e.port,e.protocol),!0)}return!1}}var kl;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(kl||(kl={}));class bv extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class Ev extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class Lo extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class Ml extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class vv extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class Sv extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class xv extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class Nl extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class Av extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class Cv extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class _v extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class Iv extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class Tv extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class qs extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class Ts extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class Lv extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class Dv extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}class Pv{constructor(t={}){l(this,"components",{});l(this,"_started",!1);this.components={};for(const[e,n]of Object.entries(t))this.components[e]=n;this.components.logger==null&&(this.components.logger=ph())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(e=>Ua(e)).map(async e=>{var n;await((n=e[t])==null?void 0:n.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Rv=["metrics","connectionProtector","dns"],kv=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Mv(r={}){const t=new Pv(r);return new Proxy(t,{get(n,s,i){if(typeof s=="string"&&!kv.includes(s)){const o=t.components[s];if(o==null&&!Rv.includes(s))throw new bv(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?t.components[s]=i:Reflect.set(n,s,i),!0}})}function Nv(r){const t={};for(const e of Object.values(r.components))for(const n of Ov(e))t[n]=!0;for(const e of Object.values(r.components))for(const n of Fv(e))if(t[n]!==!0)throw new Ev(`Service "${Bv(e)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function Ov(r){return Array.isArray(r==null?void 0:r[Lt])?r[Lt]:[]}function Fv(r){return Array.isArray(r==null?void 0:r[Js])?r[Js]:[]}function Bv(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function $v(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=t=>Ei.matches(t)?!0:er(t)),r}class de extends Event{constructor(e,n){super(e);l(this,"type");l(this,"detail");this.type=e,this.detail=n}}function Pf(r){var n;if(Lr(r))return{peerId:r,multiaddrs:[]};let t=Array.isArray(r)?r:[r],e;if(t.length>0){const s=(n=t[0].getComponents().findLast(i=>i.code===H))==null?void 0:n.value;e=s==null?void 0:ct(s),t.forEach(i=>{var a;if(!Zi(i))throw new Oi("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===H))==null?void 0:a.value;if(o==null){if(e!=null)throw new G("Multiaddrs must all have the same peer id or have no peer id")}else{const c=ct(o);if((e==null?void 0:e.equals(c))!==!0)throw new G("Multiaddrs must all have the same peer id or have no peer id")}})}return t=t.filter(s=>!tv.exactMatch(s)),{peerId:e,multiaddrs:t}}const Uv=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function zv(r,t){var s;const e=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(t==null?void 0:t.closableProtocols)??Uv;if(!(e.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(t))}catch(i){r==null||r.abort(i)}}function pa(r){const t=ge(r);let e=t.cidr;if(t.type!=="ip4"&&t.type!=="ip6")throw new G(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(e==null)switch(t.type){case"ip4":{e=32;break}case"ip6":{e=128;break}default:throw new G(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new _h(t.host,e)}function Rf(r){return!sr.exactMatch(r)}function kf(r,t,e){if(r==null||t==null)return;const n=t.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||e==null)return n;if(!e.some(i=>Rf(i)))return n}class qv{constructor(t,e={}){l(this,"connectionManager");l(this,"peerStore");l(this,"allow");l(this,"events");l(this,"log");this.allow=(e.allow??[]).map(n=>pa(n)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections - %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",e,n),e<=n)return;const s=new dr;for(const c of t){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,f)=>h+f.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(t,s),o=Math.max(e-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(at(c.remoteAddr)){const h=ge(c.remoteAddr);return d.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await zv(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(t,e){return t.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=e.get(n.remotePeer)??0,o=e.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const Mf=1e4,Nf=1e3,Kv=1e4,Si=1e4,Of=25,Vv=5,Wv=10,Hv=5,Gv="last-dial-failure",Yv="last-dial-success",Ff=500,Xv=32,Zv=100,Bf=50;function Qv(r,t){const e=bi.exactMatch(r.multiaddr),n=bi.exactMatch(t.multiaddr);if(e&&!n)return-1;if(!e&&n)return 1;const s=ma.exactMatch(r.multiaddr),i=ma.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=Ei.exactMatch(r.multiaddr),a=Ei.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=ga.exactMatch(r.multiaddr),u=ga.exactMatch(t.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const d=Tl.exactMatch(r.multiaddr),h=Tl.exactMatch(t.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const f=Ll.exactMatch(r.multiaddr),p=Ll.exactMatch(t.multiaddr);return f&&!p?-1:!f&&p?1:0}function Jv(r,t){const e=ia(r.multiaddr),n=ia(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function jv(r,t){const e=er(r.multiaddr),n=er(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function eS(r,t){return r.isCertified&&!t.isCertified?-1:!r.isCertified&&t.isCertified?1:0}function tS(r,t){const e=sr.exactMatch(r.multiaddr),n=sr.exactMatch(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function nS(r){return r.sort(Qv).sort(eS).sort(tS).sort(jv).sort(Jv)}var $f={exports:{}};(function(r){var t=Object.prototype.hasOwnProperty,e="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(e=!1));function s(c,u,d){this.fn=c,this.context=u,this.once=d||!1}function i(c,u,d,h,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||c,f),m=e?e+u:u;return c._events[m]?c._events[m].fn?c._events[m]=[c._events[m],p]:c._events[m].push(p):(c._events[m]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)t.call(d,h)&&u.push(e?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=e?e+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var f=0,p=h.length,m=new Array(p);f<p;f++)m[f]=h[f].fn;return m},a.prototype.listenerCount=function(u){var d=e?e+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,f,p,m){var y=e?e+u:u;if(!this._events[y])return!1;var g=this._events[y],S=arguments.length,v,E;if(g.fn){switch(g.once&&this.removeListener(u,g.fn,void 0,!0),S){case 1:return g.fn.call(g.context),!0;case 2:return g.fn.call(g.context,d),!0;case 3:return g.fn.call(g.context,d,h),!0;case 4:return g.fn.call(g.context,d,h,f),!0;case 5:return g.fn.call(g.context,d,h,f,p),!0;case 6:return g.fn.call(g.context,d,h,f,p,m),!0}for(E=1,v=new Array(S-1);E<S;E++)v[E-1]=arguments[E];g.fn.apply(g.context,v)}else{var L=g.length,x;for(E=0;E<L;E++)switch(g[E].once&&this.removeListener(u,g[E].fn,void 0,!0),S){case 1:g[E].fn.call(g[E].context);break;case 2:g[E].fn.call(g[E].context,d);break;case 3:g[E].fn.call(g[E].context,d,h);break;case 4:g[E].fn.call(g[E].context,d,h,f);break;default:if(!v)for(x=1,v=new Array(S-1);x<S;x++)v[x-1]=arguments[x];g[E].fn.apply(g[E].context,v)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,f){var p=e?e+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var m=this._events[p];if(m.fn)m.fn===d&&(!f||m.once)&&(!h||m.context===h)&&o(this,p);else{for(var y=0,g=[],S=m.length;y<S;y++)(m[y].fn!==d||f&&!m[y].once||h&&m[y].context!==h)&&g.push(m[y]);g.length?this._events[p]=g.length===1?g[0]:g:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=e?e+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,r.exports=a})($f);var rS=$f.exports;const sS=Th(rS);class xc extends Error{constructor(e,n){var s;super(e,n);l(this,"name","TimeoutError");(s=Error.captureStackTrace)==null||s.call(Error,this,xc)}}const Ol=r=>r.reason??new DOMException("This operation was aborted.","AbortError");function iS(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout},signal:o}=t;let a,c;const d=new Promise((h,f)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(o!=null&&o.aborted){f(Ol(o));return}if(o&&(c=()=>{f(Ol(o))},o.addEventListener("abort",c,{once:!0})),r.then(h,f),e===Number.POSITIVE_INFINITY)return;const p=new xc;a=i.setTimeout.call(void 0,()=>{if(n){try{h(n())}catch(m){f(m)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?h():s instanceof Error?f(s):(p.message=s??`Promise timed out after ${e} milliseconds`,f(p))},e)}).finally(()=>{d.clear(),c&&o&&o.removeEventListener("abort",c)});return d.clear=()=>{i.clearTimeout.call(void 0,a),a=void 0},d}function oS(r,t,e){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;e(r[o],t)<=0?(n=++o,s-=i+1):s=i}return n}var et;class aS{constructor(){oe(this,et,[])}enqueue(t,e){const{priority:n=0,id:s}=e??{},i={priority:n,id:s,run:t};if(this.size===0||D(this,et)[this.size-1].priority>=n){D(this,et).push(i);return}const o=oS(D(this,et),i,(a,c)=>c.priority-a.priority);D(this,et).splice(o,0,i)}setPriority(t,e){const n=D(this,et).findIndex(i=>i.id===t);if(n===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[s]=D(this,et).splice(n,1);this.enqueue(s.run,{priority:e,id:t})}dequeue(){const t=D(this,et).shift();return t==null?void 0:t.run}filter(t){return D(this,et).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return D(this,et).length}}et=new WeakMap;var zn,st,ht,qn,Kn,Vn,Ut,Qr,Wn,ft,At,xe,Jr,Ne,un,Ct,Mi,dn,q,Uf,zf,qf,Kf,Vf,ya,wa,Wf,Ks,ba,Ea,Vs,Hf,Jt,Gf,Ar,va;class cS extends sS{constructor(e){var n,s;super();oe(this,q);oe(this,zn);oe(this,st);oe(this,ht,0);oe(this,qn);oe(this,Kn,!1);oe(this,Vn,!1);oe(this,Ut);oe(this,Qr,0);oe(this,Wn,0);oe(this,ft);oe(this,At);oe(this,xe);oe(this,Jr);oe(this,Ne,0);oe(this,un);oe(this,Ct);oe(this,Mi,1n);oe(this,dn,new Map);l(this,"timeout");if(e={carryoverIntervalCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:aS,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=e.intervalCap)==null?void 0:n.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=e.interval)==null?void 0:s.toString())??""}\` (${typeof e.interval})`);if(le(this,zn,e.carryoverIntervalCount??e.carryoverConcurrencyCount??!1),le(this,st,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),le(this,qn,e.intervalCap),le(this,Ut,e.interval),le(this,xe,new e.queueClass),le(this,Jr,e.queueClass),this.concurrency=e.concurrency,e.timeout!==void 0&&!(Number.isFinite(e.timeout)&&e.timeout>0))throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${e.timeout}\` (${typeof e.timeout})`);this.timeout=e.timeout,le(this,Ct,e.autoStart===!1),z(this,q,Gf).call(this)}get concurrency(){return D(this,un)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);le(this,un,e),z(this,q,Vs).call(this)}setPriority(e,n){if(typeof n!="number"||!Number.isFinite(n))throw new TypeError(`Expected \`priority\` to be a finite number, got \`${n}\` (${typeof n})`);D(this,xe).setPriority(e,n)}async add(e,n={}){return n.id??(n.id=(Sn(this,Mi)._++).toString()),n={timeout:this.timeout,...n},new Promise((s,i)=>{const o=Symbol(`task-${n.id}`);D(this,xe).enqueue(async()=>{var a;Sn(this,Ne)._++,D(this,dn).set(o,{id:n.id,priority:n.priority??0,startTime:Date.now(),timeout:n.timeout});try{try{(a=n.signal)==null||a.throwIfAborted()}catch(d){throw D(this,st)||Sn(this,ht)._--,D(this,dn).delete(o),d}let c=e({signal:n.signal});n.timeout&&(c=iS(Promise.resolve(c),{milliseconds:n.timeout,message:`Task timed out after ${n.timeout}ms (queue has ${D(this,Ne)} running, ${D(this,xe).size} waiting)`})),n.signal&&(c=Promise.race([c,z(this,q,Hf).call(this,n.signal)]));const u=await c;s(u),this.emit("completed",u)}catch(c){i(c),this.emit("error",c)}finally{D(this,dn).delete(o),queueMicrotask(()=>{z(this,q,qf).call(this)})}},n),this.emit("add"),z(this,q,Ks).call(this)})}async addAll(e,n){return Promise.all(e.map(async s=>this.add(s,n)))}start(){return D(this,Ct)?(le(this,Ct,!1),z(this,q,Vs).call(this),this):this}pause(){le(this,Ct,!0)}clear(){le(this,xe,new(D(this,Jr))),z(this,q,va).call(this)}async onEmpty(){D(this,xe).size!==0&&await z(this,q,Jt).call(this,"empty")}async onSizeLessThan(e){D(this,xe).size<e||await z(this,q,Jt).call(this,"next",()=>D(this,xe).size<e)}async onIdle(){D(this,Ne)===0&&D(this,xe).size===0||await z(this,q,Jt).call(this,"idle")}async onPendingZero(){D(this,Ne)!==0&&await z(this,q,Jt).call(this,"pendingZero")}async onRateLimit(){this.isRateLimited||await z(this,q,Jt).call(this,"rateLimit")}async onRateLimitCleared(){this.isRateLimited&&await z(this,q,Jt).call(this,"rateLimitCleared")}async onError(){return new Promise((e,n)=>{const s=i=>{this.off("error",s),n(i)};this.on("error",s)})}get size(){return D(this,xe).size}sizeBy(e){return D(this,xe).filter(e).length}get pending(){return D(this,Ne)}get isPaused(){return D(this,Ct)}get isRateLimited(){return D(this,Kn)}get isSaturated(){return D(this,Ne)===D(this,un)&&D(this,xe).size>0||this.isRateLimited&&D(this,xe).size>0}get runningTasks(){return[...D(this,dn).values()].map(e=>({...e}))}}zn=new WeakMap,st=new WeakMap,ht=new WeakMap,qn=new WeakMap,Kn=new WeakMap,Vn=new WeakMap,Ut=new WeakMap,Qr=new WeakMap,Wn=new WeakMap,ft=new WeakMap,At=new WeakMap,xe=new WeakMap,Jr=new WeakMap,Ne=new WeakMap,un=new WeakMap,Ct=new WeakMap,Mi=new WeakMap,dn=new WeakMap,q=new WeakSet,Uf=function(){return D(this,st)||D(this,ht)<D(this,qn)},zf=function(){return D(this,Ne)<D(this,un)},qf=function(){Sn(this,Ne)._--,D(this,Ne)===0&&this.emit("pendingZero"),z(this,q,Ks).call(this),this.emit("next")},Kf=function(){z(this,q,Ea).call(this),z(this,q,ba).call(this),le(this,At,void 0)},Vf=function(){const e=Date.now();if(D(this,ft)===void 0){const n=D(this,Qr)-e;if(n<0){if(D(this,Wn)>0){const s=e-D(this,Wn);if(s<D(this,Ut))return z(this,q,ya).call(this,D(this,Ut)-s),!0}le(this,ht,D(this,zn)?D(this,Ne):0)}else return z(this,q,ya).call(this,n),!0}return!1},ya=function(e){D(this,At)===void 0&&le(this,At,setTimeout(()=>{z(this,q,Kf).call(this)},e))},wa=function(){D(this,ft)&&(clearInterval(D(this,ft)),le(this,ft,void 0))},Wf=function(){D(this,At)&&(clearTimeout(D(this,At)),le(this,At,void 0))},Ks=function(){if(D(this,xe).size===0)return z(this,q,wa).call(this),this.emit("empty"),D(this,Ne)===0&&(z(this,q,Wf).call(this),this.emit("idle")),!1;let e=!1;if(!D(this,Ct)){const n=!D(this,q,Vf);if(D(this,q,Uf)&&D(this,q,zf)){const s=D(this,xe).dequeue();D(this,st)||(Sn(this,ht)._++,z(this,q,Ar).call(this)),this.emit("active"),le(this,Wn,Date.now()),s(),n&&z(this,q,ba).call(this),e=!0}}return e},ba=function(){D(this,st)||D(this,ft)!==void 0||(le(this,ft,setInterval(()=>{z(this,q,Ea).call(this)},D(this,Ut))),le(this,Qr,Date.now()+D(this,Ut)))},Ea=function(){D(this,ht)===0&&D(this,Ne)===0&&D(this,ft)&&z(this,q,wa).call(this),le(this,ht,D(this,zn)?D(this,Ne):0),z(this,q,Vs).call(this),z(this,q,Ar).call(this)},Vs=function(){for(;z(this,q,Ks).call(this););},Hf=async function(e){return new Promise((n,s)=>{e.addEventListener("abort",()=>{s(e.reason)},{once:!0})})},Jt=async function(e,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(e,i),s())};this.on(e,i)})},Gf=function(){D(this,st)||(this.on("add",()=>{D(this,xe).size>0&&z(this,q,Ar).call(this)}),this.on("next",()=>{z(this,q,Ar).call(this)}))},Ar=function(){D(this,st)||D(this,Vn)||(le(this,Vn,!0),queueMicrotask(()=>{le(this,Vn,!1),z(this,q,va).call(this)}))},va=function(){const e=D(this,Kn),n=!D(this,st)&&D(this,ht)>=D(this,qn)&&D(this,xe).size>0;n!==e&&(le(this,Kn,n),this.emit(n?"rateLimit":"rateLimitCleared"))};function Yf(r){const t=[Xt.A];return r==null?t:Array.isArray(r)?r.length===0?t:r:[r]}const Xf=60;function Zf(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(t=>({name:t.name,type:Xt[t.type]})),Answer:(r.Answer??r.answers??[]).map(t=>({name:t.name,type:Xt[t.type],TTL:t.TTL??t.ttl??Xf,data:t.data instanceof Uint8Array?J(t.data):t.data}))}}const lS=4;function Fl(r,t={}){const e=new cS({concurrency:t.queryConcurrency??lS});return async(n,s={})=>{var a;const i=new URLSearchParams;i.set("name",n),Yf(s.types).forEach(c=>{i.append("type",Xt[c])}),(a=s.onProgress)==null||a.call(s,new de("dns:query",n));const o=await e.add(async()=>{var d;const c=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const u=Zf(await c.json());return(d=s.onProgress)==null||d.call(s,new de("dns:response",u)),u},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function uS(){return[Fl("https://cloudflare-dns.com/dns-query"),Fl("https://dns.google/resolve")]}var dS=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,e=Object.create(null),n=Object.create(null);function s(i,o){e[i]=o,t++,t>=r&&(t=0,n=e,e=Object.create(null))}return{has:function(i){return e[i]!==void 0||n[i]!==void 0},remove:function(i){e[i]!==void 0&&(e[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=e[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){e[i]!==void 0?e[i]=o:s(i,o)},clear:function(){e=Object.create(null),n=Object.create(null)}}};const hS=Th(dS);class fS{constructor(t){l(this,"lru");this.lru=hS(t)}get(t,e){let n=!0;const s=[];for(const i of e){const o=this.getAnswers(t,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return Zf({answers:s})}getAnswers(t,e){const n=`${t.toLowerCase()}-${e}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Xt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(t,e){const n=`${t.toLowerCase()}-${e.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(e.TTL??Xf)*1e3,value:e}),this.lru.set(n,s)}remove(t,e){const n=`${t.toLowerCase()}-${e}`;this.lru.remove(n)}clear(){this.lru.clear()}}function mS(r){return new fS(r)}const gS=1e3;class pS{constructor(t){l(this,"resolvers");l(this,"cache");this.resolvers={},this.cache=mS(t.cacheSize??gS),Object.entries(t.resolvers??{}).forEach(([e,n])=>{Array.isArray(n)||(n=[n]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=n}),this.resolvers["."]==null&&(this.resolvers["."]=uS())}async query(t,e={}){var c,u,d;const n=Yf(e.types),s=e.cached!==!1?this.cache.get(t,n):void 0;if(s!=null)return(c=e.onProgress)==null||c.call(e,new de("dns:cache",s)),s;const i=`${t.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((u=e.signal)==null?void 0:u.aborted)===!0)break;try{const f=await h(t,{...e,types:n});for(const p of f.Answer)this.cache.add(t,p);return f}catch(f){a.push(f),(d=e.onProgress)==null||d.call(e,new de("dns:error",f))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${t} ${n} failed`)}}var Xt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Xt||(Xt={}));function yS(r={}){return new pS(r)}class wS{constructor(){l(this,"dns")}canResolve(t){return t.getComponents().some(({name:e})=>e==="dnsaddr")}async resolve(t,e){var c,u;const n=(c=t.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[t];const i=await this.getDNS(e).query(`_dnsaddr.${n}`,{signal:e==null?void 0:e.signal,types:[Xt.TXT]}),o=(u=t.getComponents().find(d=>d.name==="p2p"))==null?void 0:u.value,a=[];for(const d of i.Answer){const h=d.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(Z(h)))}return a}getDNS(t){return t.dns!=null?t.dns:(this.dns==null&&(this.dns=yS()),this.dns)}}const Qf=new wS;async function Jf(r,t,e){const n=e.depth??0;if(n>(e.maxRecursiveDepth??Xv))throw new Dv("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(t))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,e);for(const c of a)i.push(...await Jf(c,t,{...e,depth:n+1}))}return s===!1&&i.push(r),i}const Er={maxParallelDials:Bf,maxDialQueueLength:Ff,maxPeerAddrsToDial:Of,dialTimeout:Mf,resolvers:{dnsaddr:Qf}};class bS{constructor(t,e={}){l(this,"queue");l(this,"components");l(this,"addressSorter");l(this,"maxPeerAddrsToDial");l(this,"maxDialQueueLength");l(this,"dialTimeout");l(this,"shutDownController");l(this,"connections");l(this,"log");l(this,"resolvers");this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??Er.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??Er.maxDialQueueLength,this.dialTimeout=e.dialTimeout??Er.dialTimeout,this.connections=e.connections??new dr,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.resolvers=e.resolvers??Er.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new tE({concurrency:e.maxParallelDials??Er.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==Fr.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var o,a,c;const{peerId:n,multiaddrs:s}=Pf(t);if(n!=null&&e.force!==!0){const u=kf(n,this.connections.get(n),s);if(u!=null)return this.log("already connected to %a",u.remoteAddr),(o=e.onProgress)==null||o.call(e,new de("dial-queue:already-connected")),u}const i=this.queue.queue.find(u=>{if((n==null?void 0:n.equals(u.options.peerId))===!0)return!0;const d=u.options.multiaddrs;if(d==null)return!1;for(const h of s)if(d.has(h.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const u of s)i.options.multiaddrs.add(u.toString());return(a=e.onProgress)==null||a.call(e,new de("dial-queue:already-in-dial-queue")),i.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new Tr("Dial queue is full");return this.log("creating dial target for %p",n,s.map(u=>u.toString())),(c=e.onProgress)==null||c.call(e,new de("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var h;(h=u.onProgress)==null||h.call(u,new de("dial-queue:start-dial"));const d=wn([this.shutDownController.signal,u.signal]);try{return await this.dialPeer(u,d)}finally{d.clear()}},{peerId:n,priority:e.priority??jf,multiaddrs:new Set(s.map(u=>u.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var d;const n=t.peerId,s=t.multiaddrs,i=new Set;let o=t.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const h=[],f=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...f]);const p=await this.calculateMultiaddrs(n,f,{...t,signal:e});for(const m of p){if(i.has(m.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",m.multiaddr,n);continue}h.push(m)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(m=>m.multiaddr.toString())),(d=t==null?void 0:t.onProgress)==null||d.call(t,new de("dial-queue:calculated-addresses",h));for(const m of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new Tr("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(m.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",m.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[Yv]:X(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p - %e",n,g)}return y}catch(y){if(this.log.error("dial failed to %a - %e",m.multiaddr,y),i.add(m.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[Gv]:X(Date.now().toString())}})}catch(g){this.log.error("could not update last dial failure key for %p - %e",n,g)}if(e.aborted)throw new qm(y.message);u.push(y)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,n={}){var h,f;const s=[...e].map(p=>({multiaddr:Z(p),isCertified:!1}));if(t!=null){if(this.components.peerId.equals(t))throw new Tr("Tried to dial self");if(await((f=(h=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(h,t))===!0)throw new Nl("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",t);try{const p=await this.components.peerStore.get(t);s.push(...p.addresses),this.log("loaded multiaddrs for %p",t,s.map(({multiaddr:m})=>m.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",t);try{const p=await this.components.peerRouting.findPeer(t,n);this.log("found multiaddrs for %p in the peer routing",t,s.map(({multiaddr:m})=>m.toString())),s.push(...p.multiaddrs.map(m=>({multiaddr:m,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,p)}}}let i=(await Promise.all(s.map(async p=>{const m=await Jf(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return m.length===1&&m[0].equals(p.multiaddr)?p:m.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(t!=null){const p=`/p2p/${t.toString()}`;i=i.map(m=>{const y=m.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:m.multiaddr.encapsulate(p),isCertified:m.isCertified}:m})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const m=(y=p.multiaddr.getComponents().findLast(g=>g.code===H))==null?void 0:y.value;return t!=null&&m!=null?t.equals(m):!0}),a=new Map;for(const p of o){const m=p.multiaddr.toString(),y=a.get(m);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(m,p)}const c=[...a.values()];if(c.length===0)throw new _v("The dial request has no valid addresses");const u=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||u.push(p);const d=this.addressSorter==null?nS(u):u.sort(this.addressSorter);if(d.length===0)throw new Nl("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const n=await this.calculateMultiaddrs(void 0,new Set(t.map(s=>s.toString())),e);return e.runOnLimitedConnection===!1?n.find(s=>!sr.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}const ES=Object.prototype.toString,vS=r=>ES.call(r)==="[object Error]",SS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function xS(r){if(!(r&&vS(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:e,stack:n}=r;return e==="Load failed"?n===void 0||"__sentry_captured__"in r:e.startsWith("error sending request for url")?!0:SS.has(e)}function AS(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function Ls(r,t,{min:e=0,allowInfinity:n=!1}={}){if(t!==void 0){if(typeof t!="number"||Number.isNaN(t))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(t))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(t<e)throw new TypeError(`Expected \`${r}\` to be â‰¥ ${e}.`)}}class CS extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,{message:t}=t):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}function _S(r,t){const e=Math.max(1,r+1),n=t.randomize?Math.random()+1:1;let s=Math.round(n*t.minTimeout*t.factor**(e-1));return s=Math.min(s,t.maxTimeout),s}function Bl(r,t){return Number.isFinite(t)?t-(performance.now()-r):t}async function IS({error:r,attemptNumber:t,retriesConsumed:e,startTime:n,options:s}){var p,m,y;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof CS)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-e):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:t,retriesLeft:o,retriesConsumed:e});if(await s.onFailedAttempt(c),Bl(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(c),d=Bl(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!xS(i)){if(u)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!u)return(m=s.signal)==null||m.throwIfAborted(),!1;const h=_S(e,s),f=Math.min(h,d);return f>0&&await new Promise((g,S)=>{var L,x;const v=()=>{var _;clearTimeout(E),(_=s.signal)==null||_.removeEventListener("abort",v),S(s.signal.reason)},E=setTimeout(()=>{var _;(_=s.signal)==null||_.removeEventListener("abort",v),g()},f);s.unref&&((L=E.unref)==null||L.call(E)),(x=s.signal)==null||x.addEventListener("abort",v,{once:!0})}),(y=s.signal)==null||y.throwIfAborted(),!0}async function TS(r,t={}){var i,o,a;if(t={...t},AS(t.retries),Object.hasOwn(t,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");t.retries??(t.retries=10),t.factor??(t.factor=2),t.minTimeout??(t.minTimeout=1e3),t.maxTimeout??(t.maxTimeout=Number.POSITIVE_INFINITY),t.maxRetryTime??(t.maxRetryTime=Number.POSITIVE_INFINITY),t.randomize??(t.randomize=!1),t.onFailedAttempt??(t.onFailedAttempt=()=>{}),t.shouldRetry??(t.shouldRetry=()=>!0),t.shouldConsumeRetry??(t.shouldConsumeRetry=()=>!0),Ls("factor",t.factor,{min:0,allowInfinity:!1}),Ls("minTimeout",t.minTimeout,{min:0,allowInfinity:!1}),Ls("maxTimeout",t.maxTimeout,{min:0,allowInfinity:!0}),Ls("maxRetryTime",t.maxRetryTime,{min:0,allowInfinity:!0}),t.factor>0||(t.factor=1),(i=t.signal)==null||i.throwIfAborted();let e=0,n=0;const s=performance.now();for(;!Number.isFinite(t.retries)||n<=t.retries;){e++;try{(o=t.signal)==null||o.throwIfAborted();const c=await r(e);return(a=t.signal)==null||a.throwIfAborted(),c}catch(c){await IS({error:c,attemptNumber:e,retriesConsumed:n,startTime:s,options:t})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class LS{constructor(t,e={}){l(this,"log");l(this,"queue");l(this,"started");l(this,"peerStore");l(this,"retries");l(this,"retryInterval");l(this,"backoffFactor");l(this,"connectionManager");l(this,"events");this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new yc({concurrency:e.maxParallelReconnects??Hv,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);$l(e)&&(this.queue.has(t)||this.queue.add(async n=>{await TS(async s=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",t,n);const s={};[...e.tags.keys()].forEach(i=>{i.startsWith($a)&&(s[i]=void 0)}),await this.peerStore.merge(t,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>$l(e)]});await Promise.all(t.map(async e=>{await this.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(t=>{this.log.error("error reconnect to peers after start - %e",t)})}stop(){this.started=!1,this.queue.abort()}}function $l(r){for(const t of r.tags.keys())if(t.startsWith($a))return!0;return!1}const jf=50,Do={maxConnections:Zv,inboundConnectionThreshold:Vv,maxIncomingPendingConnections:Wv};var Iu;Iu=Symbol.toStringTag;class DS{constructor(t,e={}){l(this,"started");l(this,"connections");l(this,"allow");l(this,"deny");l(this,"maxIncomingPendingConnections");l(this,"incomingPendingConnections");l(this,"outboundPendingConnections");l(this,"maxConnections");l(this,"dialQueue");l(this,"reconnectQueue");l(this,"connectionPruner");l(this,"inboundConnectionRateLimiter");l(this,"peerStore");l(this,"metrics");l(this,"events");l(this,"log");l(this,"peerId");l(this,Iu,"@libp2p/connection-manager");var n;if(this.maxConnections=e.maxConnections??Do.maxConnections,this.maxConnections<1)throw new G("Connection Manager maxConnections must be greater than 0");this.connections=new dr,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(s=>pa(Z(s))),this.deny=(e.deny??[]).map(s=>pa(Z(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??Do.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new nE({points:e.inboundConnectionThreshold??Do.inboundConnectionThreshold,duration:1}),this.connectionPruner=new qv({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{allow:(n=e.allow)==null?void 0:n.map(s=>Z(s))}),this.dialQueue=new bS(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??Bf,maxDialQueueLength:e.maxDialQueueLength??Ff,maxPeerAddrsToDial:e.maxPeerAddrsToDial??Of,dialTimeout:e.dialTimeout??Mf,resolvers:e.resolvers??{dnsaddr:Qf},connections:this.connections}),this.reconnectQueue=new LS({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,n;(t=this.metrics)==null||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(e=this.metrics)==null||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const u of a.streams){const d=`${u.direction} ${u.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[u,d]of Object.entries(c))s[u]=s[u]??[],s[u].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((u,d)=>u-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await hd(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await fd(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const n of e)t.push(Promise.all([$e(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(t){if(this.maxConnections<1)throw new G("Connection Manager maxConnections must be greater than 0");let e=!1;t<this.maxConnections&&(e=!0),this.maxConnections=t,e&&this.connectionPruner.maybePruneConnections()}onConnect(t){this._onConnect(t).catch(e=>{this.log.error("could not connect - %e",e)})}async _onConnect(t){const{detail:e}=t;if(!this.started){await e.close();return}if(e.status!=="open")return;const n=e.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(e),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,n=e.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==e.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(t){if(t!=null)return this.connections.get(t)??[];let e=[];for(const n of this.connections.values())e=e.concat(n);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var n,s;if(!this.started)throw new Br("Not started");this.outboundPendingConnections++;try{(n=e.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=Pf(t);if(this.peerId.equals(i))throw new Oa("Can not dial self");if(i!=null&&e.force!==!0){this.log("dial %p",i);const d=kf(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=e.onProgress)==null||s.call(e,new de("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(t,{...e,priority:e.priority??jf});if(a.status!=="open")throw new Xs("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let u=!1;for(const d of c)if(d.id===a.id&&(u=!0),e.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new Oi("Duplicate multiaddr connection")),d;return u||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(t,e,n={}){return(await this.openConnection(t,n)).newStream(e,n)}async closeConnections(t,e={}){const n=this.connections.get(t)??[];await Promise.all(n.map(async s=>{try{await Promise.all([$e(s,"close",e),s.close(e)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(t){if(this.deny.some(s=>{if(at(t.remoteAddr)){const i=ge(t.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(s=>{if(at(t.remoteAddr)){const i=ge(t.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(at(t.remoteAddr)){const s=ge(t.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(n=>Z(n))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}const PS=1e4,RS="1.0.0",kS="ping",MS="ipfs",Ul=32,NS=!0;var Tu,Lu;Lu=Symbol.toStringTag,Tu=Lt;class OS{constructor(t,e={}){l(this,"protocol");l(this,"components");l(this,"log");l(this,"heartbeatInterval");l(this,"pingIntervalMs");l(this,"abortController");l(this,"timeout");l(this,"abortConnectionOnPingFailure");l(this,Lu,"@libp2p/connection-monitor");l(this,Tu,["@libp2p/connection-monitor"]);this.components=t,this.protocol=`/${e.protocolPrefix??MS}/${kS}/${RS}`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??PS,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??NS,this.timeout=new Jb({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var n;let e=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await t.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=jh(i);e=Date.now(),await Promise.all([o.write(sh(Ul),{signal:s}),o.read({bytes:Ul,signal:s})]),t.rtt=Date.now()-e,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;t.rtt=(Date.now()-e)/2}}).catch(e=>{this.log.error("error during heartbeat - %e",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;(t=this.abortController)==null||t.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var Du;Du=Symbol.toStringTag;class FS{constructor(t,e){l(this,"routers");l(this,"started");l(this,"components");l(this,Du,"@libp2p/content-routing");var n,s,i,o,a;this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()}),getAttributesFromYieldedValue:(c,u)=>({...u,providers:[...Array.isArray(u.providers)?u.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:J(c,"base36")})}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:J(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(this.routers.length===0)throw new Lo("No content routers available");const n=this,s=new kn;for await(const i of ca(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(t,e))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(t,e={}){if(this.routers.length===0)throw new Lo("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(t,e)}))}async cancelReprovide(t,e={}){if(this.routers.length===0)throw new Lo("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(t,e)}))}async put(t,e,n){if(!this.isStarted())throw new Br;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(t,e,n)}))}async get(t,e){if(!this.isStarted())throw new Br;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(t,e)))}}const Ds=globalThis.CustomEvent??Event;async function*BS(r,t={}){let e=t.concurrency??1/0;e<1&&(e=1/0);const n=t.ordered??!1,s=new EventTarget,i=[];let o=tt(),a=tt(),c=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const m of r){if(i.length===e&&(o=tt(),await o.promise),d)break;const y={done:!1};i.push(y),m().then(g=>{y.done=!0,y.ok=!0,y.value=g,s.dispatchEvent(new Ds("task-complete"))},g=>{y.done=!0,y.err=g,s.dispatchEvent(new Ds("task-complete"))})}c=!0,s.dispatchEvent(new Ds("task-complete"))}catch(m){u=m,s.dispatchEvent(new Ds("task-complete"))}});function h(){var m;return n?(m=i[0])==null?void 0:m.done:!!i.find(y=>y.done)}function*f(){for(;i.length>0&&i[0].done;){const m=i[0];if(i.shift(),m.ok)yield m.value;else throw d=!0,o.resolve(),m.err;o.resolve()}}function*p(){for(;h();)for(let m=0;m<i.length;m++)if(i[m].done){const y=i[m];if(i.splice(m,1),m--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(h()||(a=tt(),await a.promise),u!=null||(n?yield*f():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}var Pu;Pu=Symbol.toStringTag;class $S{constructor(t,e={}){l(this,"log");l(this,"peerId");l(this,"peerStore");l(this,"routers");l(this,Pu,"@libp2p/peer-routing");var n,s;this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:J(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(this.routers.length===0)throw new Ml("No peer routers available");if(t.toString()===this.peerId.toString())throw new vv("Should not try to find self");const n=this,s=ca(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),i;throw new Ko}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new Ml("No peer routers available");const n=this,s=Wr(1024);for await(const i of BS(async function*(){const o=ca(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(t,e)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...e,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}var Ru,ku;class US extends(ku=Ze,Ru=Symbol.toStringTag,ku){constructor(e){super();l(this,"peerRouting");l(this,"log");l(this,"walking");l(this,"walkers");l(this,"shutdownController");l(this,"walkController");l(this,"needNext");l(this,Ru,"@libp2p/random-walk");this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){var s,i;this.walking||this.startWalk(),this.walkers++;const n=wn([this.shutdownController.signal,e==null?void 0:e.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=tt(),yield(await $e(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=wn([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=sh(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await yt(this.needNext.promise,e)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const em=32,tm=64;var Mu;Mu=Symbol.toStringTag;class zS{constructor(t){l(this,"log");l(this,"topologies");l(this,"handlers");l(this,"components");l(this,"middleware");l(this,Mu,"@libp2p/registrar");var e;this.components=t,this.log=t.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(e=t.metrics)==null||e.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=Pt({name:"libp2p_registrar_protocol_handlers",metrics:t.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(e==null)throw new Sv(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return e==null?[]:[...e.values()]}async handle(t,e,n){if(this.handlers.has(t)&&(n==null?void 0:n.force)!==!0)throw new xv(`Handler already registered for protocol ${t}`);this.handlers.set(t,{handler:e,options:{maxInboundStreams:em,maxOutboundStreams:tm,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]},n)}async unhandle(t,e){(Array.isArray(t)?t:[t]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},e)}async register(t,e){if(e==null)throw new G("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(t);return s==null&&(s=new Map,this.topologies.set(t,s)),s.set(n,e),n}unregister(t){for(const[e,n]of this.topologies.entries())n.has(t)&&(n.delete(t),n.size===0&&this.topologies.delete(e))}use(t,e){this.middleware.set(t,e)}unuse(t){this.middleware.delete(t)}getMiddleware(t){return this.middleware.get(t)??[]}async _onDisconnect(t){const e=t.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(e,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e))!==!1&&((u=a.filter)==null||u.remove(e),await((d=a.onDisconnect)==null?void 0:d.call(a,e)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",e,s)}}async _onPeerUpdate(t){const{peer:e,previous:n}=t.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!e.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e.id))!==!1&&((u=a.filter)==null||u.remove(e.id),await((d=a.onDisconnect)==null?void 0:d.call(a,e.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",e.id,i)}}async _onPeerIdentify(t){const e=t.detail.protocols,n=t.detail.connection,s=t.detail.peerId;try{for(const i of e){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((u=a.filter)==null||u.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}var Nu;Nu=Symbol.toStringTag;class qS{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"transports");l(this,"listeners");l(this,"faultTolerance");l(this,"started");l(this,Nu,"@libp2p/transport-manager");this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=Pt({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Pt({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??Qs.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(e==null)throw new G("Transport must have a valid tag");if(this.transports.has(e))throw new G(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,n]of this.listeners)for(this.log("closing listeners for %s",e);n.length>0;){const s=n.pop();s!=null&&t.push(s.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var s;const n=this.dialTransportForMultiaddr(t);if(n==null)throw new Lv(`No transport available for address ${String(t)}`);return(s=e==null?void 0:e.onProgress)==null||s.call(e,new de("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const n of e)t=[...t,...n.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values())if(e.dialFilter([t]).length>0)return e}listenTransportForMultiaddr(t){for(const e of this.transports.values())if(e.listenFilter([t]).length>0)return e}async listen(t){if(!this.isStarted())throw new Br("Not started");if(t==null||t.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(i=>{e.errors.set(i.toString(),new Av)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(t);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(f=>f===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),_l.matches(c)?e.ipv4.attempts++:Il.matches(c)&&e.ipv6.attempts++,n.push(u.listen(c).then(()=>{e.errors.delete(c.toString()),_l.matches(c)&&e.ipv4.success++,Il.matches(c)&&e.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,h),e.errors.set(c.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(e)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Qs.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new Cv(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...e.errors.entries()].map(([i,o])=>`
  ${i}: ${`${KS(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(t){if(t.ipv4.attempts===0||t.ipv6.attempts===0)return!1;const e=t.ipv4.attempts===t.ipv4.success,n=t.ipv6.success===0;return e&&n}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const n=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const s=e.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}function KS(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const an="/multistream/1.0.0",nm=1024,VS=X(`
`);async function Sa(r,t){const n=(await r.read(t)).subarray();if(n.byteLength===0||n[n.length-1]!==VS[0])throw new it("Missing newline");return J(n).trimEnd()}async function xa(r,t,e={}){if(t=Array.isArray(t)?[...t]:[t],t.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=Xr(r,{...e,maxDataLength:nm});for(let i=0;i<t.length;i++){const o=t[i];let a;if(i===0){n.trace('write ["%s", "%s"]',an,o);const c=X(`${an}
`),u=X(`${o}
`);if(await s.writeV([c,u],e),n.trace("reading multistream-select header"),a=await Sa(s,e),n.trace('read "%s"',a),a!==an){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(X(`${o}
`),e);if(n.trace("reading protocol response"),a=await Sa(s,e),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new ud(`Protocol selection failed - could not negotiate ${t}`)}async function Aa(r,t,e={}){t=Array.isArray(t)?t:[t];const n=r.log.newScope("mss:handle"),s=Xr(r,{...e,maxDataLength:nm,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await Sa(s,e);if(n.trace('read "%s"',i),i===an){n.trace('respond with "%s" for "%s"',an,i),await s.write(X(`${an}
`),e),n.trace('responded with "%s" for "%s"',an,i);continue}if(t.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(X(`${i}
`),e),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new j(...t.map(a=>mi.single(X(`${a}
`))),X(`
`));n.trace('respond with "%s" for %s',t,i),await s.write(o,e),n.trace('responded with "%s" for %s',t,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(X(`na
`),e),n('responded with "na" for "%s"',i)}}var Ou,Fu,Bu;class WS extends(Bu=Ze,Fu=Symbol.toStringTag,Ou=Um,Bu){constructor(e,n){super();l(this,"id");l(this,"remoteAddr");l(this,"remotePeer");l(this,"direction");l(this,"timeline");l(this,"direct");l(this,"multiplexer");l(this,"encryption");l(this,"limits");l(this,"log");l(this,"maConn");l(this,"muxer");l(this,"components");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"closeTimeout");l(this,Fu,"Connection");l(this,Ou,!0);l(this,"newStream",async(e,n={})=>{var i;if(this.muxer==null)throw new qs("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Xs(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Xs(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new Vo("Cannot open protocol stream on limited connection");Array.isArray(e)||(e=[e]),this.log.trace("starting new stream for protocols %s",e);const s=await this.muxer.createStream({...n,protocol:e.length===1?e[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,e);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const u=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:u}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",e),s.protocol=await xa(s,e,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=YS(s.protocol,this.components.registrar,n),a=zl(s.protocol,"outbound",this);if(a>o){const u=new Fa(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(u),u}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,e,o),o}});this.components=e,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??Si,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??Si,this.closeTimeout=n.closeTimeout??Nf,this.direct=Rf(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===H)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new Bi(s.local,s.error))})}get streams(){var e;return((e=this.muxer)==null?void 0:e.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(e){var i;const n=e.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await Aa(n,h,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=GS(n.protocol,this.components.registrar);if(zl(n.protocol,"inbound",this)>o)throw new dd(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:u}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&u.runOnLimitedConnection!==!0)throw new Vo("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(h,f,p)=>{await c(h,f),p(h,f)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(e,n,s){for(let i=0;i<s.length;i++){const o=s[i];e.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const u=o(e,n,(d,h)=>{e=d,n=h,a()});u instanceof Promise&&u.catch(c)}catch(u){c(u)}}),e.log.trace("ran middleware",i,o)}return e}async close(e={}){var n;if(this.log("closing connection to %a",this.remoteAddr),e.signal==null){const s=AbortSignal.timeout(this.closeTimeout);e={...e,signal:s}}await((n=this.muxer)==null?void 0:n.close(e)),await this.maConn.close(e)}abort(e){var n;(n=this.muxer)==null||n.abort(e),this.maConn.abort(e)}}function HS(r,t){return new WS(r,t)}function GS(r,t){try{const{options:e}=t.getHandler(r);if(e.maxInboundStreams!=null)return e.maxInboundStreams}catch(e){if(e.name!=="UnhandledProtocolError")throw e}return em}function YS(r,t,e={}){try{const{options:n}=t.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return e.maxOutboundStreams??tm}function zl(r,t,e){let n=0;return e.streams.forEach(s=>{s.direction===t&&s.protocol===r&&n++}),n}var $u;$u=Symbol.toStringTag;class XS{constructor(t,e){l(this,"components");l(this,"connectionEncrypters");l(this,"streamMuxers");l(this,"inboundUpgradeTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"events");l(this,"metrics");l(this,"connectionCloseTimeout");l(this,$u,"@libp2p/upgrader");var n,s,i,o;this.components=t,this.connectionEncrypters=Pt({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),e.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=Pt({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),e.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??Kv,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??Si,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??Si,this.connectionCloseTimeout=e.connectionCloseTimeout??Nf,this.events=t.events,this.metrics={dials:(n=t.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=t.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=t.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(t,...e){const n=this.components.connectionGater[t];if(n==null)return;if(await n.apply(this.components.connectionGater,e)===!0)throw new Iv(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return wn([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(e.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(t),!n)throw new Tv("Connection denied");await yt(this.shouldBlockConnection("denyInboundConnection",t),s),await this._performUpgrade(t,"inbound",{...e,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=t.remoteAddr.getComponents().findLast(d=>d.code===H))==null?void 0:s.value;let c;a!=null&&(c=ct(a),await yt(this.shouldBlockConnection("denyOutboundConnection",c,t),e.signal));let u="outbound";return e.initiator===!1&&(u="inbound"),await this._performUpgrade(t,u,e)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(t,e,n){var h,f,p,m;let s=t,i,o,a,c;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(t.log=t.log.newScope(`${e}:${u}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(t.log("protecting the %s connection",e),s=await y.protect(s,n))}try{if(ZS(n)){if(n.remotePeer==null)throw new Oi(`${e} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(f=t.remoteAddr.getComponents().findLast(S=>S.code===H))==null?void 0:f.value;let g;y!=null&&(g=ct(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new de(`upgrader:encrypt-${e}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(e==="inbound"?this._encryptInbound(s,{...n,remotePeer:g}):this._encryptOutbound(s,{...n,remotePeer:g}))}if(i.equals(this.components.peerId)){const y=new Oa("Can not dial self");throw t.abort(y),y}await this.shouldBlockConnection(e==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,t),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((m=n==null?void 0:n.onProgress)==null||m.call(n,new de(`upgrader:multiplex-${e}-connection`)),o=await(e==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw t.log.error("failed to upgrade %s connection %s %a - %e",e,e==="inbound"?"from":"to",t.remoteAddr,y),y}o!=null&&(t.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(e==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,t);const d=this._createConnection({id:u,cryptoProtocol:c,direction:e,maConn:t,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(t){const e=HS(this.components,{...t,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return e.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:e})}),this.events.safeDispatchEvent("connection:open",{detail:e}),e}async _encryptInbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{const s=await Aa(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ts(`no crypto module found for ${s}`);return t.log("encrypting inbound connection using %s",s),{...await i.secureInbound(t,e),protocol:s}}catch(s){throw new Ts(s.message)}}async _encryptOutbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",n);const s=await xa(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ts(`no crypto module found for ${s}`);return t.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(t,e),protocol:s}}catch(s){throw new Ts(s.message)}}async _multiplexOutbound(t,e,n){const s=Array.from(e.keys());t.log("outbound selecting muxer %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await xa(t,s,n),o=e.get(i);if(o==null)throw new qs(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing outbound connection - %e",i),new qs(String(i))}}async _multiplexInbound(t,e,n){const s=Array.from(e.keys());t.log("inbound handling muxers %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await Aa(t,s,n),o=e.get(i);if(o==null)throw new qs(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function ZS(r){return r.skipEncryption===!0}const rm="3.0.6",sm="js-libp2p";function QS(r,t){return`${r??sm}/${t??rm} browser/${globalThis.navigator.userAgent}`}var jr,Ca;class JS extends Ze{constructor(e){var d,h,f,p,m,y,g,S,v,E,L;super();oe(this,jr);l(this,"peerId");l(this,"peerStore");l(this,"contentRouting");l(this,"peerRouting");l(this,"metrics");l(this,"services");l(this,"logger");l(this,"status");l(this,"components");l(this,"log");this.status="stopped";const n=new Ze,s=n.dispatchEvent.bind(n);n.dispatchEvent=x=>{const _=s(x),O=this.dispatchEvent(new CustomEvent(x.type,{detail:x.detail}));return _||O},this.peerId=e.peerId,this.logger=e.logger??ph(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=e.nodeInfo)==null?void 0:d.name)??sm,o=((h=e.nodeInfo)==null?void 0:h.version)??rm,a=this.components=Mv({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:o,userAgent:((f=e.nodeInfo)==null?void 0:f.userAgent)??QS(i,o)},logger:this.logger,events:n,datastore:e.datastore??new JE,connectionGater:$v(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",WE(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),a.events.addEventListener("peer:update",x=>{if(x.detail.previous==null){const _={id:x.detail.peer.id,multiaddrs:x.detail.peer.addresses.map(O=>O.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:_})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(a)),this.components.upgrader=new XS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((x,_)=>this.configureComponent(`connection-encryption-${_}`,x(this.components))),streamMuxers:(e.streamMuxers??[]).map((x,_)=>this.configureComponent(`stream-muxers-${_}`,x(this.components))),inboundUpgradeTimeout:(p=e.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(m=e.connectionManager)==null?void 0:m.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=e.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(g=e.connectionManager)==null?void 0:g.connectionCloseTimeout}),this.configureComponent("transportManager",new qS(this.components,e.transportManager)),this.configureComponent("connectionManager",new DS(this.components,e.connectionManager)),((S=e.connectionMonitor)==null?void 0:S.enabled)!==!1&&this.configureComponent("connectionMonitor",new OS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new zS(this.components)),this.configureComponent("addressManager",new wv(this.components,e.addresses));const c=(e.peerRouters??[]).map((x,_)=>this.configureComponent(`peer-router-${_}`,x(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new $S(this.components,{routers:c}));const u=(e.contentRouters??[]).map((x,_)=>this.configureComponent(`content-router-${_}`,x(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new FS(this.components,{routers:u})),this.configureComponent("randomWalk",new US(this.components)),(e.peerDiscovery??[]).forEach((x,_)=>{this.configureComponent(`peer-discovery-${_}`,x(this.components)).addEventListener("peer",T=>{z(this,jr,Ca).call(this,T)})}),(v=e.transports)==null||v.forEach((x,_)=>{this.components.transportManager.add(this.configureComponent(`transport-${_}`,x(this.components)))}),e.services!=null)for(const x of Object.keys(e.services)){const _=e.services[x],O=_(this.components);if(O==null){this.log.error("service factory %s returned null or undefined instance",x);continue}this.services[x]=O,this.configureComponent(x,O),O[Dc]!=null&&(this.log("registering service %s for content routing",x),u.push(O[Dc])),O[Pc]!=null&&(this.log("registering service %s for peer routing",x),c.push(O[Pc])),O[Wo]!=null&&(this.log("registering service %s for peer discovery",x),(L=(E=O[Wo]).addEventListener)==null||L.call(E,"peer",T=>{z(this,jr,Ca).call(this,T)}))}Nv(a)}configureComponent(e,n){return n==null&&this.log.error("component %s was null or undefined",e),this.components[e]=n,n}async start(){var e,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(e=this.components).beforeStart)==null?void 0:n.call(e)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var e,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(e=this.components).beforeStop)==null?void 0:n.call(e)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new kn;for(const n of this.components.connectionManager.getConnections())e.add(n.remotePeer);return Array.from(e)}async dial(e,n={}){return this.components.connectionManager.openConnection(e,{priority:75,...n})}async dialProtocol(e,n,s={}){if(n==null)throw new G("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new G("no protocols were provided to open a stream");return this.components.connectionManager.openStream(e,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,n={}){var s;Zi(e)&&(e=ct(((s=e.getComponents().findLast(i=>i.code===H))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(e,n)}async getPublicKey(e,n={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const a=await this.peerStore.get(e,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=Ht([X("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Yt(i);return await this.peerStore.patch(e,{publicKey:o},n),o}async handle(e,n,s){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(e,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(e,n,s){return this.components.registrar.register(e,n,s)}unregister(e){this.components.registrar.unregister(e)}use(e,n){this.components.registrar.use(e,Array.isArray(n)?n:[n])}unuse(e){this.components.registrar.unuse(e)}async isDialable(e,n={}){return this.components.connectionManager.isDialable(e,n)}}jr=new WeakSet,Ca=function(e){const{detail:n}=e;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function jS(r={}){r.privateKey??(r.privateKey=await Dw());const t=new JS({...await Bw(r),peerId:Nw(r.privateKey)});return r.start!==!1&&await t.start(),t}var We;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let t;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(t||(t={})),function(n){n.codec=()=>ur(t)}(r.Flag||(r.Flag={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(We||(We={}));const e1=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const t1=2*1024*1024,im=16*1024;function n1(r=im){const t=Le(r-Le(r)),e=1+Le(Object.keys(We.Flag).length-1),n=1,s=r-t-e-n,i=Le(s);return t+e+n+i}const r1=n1(),s1=1e4,om="/webrtc",_a="/webrtc-signaling/0.0.1";var ql=function(r,t,e){if(e||arguments.length===2)for(var n=0,s=t.length,i;n<s;n++)(i||!(n in t))&&(i||(i=Array.prototype.slice.call(t,0,n)),i[n]=t[n]);return r.concat(i||Array.prototype.slice.call(t))},i1=function(){function r(t,e,n){this.name=t,this.version=e,this.os=n,this.type="browser"}return r}(),o1=function(){function r(t){this.version=t,this.type="node",this.name="node",this.os=process.platform}return r}(),a1=function(){function r(t,e,n,s){this.name=t,this.version=e,this.os=n,this.bot=s,this.type="bot-device"}return r}(),c1=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),l1=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),u1=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,d1=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Kl=3,h1=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",u1]],Vl=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function f1(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new l1:typeof navigator<"u"?g1(navigator.userAgent):y1()}function m1(r){return r!==""&&h1.reduce(function(t,e){var n=e[0],s=e[1];if(t)return t;var i=s.exec(r);return!!i&&[n,i]},!1)}function g1(r){var t=m1(r);if(!t)return null;var e=t[0],n=t[1];if(e==="searchbot")return new c1;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<Kl&&(s=ql(ql([],s,!0),w1(Kl-s.length),!0)):s=[];var i=s.join("."),o=p1(r),a=d1.exec(r);return a&&a[1]?new a1(e,i,o,a[1]):new i1(e,i,o)}function p1(r){for(var t=0,e=Vl.length;t<e;t++){var n=Vl[t],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function y1(){var r=typeof process<"u"&&process.version;return r?new o1(process.version.slice(1)):null}function w1(r){for(var t=[],e=0;e<r;e++)t.push("0");return t}const Wl=f1(),b1=Wl!=null&&Wl.name==="firefox";async function Hl(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??e1.map(t=>({urls:[t]})),r}class E1 extends Nh{constructor(e){super({...e,maxMessageSize:(e.maxMessageSize??im)-r1});l(this,"channel");l(this,"incomingData");l(this,"maxBufferedAmount");l(this,"receivedFinAck");l(this,"finAckTimeout");this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=Xi(),this.maxBufferedAmount=e.maxBufferedAmount??t1,this.finAckTimeout=e.finAckTimeout??s1,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=s=>{const i=s.error;this.log.trace("received datachannel error event - %e",i),this.abort(i)},this.channel.onmessage=async s=>{this.log("incoming message %d bytes",s.data.byteLength);const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const s of ua(this.incomingData))this.processIncomingProtobuf(s)}).catch(s=>{this.log.error("error processing incoming data channel messages - %e",s)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),$e(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(s=>{this.abort(s.error??s)}))}sendNewStream(){}_sendMessage(e){if(this.channel.readyState!=="open")throw new jt(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),b1){this.channel.send(e.subarray());return}for(const n of e)this.channel.send(n)}sendData(e){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(mi.single(We.encode({message:e.subarray()}))),{sentBytes:e.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(e){var n;try{this.log.error("sending reset - %e",e),this._sendFlag(We.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(e)}catch(s){this.log.error("failed to send reset - %e",s)}}async sendCloseWrite(e){var i;this._sendFlag(We.Flag.FIN),(i=e==null?void 0:e.signal)==null||i.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(e==null?void 0:e.signal)??AbortSignal.timeout(this.finAckTimeout),s=[$e(this.channel,"close",{signal:n}),$e(this.channel,"error",{signal:n})];await Promise.any([yt(this.receivedFinAck.promise,n),...s]).finally(()=>{s.forEach(o=>o.cancel())})}async sendCloseRead(e){var n;this._sendFlag(We.Flag.STOP_SENDING),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}processIncomingProtobuf(e){var s,i;const n=We.decode(e);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new j(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===We.Flag.FIN&&(this._sendFlag(We.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===We.Flag.RESET&&((s=this.receivedFinAck)==null||s.reject(new Na("The stream was reset")),this.onRemoteReset()),n.flag===We.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===We.Flag.FIN_ACK&&((i=this.receivedFinAck)==null||i.resolve()))}_sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const n=We.encode({flag:e}),s=mi.single(n);try{return this._sendMessage(s),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}sendPause(){}sendResume(){}}function Gl(r){const{channel:t,direction:e,isHandshake:n}=r;return new E1({...r,id:`${t.id}`,log:r.log.newScope(`${n===!0?"handshake":e}:${t.id}`),protocol:""})}class am{constructor(t){l(this,"protocol");l(this,"peerConnection");l(this,"metrics");l(this,"dataChannelOptions");l(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??om,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(t){this.earlyDataChannels.push(t.channel)}createStreamMuxer(t){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new v1(t,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class v1 extends Mh{constructor(e,n){super(e,{...n,name:"muxer"});l(this,"peerConnection");l(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??om,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:s})=>{this.onDataChannel(s)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(s=>{s.close()});return}n.earlyDataChannels.forEach(s=>{this.onDataChannel(s)})})}onDataChannel(e){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",e.id,e.protocol,e.readyState),e.label==="init"){this.log.trace("closing init channel %d",e.id),e.close();return}const n=Gl({...this.streamOptions,...this.dataChannelOptions,channel:e,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(e){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,e==null?void 0:e.protocol),Gl({...e,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class S1 extends kh{constructor(e){super(e);l(this,"peerConnection");this.peerConnection=e.peerConnection;const n=e.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(e){return{sentBytes:e.byteLength,canSendMore:!0}}async sendClose(e){var n;this.peerConnection.close(),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const Yl=r=>new S1(r),cm=globalThis.RTCPeerConnection,lm=globalThis.RTCSessionDescription,x1=globalThis.RTCIceCandidate;class A1 extends Error{constructor(t){super(`WebRTC transport error: ${t}`),this.name="WebRTCTransportError"}}class qt extends A1{constructor(t="SDP handshake failed"){super(t),this.name="SDPHandshakeFailedError"}}var ot;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let t;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(t||(t={})),function(n){n.codec=()=>ur(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(ot||(ot={}));const um=async(r,t,e)=>{var n,s,i,o;try{const a=Promise.withResolvers();for(C1(r,a);;){const c=await Promise.race([a.promise,t.read({signal:e.signal})]);if(c==null){(n=e.signal)==null||n.throwIfAborted();break}if(c.type!==ot.Type.ICE_CANDIDATE)throw new it("ICE candidate message expected");const u=JSON.parse(c.data??"null");if(u===""||u===null){(s=e.onProgress)==null||s.call(e,new de("webrtc:end-of-ice-candidates")),e.log.trace("end-of-candidates received");continue}const d=new x1(u);e.log.trace("%s received new ICE candidate %o",e.direction,u);try{(i=e.onProgress)==null||i.call(e,new de("webrtc:add-ice-candidate",d.candidate)),await r.addIceCandidate(d)}catch(h){e.log.error("%s bad candidate received %o - %e",e.direction,u,h)}}}catch(a){if(e.log.error("%s error parsing ICE candidate - %e",e.direction,a),((o=e.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function C1(r,t){if(r.connectionState==="connected"){t.resolve();return}r.onconnectionstatechange=e=>{switch(r.connectionState){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new ad(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function dm(r){let t;for(const e of r.getComponents())e.name==="p2p"&&(t=ct(e.value??""));if(t==null)throw new Oi("Remote peerId must be present in multiaddr");return t}async function _1({rtcConfiguration:r,dataChannel:t,signal:e,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:d,targetPeer:h}=L1(s);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",d);const f=i.getConnections(h);let p;f.length===0?(u==null||u(new de("webrtc:dial-relay")),p=await o.dial(d,{signal:e,onProgress:u})):(u==null||u(new de("webrtc:reuse-relay-connection")),p=f[0]),u==null||u(new de("webrtc:open-signaling-stream"));const m=await p.newStream(_a,{signal:e,runOnLimitedConnection:!0}),y=bn(m).pb(ot),g=new cm(r);g.addEventListener("connectionstatechange",()=>{switch(g.connectionState){case"closed":g.close();break}});const S=new am({peerConnection:g,dataChannelOptions:t});try{const v=g.createDataChannel("init");g.onicecandidate=({candidate:_})=>{if(g.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(_==null||(_==null?void 0:_.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const O=JSON.stringify((_==null?void 0:_.toJSON())??null);a.trace("initiator sending ICE candidate %o",_),y.write({type:ot.Type.ICE_CANDIDATE,data:O},{signal:e}).catch(T=>{a.error("error sending ICE candidate - %e",T)})},g.onicecandidateerror=_=>{a.error("initiator ICE candidate error",_)};const E=await g.createOffer().catch(_=>{throw a.error("could not execute createOffer - %e",_),new qt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",E.sdp),u==null||u(new de("webrtc:send-sdp-offer")),await y.write({type:ot.Type.SDP_OFFER,data:E.sdp},{signal:e}),await g.setLocalDescription(E).catch(_=>{throw a.error("could not execute setLocalDescription - %e",_),new qt("Failed to set localDescription")}),u==null||u(new de("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await y.read({signal:e});if(L.type!==ot.Type.SDP_ANSWER)throw new qt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const x=new lm({type:"answer",sdp:L.data});return await g.setRemoteDescription(x).catch(_=>{throw a.error("could not execute setRemoteDescription - %e",_),new qt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u==null||u(new de("webrtc:read-ice-candidates")),await um(g,y,{direction:"initiator",signal:e,log:a,onProgress:u}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await $e(v,"open",{signal:e})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await $e(v,"close",{signal:e}),u==null||u(new de("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await m.close({signal:e}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:g,muxerFactory:S}}catch(v){throw a.error("outgoing signaling error - %e",v),g.close(),m.abort(v),v}finally{g.onicecandidate=null,g.onicecandidateerror=null}}const Xl=he(Sc.matchers[0],ue(hr));class Ac extends Ze{constructor(e,n){super();l(this,"transportManager");l(this,"shutdownController");l(this,"events");this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(s=>Xl.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof Ac)).map(e=>e.getAddrs().filter(n=>Xl.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function I1(r,t,{peerConnection:e,signal:n,log:s}){s.trace("new inbound signaling stream");const i=bn(r).pb(ot);try{e.onicecandidate=({candidate:h})=>{if(e.connectionState==="connected"){s.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){s.trace("recipient detected end of ICE candidates");return}const f=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",f),i.write({type:ot.Type.ICE_CANDIDATE,data:f},{signal:n}).catch(p=>{s.error("error sending ICE candidate - %e",p)})},s.trace("recipient read SDP offer");const c=await i.read({signal:n});if(c.type!==ot.Type.SDP_OFFER)throw new qt(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);s.trace("recipient received SDP offer %s",c.data);const u=new lm({type:"offer",sdp:c.data});await e.setRemoteDescription(u).catch(h=>{throw s.error("could not execute setRemoteDescription - %e",h),new qt("Failed to set remoteDescription")});const d=await e.createAnswer().catch(h=>{throw s.error("could not execute createAnswer - %e",h),new qt("Failed to create answer")});s.trace("recipient send SDP answer %s",d.sdp),await i.write({type:ot.Type.SDP_ANSWER,data:d.sdp},{signal:n}),await e.setLocalDescription(d).catch(h=>{throw s.error("could not execute setLocalDescription - %e",h),new qt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await um(e,i,{direction:"recipient",signal:n,log:s})}catch(c){if(e.connectionState!=="connected")throw s.error("error while handling signaling stream from peer %a - %e",t.remoteAddr,c),e.close(),c;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",t.remoteAddr,c)}const o=dm(t.remoteAddr),a=Z(`/webrtc/p2p/${o}`);return s.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}var Uu,zu,qu,Ku;Ku=md,qu=Symbol.toStringTag,zu=Lt,Uu=Js;class T1{constructor(t,e={}){l(this,"components");l(this,"init");l(this,"log");l(this,"_started",!1);l(this,"metrics");l(this,"shutdownController");l(this,Ku,!0);l(this,qu,"@libp2p/webrtc");l(this,zu,["@libp2p/transport"]);l(this,Uu,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=t,this.init=e,this.log=t.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(_a,(t,e)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(t,e,n).catch(s=>{this.log.error("failed to handle incoming connect from %p - %e",e.remotePeer,s)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(_a),this._started=!1}createListener(t){return new Ac(this.components,{shutdownController:this.shutdownController})}listenFilter(t){return t.filter(ga.exactMatch)}dialFilter(t){return this.listenFilter(t)}async dial(t,e){var c;this.log.trace("dialing address: %a",t);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await _1({rtcConfiguration:await Hl(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:t,dataChannelOptions:this.init.dataChannel,signal:e.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:e.onProgress}),o=Yl({peerConnection:s,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await e.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:dm(t),muxerFactory:i,onProgress:e.onProgress,signal:e.signal});return this._closeOnShutdown(s,o),a}async _onProtocol(t,e,n){var o;const s=new cm(await Hl(this.init.rtcConfiguration));s.addEventListener("connectionstatechange",()=>{switch(s.connectionState){case"closed":s.close();break}});const i=new am({peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await I1(t,e,{peerConnection:s,signal:n,log:this.log});await t.close({signal:n});const u=Yl({peerConnection:s,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(u,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:i,signal:n}),this._closeOnShutdown(s,u)}catch(a){throw this.log.error("incoming signaling error - %e",a),s.close(),t.abort(a),a}}_closeOnShutdown(t,e){const n=()=>{e.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",s)})};this.shutdownController.signal.addEventListener("abort",n),t.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function L1(r){const t=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(t==null)throw new G("Destination peer id was missing");return{circuitAddress:Z(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:ct(t)}}const Zr=65535,Zl=Zr-16;var Vu,Wu;const us=!!((Wu=(Vu=globalThis.process)==null?void 0:Vu.env)!=null&&Wu.DUMP_SESSION_KEYS),Ql=16;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function D1(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Ia(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function Po(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function ze(r,t,e=""){const n=D1(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Jl(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function P1(r,t){ze(r,void 0,"output");const e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Wt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function ir(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function R1(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const k1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function M1(r,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(r,t)}function N1(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}const O1=(r,t)=>{function e(n,...s){if(ze(n,void 0,"key"),!k1)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const d=s[0];ze(d,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const i=r.tagLength;i&&s[1]!==void 0&&ze(s[1],void 0,"AAD");const o=t(n,...s),a=(d,h)=>{if(h!==void 0){if(d!==2)throw new Error("cipher output not supported");ze(h,void 0,"output")}};let c=!1;return{encrypt(d,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,ze(d),a(o.encrypt.length,h),o.encrypt(d,h)},decrypt(d,h){if(ze(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return a(o.decrypt.length,h),o.decrypt(d,h)}}}return Object.assign(e,r),e};function jl(r,t,e=!0){if(t===void 0)return new Uint8Array(r);if(t.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+t.length);if(e&&!B1(t))throw new Error("invalid output, must be aligned");return t}function F1(r,t,e){Ia(e);const n=new Uint8Array(16),s=R1(n);return s.setBigUint64(0,BigInt(t),e),s.setBigUint64(8,BigInt(r),e),n}function B1(r){return r.byteOffset%4===0}function xi(r){return Uint8Array.from(r)}const hm=r=>Uint8Array.from(r.split(""),t=>t.charCodeAt(0)),$1=hm("expand 16-byte k"),U1=hm("expand 32-byte k"),z1=Wt($1),q1=Wt(U1);function te(r,t){return r<<t|r>>>32-t}function Ta(r){return r.byteOffset%4===0}const Ps=64,K1=16,fm=2**32-1,eu=Uint32Array.of();function V1(r,t,e,n,s,i,o,a){const c=s.length,u=new Uint8Array(Ps),d=Wt(u),h=Ta(s)&&Ta(i),f=h?Wt(s):eu,p=h?Wt(i):eu;for(let m=0;m<c;o++){if(r(t,e,n,d,o,a),o>=fm)throw new Error("arx: counter overflow");const y=Math.min(Ps,c-m);if(h&&y===Ps){const g=m/4;if(m%4!==0)throw new Error("arx: invalid block position");for(let S=0,v;S<K1;S++)v=g+S,p[v]=f[v]^d[S];m+=Ps;continue}for(let g=0,S;g<y;g++)S=m+g,i[S]=s[S]^u[g];m+=y}}function W1(r,t){const{allowShortKeys:e,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=M1({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof r!="function")throw new Error("core must be a function");return Po(s),Po(o),Ia(i),Ia(e),(a,c,u,d,h=0)=>{ze(a,void 0,"key"),ze(c,void 0,"nonce"),ze(u,void 0,"data");const f=u.length;if(d===void 0&&(d=new Uint8Array(f)),ze(d,void 0,"output"),Po(h),h<0||h>=fm)throw new Error("arx: counter overflow");if(d.length<f)throw new Error(`arx: output (${d.length}) is shorter than data (${f})`);const p=[];let m=a.length,y,g;if(m===32)p.push(y=xi(a)),g=q1;else if(m===16&&e)y=new Uint8Array(32),y.set(a),y.set(a,16),g=z1,p.push(y);else throw ze(a,32,"arx key"),new Error("invalid key size");Ta(c)||p.push(c=xi(c));const S=Wt(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(g,S,Wt(c.subarray(0,16)),S),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const E=Wt(c);return V1(r,g,S,E,u,d,h,o),ir(...p),d}}function Ie(r,t){return r[t++]&255|(r[t++]&255)<<8}class H1{constructor(t){l(this,"blockLen",16);l(this,"outputLen",16);l(this,"buffer",new Uint8Array(16));l(this,"r",new Uint16Array(10));l(this,"h",new Uint16Array(10));l(this,"pad",new Uint16Array(8));l(this,"pos",0);l(this,"finished",!1);t=xi(ze(t,32,"key"));const e=Ie(t,0),n=Ie(t,2),s=Ie(t,4),i=Ie(t,6),o=Ie(t,8),a=Ie(t,10),c=Ie(t,12),u=Ie(t,14);this.r[0]=e&8191,this.r[1]=(e>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=Ie(t,16+2*d)}process(t,e,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],d=o[3],h=o[4],f=o[5],p=o[6],m=o[7],y=o[8],g=o[9],S=Ie(t,e+0),v=Ie(t,e+2),E=Ie(t,e+4),L=Ie(t,e+6),x=Ie(t,e+8),_=Ie(t,e+10),O=Ie(t,e+12),T=Ie(t,e+14);let I=i[0]+(S&8191),$=i[1]+((S>>>13|v<<3)&8191),U=i[2]+((v>>>10|E<<6)&8191),M=i[3]+((E>>>7|L<<9)&8191),N=i[4]+((L>>>4|x<<12)&8191),w=i[5]+(x>>>1&8191),b=i[6]+((x>>>14|_<<2)&8191),C=i[7]+((_>>>11|O<<5)&8191),P=i[8]+((O>>>8|T<<8)&8191),k=i[9]+(T>>>5|s),A=0,F=A+I*a+$*(5*g)+U*(5*y)+M*(5*m)+N*(5*p);A=F>>>13,F&=8191,F+=w*(5*f)+b*(5*h)+C*(5*d)+P*(5*u)+k*(5*c),A+=F>>>13,F&=8191;let R=A+I*c+$*a+U*(5*g)+M*(5*y)+N*(5*m);A=R>>>13,R&=8191,R+=w*(5*p)+b*(5*f)+C*(5*h)+P*(5*d)+k*(5*u),A+=R>>>13,R&=8191;let B=A+I*u+$*c+U*a+M*(5*g)+N*(5*y);A=B>>>13,B&=8191,B+=w*(5*m)+b*(5*p)+C*(5*f)+P*(5*h)+k*(5*d),A+=B>>>13,B&=8191;let K=A+I*d+$*u+U*c+M*a+N*(5*g);A=K>>>13,K&=8191,K+=w*(5*y)+b*(5*m)+C*(5*p)+P*(5*f)+k*(5*h),A+=K>>>13,K&=8191;let ne=A+I*h+$*d+U*u+M*c+N*a;A=ne>>>13,ne&=8191,ne+=w*(5*g)+b*(5*y)+C*(5*m)+P*(5*p)+k*(5*f),A+=ne>>>13,ne&=8191;let Q=A+I*f+$*h+U*d+M*u+N*c;A=Q>>>13,Q&=8191,Q+=w*a+b*(5*g)+C*(5*y)+P*(5*m)+k*(5*p),A+=Q>>>13,Q&=8191;let W=A+I*p+$*f+U*h+M*d+N*u;A=W>>>13,W&=8191,W+=w*c+b*a+C*(5*g)+P*(5*y)+k*(5*m),A+=W>>>13,W&=8191;let ce=A+I*m+$*p+U*f+M*h+N*d;A=ce>>>13,ce&=8191,ce+=w*u+b*c+C*a+P*(5*g)+k*(5*y),A+=ce>>>13,ce&=8191;let fe=A+I*y+$*m+U*p+M*f+N*h;A=fe>>>13,fe&=8191,fe+=w*d+b*u+C*c+P*a+k*(5*g),A+=fe>>>13,fe&=8191;let ye=A+I*g+$*y+U*m+M*p+N*f;A=ye>>>13,ye&=8191,ye+=w*h+b*d+C*u+P*c+k*a,A+=ye>>>13,ye&=8191,A=(A<<2)+A|0,A=A+F|0,F=A&8191,A=A>>>13,R+=A,i[0]=F,i[1]=R,i[2]=B,i[3]=K,i[4]=ne,i[5]=Q,i[6]=W,i[7]=ce,i[8]=fe,i[9]=ye}finalize(){const{h:t,pad:e}=this,n=new Uint16Array(10);let s=t[1]>>>13;t[1]&=8191;for(let a=2;a<10;a++)t[a]+=s,s=t[a]>>>13,t[a]&=8191;t[0]+=s*5,s=t[0]>>>13,t[0]&=8191,t[1]+=s,s=t[1]>>>13,t[1]&=8191,t[2]+=s,n[0]=t[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=t[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)t[a]=t[a]&i|n[a];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let o=t[0]+e[0];t[0]=o&65535;for(let a=1;a<8;a++)o=(t[a]+e[a]|0)+(o>>>16)|0,t[a]=o&65535;ir(n)}update(t){Jl(this),ze(t),t=xi(t);const{buffer:e,blockLen:n}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(t,i);continue}e.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(e,0,!1),this.pos=0)}return this}destroy(){ir(this.h,this.r,this.buffer,this.pad)}digestInto(t){Jl(this),P1(t,this),this.finished=!0;const{buffer:e,h:n}=this;let{pos:s}=this;if(s){for(e[s++]=1;s<16;s++)e[s]=0;this.process(e,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)t[i++]=n[o]>>>0,t[i++]=n[o]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}}function G1(r){const t=(n,s)=>r(s).update(n).digest(),e=r(new Uint8Array(32));return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=n=>r(n),t}const Y1=G1(r=>new H1(r));function X1(r,t,e,n,s,i=20){let o=r[0],a=r[1],c=r[2],u=r[3],d=t[0],h=t[1],f=t[2],p=t[3],m=t[4],y=t[5],g=t[6],S=t[7],v=s,E=e[0],L=e[1],x=e[2],_=o,O=a,T=c,I=u,$=d,U=h,M=f,N=p,w=m,b=y,C=g,P=S,k=v,A=E,F=L,R=x;for(let K=0;K<i;K+=2)_=_+$|0,k=te(k^_,16),w=w+k|0,$=te($^w,12),_=_+$|0,k=te(k^_,8),w=w+k|0,$=te($^w,7),O=O+U|0,A=te(A^O,16),b=b+A|0,U=te(U^b,12),O=O+U|0,A=te(A^O,8),b=b+A|0,U=te(U^b,7),T=T+M|0,F=te(F^T,16),C=C+F|0,M=te(M^C,12),T=T+M|0,F=te(F^T,8),C=C+F|0,M=te(M^C,7),I=I+N|0,R=te(R^I,16),P=P+R|0,N=te(N^P,12),I=I+N|0,R=te(R^I,8),P=P+R|0,N=te(N^P,7),_=_+U|0,R=te(R^_,16),C=C+R|0,U=te(U^C,12),_=_+U|0,R=te(R^_,8),C=C+R|0,U=te(U^C,7),O=O+M|0,k=te(k^O,16),P=P+k|0,M=te(M^P,12),O=O+M|0,k=te(k^O,8),P=P+k|0,M=te(M^P,7),T=T+N|0,A=te(A^T,16),w=w+A|0,N=te(N^w,12),T=T+N|0,A=te(A^T,8),w=w+A|0,N=te(N^w,7),I=I+$|0,F=te(F^I,16),b=b+F|0,$=te($^b,12),I=I+$|0,F=te(F^I,8),b=b+F|0,$=te($^b,7);let B=0;n[B++]=o+_|0,n[B++]=a+O|0,n[B++]=c+T|0,n[B++]=u+I|0,n[B++]=d+$|0,n[B++]=h+U|0,n[B++]=f+M|0,n[B++]=p+N|0,n[B++]=m+w|0,n[B++]=y+b|0,n[B++]=g+C|0,n[B++]=S+P|0,n[B++]=v+k|0,n[B++]=E+A|0,n[B++]=L+F|0,n[B++]=x+R|0}const Z1=W1(X1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),Q1=new Uint8Array(16),tu=(r,t)=>{r.update(t);const e=t.length%16;e&&r.update(Q1.subarray(e))},J1=new Uint8Array(32);function nu(r,t,e,n,s){s!==void 0&&ze(s,void 0,"AAD");const i=r(t,e,J1),o=F1(n.length,s?s.length:0,!0),a=Y1.create(i);s&&tu(a,s),tu(a,n),a.update(o);const c=a.digest();return ir(i,o),c}const j1=r=>(t,e,n)=>({encrypt(i,o){const a=i.length;o=jl(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(t,e,c,c,1);const u=nu(r,t,e,c,n);return o.set(u,a),ir(u),o},decrypt(i,o){o=jl(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=nu(r,t,e,a,n);if(!N1(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(t,e,o,o,1),ir(u),o}}),ru=O1({blockSize:64,nonceLength:12,tagLength:16},j1(Z1));function ex(r,t,e){return Vi(r),e===void 0&&(e=new Uint8Array(r.outputLen)),Yi(r,e,t)}const Ro=Uint8Array.of(0),su=Uint8Array.of();function tx(r,t,e,n=32){Vi(r),Gt(n,"length");const s=r.outputLen;if(n>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(n/s);e===void 0?e=su:Y(e,void 0,"info");const o=new Uint8Array(i*s),a=Yi.create(r,t),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let d=0;d<i;d++)Ro[0]=d+1,c.update(d===0?su:u).update(e).update(Ro).digestInto(u),o.set(u,s*d),a._cloneInto(c);return a.destroy(),c.destroy(),fn(u,Ro),o.slice(0,n)}const nx={hashSHA256(r){return Pr(r.subarray())},getHKDF(r,t){const e=ex(Pr,t,r),s=tx(Pr,e,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=bs.utils.randomSecretKey();return{publicKey:bs.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:bs.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,t){return bs.getSharedSecret(r.subarray(),t.subarray())},chaCha20Poly1305Encrypt(r,t,e,n){return ru(n,t,e).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,t,e,n,s){return ru(n,t,e).decrypt(r.subarray(),s)}},rx=nx;function sx(r){return{generateKeypair:r.generateX25519KeyPair,dh:(t,e)=>r.generateX25519SharedKey(t.privateKey,e).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const Ai=r=>{const t=pt(2);return t[0]=r>>8,t[1]=r,t};Ai.bytes=2;const Ci=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let t=0;return t+=r[0]<<8,t+=r[1],t}return r.getUint16(0)};Ci.bytes=2;function ix(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function mm(r,t){!t.enabled||!us||(r?(t(`LOCAL_STATIC_PUBLIC_KEY ${J(r.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${J(r.privateKey,"hex")}`)):t("Missing local static keys."))}function gm(r,t){!t.enabled||!us||(r?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${J(r.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${J(r.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function ox(r,t){!t.enabled||!us||t(r?`REMOTE_STATIC_PUBLIC_KEY ${J(r.subarray(),"hex")}`:"Missing remote static public key.")}function pm(r,t){!t.enabled||!us||t(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${J(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function ym(r,t,e){!e.enabled||!us||(e(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&J(r.k,"hex")}`),e(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&J(t.k,"hex")}`))}const Ni=class Ni extends Error{constructor(e="Invalid crypto exchange"){super(e);l(this,"code");this.code=Ni.code}};l(Ni,"code","ERR_INVALID_CRYPTO_EXCHANGE");let Or=Ni;const ax=0,cx=4294967295,lx="Cipherstate has reached maximum n, a new handshake must be performed";class ux{constructor(t=ax){l(this,"n");l(this,"bytes");l(this,"view");this.n=t,this.bytes=ae(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>cx)throw new Error(lx)}}const Fn=ae(0);class Rs{constructor(t,e=void 0,n=0){l(this,"k");l(this,"n");l(this,"crypto");this.crypto=t,this.k=e,this.n=new ux(n)}hasKey(){return!!this.k}encryptWithAd(t,e){if(!this.hasKey())return e;this.n.assertValue();const n=this.crypto.encrypt(e,this.n.getBytes(),t,this.k);return this.n.increment(),n}decryptWithAd(t,e,n){if(!this.hasKey())return e;this.n.assertValue();const s=this.crypto.decrypt(e,this.n.getBytes(),t,this.k,n);return this.n.increment(),s}}class dx{constructor(t,e){l(this,"cs");l(this,"ck");l(this,"h");l(this,"crypto");this.crypto=t;const n=X(e,"utf-8");this.h=fx(t,n),this.ck=this.h,this.cs=new Rs(t)}mixKey(t){const[e,n]=this.crypto.hkdf(this.ck,t);this.ck=e,this.cs=new Rs(this.crypto,n)}mixHash(t){this.h=this.crypto.hash(new j(this.h,t))}encryptAndHash(t){const e=this.cs.encryptWithAd(this.h,t);return this.mixHash(e),e}decryptAndHash(t){const e=this.cs.decryptWithAd(this.h,t);return this.mixHash(t),e}split(){const[t,e]=this.crypto.hkdf(this.ck,Fn);return[new Rs(this.crypto,t),new Rs(this.crypto,e)]}}class hx{constructor(t){l(this,"ss");l(this,"s");l(this,"e");l(this,"rs");l(this,"re");l(this,"initiator");l(this,"crypto");const{crypto:e,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=t;this.crypto=e,this.ss=new dx(e,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const t=this.crypto.generateKeypair();return this.ss.mixHash(t.publicKey),this.e=t,t.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(t,e=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(t.byteLength<e+32)throw new Error("message is not long enough");this.re=t.sublist(e,e+32),this.ss.mixHash(this.re)}readS(t,e=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(t.byteLength<e+n)throw new Error("message is not long enough");const s=t.sublist(e,e+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class wm extends hx{writeMessageA(t){return new j(this.writeE(),this.ss.encryptAndHash(t))}writeMessageB(t){const e=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new j(e,n,this.ss.encryptAndHash(t))}writeMessageC(t){const e=this.writeS();return this.writeSE(),new j(e,this.ss.encryptAndHash(t))}readMessageA(t){try{return this.readE(t),this.ss.decryptAndHash(t.sublist(32))}catch(e){throw new Or(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(t){try{this.readE(t),this.readEE();const e=this.readS(t,32);return this.readES(),this.ss.decryptAndHash(t.sublist(32+e))}catch(e){throw new Or(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(t){try{const e=this.readS(t);return this.readSE(),this.ss.decryptAndHash(t.sublist(e))}catch(e){throw new Or(`handshake stage 2 validation fail: ${e.message}`)}}}function fx(r,t){if(t.length<=32){const e=ae(32);return e.set(t),e}else return r.hash(t)}var _i;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.webtransportCerthashes!=null)for(const i of e.webtransportCerthashes)n.uint32(10),n.bytes(i);if(e.streamMuxers!=null)for(const i of e.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new Dt('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(e.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new Dt('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(e.string());break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(_i||(_i={}));var Ii;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.identityKey!=null&&e.identityKey.byteLength>0&&(n.uint32(10),n.bytes(e.identityKey)),e.identitySig!=null&&e.identitySig.byteLength>0&&(n.uint32(18),n.bytes(e.identitySig)),e.extensions!=null&&(n.uint32(34),_i.codec().encode(e.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={identityKey:ae(0),identitySig:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.identityKey=e.bytes();break}case 2:{i.identitySig=e.bytes();break}case 4:{i.extensions=_i.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Ii||(Ii={}));async function bm(r,t,e){const n=await r.sign(vm(t));return Ii.encode({identityKey:It(r.publicKey),identitySig:n,extensions:e})}async function Em(r,t,e){try{const n=Ii.decode(r),s=Yt(n.identityKey);if((e==null?void 0:e.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${e}`);if(!t)throw new Error("Remote static does not exist");const i=vm(t);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new od(n.message)}}function vm(r){const t=X("noise-libp2p-static-key:");return r instanceof Uint8Array?Ht([t,r],t.length+r.length):(r.prepend(t),r)}class mx extends dc{constructor(e,n,s){super({log:e.log,inactivityTimeout:e.inactivityTimeout,maxReadBufferLength:e.maxReadBufferLength,direction:e.direction});l(this,"stream");l(this,"handshake");l(this,"metrics");l(this,"decoder");this.stream=e,this.handshake=n,this.metrics=s,this.decoder=new Q0({lengthDecoder:Ci,maxBufferSize:16*1024*1024,encodingLength:()=>2});const i=u=>{try{for(const d of this.decoder.decode(u.data))this.onData(this.decrypt(d))}catch(d){this.abort(d)}};this.stream.addEventListener("message",i);const o=u=>{u.error!=null?u.local===!0?this.abort(u.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(e){var s;const n=new j;for(let i=0;i<e.byteLength;i+=Zl){let o=i+Zl;o>e.byteLength&&(o=e.byteLength);let a;e instanceof Uint8Array?a=this.handshake.encrypt(e.subarray(i,o)):a=this.handshake.encrypt(e.sublist(i,o)),(s=this.metrics)==null||s.encryptedPackets.increment(),n.append(Ai(a.byteLength)),n.append(a)}return n}decrypt(e){var s,i;const n=new j;for(let o=0;o<e.byteLength;o+=Zr){let a=o+Zr;if(a>e.byteLength&&(a=e.byteLength),a-Ql<o)throw new Error("Invalid chunk");let c;e instanceof Uint8Array?c=e.subarray(o,a):c=e.sublist(o,a);const u=e.subarray(o,a-Ql);try{const d=this.handshake.decrypt(c,u);(s=this.metrics)==null||s.decryptedPackets.increment(),n.append(d)}catch(d){throw(i=this.metrics)==null||i.decryptErrors.increment(),d}}return n}close(e){return this.stream.close(e)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(e){this.stream.abort(e)}sendData(e){return{sentBytes:e.byteLength,canSendMore:this.stream.send(this.encrypt(e))}}}function iu(r,t,e){return new mx(r,t,e)}async function gx(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await bm(i,a.publicKey,u),h=new wm({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});mm(h.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(Fn),t),e.trace("Stage 0 - Initiator finished sending first message."),gm(h.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=h.readMessageB(await n.read(t));e.trace("Stage 1 - Initiator received the message."),pm(h.re,e),ox(h.rs,e),e.trace("Initiator going to check remote's signature...");const p=await Em(f,h.rs,c);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(d),t),e.trace("Stage 2 - Initiator sent message with signed payload.");const[m,y]=h.ss.split();return ym(m,y,e),{payload:p,encrypt:g=>m.encryptWithAd(Fn,g),decrypt:(g,S)=>y.decryptWithAd(Fn,g,S)}}async function px(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await bm(i,a.publicKey,u),h=new wm({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});mm(h.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),e.trace("Stage 0 - Responder received first message."),pm(h.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(d),t),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),gm(h.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const f=h.readMessageC(await n.read(t));e.trace("Stage 2 - Responder received the message, finished handshake.");const p=await Em(f,h.rs,c),[m,y]=h.ss.split();return ym(m,y,e),{payload:p,encrypt:g=>y.encryptWithAd(Fn,g),decrypt:(g,S)=>m.decryptWithAd(Fn,g,S)}}var Hu,Gu;Gu=Symbol.toStringTag,Hu=Lt;class yx{constructor(t,e={}){l(this,"protocol","/noise");l(this,"crypto");l(this,"prologue");l(this,"staticKey");l(this,"extensions");l(this,"metrics");l(this,"components");l(this,"log");l(this,Gu,"@chainsafe/libp2p-noise");l(this,Hu,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=e,{metrics:a}=t;this.components=t,this.log=t.logger.forComponent("libp2p:noise");const c=i??rx;this.crypto=sx(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?ix(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??ae(0)}async secureOutbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=Xr(t,{lengthEncoder:Ai,lengthDecoder:Ci,maxDataLength:Zr}),i=await this.performHandshakeInitiator(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Yt(i.payload.identityKey);return{connection:iu(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:qr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}getStreamMuxer(t){if(t==null||t.length===0)return;const e=this.components.upgrader.getStreamMuxers();if(e!=null)for(const n of t){const s=e.get(n);if(s!=null)return s}if(t.length)throw new zm("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=Xr(t,{lengthEncoder:Ai,lengthDecoder:Ci,maxDataLength:Zr}),i=await this.performHandshakeResponder(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Yt(i.payload.identityKey);return{connection:iu(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:qr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}async performHandshakeInitiator(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await gx({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}async performHandshakeResponder(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await px({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}}function wx(r={}){return t=>new yx(t,r)}function bx(r){return t=>new T1(t,r)}var Ae;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(Ae||(Ae={}));var re;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(re||(re={}));Object.values(re).filter(r=>typeof r!="string");const Ex=0;var Qe;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(Qe||(Qe={}));const cn=12;class ds extends Error{constructor(e,n){super(e);l(this,"reason");this.name="ProtocolError",this.reason=n}}l(ds,"name","ProtocolError");function vx(r){return(r==null?void 0:r.reason)!==null}class ln extends ds{constructor(t="The frame was invalid"){super(t,Qe.ProtocolError),this.name="InvalidFrameError"}}l(ln,"name","InvalidFrameError");class Sm extends ds{constructor(t="Un-requested ping error"){super(t,Qe.ProtocolError),this.name="UnRequestedPingError"}}l(Sm,"name","UnRequestedPingError");class xm extends ds{constructor(t="Not matching ping error"){super(t,Qe.ProtocolError),this.name="NotMatchingPingError"}}l(xm,"name","NotMatchingPingError");class Am extends ds{constructor(t="Receive window exceeded"){super(t,Qe.ProtocolError),this.name="ReceiveWindowExceededError"}}l(Am,"name","ReceiveWindowExceededError");const Cm=256*1024,Sx=16*1024*1024,ks={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function xx(r){var t,e,n,s,i,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new G("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new G("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new G("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new G("MaxMessageSize must be greater than a kilobyte");if(((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)!=null&&((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)<Cm)throw new G("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.initialStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new G("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new G("MaxStreamWindowSize must be less than equal MAX_UINT32")}function Ax(r){return r.header.type===Ae.Data&&r.data!==null}const ou=2**24;function Cx(r){if(r[0]!==Ex)throw new ln("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*ou+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*ou+(r[9]<<16)+(r[10]<<8)+r[11]}}class _x{constructor(){l(this,"buffer");this.buffer=new j}*emitFrames(t){for(this.buffer.append(t);;){const e=this.readFrame();if(e===void 0)break;yield e}}readFrame(){let t=cn;if(this.buffer.byteLength<cn)return;const e=Cx(this.buffer.subarray(0,cn));if(e.type===Ae.Data){if(t+=e.length,this.buffer.byteLength<t)return;const n=this.buffer.sublist(cn,t);return this.buffer.consume(t),{header:e,data:n}}return this.buffer.consume(t),{header:e}}}function au(r){const t=new Uint8Array(cn);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var He;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(He||(He={}));class Ix extends Nh{constructor(e){const n=e.initialStreamWindowSize??Cm;super({...e,maxMessageSize:n-cn});l(this,"streamId");l(this,"state");l(this,"sendWindowCapacity");l(this,"recvWindow");l(this,"recvWindowCapacity");l(this,"maxStreamWindowSize");l(this,"epochStart");l(this,"getRTT");l(this,"sendFrame");this.streamId=e.streamId,this.state=e.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=e.maxStreamWindowSize??Sx,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame;const s=()=>{this.state=He.Finished};this.addEventListener("close",s)}sendData(e){var o,a;const n=e.byteLength;let s=0,i=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);e.byteLength>0;){if(this.sendWindowCapacity===0){i=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",s,n);break}const c=Math.min(this.sendWindowCapacity,e.byteLength),u=this.getSendFlags(),d=e.sublist(0,c);e.consume(c);const h=this.sendFrame({type:Ae.Data,flag:u,streamID:this.streamId,length:c},d);if(this.sendWindowCapacity-=c,s+=c,!h){i=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",s,n);break}}return{sentBytes:s,canSendMore:i}}async sendReset(){this.sendFrame({type:Ae.WindowUpdate,flag:re.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|re.FIN;this.sendFrame({type:Ae.WindowUpdate,flag:e,streamID:this.streamId,length:0})}async sendCloseRead(e){var n;(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendPause(){this.state=He.Paused}sendResume(){this.state=He.Established,this.sendWindowUpdate()}handleWindowUpdate(e){var n;this.processFlags(e.header.flag),this.sendWindowCapacity+=e.header.length,this.maxMessageSize=this.sendWindowCapacity-cn,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",e.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(e){if(!Ax(e))throw new ln("Frame was not data frame");if(this.processFlags(e.header.flag),this.recvWindowCapacity<e.header.length)throw new Am("Receive window exceeded");this.recvWindowCapacity-=e.header.length,this.onData(e.data),this.sendWindowUpdate()}processFlags(e){(e&re.ACK)===re.ACK&&this.state===He.SYNSent&&(this.state=He.Established),(e&re.FIN)===re.FIN&&this.onRemoteCloseWrite(),(e&re.RST)===re.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case He.Init:return this.state=He.SYNSent,re.SYN;case He.SYNReceived:return this.state=He.Established,re.ACK;default:return 0}}sendWindowUpdate(){if(this.state===He.Paused){this.epochStart=Date.now();return}const e=this.getSendFlags(),n=Date.now(),s=this.getRTT();if(e===0&&s>-1&&n-this.epochStart<=s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:Ae.WindowUpdate,flag:e,streamID:this.streamId,length:i})}}function cu(r){return{type:Ae[r.type],flags:[(r.flag&re.SYN)===re.SYN?"SYN":void 0,(r.flag&re.ACK)===re.ACK?"ACK":void 0,(r.flag&re.FIN)===re.FIN?"FIN":void 0,(r.flag&re.RST)===re.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const _m="/yamux/1.0.0";var Yu,Xu;Xu=Symbol.toStringTag,Yu=Lt;class Tx{constructor(t={}){l(this,"protocol",_m);l(this,"_init");l(this,Xu,"@chainsafe/libp2p-yamux");l(this,Yu,["@libp2p/stream-multiplexing"]);this._init=t}createStreamMuxer(t){return new Lx(t,{...this._init})}}class Lx extends Mh{constructor(e,n={}){super(e,{...n,protocol:_m,name:"yamux"});l(this,"nextStreamID");l(this,"nextPingID");l(this,"activePing");l(this,"rtt");l(this,"client");l(this,"localGoAway");l(this,"remoteGoAway");l(this,"numInboundStreams");l(this,"numOutboundStreams");l(this,"decoder");l(this,"keepAlive");l(this,"enableKeepAlive");l(this,"keepAliveInterval");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");this.client=e.direction==="outbound",xx(n),this.enableKeepAlive=n.enableKeepAlive??ks.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??ks.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??ks.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??ks.maxOutboundStreams,this.decoder=new _x,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=sE(async s=>{try{await this.ping(s)}catch(i){this.log.error("ping error: %s",i)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(e){for(const n of this.decoder.emitFrames(e))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new In("Muxer closed remotely");if(this.localGoAway!==void 0)throw new In("Muxer closed locally");const e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new Fa("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",e);const n=this._newStream(e,He.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(e){if(this.remoteGoAway!==void 0)throw new In("Muxer closed remotely");if(this.localGoAway!==void 0)throw new In("Muxer closed locally");if(this.activePing!=null)return yt(this.activePing.promise,e==null?void 0:e.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await yt(this.activePing.promise,e==null?void 0:e.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(e={}){var n;if(this.status==="open")try{const s=(e==null?void 0:e.reason)??Qe.NormalTermination;this.log.trace("muxer close reason=%s",Qe[s]),await super.close(e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}abort(e){var n;if(this.status==="open")try{super.abort(e);let s=Qe.InternalError;vx(e)&&(s=e.reason),this.log.error("muxer abort reason=%s error=%s",s,e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var e;try{super.onTransportClosed()}finally{(e=this.keepAlive)==null||e.stop()}}_newStream(e,n,s){if(this.streams.find(o=>o.streamId===e)!=null)throw new G("Stream already exists with that id");const i=new Ix({...this.streamOptions,id:`${e}`,streamId:e,state:n,direction:s,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${s}:${e}`),getRTT:this.getRTT.bind(this)});return i.addEventListener("close",()=>{this.closeStream(e)},{once:!0}),i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(e){const{streamID:n,type:s,length:i}=e.header;if(this.log.trace("received frame %o",cu(e.header)),n===0)switch(s){case Ae.Ping:{this.handlePing(e.header);return}case Ae.GoAway:{this.handleGoAway(i);return}default:throw new ln("Invalid frame type")}else switch(e.header.type){case Ae.Data:case Ae.WindowUpdate:{this.handleStreamMessage(e);return}default:throw new ln("Invalid frame type")}}handlePing(e){if(e.flag===re.SYN)this.log.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,re.ACK);else if(e.flag===re.ACK)this.log.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new ln("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new Sm("ping not requested");if(this.activePing.id!==e)throw new xm("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(e){this.log.trace("received GoAway reason=%s",Qe[e]??"unknown"),this.remoteGoAway=e,e===Qe.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(e){const{streamID:n,flag:s,type:i}=e.header;(s&re.SYN)===re.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(i){case Ae.WindowUpdate:{o.handleWindowUpdate(e);return}case Ae.Data:{o.handleData(e);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new G("Both endpoints are clients");if(this.streams.find(s=>s.streamId===e))return;if(this.log.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:Ae.WindowUpdate,flag:re.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:Ae.WindowUpdate,flag:re.RST,streamID:e,length:0});return}const n=this._newStream(e,He.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(e,n){let s;if(e.type===Ae.Data){if(n==null)throw new ln("Invalid frame");s=new j(au(e),n)}else s=au(e);return this.log.trace("sending frame %o",cu(e)),this.send(s)}sendPing(e,n=re.SYN){n===re.SYN?this.log.trace("sending ping request pingId=%s",e):this.log.trace("sending ping response pingId=%s",e),this.sendFrame({type:Ae.Ping,flag:n,streamID:0,length:e})}sendGoAway(e=Qe.NormalTermination){this.log("sending GoAway reason=%s",Qe[e]),this.localGoAway=e,this.sendFrame({type:Ae.GoAway,flag:0,streamID:0,length:e})}}function Dx(r={}){return()=>new Tx(r)}const Px="0.1.0",Rx="id",kx="1.0.0",Mx=1024*8;var Ti;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.protocolVersion!=null&&(n.uint32(42),n.string(e.protocolVersion)),e.agentVersion!=null&&(n.uint32(50),n.string(e.agentVersion)),e.publicKey!=null&&(n.uint32(10),n.bytes(e.publicKey)),e.listenAddrs!=null)for(const i of e.listenAddrs)n.uint32(18),n.bytes(i);if(e.observedAddr!=null&&(n.uint32(34),n.bytes(e.observedAddr)),e.protocols!=null)for(const i of e.protocols)n.uint32(26),n.string(i);e.signedPeerRecord!=null&&(n.uint32(66),n.bytes(e.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 5:{i.protocolVersion=e.string();break}case 6:{i.agentVersion=e.string();break}case 1:{i.publicKey=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new Dt('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(e.bytes());break}case 4:{i.observedAddr=e.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new Dt('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 8:{i.signedPeerRecord=e.bytes();break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Ti||(Ti={}));const vt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:Mx,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function Nx(r){if(r!=null&&r.length>0)try{return Z(r)}catch{}}async function Ox(r,t,e,n,s){if(e("received identify from %p",n.remotePeer),s==null)throw new it("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:Z(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Yt(s.publicKey);if(!qr(c).equals(n.remotePeer))throw new it("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){e.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const u=await En.openAndCertify(c,Tt.DOMAIN);let d=Tt.createFromProtobuf(u.payload);const h=cs(u.publicKey.toCID());if(!d.peerId.equals(h))throw new it("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(d.peerId))throw new it("signing key does not match remote PeerId");let f;try{f=await r.get(d.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(f!=null&&(i.metadata=f.metadata,f.peerRecordEnvelope!=null)){const p=En.createFromProtobuf(f.peerRecordEnvelope),m=Tt.createFromProtobuf(p.payload);m.seqNumber>=d.seqNumber&&(e("sequence number was lower or equal to existing sequence number - stored: %d received: %d",m.seqNumber,d.seqNumber),d=m,c=f.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=d.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:d.seqNumber,addresses:d.multiaddrs}}else e("%p did not send a signed peer record",n.remotePeer);if(e.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=X(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=X(s.protocolVersion)),e.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>Z(c)),observedAddr:s.observedAddr==null?void 0:Z(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}class Fx{constructor(t,e){l(this,"host");l(this,"components");l(this,"protocol");l(this,"started");l(this,"timeout");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");l(this,"maxMessageSize");l(this,"maxObservedAddresses");l(this,"runOnLimitedConnection");l(this,"log");this.protocol=e.protocol,this.started=!1,this.components=t,this.log=e.log,this.timeout=e.timeout??vt.timeout,this.maxInboundStreams=e.maxInboundStreams??vt.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??vt.maxOutboundStreams,this.maxMessageSize=e.maxMessageSize??vt.maxMessageSize,this.maxObservedAddresses=e.maxObservedAddresses??vt.maxObservedAddresses,this.runOnLimitedConnection=e.runOnLimitedConnection??vt.runOnLimitedConnection,this.host={protocolVersion:`${e.protocolPrefix??vt.protocolPrefix}/${Px}`,agentVersion:t.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:X(this.host.agentVersion),ProtocolVersion:X(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}var Zu,Qu;class Bx extends(Qu=Fx,Zu=Lt,Qu){constructor(e,n={}){super(e,{...n,protocol:`/${n.protocolPrefix??vt.protocolPrefix}/${Rx}/${kx}`,log:e.logger.forComponent("libp2p:identify")});l(this,Zu,["@libp2p/identify"]);(n.runOnConnectionOpen??vt.runOnConnectionOpen)&&e.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(()=>{})})}async _identify(e,n={}){let s,i;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",e.remoteAddr);try{s=await e.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),i=s.log.newScope("identify");const o=bn(s,{maxDataLength:this.maxMessageSize}).pb(Ti),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw i==null||i.error("identify failed - %e",o),s==null||s.abort(o),o}}async identify(e,n={}){const s=await this._identify(e,n),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new it("Public key was missing from identify message");const c=Yt(i),u=cs(c.toCID());if(!e.remotePeer.equals(u))throw new it("Identified peer does not match the expected peer");if(this.components.peerId.equals(u))throw new it("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",u,o),Ox(this.components.peerStore,this.components.events,this.log,e,s)}maybeAddObservedAddress(e){const n=Nx(e);if(n==null||(this.log.trace("our observed address was %a",n),er(n)))return;const s=n.getComponents();if((s[0].code===nr||s[0].code===hc&&s[1].code===nr)&&!vb(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}bi.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(e,n){const s=e.log.newScope("identify");s("responding to identify");const i=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:i}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(H));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new Tt({peerId:this.components.peerId,multiaddrs:a});c=(await En.seal(h,this.components.privateKey,{signal:i})).marshal().subarray()}let u=n.remoteAddr.bytes;nv.matches(n.remoteAddr)||(u=void 0);const d=bn(e).pb(Ti);s("send response"),await d.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:It(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:u,protocols:o.protocols},{signal:i}),s("close write"),await d.unwrap().unwrap().close({signal:i})}}function $x(r={}){return t=>new Bx(t,r)}const Ux=1,Im=5e3,zx=100,Ms=`${$a}-circuit-relay`;BigInt(1<<17);const Li="/libp2p/circuit/relay/0.2.0/hop",lu="/libp2p/circuit/relay/0.2.0/stop",uu=300,qx=4096,Kx=.001;var or;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(t||(t={})),function(n){n.codec=()=>ur(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),ar.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),Di.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),qe.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u,d;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const h=n.uint32();switch(h>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=ar.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.reservation=Di.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.reservation});break}case 4:{o.limit=cr.codec().decode(n,n.uint32(),{limits:(d=i.limits)==null?void 0:d.limit});break}case 5:{o.status=qe.codec().decode(n);break}default:{n.skipType(h&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(or||(or={}));var St;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(t||(t={})),function(n){n.codec=()=>ur(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),ar.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),cr.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),qe.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const d=n.uint32();switch(d>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=ar.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.limit=cr.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.limit});break}case 4:{o.status=qe.codec().decode(n);break}default:{n.skipType(d&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(St||(St={}));var ar;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.id!=null&&e.id.byteLength>0&&(n.uint32(10),n.bytes(e.id)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={id:ae(0),addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Dt('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(ar||(ar={}));var Di;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.expire!=null&&e.expire!==0n&&(n.uint32(8),n.uint64(e.expire)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);e.voucher!=null&&(n.uint32(26),Ri.codec().encode(e.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={expire:0n,addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.expire=e.uint64();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new Dt('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}case 3:{i.voucher=Ri.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.voucher});break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Di||(Di={}));var cr;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.duration!=null&&(n.uint32(8),n.uint32(e.duration)),e.data!=null&&(n.uint32(16),n.uint64(e.data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.duration=e.uint32();break}case 2:{i.data=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(cr||(cr={}));var qe;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(qe||(qe={}));var La;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(La||(La={}));(function(r){r.codec=()=>ur(La)})(qe||(qe={}));var Pi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.relay!=null&&e.relay.byteLength>0&&(n.uint32(10),n.bytes(e.relay)),e.peer!=null&&e.peer.byteLength>0&&(n.uint32(18),n.bytes(e.peer)),e.expiration!=null&&e.expiration!==0n&&(n.uint32(24),n.uint64(e.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={relay:ae(0),peer:ae(0),expiration:0n},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.relay=e.bytes();break}case 2:{i.peer=e.bytes();break}case 3:{i.expiration=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Pi||(Pi={}));var Ri;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&(n.uint32(26),Pi.codec().encode(e.payload,n)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={publicKey:ae(0),payloadType:ae(0),signature:ae(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=Pi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.payload});break}case 5:{i.signature=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Ri||(Ri={}));class Da extends Error{constructor(){super(...arguments);l(this,"name","HadEnoughRelaysError")}}l(Da,"name","HadEnoughRelaysError");class Tm extends Error{constructor(){super(...arguments);l(this,"name","DoubleRelayError")}}l(Tm,"name","DoubleRelayError");class Lm extends Error{constructor(){super(...arguments);l(this,"name","RelayQueueFullError")}}l(Lm,"name","RelayQueueFullError");function du(r){const t=r*BigInt(1e3),e=new Date().getTime();return Number(t-BigInt(e))}class hu{constructor(t){l(this,"expires");l(this,"bytes");(t==null?void 0:t.duration)!=null&&(t==null?void 0:t.duration)!==0&&(this.expires=Date.now()+t.duration*1e3),this.bytes=t==null?void 0:t.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(t){this.bytes!=null&&(this.bytes-=BigInt(t.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const t={};if(this.bytes!=null){const e=this;Object.defineProperty(t,"bytes",{get(){return e.bytes}})}if(this.expires!=null){const e=this;Object.defineProperty(t,"seconds",{get(){return Math.round(((e.expires??0)-Date.now())/1e3)}})}return t}}const Dm=he(ie(Sc.matchers[0],ue(hr))),Pm=he(ue(hr));class Vx extends Ze{constructor(e,n={}){super();l(this,"components");l(this,"started");l(this,"running");l(this,"topologyId");l(this,"log");l(this,"discoveryController");l(this,"filter");l(this,"queue");this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=n.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Li,{filter:this.filter,onConnect:e=>{var n,s;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,(n=this.queue)==null?void 0:n.size,(s=this.queue)==null?void 0:s.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var s;this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[i=>i.protocols.includes(Li)],orders:[()=>Math.random()<.5?1:-1,(i,o)=>{const a=fu(i),c=fu(o);return a>c?-1:c>a?1:0}]});for(const i of e)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",e.length);const n=this.queue=new yc({concurrency:5});this.log("start random walk");for await(const i of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",i.id),n.has(i.id)){this.log.trace("random peer %p was already in queue",i.id);continue}if(((s=this.components.connectionManager.getConnections(i.id))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",i.id);continue}if(!await this.components.connectionManager.isDialable(i.multiaddrs)){this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(o=>o.toString()));continue}n.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await n.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,n.size,n.running),n.add(this.dialPeer,{peerId:i.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",i.id,o)})}this.log("stop random walk"),await n.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",e)}))}stopDiscovery(){var e,n;this.log("stop discovery"),this.running=!1,(e=this.discoveryController)==null||e.abort(),(n=this.queue)==null||n.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p",e.detail.id),this.maybeDialPeer(e).catch(n=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,n)})}async maybeDialPeer(e){var i,o;if(this.queue==null)return;const n=e.detail.id,s=e.detail.multiaddrs;if(this.queue.has(n)){this.log.trace("random peer %p was already in queue",n);return}if(((i=this.components.connectionManager.getConnections(n))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",n);return}if(!await this.components.connectionManager.isDialable(s)){this.log.trace("random peer %p was not dialable",n);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",e.detail.id,a)})}async dialPeer({peerId:e,signal:n}){const s=wn([AbortSignal.timeout(5e3),n]);try{await this.components.connectionManager.openConnection(e,{signal:s})}finally{s.clear()}}}function fu(r){const t=r.metadata.get("last-dial-success");return t==null?0:new Date(J(t)).getTime()}class Wx extends Ze{constructor(e,n={}){super();l(this,"connectionManager");l(this,"addressManager");l(this,"reservationStore");l(this,"listeningAddrs");l(this,"log");l(this,"listenTimeout");l(this,"reservationId");l(this,"relay");l(this,"_onRemoveRelayPeer",e=>{var n,s;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,(n=this.relay)==null?void 0:n.equals(e.detail.relay)),((s=this.relay)==null?void 0:s.equals(e.detail.relay))===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(i=>{this.addressManager.removeObservedAddr(i)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});l(this,"_onAddRelayPeer",e=>{const{details:n}=e.detail;n.type!=="configured"&&n.id===this.reservationId&&this.addedRelay(e.detail)});this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=n.listenTimeout??Im,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(Pm.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(Dm.exactMatch(e)){this.log("listen on specific relay server %a",e);const n=AbortSignal.timeout(this.listenTimeout),s=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(s,{signal:n});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const o=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(o)}}else throw new Zs(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(n=>Z(n).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(n=>{this.addressManager.confirmObservedAddr(n,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Hx(r){return new Wx(r)}const Gx="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Yx=(r=21)=>{let t="",e=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)t+=Gx[e[r]&63];return t};const Xx=60*1e3*10,Zx=60*1e3*5,Qx=30*1e3;var Ye,Rm,Cr,_r;class Jx extends Ze{constructor(e,n){super();oe(this,Ye);l(this,"peerId");l(this,"connectionManager");l(this,"peerStore");l(this,"events");l(this,"reserveQueue");l(this,"reservations");l(this,"pendingReservations");l(this,"maxReservationQueueLength");l(this,"reservationCompletionTimeout");l(this,"started");l(this,"log");l(this,"relayFilter");this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new dr,this.pendingReservations=[],this.maxReservationQueueLength=(n==null?void 0:n.maxReservationQueueLength)??zx,this.reservationCompletionTimeout=(n==null?void 0:n.reservationCompletionTimeout)??Im,this.started=!1,this.relayFilter=Wr(100),this.reserveQueue=new yc({concurrency:(n==null?void 0:n.reservationConcurrency)??Ux,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",s=>{[...this.reservations.values()].find(o=>o.connection===s.detail.id)!=null&&z(this,Ye,Cr).call(this,s.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",s.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[n=>n.tags.has(Ms)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async n=>{await this.peerStore.merge(n.id,{tags:{[Ms]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async n=>this.addRelay(n.id,"discovered"))),z(this,Ye,_r).call(this)}).catch(e=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=Yx();return this.pendingReservations.push(e),z(this,Ye,_r).call(this),e}async addRelay(e,n){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Zs("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Lm("The reservation queue is full");const s=this.reserveQueue.find(e);if(s!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),s.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Zs("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const o=this.reservations.get(e);if(o!=null){const y=this.connectionManager.getConnections(e);let g=!1;if(y.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),y.map(S=>S.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),g=!0),g&&du(o.reservation.expire)>Xx)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:o};await z(this,Ye,Cr).call(this,e)}if(n==="discovered"&&this.pendingReservations.length===0)throw new Da("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(e,{signal:a});if(sr.matches(c.remoteAddr))throw new Tm("not creating reservation over relayed connection");const u=await z(this,Ye,Rm).call(this,c,{signal:a}),d=du(u.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+d).toString());const h=Math.min(Math.max(d-Zx,Qx),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,n).catch(async y=>{this.log.error("could not refresh reservation to relay %p - %e",e,y),await z(this,Ye,Cr).call(this,e)}).catch(y=>{this.log.error("could not remove expired reservation to relay %p - %e",e,y)})},h);let p;if(n==="discovered"){const y=this.pendingReservations.pop();if(y==null)throw new Da("Made reservation on relay but did not need any more discovered relays");p={timeout:f,reservation:u,type:n,connection:c.id,id:y}}else p={timeout:f,reservation:u,type:n,connection:c.id};this.reservations.set(e,p),await this.peerStore.merge(e,{tags:{[Ms]:{value:1,ttl:d}}}),z(this,Ye,_r).call(this);const m={relay:e,details:p};return this.safeDispatchEvent("relay:created-reservation",{detail:m}),m}catch(o){throw n==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),z(this,Ye,Cr).call(this,e).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,a)}),o}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var n;return(n=this.reservations.get(e))==null?void 0:n.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((n,s)=>(s.type===e&&n++,n),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}Ye=new WeakSet,Rm=async function(e,n){var u;(u=n.signal)==null||u.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const s=await e.newStream(Li,n),o=bn(s).pb(or);this.log.trace("send RESERVE to %p",e.remotePeer),await o.write({type:or.Type.RESERVE},n);let a;try{this.log.trace("reading response from %p",e.remotePeer),a=await o.read(n)}catch(d){throw s.abort(d),d}finally{s.status!=="closed"&&await s.close(n)}if(this.log.trace("read response %s",a.status),a.status===qe.OK&&a.reservation!=null){const d=new Set;d.add(e.remoteAddr.toString());for(const h of a.reservation.addrs){let f=Z(h);f.getComponents().find(p=>p.code===H)==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=Z(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),d.add(f.toString())}return a.reservation.addrs=[...d].map(h=>Z(h).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},Cr=async function(e){const n=this.reservations.get(e);n!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(n.timeout),this.reservations.delete(e),n.type==="discovered"&&this.pendingReservations.push(n.id),await this.peerStore.merge(e,{tags:{[Ms]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:n}}),z(this,Ye,_r).call(this))},_r=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Wr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class jx extends kh{constructor(e){super({...e,direction:e.stream.direction});l(this,"stream");l(this,"init");this.init=e,this.stream=e.stream,this.stream.addEventListener("close",n=>{this.onTransportClosed(n.error)}),this.stream.addEventListener("remoteCloseWrite",n=>{this.onRemoteCloseWrite(),this.close().catch(s=>{this.abort(s)})}),this.stream.addEventListener("message",n=>{var s;(s=e.onDataRead)==null||s.call(e,n.data),this.onData(n.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(e){var n,s;return(s=(n=this.init).onDataWrite)==null||s.call(n,e),{sentBytes:e.byteLength,canSendMore:this.stream.send(e)}}async sendClose(e){await this.stream.close(e)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function mu(r){return new jx(r)}const e2=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(Z)}catch{return!1}return!0},gu={maxInboundStopStreams:uu,maxOutboundStopStreams:uu};var Ju,ju,ed,td;class t2{constructor(t,e={}){l(this,"components");l(this,"discovery");l(this,"reservationStore");l(this,"maxInboundStopStreams");l(this,"maxOutboundStopStreams");l(this,"started");l(this,"log");l(this,"shutdownController");l(this,td,"@libp2p/circuit-relay-v2-transport");l(this,ed,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);l(this,Ju,!0);this.components=t,this.log=t.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=e.maxInboundStopStreams??gu.maxInboundStopStreams,this.maxOutboundStopStreams=e.maxOutboundStopStreams??gu.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Vx(t,{filter:e.discoveryFilter??aE(qx,Kx)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",n.detail,s)})}),this.reservationStore=new Jx(t,e),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var n;(n=this.discovery)==null||n.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var n;(n=this.discovery)==null||n.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[(td=Symbol.toStringTag,ed=Lt,ju=Js,Ju=md,ju)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(lu,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await hd(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await fd(this.discovery,this.reservationStore),await this.components.registrar.unhandle(lu),this.started=!1}async dial(t,e){var p,m,y,g,S,v,E,L;const n=t.toString().split("/p2p-circuit"),s=Z(n[0]),i=Z(n[n.length-1]),o=(p=s.getComponents().find(x=>x.code===H))==null?void 0:p.value,a=(m=i.getComponents().find(x=>x.code===H))==null?void 0:m.value;if(o==null||a==null){const x=`ircuit relay dial to ${t.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${x}`),new Tr(`C${x}`)}const c=ct(o),u=ct(a);let h=this.components.connectionManager.getConnections(c)[0];h==null?(await this.components.peerStore.merge(c,{multiaddrs:[s]}),(y=e.onProgress)==null||y.call(e,new de("circuit-relay:open-connection")),h=await this.components.connectionManager.openConnection(c,e)):(g=e.onProgress)==null||g.call(e,new de("circuit-relay:reuse-connection"));let f;try{(S=e.onProgress)==null||S.call(e,new de("circuit-relay:open-hop-stream")),f=await h.newStream(Li,e);const x=bn(f).pb(or);(v=e.onProgress)==null||v.call(e,new de("circuit-relay:write-connect-message")),await x.write({type:or.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[Z(i).bytes]}},e),(E=e.onProgress)==null||E.call(e,new de("circuit-relay:read-connect-response"));const _=await x.read(e);if(_.status!==qe.OK)throw new it(`failed to connect via relay with status ${((L=_==null?void 0:_.status)==null?void 0:L.toString())??"undefined"}`);const O=new hu(_.limit),T=mu({stream:x.unwrap().unwrap(),remoteAddr:t,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:O.onData,onDataWrite:O.onData,log:f.log.newScope("circuit-relay:connection")}),I=await this.components.upgrader.upgradeOutbound(T,{...e,limits:O.getLimits()});return I.log("outbound relayed connection established to %p with limits %o, over connection %s",I.remotePeer,_.limit??"none",h.id),I}catch(x){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",u,c,x),f==null||f.abort(x),x}}createListener(t){return Hx({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>Dm.exactMatch(e)||Pm.exactMatch(e))}dialFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>sr.exactMatch(e))}async onStop(t,e){var s,i;const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(p){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",p)}const o=bn(t).pb(St),a=await o.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await o.write({type:St.Type.STATUS,status:qe.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(a.type!==St.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:St.Type.STATUS,status:qe.UNEXPECTED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(!e2(a)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:St.Type.STATUS,status:qe.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const c=as(ts(a.peer.id));if(await((i=(s=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:i.call(s,e.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await o.write({type:St.Type.STATUS,status:qe.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await o.write({type:St.Type.STATUS,status:qe.OK},{signal:n});const u=new hu(a.limit),d=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),h=this.components.addressManager.getAddresses()[0],f=mu({stream:o.unwrap().unwrap(),remoteAddr:d,localAddr:h,onDataRead:u.onData,onDataWrite:u.onData,log:t.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(f,{limits:u.getLimits(),signal:n}),f.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",e.id)}finally{n==null||n.clear()}}}function n2(r={}){return t=>new t2(t,r)}const r2="bootstrap",s2=50,i2=1e3;var nd,rd,sd,id;class km extends(id=Ze,sd=Wo,rd=Symbol.toStringTag,nd=Lt,id){constructor(e,n={list:[]}){if(n.list==null||n.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();l(this,"log");l(this,"timer");l(this,"list");l(this,"timeout");l(this,"components");l(this,"_init");l(this,sd,this);l(this,rd,"@libp2p/bootstrap");l(this,nd,["@libp2p/peer-discovery"]);this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=n.timeout??i2,this.list=n.list.map(s=>Z(s)).filter(s=>{var o;return Sc.matches(s)?((o=s.getComponents().findLast(a=>a.code===H))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",s),!1)}).map(s=>{var i;return{id:ct(((i=s.getComponents().findLast(o=>o.code===H))==null?void 0:i.value)??""),multiaddrs:[s]}}),this._init=n}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error("failed to discover bootstrap peers - %e",e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??r2]:{value:this._init.tagValue??s2,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not dial bootstrap peer %p - %e",e.id,n)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}l(km,"tag","bootstrap");function o2(r){return t=>new km(t,r)}window.location.hostname==="localhost"&&Object.defineProperty(HTMLElement.prototype,"style",{set:()=>console.error("Inline style set detected in blockchain.ts! Check stack trace."),configurable:!0});const a2=location.hostname.split("."),Mm=a2[0],c2=location.pathname==="/"||location.pathname===""?`${Mm}.github.io`:location.pathname.split("/")[1],lt=`${Mm}/${c2}`,l2="data/state.json",Pa=`https://api.github.com/repos/${lt}/contents/${l2}`,Ra="gitchain_github_access_token",ki=`https://api.github.com/repos/${lt}/issues`,pu="/gitchain/tx/1.0.0",Kt="data/server-peer.json",u2=5*60*1e3;let $t=null,Ws=!1,yu=null;function Nm(r,t,e,n){const s=`${r}${t}${e}${JSON.stringify(n)}`;return CryptoJS.SHA256(s).toString()}function d2(){const r=new Date().toISOString();return{index:0,previousHash:"0",timestamp:r,transactions:[],hash:Nm(0,"0",r,[])}}function Om(r){return JSON.stringify(r,Object.keys(r).sort())}function ka(r){const e=sha3.keccak256(r).match(/.{2}/g);if(!e)throw new Error("Failed to parse hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}function h2(r){const t=new Uint8Array(r.length/2);for(let e=0;e<r.length;e+=2)t[e/2]=parseInt(r.substr(e,2),16);return t}function Ir(r){return Array.from(r,t=>t.toString(16).padStart(2,"0")).join("")}function Cc(r){try{const t=ka(Om({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})),e=h2(r.signature);if(e.length!==65)return!1;const n=Ir(e.slice(0,32)),s=Ir(e.slice(32,64)),i=e[64]-27,o=new ec("secp256k1"),a=Ir(t),c={r:n,s},u=o.recoverPubKey(a,c,i),d=ka(u.encode("array",!0).slice(1));return`0x${Ir(d.slice(-20))}`.toLowerCase()===r.from.toLowerCase()}catch{return!1}}async function f2(r,t){const e=Ir(ka(Om({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})));return Cc(r)?(t.nonces[r.from]||0)+1!==r.nonce?{valid:!1,txid:e}:r.from.toLowerCase()!==Ys.toLowerCase()&&(t.balances[r.from]||0)<r.amount?{valid:!1,txid:e}:!/^0x[a-fA-F0-9]{40}$/.test(r.from)||!/^0x[a-fA-F0-9]{40}$/.test(r.to)?{valid:!1,txid:e}:(t.pending.push(r),{valid:!0,txid:e}):{valid:!1,txid:e}}async function m2(r){if(r.pending.length===0)return null;const t=[],e={...r.balances},n={...r.nonces};for(const u of r.pending)Cc(u)&&(n[u.from]||0)+1===u.nonce&&(u.from.toLowerCase()===Ys.toLowerCase()||(e[u.from]||0)>=u.amount)&&(u.from.toLowerCase()!==Ys.toLowerCase()&&(e[u.from]=(e[u.from]||0)-u.amount),e[u.to]=(e[u.to]||0)+u.amount,n[u.from]=u.nonce,t.push(u));if(t.length===0)return r.pending=[],null;const s=r.chain.length,i=r.chain.length>0?r.chain[r.chain.length-1].hash:"0",o=new Date().toISOString(),a=Nm(s,i,o,t),c={index:s,previousHash:i,timestamp:o,transactions:t,hash:a};return r.chain.push(c),r.pending=[],r.balances=e,r.nonces=n,s}function Zt(){var t;let r=localStorage.getItem(Ra);if(!r){if(r=(t=document.getElementById("githubAccessToken"))==null?void 0:t.value,!r)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(Ra,r)}return console.log("Retrieved GitHub access token"),r}async function g2(r){console.log("Entering initP2P, isHost:",r),Ws=r;try{console.log("Creating libp2p node..."),$t=await jS({addresses:{listen:["/webrtc","/p2p-circuit"]},transports:[n2({hop:{enabled:!1}}),bx({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncrypters:[wx()],streamMuxers:[Dx()],peerDiscovery:[o2({list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbX7TbXrHRQHh2","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqduuO5wL","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76C42gEOzRVzYVdigitaltA5dyxuEXsBC","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp"]})],services:{identify:$x()},connectionGater:{denyDialMultiaddr:async()=>!1}}),console.log("Starting libp2p node..."),await $t.start(),console.log("libp2p started, peerId:",$t.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(e=>setTimeout(e,1e3)),$t.addEventListener("peer:connect",e=>{console.log("Connected to peer:",e.detail.toString())}),console.log("Registering protocol handler for:",pu),await $t.handle(pu,async({stream:e,connection:n})=>{console.log("Incoming TX stream from",n.remotePeer.toString());const s=await y2(e);try{const i=JSON.parse(s);if(Cc(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:lt,txn:i}),a=await fetch(ki,{method:"POST",headers:{Authorization:`token ${Zt()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}e.close()}),Ws&&(console.log("Host mode: Advertising peer info"),await wu(),console.log("Setting interval for periodic peer advertising"),setInterval(wu,u2),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await p2()})),console.log("initP2P completed successfully")}catch(t){console.error("Failed to initialize P2P:",t),Ws&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function wu(r=3,t=1e3){if(console.log("Entering advertiseServerPeer, retries:",r),!Ws||!$t)return console.log("Not in host mode or libp2p not initialized"),!1;const e=$t.peerId.toString(),n=$t.getMultiaddrs().map(a=>a.toString()),s={peerId:e,multiaddrs:n,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===yu)return console.log("No change in peer info, skipping update"),!0;yu=i;const o=Zt();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=r;a++){console.log(`Attempt ${a}/${r} to advertise peer info`);try{console.log("Fetching SHA for",Kt);const c=await Fm(Kt);console.log("SHA:",c||"none (new file)");const u={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(u.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${lt}/contents/${Kt}`);const d=await fetch(`https://api.github.com/repos/${lt}/contents/${Kt}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(u)});if(d.ok)return console.log("Advertised peer info successfully"),!0;{const h=await d.text();if(console.error(`Attempt ${a}/${r} - Failed to advertise peer: ${d.status} ${h}`),(d.status===403||d.status===429)&&(console.log(`Retrying after ${t}ms due to ${d.status}`),a<r)){await new Promise(f=>setTimeout(f,t));continue}throw new Error(`HTTP ${d.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${r} - Error advertising peer:`,c),a===r)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(u=>setTimeout(u,t))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function p2(){console.log("Entering deleteServerPeerFile");const r=Zt();if(!r){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",Kt);const t=await Fm(Kt);if(!t){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",Kt);const e=await fetch(`https://api.github.com/repos/${lt}/contents/${Kt}`,{method:"DELETE",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:t})});e.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",e.status,await e.text())}catch(t){console.error("Error deleting peer file:",t)}}async function Fm(r){console.log("Entering getFileSha for",r);const t=Zt();if(!t)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${lt}/contents/${r}?ref=main`);const e=await fetch(`https://api.github.com/repos/${lt}/contents/${r}?ref=main`,{headers:{Authorization:`token ${t}`,Accept:"application/vnd.github.v3+json"}});if(e.ok){const n=await e.json();return console.log("SHA retrieved:",n.sha),n.sha}return e.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${r}: ${e.status} ${await e.text()}`),null)}catch(e){return console.error(`Error fetching SHA for ${r}:`,e),null}}async function y2(r){console.log("Reading stream to string");const t=[];for await(const s of r.source)t.push(s);const e=Ht(t),n=J(e);return console.log("Stream read complete, length:",n.length),n}async function Hs(){console.log("Entering fetchState");const r=Zt();if(!r)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",Pa);const t=await fetch(`${Pa}?ref=main`,{headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json"}});if(!t.ok){if(t.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",t.status,await t.text()),new Error(`Error fetching state: ${t.statusText}`)}const e=await t.json(),n=JSON.parse(atob(e.content));return console.log("State fetched, chain length:",n.chain.length),{content:n,sha:e.sha}}catch(t){return console.error("Error fetching state:",t),null}}async function Gs(r,t,e,n=3){console.log("Entering updateState, message:",e);const s=Zt();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(r,null,2));try{const o={message:e,content:i,branch:"main"};t&&(o.sha=t),console.log("Sending PUT request to update state");const a=await fetch(Pa,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&n>0){console.log("Conflict detected, retrying...");const c=await Hs();if(!c)throw new Error("Failed to refetch");return Gs(r,c.sha,e,n-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function Ns(r,t,e){console.log("Entering closeIssueWithComment, issue:",r);const n=Zt();if(!n){console.log("No PAT available for closing issue");return}const s=e&&t!==null?`Confirmed in block ${t}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${lt}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${lt})`;console.log("Creating comment for issue:",r),await fetch(`${ki}/${r}/comments`,{method:"POST",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",r),await fetch(`${ki}/${r}`,{method:"PATCH",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function w2(){console.log("Entering processTxns");const r=document.getElementById("output"),t=document.getElementById("processingMessage");t.classList.add("visible");let e=await Hs(),n=e==null?void 0:e.content;if(!n){if(console.log("No state found, initializing"),n={chain:[d2()],pending:[],balances:{[Ys]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await Gs(n,null,"Initialize state")){console.log("Failed to initialize state"),r.textContent+=`
Failed to initialize.`,t.classList.remove("visible");return}e=await Hs(),n=e.content}console.log("Fetching open issues");const i=await(await fetch(`${ki}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${Zt()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=n.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(n.lastProcessedDate))continue;let c;try{const m=JSON.parse(a.body);if(m.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await Ns(a.number,null,!1);continue}if(m.repo!==lt){console.log("Skipping issue from wrong repo:",a.number),await Ns(a.number,null,!1);continue}c=m.txn}catch{console.log("Invalid issue body, closing:",a.number),await Ns(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:u,txid:d}=await f2(c,n);console.log(`Transaction ID: ${d}, valid: ${u}`);const h=u?await m2(n):null;if(await Ns(a.number,h,u),u&&h!==null?(console.log(`Transaction ID: ${d} settled in block ${h}`),r.textContent+=`
Processed txn ${d} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),r.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await Gs(n,e.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),r.textContent+=`
Failed to update state after issue #${a.number}`,t.classList.remove("visible");return}e=await Hs(),n=e.content;const p=a.created_at;new Date(p)>new Date(o)&&(o=p)}o!==n.lastProcessedDate&&(console.log("Updating last processed date:",o),n.lastProcessedDate=o,await Gs(n,e.sha,"Update last processed date")),console.log("processTxns completed"),t.classList.remove("visible")}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(Ra)?(console.log("PAT found, initializing P2P as host"),g2(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{w2()},15e3)});
