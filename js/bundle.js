var __defProp$9 = Object.defineProperty;
var __name$9 = (target, value2) => __defProp$9(target, "name", { value: value2, configurable: true });
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 4] = "SILENT";
  return LogLevel2;
})(LogLevel || {});
var COLORS = {
  reset: "\x1B[0m",
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  gray: "\x1B[90m"
};
var BROWSER_COLORS = {
  DEBUG: "color: #6B7280; font-weight: normal",
  INFO: "color: #3B82F6; font-weight: normal",
  WARN: "color: #F59E0B; font-weight: bold",
  ERROR: "color: #EF4444; font-weight: bold",
  namespace: "color: #8B5CF6; font-weight: bold",
  timestamp: "color: #9CA3AF; font-weight: normal"
};
var LoggerManager = class {
  static {
    __name$9(this, "LoggerManager");
  }
  config;
  namespacePatterns = /* @__PURE__ */ new Map();
  isBrowser;
  constructor() {
    this.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    this.config = {
      level: 3,
      // Silent by default - only errors (nothing is logged without explicit config)
      namespaces: {},
      colors: true,
      timestamps: true,
      formatter: this.defaultFormatter.bind(this)
    };
  }
  /**
   * Set global log level
   */
  setGlobalLogLevel(level) {
    this.config.level = level;
  }
  /**
   * Set log level for a specific namespace or pattern
   * Supports wildcards: 'kasstamp:*' or 'kasstamp:sdk:*'
   */
  setNamespaceLogLevel(namespace, level) {
    this.config.namespaces[namespace] = level;
    this.namespacePatterns.set(namespace, level);
  }
  /**
   * Configure logger
   */
  configure(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.namespaces) {
      Object.entries(config.namespaces).forEach(([namespace, level]) => {
        this.namespacePatterns.set(namespace, level);
      });
    }
  }
  /**
   * Reset logger configuration to silent (ERROR only)
   */
  reset() {
    this.config = {
      level: 3,
      // Silent by default
      namespaces: {},
      colors: true,
      timestamps: true,
      formatter: this.defaultFormatter.bind(this)
    };
    this.namespacePatterns.clear();
  }
  /**
   * Get effective log level for a namespace
   */
  getEffectiveLevel(namespace) {
    if (this.config.namespaces[namespace] !== void 0) {
      return this.config.namespaces[namespace];
    }
    const parts = namespace.split(":");
    for (let i2 = parts.length; i2 > 0; i2--) {
      const pattern = parts.slice(0, i2).join(":");
      if (this.config.namespaces[pattern] !== void 0) {
        return this.config.namespaces[pattern];
      }
      const wildcardPattern = `${pattern}:*`;
      if (this.config.namespaces[wildcardPattern] !== void 0) {
        return this.config.namespaces[wildcardPattern];
      }
    }
    return this.config.level;
  }
  /**
   * Default formatter for log messages
   */
  defaultFormatter(level, namespace, message2, timestamp) {
    const time = this.config.timestamps ? timestamp.toISOString() : "";
    if (this.isBrowser && this.config.colors) {
      return time ? `%c${time}%c [%c${level}%c] %c[${namespace}]%c ${message2}` : `[%c${level}%c] %c[${namespace}]%c ${message2}`;
    } else if (this.config.colors) {
      const levelColor = this.getLevelColor(level);
      const timeStr = time ? `${COLORS.gray}${time}${COLORS.reset} ` : "";
      return `${timeStr}${levelColor}[${level}]${COLORS.reset} ${COLORS.magenta}[${namespace}]${COLORS.reset} ${message2}`;
    } else {
      return time ? `${time} [${level}] [${namespace}] ${message2}` : `[${level}] [${namespace}] ${message2}`;
    }
  }
  getLevelColor(level) {
    switch (level) {
      case "DEBUG":
        return COLORS.gray;
      case "INFO":
        return COLORS.blue;
      case "WARN":
        return COLORS.yellow;
      case "ERROR":
        return COLORS.red;
      default:
        return COLORS.reset;
    }
  }
  /**
   * Get browser color arguments for console styling
   */
  getBrowserColorArgs(level) {
    if (!this.config.timestamps) {
      return [
        BROWSER_COLORS[level] || "",
        "",
        BROWSER_COLORS.namespace,
        ""
      ];
    }
    return [
      BROWSER_COLORS.timestamp,
      "",
      BROWSER_COLORS[level] || "",
      "",
      BROWSER_COLORS.namespace,
      ""
    ];
  }
  getConfig() {
    return this.config;
  }
  isBrowserEnvironment() {
    return this.isBrowser;
  }
};
var loggerManager = new LoggerManager();
var Logger = class _Logger {
  static {
    __name$9(this, "Logger");
  }
  namespace;
  constructor(namespace) {
    this.namespace = namespace;
  }
  /**
   * Check if a log level is enabled for this logger
   * Checks dynamically so configuration changes take effect immediately
   */
  isLevelEnabled(level) {
    const effectiveLevel = loggerManager.getEffectiveLevel(this.namespace);
    return effectiveLevel <= level;
  }
  /**
   * Log a debug message
   * Calls console directly to preserve call site in browser DevTools
   */
  debug(message2, context) {
    if (!this.isLevelEnabled(
      0
      /* DEBUG */
    )) return;
    const config = loggerManager.getConfig();
    const timestamp = /* @__PURE__ */ new Date();
    const formattedMessage = config.formatter("DEBUG", this.namespace, message2, timestamp);
    if (loggerManager.isBrowserEnvironment() && config.colors) {
      const colorArgs = loggerManager.getBrowserColorArgs("DEBUG");
      if (context && Object.keys(context).length > 0) {
        console.debug(formattedMessage, ...colorArgs, context);
      } else {
        console.debug(formattedMessage, ...colorArgs);
      }
    } else {
      if (context && Object.keys(context).length > 0) {
        console.debug(formattedMessage, context);
      } else {
        console.debug(formattedMessage);
      }
    }
  }
  /**
   * Log an info message
   * Calls console directly to preserve call site in browser DevTools
   */
  info(message2, context) {
    if (!this.isLevelEnabled(
      1
      /* INFO */
    )) return;
    const config = loggerManager.getConfig();
    const timestamp = /* @__PURE__ */ new Date();
    const formattedMessage = config.formatter("INFO", this.namespace, message2, timestamp);
    if (loggerManager.isBrowserEnvironment() && config.colors) {
      const colorArgs = loggerManager.getBrowserColorArgs("INFO");
      if (context && Object.keys(context).length > 0) {
        console.info(formattedMessage, ...colorArgs, context);
      } else {
        console.info(formattedMessage, ...colorArgs);
      }
    } else {
      if (context && Object.keys(context).length > 0) {
        console.info(formattedMessage, context);
      } else {
        console.info(formattedMessage);
      }
    }
  }
  /**
   * Log a warning message
   * Calls console directly to preserve call site in browser DevTools
   */
  warn(message2, context) {
    if (!this.isLevelEnabled(
      2
      /* WARN */
    )) return;
    const config = loggerManager.getConfig();
    const timestamp = /* @__PURE__ */ new Date();
    const formattedMessage = config.formatter("WARN", this.namespace, message2, timestamp);
    if (loggerManager.isBrowserEnvironment() && config.colors) {
      const colorArgs = loggerManager.getBrowserColorArgs("WARN");
      if (context && Object.keys(context).length > 0) {
        console.warn(formattedMessage, ...colorArgs, context);
      } else {
        console.warn(formattedMessage, ...colorArgs);
      }
    } else {
      if (context && Object.keys(context).length > 0) {
        console.warn(formattedMessage, context);
      } else {
        console.warn(formattedMessage);
      }
    }
  }
  /**
   * Log an error message
   * Calls console directly to preserve call site in browser DevTools
   */
  error(message2, error, context) {
    if (!this.isLevelEnabled(
      3
      /* ERROR */
    )) return;
    let actualError;
    let actualContext;
    if (error instanceof Error) {
      actualError = error;
      actualContext = context;
    } else {
      actualContext = error;
    }
    const config = loggerManager.getConfig();
    const timestamp = /* @__PURE__ */ new Date();
    const formattedMessage = config.formatter("ERROR", this.namespace, message2, timestamp);
    if (loggerManager.isBrowserEnvironment() && config.colors) {
      const colorArgs = loggerManager.getBrowserColorArgs("ERROR");
      if (actualContext && Object.keys(actualContext).length > 0) {
        console.error(formattedMessage, ...colorArgs, actualContext);
      } else {
        console.error(formattedMessage, ...colorArgs);
      }
    } else {
      if (actualContext && Object.keys(actualContext).length > 0) {
        console.error(formattedMessage, actualContext);
      } else {
        console.error(formattedMessage);
      }
    }
    if (actualError && actualError.stack) {
      console.error(actualError.stack);
    }
  }
  /**
   * Create a child logger with additional namespace
   */
  child(subNamespace) {
    return new _Logger(`${this.namespace}:${subNamespace}`);
  }
};
function createLogger(namespace) {
  return new Logger(namespace);
}
__name$9(createLogger, "createLogger");
function setGlobalLogLevel(level) {
  loggerManager.setGlobalLogLevel(level);
}
__name$9(setGlobalLogLevel, "setGlobalLogLevel");
function setNamespaceLogLevel(namespace, level) {
  loggerManager.setNamespaceLogLevel(namespace, level);
}
__name$9(setNamespaceLogLevel, "setNamespaceLogLevel");
function configureLogger(config) {
  loggerManager.configure(config);
}
__name$9(configureLogger, "configureLogger");
function disableLogging() {
  loggerManager.setGlobalLogLevel(
    4
    /* SILENT */
  );
}
__name$9(disableLogging, "disableLogging");
function enableDebugLogging() {
  loggerManager.setGlobalLogLevel(
    0
    /* DEBUG */
  );
}
__name$9(enableDebugLogging, "enableDebugLogging");
function resetLogger() {
  loggerManager.reset();
}
__name$9(resetLogger, "resetLogger");
function initializeLoggers() {
  {
    setGlobalLogLevel(LogLevel.WARN);
  }
}
const ADMIN_ADDRESS = "0x097efb2a92bc5205e1615db52338a118f1619f3f";
const connectionSymbol = Symbol.for("@libp2p/connection");
const contentRoutingSymbol = Symbol.for("@libp2p/content-routing");
let AbortError$6 = class AbortError extends Error {
  static name = "AbortError";
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
  }
};
class UnexpectedPeerError extends Error {
  static name = "UnexpectedPeerError";
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.name = "UnexpectedPeerError";
  }
}
let InvalidCryptoExchangeError$1 = class InvalidCryptoExchangeError extends Error {
  static name = "InvalidCryptoExchangeError";
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.name = "InvalidCryptoExchangeError";
  }
};
let InvalidParametersError$1 = class InvalidParametersError extends Error {
  static name = "InvalidParametersError";
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
class InvalidPublicKeyError extends Error {
  static name = "InvalidPublicKeyError";
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
}
class ConnectionClosedError extends Error {
  static name = "ConnectionClosedError";
  constructor(message2 = "The connection is closed") {
    super(message2);
    this.name = "ConnectionClosedError";
  }
}
class ConnectionFailedError extends Error {
  static name = "ConnectionFailedError";
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
}
class MuxerClosedError extends Error {
  static name = "MuxerClosedError";
  constructor(message2 = "The muxer is closed") {
    super(message2);
    this.name = "MuxerClosedError";
  }
}
class StreamResetError extends Error {
  static name = "StreamResetError";
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
}
class StreamStateError extends Error {
  static name = "StreamStateError";
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
}
class StreamBufferError extends Error {
  static name = "StreamBufferError";
  constructor(message2 = "The stream buffer was full") {
    super(message2);
    this.name = "StreamBufferError";
  }
}
let NotFoundError$1 = class NotFoundError extends Error {
  static name = "NotFoundError";
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
class InvalidPeerIdError extends Error {
  static name = "InvalidPeerIdError";
  constructor(message2 = "Invalid PeerID") {
    super(message2);
    this.name = "InvalidPeerIdError";
  }
}
let InvalidMultiaddrError$1 = class InvalidMultiaddrError extends Error {
  static name = "InvalidMultiaddrError";
  constructor(message2 = "Invalid multiaddr") {
    super(message2);
    this.name = "InvalidMultiaddrError";
  }
};
class InvalidCIDError extends Error {
  static name = "InvalidCIDError";
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
}
class InvalidMultihashError extends Error {
  static name = "InvalidMultihashError";
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
}
class UnsupportedProtocolError extends Error {
  static name = "UnsupportedProtocolError";
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
}
class InvalidMessageError extends Error {
  static name = "InvalidMessageError";
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
}
let TimeoutError$2 = class TimeoutError extends Error {
  static name = "TimeoutError";
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
class NotStartedError extends Error {
  static name = "NotStartedError";
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
}
class DialError extends Error {
  static name = "DialError";
  constructor(message2 = "Dial error") {
    super(message2);
    this.name = "DialError";
  }
}
class ListenError extends Error {
  static name = "ListenError";
  constructor(message2 = "Listen error") {
    super(message2);
    this.name = "ListenError";
  }
}
class LimitedConnectionError extends Error {
  static name = "LimitedConnectionError";
  constructor(message2 = "Limited connection") {
    super(message2);
    this.name = "LimitedConnectionError";
  }
}
class TooManyInboundProtocolStreamsError extends Error {
  static name = "TooManyInboundProtocolStreamsError";
  constructor(message2 = "Too many inbound protocol streams") {
    super(message2);
    this.name = "TooManyInboundProtocolStreamsError";
  }
}
class TooManyOutboundProtocolStreamsError extends Error {
  static name = "TooManyOutboundProtocolStreamsError";
  constructor(message2 = "Too many outbound protocol streams") {
    super(message2);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
}
class UnsupportedKeyTypeError extends Error {
  static name = "UnsupportedKeyTypeError";
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
}
class StreamMessageEvent extends Event {
  data;
  constructor(data, eventInitDict) {
    super("message", eventInitDict);
    this.data = data;
  }
}
class StreamCloseEvent extends Event {
  error;
  local;
  constructor(local, error, eventInitDict) {
    super("close", eventInitDict);
    this.error = error;
    this.local = local;
  }
}
class StreamAbortEvent extends StreamCloseEvent {
  constructor(error, eventInitDict) {
    super(true, error, eventInitDict);
  }
}
class StreamResetEvent extends StreamCloseEvent {
  constructor(error, eventInitDict) {
    super(false, error, eventInitDict);
  }
}
const peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");
const peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return Boolean(other?.[peerIdSymbol]);
}
const peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");
const KEEP_ALIVE = "keep-alive";
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStart != null) {
      await s2.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.start();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStart != null) {
      await s2.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStop != null) {
      await s2.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.stop();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStop != null) {
      await s2.afterStop();
    }
  }));
}
const transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));
function setMaxListeners() {
}
class TypedEventEmitter extends EventTarget {
  #listeners = /* @__PURE__ */ new Map();
  constructor() {
    super();
  }
  listenerCount(type) {
    const listeners = this.#listeners.get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      list = [];
      this.#listeners.set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = this.#listeners.get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    this.#listeners.set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = this.#listeners.get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    this.#listeners.set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
}
const serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
const serviceDependencies = Symbol.for("@libp2p/service-dependencies");
function equals$2(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function fromString$1(str) {
  return new TextEncoder().encode(str);
}
function toString$2(b) {
  return new TextDecoder().decode(b);
}
function base$1(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode3(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i3 < length3) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      pbegin++;
    }
    var it2 = size2 - length3;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i3 < length3) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length3;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j2 = zeroes;
    while (it4 !== size2) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode3,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base$1;
var _brrp__multiformats_scope_baseX = src;
class Encoder {
  name;
  prefix;
  baseEncode;
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
let Decoder$1 = class Decoder {
  name;
  prefix;
  baseDecode;
  prefixCodePoint;
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$1(this, decoder);
  }
};
class ComposedDecoder {
  decoders;
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$1(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
function or$1(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
class Codec {
  name;
  prefix;
  baseEncode;
  baseDecode;
  encoder;
  decoder;
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder$1(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
function from$1({ name: name2, prefix, encode: encode3, decode: decode2 }) {
  return new Codec(name2, prefix, encode3, decode2);
}
function baseX({ name: name2, prefix, alphabet: alphabet2 }) {
  const { encode: encode3, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from$1({
    prefix,
    name: name2,
    encode: encode3,
    decode: (text) => coerce(decode2(text))
  });
}
function decode$6(string2, alphabetIdx, bitsPerChar, name2) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = alphabetIdx[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode$5(data, alphabet2, bitsPerChar) {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad2) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet2) {
  const alphabetIdx = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    alphabetIdx[alphabet2[i2]] = i2;
  }
  return alphabetIdx;
}
function rfc4648({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx(alphabet2);
  return from$1({
    prefix,
    name: name2,
    encode(input) {
      return encode$5(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$6(input, alphabetIdx, bitsPerChar, name2);
    }
  });
}
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
var encode_1 = encode$4;
var MSB$1 = 128, MSBALL = -128, INT = Math.pow(2, 31);
function encode$4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$4.bytes = offset - oldOffset + 1;
  return out;
}
var decode$5 = read$1;
var MSB$1$1 = 128, REST$1 = 127;
function read$1(buf, offset) {
  var res = 0, offset = offset || 0, shift2 = 0, counter = offset, b, l2 = buf.length;
  do {
    if (counter >= l2) {
      read$1.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift2 < 28 ? (b & REST$1) << shift2 : (b & REST$1) * Math.pow(2, shift2);
    shift2 += 7;
  } while (b >= MSB$1$1);
  read$1.bytes = counter - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length$1 = function(value2) {
  return value2 < N1$1 ? 1 : value2 < N2$1 ? 2 : value2 < N3$1 ? 3 : value2 < N4$1 ? 4 : value2 < N5$1 ? 5 : value2 < N6$1 ? 6 : value2 < N7$1 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode$5,
  encodingLength: length$1
};
var _brrp_varint = varint;
function decode$4(data, offset = 0) {
  const code2 = _brrp_varint.decode(data, offset);
  return [code2, _brrp_varint.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  _brrp_varint.encode(int, target, offset);
  return target;
}
function encodingLength$1(int) {
  return _brrp_varint.encodingLength(int);
}
function create(code2, digest10) {
  const size2 = digest10.byteLength;
  const sizeOffset = encodingLength$1(code2);
  const digestOffset = sizeOffset + encodingLength$1(size2);
  const bytes = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes, 0);
  encodeTo(size2, bytes, sizeOffset);
  bytes.set(digest10, digestOffset);
  return new Digest(code2, size2, digest10, bytes);
}
function decode$3(multihash) {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode$4(bytes);
  const [size2, digestOffset] = decode$4(bytes.subarray(sizeOffset));
  const digest10 = bytes.subarray(sizeOffset + digestOffset);
  if (digest10.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size2, digest10, bytes);
}
function equals$1(a2, b) {
  if (a2 === b) {
    return true;
  } else {
    const data = b;
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals$2(a2.bytes, data.bytes);
  }
}
class Digest {
  code;
  size;
  digest;
  bytes;
  /**
   * Creates a multihash digest.
   */
  constructor(code2, size2, digest10, bytes) {
    this.code = code2;
    this.size = size2;
    this.digest = digest10;
    this.bytes = bytes;
  }
}
function format(link, base3) {
  const { bytes, version: version3 } = link;
  switch (version3) {
    case 0:
      return toStringV0(bytes, baseCache(link), base3 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base3 ?? base32.encoder);
  }
}
const cache$1 = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache2 = cache$1.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache$1.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
class CID {
  code;
  version;
  multihash;
  bytes;
  "/";
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version3, code2, multihash, bytes) {
    this.code = code2;
    this.version = version3;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest10 } = this.multihash;
        const multihash = create(code2, digest10);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals$1(self2.multihash, unknown.multihash);
  }
  toString(base3) {
    return format(this, base3);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  [Symbol.toStringTag] = "CID";
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version3, code: code2, multihash, bytes } = value2;
      return new CID(version3, code2, multihash, bytes ?? encodeCID(version3, code2, multihash.bytes));
    } else if (value2[cidSymbol] === true) {
      const { version: version3, multihash, code: code2 } = value2;
      const digest10 = decode$3(multihash);
      return CID.create(version3, code2, digest10);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version3, code2, digest10) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest10.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version3) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version3, code2, digest10, digest10.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version3, code2, digest10.bytes);
        return new CID(version3, code2, digest10, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest10) {
    return CID.create(0, DAG_PB_CODE, digest10);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code2, digest10) {
    return CID.create(1, code2, digest10);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest10 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest10) : CID.createV1(specs.codec, digest10);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode$4(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version3 = next();
    let codec = DAG_PB_CODE;
    if (version3 === 18) {
      version3 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version3 !== 0 && version3 !== 1) {
      throw new RangeError(`Invalid CID version ${version3}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return { version: version3, codec, multihashCode, digestSize, multihashSize, size: size2 };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
}
function parseCIDtoBytes(source, base3) {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base3 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base3 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base3.decode(source)];
    }
  }
}
function toStringV0(bytes, cache2, base3) {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache2, base3) {
  const { prefix } = base3;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
function encodeCID(version3, code2, multihash) {
  const codeOffset = encodingLength$1(version3);
  const hashOffset = codeOffset + encodingLength$1(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version3, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const code$1 = 0;
const name$1 = "identity";
const encode$3 = coerce;
function digest(input, options) {
  if (options?.truncate != null && options.truncate !== input.byteLength) {
    if (options.truncate < 0 || options.truncate > input.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
    }
    input = input.subarray(0, options.truncate);
  }
  return create(code$1, encode$3(input));
}
const identity$1 = { code: code$1, name: name$1, encode: encode$3, digest };
function equals(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}
function alloc$1(size2 = 0) {
  return new Uint8Array(size2);
}
function allocUnsafe(size2 = 0) {
  return new Uint8Array(size2);
}
function asUint8Array(buf) {
  return buf;
}
function concat(arrays, length3) {
  if (length3 == null) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}
const symbol$1 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf of bufs) {
    const bufEnd = offset + buf.byteLength;
    if (index < bufEnd) {
      return {
        buf,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value2) {
  return Boolean(value2?.[symbol$1]);
}
class Uint8ArrayList {
  bufs;
  length;
  [symbol$1] = true;
  constructor(...data) {
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[Symbol.iterator]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length3 = 0;
    for (const buf of bufs) {
      if (buf instanceof Uint8Array) {
        length3 += buf.byteLength;
        this.bufs.push(buf);
      } else if (isUint8ArrayList(buf)) {
        length3 += buf.byteLength;
        this.bufs.push(...buf.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length3 = 0;
    for (const buf of bufs.reverse()) {
      if (buf instanceof Uint8Array) {
        length3 += buf.byteLength;
        this.bufs.unshift(buf);
      } else if (isUint8ArrayList(buf)) {
        length3 += buf.byteLength;
        this.bufs.unshift(...buf.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length3;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value2) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value2;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf.length; i2++) {
        this.set(offset + i2, buf[i2]);
      }
    } else if (isUint8ArrayList(buf)) {
      for (let i2 = 0; i2 < buf.length; i2++) {
        this.set(offset + i2, buf.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0) {
      return;
    }
    if (bytes === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes >= this.bufs[0].byteLength) {
        bytes -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes);
        this.length -= bytes;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length3);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length3);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length3 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length3;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        const start2 = beginInclusive - bufStart;
        bufs.push(buf.subarray(start2, start2 + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf);
          continue;
        }
        bufs.push(buf.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf);
          break;
        }
        bufs.push(buf.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c2 = 0; c2 < radix; c2++) {
      rightmostPositions[c2] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value2) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt8(0, value2);
    this.write(buf, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value2, littleEndian) {
    const buf = alloc$1(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt16(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value2, littleEndian) {
    const buf = alloc$1(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setInt32(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value2, littleEndian) {
    const buf = alloc$1(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigInt64(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint8(byteOffset) {
    const buf = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value2) {
    const buf = allocUnsafe(1);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint8(0, value2);
    this.write(buf, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value2, littleEndian) {
    const buf = alloc$1(2);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint16(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value2, littleEndian) {
    const buf = alloc$1(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setUint32(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value2, littleEndian) {
    const buf = alloc$1(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setBigUint64(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value2, littleEndian) {
    const buf = alloc$1(4);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat32(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value2, littleEndian) {
    const buf = alloc$1(8);
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    view.setFloat64(0, value2, littleEndian);
    this.write(buf, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length3) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length3 == null) {
      length3 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length3;
    return list;
  }
}
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  const codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c2}`);
  }
  p2[codePoint] = i2;
  return p2;
}, []);
function encode$2(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$2(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$1({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode$2,
  decode: decode$2
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const identity = from$1({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$2(buf),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const DEFAULT_MIN_DIGEST_LENGTH = 20;
function from({ name: name2, code: code2, encode: encode3, minDigestLength, maxDigestLength }) {
  return new Hasher(name2, code2, encode3, minDigestLength, maxDigestLength);
}
class Hasher {
  name;
  code;
  encode;
  minDigestLength;
  maxDigestLength;
  constructor(name2, code2, encode3, minDigestLength, maxDigestLength) {
    this.name = name2;
    this.code = code2;
    this.encode = encode3;
    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
    this.maxDigestLength = maxDigestLength;
  }
  digest(input, options) {
    if (options?.truncate != null) {
      if (options.truncate < this.minDigestLength) {
        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
      }
      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
      }
    }
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      if (result instanceof Uint8Array) {
        return createDigest(result, this.code, options?.truncate);
      }
      return result.then((digest10) => createDigest(digest10, this.code, options?.truncate));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
function createDigest(digest10, code2, truncate) {
  if (truncate != null && truncate !== digest10.byteLength) {
    if (truncate > digest10.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest10.byteLength}`);
    }
    digest10 = digest10.subarray(0, truncate);
  }
  return create(code2, digest10);
}
function sha$1(name2) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
}
const sha256$2 = from({
  name: "sha2-256",
  code: 18,
  encode: sha$1("SHA-256")
});
const bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32$1, ...base36$1, ...base58, ...base64$1, ...base256emoji$1 };
function createCodec$1(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
const string = createCodec$1("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec$1("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string2 += String.fromCharCode(buf[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString$1(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.encoder.encode(array).substring(1);
}
const TAG_MASK = parseInt("11111", 2);
const LONG_LENGTH_MASK = parseInt("10000000", 2);
const LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
const decoders$1 = {
  0: readSequence,
  1: readSequence,
  2: readInteger,
  3: readBitString,
  4: readOctetString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf, context = { offset: 0 }) {
  const tag = buf[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders$1[tag] != null) {
    return decoders$1[tag](buf, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf, context) {
  let length3 = 0;
  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i2 = 0; i2 < count; i2++, context.offset++) {
      str += buf[context.offset].toString(16).padStart(2, "0");
    }
    length3 = parseInt(str, 16);
  } else {
    length3 = buf[context.offset];
    context.offset++;
  }
  return length3;
}
function readSequence(buf, context) {
  readLength(buf, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf.byteLength) {
      break;
    }
    const result = decodeDer(buf, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf, context) {
  const length3 = readLength(buf, context);
  const start2 = context.offset;
  const end = context.offset + length3;
  const vals = [];
  for (let i2 = start2; i2 < end; i2++) {
    if (i2 === start2 && buf[i2] === 0) {
      continue;
    }
    vals.push(buf[i2]);
  }
  context.offset += length3;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf, context) {
  const count = readLength(buf, context);
  const finalOffset = context.offset + count;
  const byte = buf[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num = [];
  while (context.offset < finalOffset) {
    const byte2 = buf[context.offset];
    context.offset++;
    num.push(byte2 & 127);
    if (byte2 < 128) {
      num.reverse();
      let val = 0;
      for (let i2 = 0; i2 < num.length; i2++) {
        val += num[i2] << i2 * 7;
      }
      oid += `.${val}`;
      num = [];
    }
  }
  return oid;
}
function readNull(buf, context) {
  context.offset++;
  return null;
}
function readBitString(buf, context) {
  const length3 = readLength(buf, context);
  const unusedBits = buf[context.offset];
  context.offset++;
  const bytes = buf.subarray(context.offset, context.offset + length3 - 1);
  context.offset += length3;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString(buf, context) {
  const length3 = readLength(buf, context);
  const bytes = buf.subarray(context.offset, context.offset + length3);
  context.offset += length3;
  return bytes;
}
function encodeNumber(value2) {
  let number = value2.toString(16);
  if (number.length % 2 === 1) {
    number = "0" + number;
  }
  const array = new Uint8ArrayList();
  for (let i2 = 0; i2 < number.length; i2 += 2) {
    array.append(Uint8Array.from([parseInt(`${number[i2]}${number[i2 + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length3 = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length3.byteLength | LONG_LENGTH_MASK
  ]), length3);
}
function encodeInteger(value2) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive2 = (value2.subarray()[0] & mask) === mask;
  if (positive2) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value2);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value2) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value2);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeSequence(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf of values) {
    output.append(buf);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
}
async function hashAndVerify$3(key2, sig, msg, options) {
  const publicKey = await crypto.subtle.importKey("jwk", key2, {
    name: "ECDSA",
    namedCurve: key2.crv ?? "P-256"
  }, false, ["verify"]);
  options?.signal?.throwIfAborted();
  const result = await crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey, sig, msg.subarray());
  options?.signal?.throwIfAborted();
  return result;
}
const OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
const OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
const OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
const P_256_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
const P_384_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
const P_521_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
const P_256_KEY_LENGTH = 32;
const P_384_KEY_LENGTH = 48;
const P_521_KEY_LENGTH = 66;
function unmarshalECDSAPublicKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPublicKey(message2);
}
function pkiMessageToECDSAPublicKey(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
    x = toString$1(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString$1(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_256_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
    x = toString$1(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString$1(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_384_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
    x = toString$1(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString$1(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_521_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError$1(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function publicKeyToPKIMessage(publicKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeSequence([
      getOID(publicKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString(publicKey.x ?? "", "base64url"), fromString(publicKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID(curve2) {
  if (curve2 === "P-256") {
    return OID_256;
  }
  if (curve2 === "P-384") {
    return OID_384;
  }
  if (curve2 === "P-521") {
    return OID_521;
  }
  throw new InvalidParametersError$1(`Invalid curve ${curve2}`);
}
class ECDSAPublicKey {
  type = "ECDSA";
  jwk;
  _raw;
  constructor(jwk) {
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity$1.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key2) {
    if (key2 == null || !(key2.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key2.raw);
  }
  async verify(data, sig, options) {
    return hashAndVerify$3(this.jwk, sig, data, options);
  }
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes$1(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber$1(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes$1(value2, length3, title = "") {
  const bytes = isBytes$1(value2);
  const len = value2?.length;
  const needsLen = length3 !== void 0;
  if (!bytes || needsLen && len !== length3) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length3}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber$1(h.outputLen);
  anumber$1(h.blockLen);
}
function aexists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput$1(out, instance) {
  abytes$1(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function clean$1(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView$1(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift2) {
  return word << 32 - shift2 | word >>> shift2;
}
const hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex$1(bytes) {
  abytes$1(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes[bytes[i2]];
  }
  return hex;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes$1(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes$1(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes$1(bytesLength = 32) {
  const cr = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof cr?.getRandomValues !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
const oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});
function Chi(a2, b, c2) {
  return a2 & b ^ ~a2 & c2;
}
function Maj(a2, b, c2) {
  return a2 & b ^ a2 & c2 ^ b & c2;
}
class HashMD {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(blockLen, outputLen, padOffset, isLE2) {
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView$1(this.buffer);
  }
  update(data) {
    aexists$1(this);
    abytes$1(data);
    const { view, buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView$1(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists$1(this);
    aoutput$1(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    clean$1(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer[i2] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView$1(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to ||= new this.constructor();
    to.set(...this.get());
    const { blockLen, buffer, length: length3, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length3;
    to.pos = pos;
    if (length3 % blockLen)
      to.buffer.set(buffer);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l2];
  }
  return [Ah, Al];
}
const shrSH = (h, _l, s2) => h >>> s2;
const shrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
const rotrSH = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
const rotrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
const rotrBH = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
const rotrBL = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA2_32B extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean$1(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean$1(this.buffer);
  }
}
class _SHA256 extends SHA2_32B {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = SHA256_IV[0] | 0;
  B = SHA256_IV[1] | 0;
  C = SHA256_IV[2] | 0;
  D = SHA256_IV[3] | 0;
  E = SHA256_IV[4] | 0;
  F = SHA256_IV[5] | 0;
  G = SHA256_IV[6] | 0;
  H = SHA256_IV[7] | 0;
  constructor() {
    super(32);
  }
}
const K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA2_64B extends HashMD {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean$1(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean$1(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class _SHA512 extends SHA2_64B {
  Ah = SHA512_IV[0] | 0;
  Al = SHA512_IV[1] | 0;
  Bh = SHA512_IV[2] | 0;
  Bl = SHA512_IV[3] | 0;
  Ch = SHA512_IV[4] | 0;
  Cl = SHA512_IV[5] | 0;
  Dh = SHA512_IV[6] | 0;
  Dl = SHA512_IV[7] | 0;
  Eh = SHA512_IV[8] | 0;
  El = SHA512_IV[9] | 0;
  Fh = SHA512_IV[10] | 0;
  Fl = SHA512_IV[11] | 0;
  Gh = SHA512_IV[12] | 0;
  Gl = SHA512_IV[13] | 0;
  Hh = SHA512_IV[14] | 0;
  Hl = SHA512_IV[15] | 0;
  constructor() {
    super(64);
  }
}
const sha256$1 = /* @__PURE__ */ createHasher(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);
const sha512$1 = /* @__PURE__ */ createHasher(
  () => new _SHA512(),
  /* @__PURE__ */ oidNist(3)
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = /* @__PURE__ */ BigInt(0);
const _1n$6 = /* @__PURE__ */ BigInt(1);
function abool$1(value2, title = "") {
  if (typeof value2 !== "boolean") {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected boolean, got type=" + typeof value2);
  }
  return value2;
}
function abignumber(n2) {
  if (typeof n2 === "bigint") {
    if (!isPosBig(n2))
      throw new Error("positive bigint expected, got " + n2);
  } else
    anumber$1(n2);
  return n2;
}
function numberToHexUnpadded(num) {
  const hex = abignumber(num).toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n$5 : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex$1(bytes));
}
function bytesToNumberLE(bytes) {
  return hexToNumber(bytesToHex$1(copyBytes$1(abytes$1(bytes)).reverse()));
}
function numberToBytesBE(n2, len) {
  anumber$1(len);
  n2 = abignumber(n2);
  const res = hexToBytes$1(n2.toString(16).padStart(len * 2, "0"));
  if (res.length !== len)
    throw new Error("number too large");
  return res;
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function copyBytes$1(bytes) {
  return Uint8Array.from(bytes);
}
const isPosBig = (n2) => typeof n2 === "bigint" && _0n$5 <= n2;
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n$5; n2 >>= _1n$6, len += 1)
    ;
  return len;
}
const bitMask = (n2) => (_1n$6 << BigInt(n2)) - _1n$6;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  anumber$1(hashLen, "hashLen");
  anumber$1(qByteLen, "qByteLen");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const NULL = Uint8Array.of();
  const byte0 = Uint8Array.of(0);
  const byte1 = Uint8Array.of(1);
  const _maxDrbgIters = 1e3;
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
  const reseed2 = (seed = NULL) => {
    k = h(byte0, seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(byte1, seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= _maxDrbgIters)
      throw new Error("drbg: tried max amount of iterations");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed2(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed2();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, fields = {}, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  const iter = (f2, isOpt) => Object.entries(f2).forEach(([k, v]) => checkField(k, v, isOpt));
  iter(fields, false);
  iter(optFields, true);
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = /* @__PURE__ */ BigInt(0), _1n$5 = /* @__PURE__ */ BigInt(1), _2n$5 = /* @__PURE__ */ BigInt(2);
const _3n$2 = /* @__PURE__ */ BigInt(3), _4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5);
const _7n = /* @__PURE__ */ BigInt(7), _8n$2 = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);
const _16n = /* @__PURE__ */ BigInt(16);
function mod(a2, b) {
  const result = a2 % b;
  return result >= _0n$4 ? result : b + result;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n$4) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n$4)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n$4)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a2 = mod(number, modulo);
  let b = modulo;
  let x = _0n$4, u = _1n$5;
  while (a2 !== _0n$4) {
    const q = b / a2;
    const r2 = b % a2;
    const m2 = x - u * q;
    b = a2, a2 = r2, x = u, u = m2;
  }
  const gcd = b;
  if (gcd !== _1n$5)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp, root, n2) {
  if (!Fp.eql(Fp.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n2) {
  const p1div4 = (Fp.ORDER + _1n$5) / _4n$1;
  const root = Fp.pow(n2, p1div4);
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt5mod8(Fp, n2) {
  const p5div8 = (Fp.ORDER - _5n$1) / _8n$2;
  const n22 = Fp.mul(n2, _2n$5);
  const v = Fp.pow(n22, p5div8);
  const nv = Fp.mul(n2, v);
  const i2 = Fp.mul(Fp.mul(nv, _2n$5), v);
  const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
  assertIsSquare(Fp, root, n2);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp, n2) => {
    let tv1 = Fp.pow(n2, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n2);
    const e2 = Fp.eql(Fp.sqr(tv3), n2);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e2);
    const e3 = Fp.eql(Fp.sqr(tv2), n2);
    const root = Fp.cmov(tv1, tv2, e3);
    assertIsSquare(Fp, root, n2);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n$2)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n$5;
  let S2 = 0;
  while (Q % _2n$5 === _0n$4) {
    Q /= _2n$5;
    S2++;
  }
  let Z = _2n$5;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n$5) / _2n$5;
  return function tonelliSlow(Fp, n2) {
    if (Fp.is0(n2))
      return n2;
    if (FpLegendre(Fp, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S2;
    let c2 = Fp.mul(Fp.ONE, cc);
    let t2 = Fp.pow(n2, Q);
    let R2 = Fp.pow(n2, Q1div2);
    while (!Fp.eql(t2, Fp.ONE)) {
      if (Fp.is0(t2))
        return Fp.ZERO;
      let i2 = 1;
      let t_tmp = Fp.sqr(t2);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i2++;
        t_tmp = Fp.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n$5 << BigInt(M - i2 - 1);
      const b = Fp.pow(c2, exponent);
      M = i2;
      c2 = Fp.sqr(b);
      t2 = Fp.mul(t2, c2);
      R2 = Fp.mul(R2, b);
    }
    return R2;
  };
}
function FpSqrt(P) {
  if (P % _4n$1 === _3n$2)
    return sqrt3mod4;
  if (P % _8n$2 === _5n$1)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$5) === _1n$5;
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  validateObject(field, opts);
  return field;
}
function FpPow(Fp, num, power) {
  if (power < _0n$4)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n$4)
    return Fp.ONE;
  if (power === _1n$5)
    return num;
  let p2 = Fp.ONE;
  let d2 = num;
  while (power > _0n$4) {
    if (power & _1n$5)
      p2 = Fp.mul(p2, d2);
    d2 = Fp.sqr(d2);
    power >>= _1n$5;
  }
  return p2;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i2) => {
    if (Fp.is0(num))
      return acc;
    inverted[i2] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i2) => {
    if (Fp.is0(num))
      return acc;
    inverted[i2] = Fp.mul(acc, inverted[i2]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n2) {
  const p1mod2 = (Fp.ORDER - _1n$5) / _2n$5;
  const powered = Fp.pow(n2, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero3 = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero3 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero3 ? 0 : -1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber$1(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
class _Field {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = _0n$4;
  ONE = _1n$5;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(ORDER, opts = {}) {
    if (ORDER <= _0n$4)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    this.isLE = false;
    if (opts != null && typeof opts === "object") {
      if (typeof opts.BITS === "number")
        _nbitLength = opts.BITS;
      if (typeof opts.sqrt === "function")
        this.sqrt = opts.sqrt;
      if (typeof opts.isLE === "boolean")
        this.isLE = opts.isLE;
      if (opts.allowedLengths)
        this._lengths = opts.allowedLengths?.slice();
      if (typeof opts.modFromBytes === "boolean")
        this._mod = opts.modFromBytes;
    }
    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
    if (nByteLength > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = ORDER;
    this.BITS = nBitLength;
    this.BYTES = nByteLength;
    this._sqrt = void 0;
    Object.preventExtensions(this);
  }
  create(num) {
    return mod(num, this.ORDER);
  }
  isValid(num) {
    if (typeof num !== "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof num);
    return _0n$4 <= num && num < this.ORDER;
  }
  is0(num) {
    return num === _0n$4;
  }
  // is valid and invertible
  isValidNot0(num) {
    return !this.is0(num) && this.isValid(num);
  }
  isOdd(num) {
    return (num & _1n$5) === _1n$5;
  }
  neg(num) {
    return mod(-num, this.ORDER);
  }
  eql(lhs, rhs) {
    return lhs === rhs;
  }
  sqr(num) {
    return mod(num * num, this.ORDER);
  }
  add(lhs, rhs) {
    return mod(lhs + rhs, this.ORDER);
  }
  sub(lhs, rhs) {
    return mod(lhs - rhs, this.ORDER);
  }
  mul(lhs, rhs) {
    return mod(lhs * rhs, this.ORDER);
  }
  pow(num, power) {
    return FpPow(this, num, power);
  }
  div(lhs, rhs) {
    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(num) {
    return num * num;
  }
  addN(lhs, rhs) {
    return lhs + rhs;
  }
  subN(lhs, rhs) {
    return lhs - rhs;
  }
  mulN(lhs, rhs) {
    return lhs * rhs;
  }
  inv(num) {
    return invert(num, this.ORDER);
  }
  sqrt(num) {
    if (!this._sqrt)
      this._sqrt = FpSqrt(this.ORDER);
    return this._sqrt(this, num);
  }
  toBytes(num) {
    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);
  }
  fromBytes(bytes, skipValidation = false) {
    abytes$1(bytes);
    const { _lengths: allowedLengths, BYTES, isLE: isLE2, ORDER, _mod: modFromBytes } = this;
    if (allowedLengths) {
      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
        throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
      }
      const padded = new Uint8Array(BYTES);
      padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);
      bytes = padded;
    }
    if (bytes.length !== BYTES)
      throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
    let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    if (modFromBytes)
      scalar = mod(scalar, ORDER);
    if (!skipValidation) {
      if (!this.isValid(scalar))
        throw new Error("invalid field element: outside of range 0..ORDER");
    }
    return scalar;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(lst) {
    return FpInvertBatch(this, lst);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(a2, b, condition) {
    return condition ? b : a2;
  }
}
function Field(ORDER, opts = {}) {
  return new _Field(ORDER, opts);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length3 = getFieldBytesLength(fieldOrder);
  return length3 + Math.ceil(length3 / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  abytes$1(key2);
  const len = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE2 ? bytesToNumberLE(key2) : bytesToNumberBE(key2);
  const reduced = mod(num, fieldOrder - _1n$5) + _1n$5;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0);
const _1n$4 = /* @__PURE__ */ BigInt(1);
function negateCt(condition, item) {
  const neg4 = item.negate();
  return condition ? neg4 : item;
}
function normalizeZ(c2, points) {
  const invertedZs = FpInvertBatch(c2.Fp, points.map((p2) => p2.Z));
  return points.map((p2, i2) => c2.fromAffine(p2.toAffine(invertedZs[i2])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n$4;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
const pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n2) {
  if (n2 !== _0n$3)
    throw new Error("invalid wNAF");
}
class wNAF {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(Point2, bits) {
    this.BASE = Point2.BASE;
    this.ZERO = Point2.ZERO;
    this.Fn = Point2.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p2 = this.ZERO) {
    let d2 = elm;
    while (n2 > _0n$3) {
      if (n2 & _1n$4)
        p2 = p2.add(d2);
      d2 = d2.double();
      n2 >>= _1n$4;
    }
    return p2;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
   * - 𝑊 is the window size
   * - 𝑛 is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point5, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p2 = point5;
    let base3 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p2;
      points.push(base3);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base3 = base3.add(p2);
        points.push(base3);
      }
      p2 = base3.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p2 = this.ZERO;
    let f2 = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p2 = p2.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p: p2, f: f2 };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n$3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W, point5, transform) {
    let comp = pointPrecomputes.get(point5);
    if (!comp) {
      comp = this.precomputeWindow(point5, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point5, comp);
      }
    }
    return comp;
  }
  cached(point5, scalar, transform) {
    const W = getW(point5);
    return this.wNAF(W, this.getPrecomputes(W, point5, transform), scalar);
  }
  unsafe(point5, scalar, transform, prev) {
    const W = getW(point5);
    if (W === 1)
      return this._unsafeLadder(point5, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point5, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
}
function mulEndoUnsafe(Point2, point5, k1, k2) {
  let acc = point5;
  let p1 = Point2.ZERO;
  let p2 = Point2.ZERO;
  while (k1 > _0n$3 || k2 > _0n$3) {
    if (k1 & _1n$4)
      p1 = p1.add(acc);
    if (k2 & _1n$4)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n$4;
    k2 >>= _1n$4;
  }
  return { p1, p2 };
}
function createField(order, field, isLE2) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE2 });
  }
}
function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p2 of ["p", "n", "h"]) {
    const val = CURVE[p2];
    if (!(typeof val === "bigint" && val > _0n$3))
      throw new Error(`CURVE.${p2} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p2 of params) {
    if (!Fp.isValid(CURVE[p2]))
      throw new Error(`CURVE.${p2} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}
function createKeygen(randomSecretKey, getPublicKey) {
  return function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$4 = BigInt(2), _8n$1 = BigInt(8);
function isEdValidXY(Fp, CURVE, x, y) {
  const x2 = Fp.sqr(x);
  const y2 = Fp.sqr(y);
  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
  return Fp.eql(left, right);
}
function edwards$1(params, extraOpts = {}) {
  const validated = createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor } = CURVE;
  validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n$4 << BigInt(Fn.BYTES * 8) - _1n$3;
  const modP = (n2) => Fp.create(n2);
  const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
    } catch (e2) {
      return { isValid: false, value: _0n$2 };
    }
  });
  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n$3 : _0n$2;
    aInRange("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aedpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("EdwardsPoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n$1 : Fp.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: _0n$2, y: _1n$3 };
    if (zz !== _1n$3)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    const { a: a2, d: d2 } = CURVE;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p2;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a2);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point2 {
    // base / generator point
    static BASE = new Point2(CURVE.Gx, CURVE.Gy, _1n$3, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    static ZERO = new Point2(_0n$2, _1n$3, _1n$3, _0n$2);
    // 0, 1, 1, 0
    // math field
    static Fp = Fp;
    // scalar field
    static Fn = Fn;
    X;
    Y;
    Z;
    T;
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    static fromAffine(p2) {
      if (p2 instanceof Point2)
        throw new Error("extended point not allowed");
      const { x, y } = p2 || {};
      acoord("x", x);
      acoord("y", y);
      return new Point2(x, y, _1n$3, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes, zip215 = false) {
      const len = Fp.BYTES;
      const { a: a2, d: d2 } = CURVE;
      bytes = copyBytes$1(abytes$1(bytes, len, "point"));
      abool$1(zip215, "zip215");
      const normed = copyBytes$1(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & -129;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp.ORDER;
      aInRange("point.y", y, _0n$2, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n$3);
      const v = modP(d2 * y2 - a2);
      let { isValid: isValid2, value: x } = uvRatio2(u, v);
      if (!isValid2)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n$3) === _1n$3;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n$2 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point2.fromAffine({ x, y });
    }
    static fromHex(hex, zip215 = false) {
      return Point2.fromBytes(hexToBytes$1(hex), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n$4);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aedpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    negate() {
      return new Point2(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n$4 * modP(Z1 * Z1));
      const D = modP(a2 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aedpoint(other);
      const { a: a2, d: d2 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a2 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point2(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p: p2, f: f2 } = wnaf.cached(this, scalar, (p3) => normalizeZ(Point2, p3));
      return normalizeZ(Point2, [p2, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point2.ZERO) {
      if (!Fn.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n$2)
        return Point2.ZERO;
      if (this.is0() || scalar === _1n$3)
        return this;
      return wnaf.unsafe(this, scalar, (p2) => normalizeZ(Point2, p2), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n$3)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n$3 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex$1(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const wnaf = new wNAF(Point2, Fn.BITS);
  Point2.BASE.precompute(8);
  return Point2;
}
function eddsa$1(Point2, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp, Fn } = Point2;
  const randomBytes2 = eddsaOpts.randomBytes || randomBytes$1;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool$1(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash3) {
    return Fn.create(bytesToNumberLE(hash3));
  }
  function getPrivateScalar(key2) {
    const len = lengths.secretKey;
    abytes$1(key2, lengths.secretKey, "secretKey");
    const hashed = abytes$1(cHash(key2), 2 * len, "hashedSecretKey");
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point5 = BASE.multiply(scalar);
    const pointBytes = point5.toBytes();
    return { head, prefix, scalar, point: point5, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, abytes$1(context, void 0, "context"), !!prehash)));
  }
  function sign5(msg, secretKey, options = {}) {
    msg = abytes$1(msg, void 0, "message");
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r2 = hashDomainToScalar(options.context, prefix, msg);
    const R2 = BASE.multiply(r2).toBytes();
    const k = hashDomainToScalar(options.context, R2, pointBytes, msg);
    const s2 = Fn.create(r2 + k * scalar);
    if (!Fn.isValid(s2))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R2, Fn.toBytes(s2));
    return abytes$1(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify5(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = lengths.signature;
    sig = abytes$1(sig, len, "signature");
    msg = abytes$1(msg, void 0, "message");
    publicKey = abytes$1(publicKey, lengths.publicKey, "publicKey");
    if (zip215 !== void 0)
      abool$1(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r2 = sig.subarray(0, mid);
    const s2 = bytesToNumberLE(sig.subarray(mid, len));
    let A, R2, SB;
    try {
      A = Point2.fromBytes(publicKey, zip215);
      R2 = Point2.fromBytes(r2, zip215);
      SB = BASE.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R2.toBytes(), A.toBytes(), msg);
    const RkA = R2.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed = randomBytes2(lengths.seed)) {
    return abytes$1(seed, lengths.seed, "seed");
  }
  function isValidSecretKey(key2) {
    return isBytes$1(key2) && key2.length === Fn.BYTES;
  }
  function isValidPublicKey(key2, zip215) {
    try {
      return !!Point2.fromBytes(key2, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils2 = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey) {
      const { y } = Point2.fromBytes(publicKey);
      const size2 = lengths.publicKey;
      const is25519 = size2 === 32;
      if (!is25519 && size2 !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp.div(_1n$3 + y, _1n$3 - y) : Fp.div(y - _1n$3, y + _1n$3);
      return Fp.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size2 = lengths.secretKey;
      abytes$1(secretKey, size2);
      const hashed = cHash(secretKey.subarray(0, size2));
      return adjustScalarBytes2(hashed).subarray(0, size2);
    }
  };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getPublicKey,
    sign: sign5,
    verify: verify5,
    utils: utils2,
    Point: Point2,
    lengths
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$2 = BigInt(1);
const _2n$3 = BigInt(2);
function validateOpts(curve2) {
  validateObject(curve2, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve2 });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand3 } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand3 || randomBytes$1;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n$3 ** BigInt(254) : _2n$3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n$3 ** BigInt(251) - _1n$2 : BigInt(4) * _2n$3 ** BigInt(445) - _1n$2;
  const maxScalar = minScalar + maxAdded + _1n$2;
  const modP = (n2) => mod(n2, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = copyBytes$1(abytes$1(u, fieldLen, "uCoordinate"));
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(copyBytes$1(abytes$1(scalar, fieldLen, "scalar"))));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n$1)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  const getPublicKey = scalarMultBase;
  const getSharedSecret = scalarMult;
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n$1, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n$2;
    let z_2 = _0n$1;
    let x_3 = u;
    let z_3 = _1n$2;
    let swap = _0n$1;
    for (let t2 = BigInt(montgomeryBits - 1); t2 >= _0n$1; t2--) {
      const k_t = k >> t2 & _1n$2;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen,
    publicKey: fieldLen,
    seed: fieldLen
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
    abytes$1(seed, lengths.seed, "seed");
    return seed;
  };
  const utils2 = { randomSecretKey };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getSharedSecret,
    getPublicKey,
    scalarMult,
    scalarMultBase,
    utils: utils2,
    GuBytes: GuBytes.slice(),
    lengths
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _1n$1 = BigInt(1), _2n$2 = BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
const _5n = BigInt(5), _8n = BigInt(8);
const ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
const ed25519_CURVE = /* @__PURE__ */ (() => ({
  p: ed25519_CURVE_p,
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n$2, P) * b2 % P;
  const b5 = pow2(b4, _1n$1, P) * x % P;
  const b10 = pow2(b5, _5n, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n$2, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u, v) {
  const P = ed25519_CURVE_p;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
const ed25519_Point = /* @__PURE__ */ edwards$1(ed25519_CURVE, { uvRatio });
function ed(opts) {
  return eddsa$1(ed25519_Point, sha512$1, Object.assign({ adjustScalarBytes }, opts));
}
const ed25519 = /* @__PURE__ */ ed({});
const x25519 = /* @__PURE__ */ (() => {
  const P = ed25519_CURVE_p;
  return montgomery({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n$1, P) * b2, P);
    },
    adjustScalarBytes
  });
})();
class VerificationError extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
}
class WebCryptoMissingError extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
}
const webcrypto = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto?.subtle == null) {
      throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};
const PUBLIC_KEY_BYTE_LENGTH = 32;
const PRIVATE_KEY_BYTE_LENGTH = 64;
const KEYS_BYTE_LENGTH = 32;
let ed25519Supported;
const webCryptoEd25519SupportedPromise = (async () => {
  try {
    await webcrypto.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
    return true;
  } catch {
    return false;
  }
})();
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomSecretKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
async function hashAndSignWebCrypto(privateKey, msg) {
  let privateKeyRaw;
  if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
    privateKeyRaw = privateKey.subarray(0, 32);
  } else {
    privateKeyRaw = privateKey;
  }
  const jwk = {
    crv: "Ed25519",
    kty: "OKP",
    x: toString$1(privateKey.subarray(32), "base64url"),
    d: toString$1(privateKeyRaw, "base64url"),
    ext: true,
    key_ops: ["sign"]
  };
  const key2 = await webcrypto.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
  const sig = await webcrypto.get().subtle.sign({ name: "Ed25519" }, key2, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
function hashAndSignNoble(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
async function hashAndSign(privateKey, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndSignWebCrypto(privateKey, msg);
  }
  return hashAndSignNoble(privateKey, msg);
}
async function hashAndVerifyWebCrypto(publicKey, sig, msg) {
  if (publicKey.buffer instanceof ArrayBuffer) {
    const key2 = await webcrypto.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
    const isValid2 = await webcrypto.get().subtle.verify({ name: "Ed25519" }, key2, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    return isValid2;
  }
  throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
}
function hashAndVerifyNoble(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
async function hashAndVerify$2(publicKey, sig, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndVerifyWebCrypto(publicKey, sig, msg);
  }
  return hashAndVerifyNoble(publicKey, sig, msg);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey[i2];
  }
  return privateKey;
}
function isPromise$1(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
class Ed25519PublicKey {
  type = "Ed25519";
  raw;
  constructor(key2) {
    this.raw = ensureEd25519Key(key2, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity$1.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key2) {
    if (key2 == null || !(key2.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key2.raw);
  }
  verify(data, sig, options) {
    options?.signal?.throwIfAborted();
    const result = hashAndVerify$2(this.raw, sig, data);
    if (isPromise$1(result)) {
      return result.then((res) => {
        options?.signal?.throwIfAborted();
        return res;
      });
    }
    return result;
  }
}
class Ed25519PrivateKey {
  type = "Ed25519";
  raw;
  publicKey;
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key2, publicKey) {
    this.raw = ensureEd25519Key(key2, PRIVATE_KEY_BYTE_LENGTH);
    this.publicKey = new Ed25519PublicKey(publicKey);
  }
  equals(key2) {
    if (key2 == null || !(key2.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key2.raw);
  }
  sign(message2, options) {
    options?.signal?.throwIfAborted();
    const sig = hashAndSign(this.raw, message2);
    if (isPromise$1(sig)) {
      return sig.then((res) => {
        options?.signal?.throwIfAborted();
        return res;
      });
    }
    options?.signal?.throwIfAborted();
    return sig;
  }
}
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateEd25519KeyPair() {
  const { privateKey, publicKey } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureEd25519Key(key2, length3) {
  key2 = Uint8Array.from(key2 ?? []);
  if (key2.length !== length3) {
    throw new InvalidParametersError$1(`Key must be a Uint8Array of length ${length3}, got ${key2.length}`);
  }
  return key2;
}
const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
const MSB = 128;
const REST = 127;
function encodingLength(value2) {
  if (value2 < N1) {
    return 1;
  }
  if (value2 < N2) {
    return 2;
  }
  if (value2 < N3) {
    return 3;
  }
  if (value2 < N4) {
    return 4;
  }
  if (value2 < N5) {
    return 5;
  }
  if (value2 < N6) {
    return 6;
  }
  if (value2 < N7) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value2, buf, offset = 0) {
  switch (encodingLength(value2)) {
    case 8: {
      buf[offset++] = value2 & 255 | MSB;
      value2 /= 128;
    }
    case 7: {
      buf[offset++] = value2 & 255 | MSB;
      value2 /= 128;
    }
    case 6: {
      buf[offset++] = value2 & 255 | MSB;
      value2 /= 128;
    }
    case 5: {
      buf[offset++] = value2 & 255 | MSB;
      value2 /= 128;
    }
    case 4: {
      buf[offset++] = value2 & 255 | MSB;
      value2 >>>= 7;
    }
    case 3: {
      buf[offset++] = value2 & 255 | MSB;
      value2 >>>= 7;
    }
    case 2: {
      buf[offset++] = value2 & 255 | MSB;
      value2 >>>= 7;
    }
    case 1: {
      buf[offset++] = value2 & 255;
      value2 >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf;
}
function encodeUint8ArrayList(value2, buf, offset = 0) {
  switch (encodingLength(value2)) {
    case 8: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 /= 128;
    }
    case 7: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 /= 128;
    }
    case 6: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 /= 128;
    }
    case 5: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 /= 128;
    }
    case 4: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 >>>= 7;
    }
    case 3: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 >>>= 7;
    }
    case 2: {
      buf.set(offset++, value2 & 255 | MSB);
      value2 >>>= 7;
    }
    case 1: {
      buf.set(offset++, value2 & 255);
      value2 >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf;
}
function decodeUint8Array(buf, offset) {
  let b = buf[offset];
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 1];
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 2];
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 3];
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 4];
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 5];
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 6];
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf[offset + 7];
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf, offset) {
  let b = buf.get(offset);
  let res = 0;
  res += b & REST;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 1);
  res += (b & REST) << 7;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 2);
  res += (b & REST) << 14;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 3);
  res += (b & REST) << 21;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 4);
  res += (b & REST) * N4;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 5);
  res += (b & REST) * N5;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 6);
  res += (b & REST) * N6;
  if (b < MSB) {
    return res;
  }
  b = buf.get(offset + 7);
  res += (b & REST) * N7;
  if (b < MSB) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function encode$1(value2, buf, offset = 0) {
  if (buf == null) {
    buf = allocUnsafe(encodingLength(value2));
  }
  if (buf instanceof Uint8Array) {
    return encodeUint8Array(value2, buf, offset);
  } else {
    return encodeUint8ArrayList(value2, buf, offset);
  }
}
function decode$1(buf, offset = 0) {
  if (buf instanceof Uint8Array) {
    return decodeUint8Array(buf, offset);
  } else {
    return decodeUint8ArrayList(buf, offset);
  }
}
const f32 = new Float32Array([-0]);
const f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf, pos) {
  f32[0] = val;
  buf[pos] = f8b[0];
  buf[pos + 1] = f8b[1];
  buf[pos + 2] = f8b[2];
  buf[pos + 3] = f8b[3];
}
function readFloatLE(buf, pos) {
  f8b[0] = buf[pos];
  f8b[1] = buf[pos + 1];
  f8b[2] = buf[pos + 2];
  f8b[3] = buf[pos + 3];
  return f32[0];
}
const f64 = new Float64Array([-0]);
const d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf, pos) {
  f64[0] = val;
  buf[pos] = d8b[0];
  buf[pos + 1] = d8b[1];
  buf[pos + 2] = d8b[2];
  buf[pos + 3] = d8b[3];
  buf[pos + 4] = d8b[4];
  buf[pos + 5] = d8b[5];
  buf[pos + 6] = d8b[6];
  buf[pos + 7] = d8b[7];
}
function readDoubleLE(buf, pos) {
  d8b[0] = buf[pos];
  d8b[1] = buf[pos + 1];
  d8b[2] = buf[pos + 2];
  d8b[3] = buf[pos + 3];
  d8b[4] = buf[pos + 4];
  d8b[5] = buf[pos + 5];
  d8b[6] = buf[pos + 6];
  d8b[7] = buf[pos + 7];
  return f64[0];
}
const MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
const MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
class LongBits {
  lo;
  hi;
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned = false) {
    if (!unsigned && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned = false) {
    if (unsigned) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned = false) {
    return this.toBigInt(unsigned).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value2) {
    if (value2 === 0n) {
      return zero;
    }
    if (value2 < MAX_SAFE_NUMBER_INTEGER && value2 > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value2));
    }
    const negative = value2 < 0n;
    if (negative) {
      value2 = -value2;
    }
    let hi = value2 >> 32n;
    let lo = value2 - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value2) {
    if (value2 === 0) {
      return zero;
    }
    const sign5 = value2 < 0;
    if (sign5) {
      value2 = -value2;
    }
    let lo = value2 >>> 0;
    let hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign5) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value2) {
    if (typeof value2 === "number") {
      return LongBits.fromNumber(value2);
    }
    if (typeof value2 === "bigint") {
      return LongBits.fromBigInt(value2);
    }
    if (typeof value2 === "string") {
      return LongBits.fromBigInt(BigInt(value2));
    }
    return value2.low != null || value2.high != null ? new LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
  }
}
const zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
const TWO_32 = 4294967296n;
function length(string2) {
  let len = 0;
  let c2 = 0;
  for (let i2 = 0; i2 < string2.length; ++i2) {
    c2 = string2.charCodeAt(i2);
    if (c2 < 128) {
      len += 1;
    } else if (c2 < 2048) {
      len += 2;
    } else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
      ++i2;
      len += 4;
    } else {
      len += 3;
    }
  }
  return len;
}
function read(buffer, start2, end) {
  const len = end - start2;
  if (len < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i2 = 0;
  let t2;
  while (start2 < end) {
    t2 = buffer[start2++];
    if (t2 < 128) {
      chunk[i2++] = t2;
    } else if (t2 > 191 && t2 < 224) {
      chunk[i2++] = (t2 & 31) << 6 | buffer[start2++] & 63;
    } else if (t2 > 239 && t2 < 365) {
      t2 = ((t2 & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
      chunk[i2++] = 55296 + (t2 >> 10);
      chunk[i2++] = 56320 + (t2 & 1023);
    } else {
      chunk[i2++] = (t2 & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
    }
    if (i2 > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i2 = 0;
    }
  }
  if (parts != null) {
    if (i2 > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i2));
}
function write(string2, buffer, offset) {
  const start2 = offset;
  let c1;
  let c2;
  for (let i2 = 0; i2 < string2.length; ++i2) {
    c1 = string2.charCodeAt(i2);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i2;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start2;
}
function indexOutOfRange(reader, writeLength) {
  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf, end) {
  return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
class Uint8ArrayReader {
  buf;
  pos;
  len;
  _slice = Uint8Array.prototype.subarray;
  constructor(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value2 = 4294967295;
    value2 = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value2;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value2 = this.uint32();
    return value2 >>> 1 ^ -(value2 & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value2 = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value2;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value2 = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value2;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length3 = this.uint32();
    const start2 = this.pos;
    const end = this.pos + length3;
    if (end > this.len) {
      throw indexOutOfRange(this, length3);
    }
    this.pos += length3;
    return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes = this.bytes();
    return read(bytes, 0, bytes.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length3) {
    if (typeof length3 === "number") {
      if (this.pos + length3 > this.len) {
        throw indexOutOfRange(this, length3);
      }
      this.pos += length3;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits = new LongBits(0, 0);
    let i2 = 0;
    if (this.len - this.pos > 4) {
      for (; i2 < 4; ++i2) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits;
      }
      i2 = 0;
    } else {
      for (; i2 < 3; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i2 < 5; ++i2) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    } else {
      for (; i2 < 5; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value2 = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength(value2);
    return value2;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
}
function createReader(buf) {
  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
}
function decodeMessage(buf, codec, opts) {
  const reader = createReader(buf);
  return codec.decode(reader, void 0, opts);
}
function pool(size2) {
  const SIZE = 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return function poolAlloc(size3) {
    if (size3 < 1 || size3 > MAX) {
      return allocUnsafe(size3);
    }
    if (offset + size3 > SIZE) {
      slab = allocUnsafe(SIZE);
      offset = 0;
    }
    const buf = slab.subarray(offset, offset += size3);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf;
  };
}
class Op {
  /**
   * Function to call
   */
  fn;
  /**
   * Value byte length
   */
  len;
  /**
   * Next operation
   */
  next;
  /**
   * Value to write
   */
  val;
  constructor(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
}
function noop() {
}
class State {
  /**
   * Current head
   */
  head;
  /**
   * Current tail
   */
  tail;
  /**
   * Current buffer length
   */
  len;
  /**
   * Next state
   */
  next;
  constructor(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
}
const bufferPool = pool();
function alloc(size2) {
  if (globalThis.Buffer != null) {
    return allocUnsafe(size2);
  }
  return bufferPool(size2);
}
class Uint8ArrayWriter {
  /**
   * Current length
   */
  len;
  /**
   * Operations head
   */
  head;
  /**
   * Operations tail
   */
  tail;
  /**
   * Linked forked states
   */
  states;
  constructor() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value2) {
    this.len += (this.tail = this.tail.next = new VarintOp((value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5, value2)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value2) {
    return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value2) {
    return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value2) {
    const bits = LongBits.fromBigInt(value2);
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value2) {
    return this._push(encodeUint8Array, encodingLength(value2), value2);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value2) {
    return this.uint64(BigInt(value2));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value2) {
    return this.uint64(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value2) {
    return this.uint64Number(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value2) {
    return this.uint64String(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value2) {
    const bits = LongBits.fromBigInt(value2).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value2) {
    const bits = LongBits.fromNumber(value2).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value2) {
    return this.sint64(BigInt(value2));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value2) {
    return this._push(writeByte, 1, value2 ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value2) {
    return this._push(writeFixed32, 4, value2 >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value2) {
    return this.fixed32(value2);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value2) {
    const bits = LongBits.fromBigInt(value2);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value2) {
    const bits = LongBits.fromNumber(value2);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value2) {
    return this.fixed64(BigInt(value2));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value2) {
    return this.fixed64(value2);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value2) {
    return this.fixed64Number(value2);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value2) {
    return this.fixed64String(value2);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value2) {
    return this._push(writeFloatLE, 4, value2);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value2) {
    return this._push(writeDoubleLE, 8, value2);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value2) {
    const len = value2.length >>> 0;
    if (len === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len)._push(writeBytes, len, value2);
  }
  /**
   * Writes a string
   */
  string(value2) {
    const len = length(value2);
    return len !== 0 ? this.uint32(len)._push(write, len, value2) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len = this.len;
    this.reset().uint32(len);
    if (len !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf = alloc(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  }
}
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
class VarintOp extends Op {
  next;
  constructor(len, val) {
    super(writeVarint32, len, val);
    this.next = void 0;
  }
}
function writeVarint64(val, buf, pos) {
  while (val.hi !== 0) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeBytes(val, buf, pos) {
  buf.set(val, pos);
}
if (globalThis.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value2) {
    const len = value2.length >>> 0;
    this.uint32(len);
    if (len > 0) {
      this._push(writeBytesBuffer, len, value2);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value2) {
    const len = globalThis.Buffer.byteLength(value2);
    this.uint32(len);
    if (len > 0) {
      this._push(writeStringBuffer, len, value2);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf, pos) {
  buf.set(val, pos);
}
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40) {
    write(val, buf, pos);
  } else if (buf.utf8Write != null) {
    buf.utf8Write(val, pos);
  } else {
    buf.set(fromString(val), pos);
  }
}
function createWriter() {
  return new Uint8ArrayWriter();
}
function encodeMessage(message2, codec) {
  const w = createWriter();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(name2, type, encode3, decode2) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode2
  };
}
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode3 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode2 = function enumDecode(reader) {
    const val = reader.int32();
    return findValue(val);
  };
  return createCodec("enum", CODEC_TYPES.VARINT, encode3, decode2);
}
function message(encode3, decode2) {
  return createCodec("message", CODEC_TYPES.LENGTH_DELIMITED, encode3, decode2);
}
class MaxLengthError extends Error {
  /**
   * This will be removed in a future release
   *
   * @deprecated use the `.name` property instead
   */
  code = "ERR_MAX_LENGTH";
  name = "MaxLengthError";
}
class MaxSizeError extends Error {
  /**
   * This will be removed in a future release
   *
   * @deprecated use the `.name` property instead
   */
  code = "ERR_MAX_SIZE";
  name = "MaxSizeError";
}
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey$1;
(function(PublicKey3) {
  let _codec;
  PublicKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey3.encode = (obj) => {
    return encodeMessage(obj, PublicKey3.codec());
  };
  PublicKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PublicKey3.codec(), opts);
  };
})(PublicKey$1 || (PublicKey$1 = {}));
var PrivateKey$1;
(function(PrivateKey3) {
  let _codec;
  PrivateKey3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey3.encode = (obj) => {
    return encodeMessage(obj, PrivateKey3.codec());
  };
  PrivateKey3.decode = (buf, opts) => {
    return decodeMessage(buf, PrivateKey3.codec(), opts);
  };
})(PrivateKey$1 || (PrivateKey$1 = {}));
function randomBytes(length3) {
  if (isNaN(length3) || length3 <= 0) {
    throw new InvalidParametersError$1("random bytes length must be a Number bigger than 0");
  }
  return randomBytes$1(length3);
}
class RSAPublicKey {
  type = "RSA";
  jwk;
  _raw;
  _multihash;
  constructor(jwk, digest10) {
    this.jwk = jwk;
    this._multihash = digest10;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = jwkToPkix(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key2) {
    if (key2 == null || !(key2.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key2.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify$1(this.jwk, sig, data, options);
  }
}
const SHA2_256_CODE = 18;
const MAX_RSA_JWK_SIZE = 1062;
const RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkixMessageToJwk(message2) {
  const keys = decodeDer(message2[1], {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString$1(keys[0], "base64url"),
    e: toString$1(keys[1], "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError$1("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence([
    RSA_ALGORITHM_IDENTIFIER,
    encodeBitString(encodeSequence([
      encodeInteger(fromString(jwk.n, "base64url")),
      encodeInteger(fromString(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkixToRSAPublicKey(bytes, digest10) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
    throw new InvalidPublicKeyError("Key size is too large");
  }
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToRSAPublicKey(message2, bytes, digest10);
}
function pkixMessageToRSAPublicKey(message2, bytes, digest10) {
  const jwk = pkixMessageToJwk(message2);
  if (digest10 == null) {
    const hash3 = sha256$1(PublicKey$1.encode({
      Type: KeyType.RSA,
      Data: bytes
    }));
    digest10 = create(SHA2_256_CODE, hash3);
  }
  return new RSAPublicKey(jwk, digest10);
}
async function hashAndVerify$1(key2, sig, msg, options) {
  const publicKey = await webcrypto.get().subtle.importKey("jwk", key2, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  options?.signal?.throwIfAborted();
  const result = await webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
  options?.signal?.throwIfAborted();
  return result;
}
class _HMAC {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(hash3, key2) {
    ahash(hash3);
    abytes$1(key2, void 0, "key");
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key2.length > blockLen ? hash3.create().update(key2).digest() : key2);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    clean$1(pad2);
  }
  update(buf) {
    aexists$1(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists$1(this);
    abytes$1(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac$2 = (hash3, key2, message2) => new _HMAC(hash3, key2).update(message2).digest();
hmac$2.create = (hash3, key2) => new _HMAC(hash3, key2);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n$1) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n;
  const k2neg = k2 < _0n;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n;
  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format2) {
  if (!["compact", "recovered", "der"].includes(format2))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format2;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  abool$1(optsn.lowS, "lowS");
  abool$1(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
class DERErr extends Error {
  constructor(m2 = "") {
    super(m2);
  }
}
const DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length3 = 0;
      if (!isLong)
        length3 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length3 = length3 << 8 | b;
        pos += lenLen;
        if (length3 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length3);
      if (v.length !== length3)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length3) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E } = DER;
      if (num < _0n)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(bytes) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = abytes$1(bytes, void 0, "signature");
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
const _0n = BigInt(0), _1n = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrass(params, extraOpts = {}) {
  const validated = createCurveFields("weierstrass", params, extraOpts);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp, Fn);
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes(_c, point5, isCompressed) {
    const { x, y } = point5.toAffine();
    const bx = Fp.toBytes(x);
    abool$1(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes$1(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length3 = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length3 === comp && (head === 2 || head === 3)) {
      const x = Fp.fromBytes(tail);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const evenY = Fp.isOdd(y);
      const evenH = (head & 1) === 1;
      if (evenH !== evenY)
        y = Fp.neg(y);
      return { x, y };
    } else if (length3 === uncomp && head === 4) {
      const L = Fp.BYTES;
      const x = Fp.fromBytes(tail.subarray(0, L));
      const y = Fp.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length3}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint2 = extraOpts.toBytes || pointToBytes;
  const decodePoint4 = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp.sqr(y);
    const right = weierstrassEquation(x);
    return Fp.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp.isValid(n2) || banZero && Fp.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point2))
      throw new Error("Weierstrass Point expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn.ORDER);
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    if (Fp.eql(Z, Fp.ONE))
      return { x: X, y: Y };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(Z);
    const x = Fp.mul(X, iz);
    const y = Fp.mul(Y, iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp.is0(p2.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p2.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point2(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point2 {
    // base / generator point
    static BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    static ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);
    // 0, 1, 0
    // math field
    static Fp = Fp;
    // scalar field
    static Fn = Fn;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p2) {
      const { x, y } = p2 || {};
      if (!p2 || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p2 instanceof Point2)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp.ONE);
    }
    static fromBytes(bytes) {
      const P = Point2.fromAffine(decodePoint4(abytes$1(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return Point2.fromBytes(hexToBytes$1(hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point2(this.X, Fp.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b } = CURVE;
      const b3 = Fp.mul(b, _3n);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a2, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a2, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a2, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a2, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a2, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a2, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point5, fake;
      const mul5 = (n2) => wnaf.cached(this, n2, (p2) => normalizeZ(Point2, p2));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul5(k1);
        const { p: k2p, f: k2f } = mul5(k2);
        fake = k1f.add(k2f);
        point5 = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p2, f: f2 } = mul5(scalar);
        point5 = p2;
        fake = f2;
      }
      return normalizeZ(Point2, [point5, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p2 = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n || p2.is0())
        return Point2.ZERO;
      if (sc === _1n)
        return p2;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2: p22 } = mulEndoUnsafe(Point2, p2, k1, k2);
        return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p2, sc);
      }
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool$1(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint2(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex$1(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const bits = Fn.BITS;
  const wnaf = new wNAF(Point2, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point2.BASE.precompute(8);
  return Point2;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function getWLengths(Fp, Fn) {
  return {
    secretKey: Fn.BYTES,
    publicKey: 1 + Fp.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn.BYTES
  };
}
function ecdh(Point2, ecdhOpts = {}) {
  const { Fn } = Point2;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes$1;
  const lengths = Object.assign(getWLengths(Point2.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      const num = Fn.fromBytes(secretKey);
      return Fn.isValidNot0(num);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l2 = publicKey.length;
      if (isCompressed === true && l2 !== comp)
        return false;
      if (isCompressed === false && l2 !== publicKeyUncompressed)
        return false;
      return !!Point2.fromBytes(publicKey);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(abytes$1(seed, lengths.seed, "seed"), Fn.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point2.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    const { secretKey, publicKey, publicKeyUncompressed } = lengths;
    if (!isBytes$1(item))
      return void 0;
    if ("_lengths" in Fn && Fn._lengths || secretKey === publicKey)
      return void 0;
    const l2 = abytes$1(item, void 0, "key").length;
    return l2 === publicKey || l2 === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s2 = Fn.fromBytes(secretKeyA);
    const b = Point2.fromBytes(publicKeyB);
    return b.multiply(s2).toBytes(isCompressed);
  }
  const utils2 = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey
  };
  const keygen = createKeygen(randomSecretKey, getPublicKey);
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point2, utils: utils2, lengths });
}
function ecdsa(Point2, hash3, ecdsaOpts = {}) {
  ahash(hash3);
  validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  ecdsaOpts = Object.assign({}, ecdsaOpts);
  const randomBytes2 = ecdsaOpts.randomBytes || randomBytes$1;
  const hmac3 = ecdsaOpts.hmac || ((key2, msg) => hmac$2(hash3, key2, msg));
  const { Fp, Fn } = Point2;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh(Point2, ecdsaOpts);
  const defaultSigOpts = {
    prehash: true,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
    format: "compact",
    extraEntropy: false
  };
  const hasLargeCofactor = CURVE_ORDER * _2n$1 < Fp.ORDER;
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n;
    return number > HALF;
  }
  function validateRS(title, num) {
    if (!Fn.isValidNot0(num))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num;
  }
  function assertSmallCofactor() {
    if (hasLargeCofactor)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function validateSigLength(bytes, format2) {
    validateSigFormat(format2);
    const size2 = lengths.signature;
    const sizer = format2 === "compact" ? size2 : format2 === "recovered" ? size2 + 1 : void 0;
    return abytes$1(bytes, sizer);
  }
  class Signature2 {
    r;
    s;
    recovery;
    constructor(r2, s2, recovery) {
      this.r = validateRS("r", r2);
      this.s = validateRS("s", s2);
      if (recovery != null) {
        assertSmallCofactor();
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("invalid recovery id");
        this.recovery = recovery;
      }
      Object.freeze(this);
    }
    static fromBytes(bytes, format2 = defaultSigOpts.format) {
      validateSigLength(bytes, format2);
      let recid;
      if (format2 === "der") {
        const { r: r3, s: s3 } = DER.toSig(abytes$1(bytes));
        return new Signature2(r3, s3);
      }
      if (format2 === "recovered") {
        recid = bytes[0];
        format2 = "compact";
        bytes = bytes.subarray(1);
      }
      const L = lengths.signature / 2;
      const r2 = bytes.subarray(0, L);
      const s2 = bytes.subarray(L, L * 2);
      return new Signature2(Fn.fromBytes(r2), Fn.fromBytes(s2), recid);
    }
    static fromHex(hex, format2) {
      return this.fromBytes(hexToBytes$1(hex), format2);
    }
    assertRecovery() {
      const { recovery } = this;
      if (recovery == null)
        throw new Error("invalid recovery id: must be present");
      return recovery;
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const { r: r2, s: s2 } = this;
      const recovery = this.assertRecovery();
      const radj = recovery === 2 || recovery === 3 ? r2 + CURVE_ORDER : r2;
      if (!Fp.isValid(radj))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const x = Fp.toBytes(radj);
      const R2 = Point2.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(abytes$1(messageHash, void 0, "msgHash"));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s2 * ir);
      const Q = Point2.BASE.multiplyUnsafe(u1).add(R2.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("invalid recovery: point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format2 = defaultSigOpts.format) {
      validateSigFormat(format2);
      if (format2 === "der")
        return hexToBytes$1(DER.hexFromSig(this));
      const { r: r2, s: s2 } = this;
      const rb = Fn.toBytes(r2);
      const sb = Fn.toBytes(s2);
      if (format2 === "recovered") {
        assertSmallCofactor();
        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
      }
      return concatBytes(rb, sb);
    }
    toHex(format2) {
      return bytesToHex$1(this.toBytes(format2));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num) {
    aInRange("num < 2^" + fnBits, num, _0n, ORDER_MASK);
    return Fn.toBytes(num);
  }
  function validateMsgAndHash(message2, prehash) {
    abytes$1(message2, void 0, "message");
    return prehash ? abytes$1(hash3(message2), void 0, "prehashed message") : message2;
  }
  function prepSig(message2, secretKey, opts) {
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    const h1int = bits2int_modN(message2);
    const d2 = Fn.fromBytes(secretKey);
    if (!Fn.isValidNot0(d2))
      throw new Error("invalid private key");
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e2 = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;
      seedArgs.push(abytes$1(e2, void 0, "extraEntropy"));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r2 = Fn.create(q.x);
      if (r2 === _0n)
        return;
      const s2 = Fn.create(ik * Fn.create(m2 + r2 * d2));
      if (s2 === _0n)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = Fn.neg(s2);
        recovery ^= 1;
      }
      return new Signature2(r2, normS, hasLargeCofactor ? void 0 : recovery);
    }
    return { seed, k2sig };
  }
  function sign5(message2, secretKey, opts = {}) {
    const { seed, k2sig } = prepSig(message2, secretKey, opts);
    const drbg = createHmacDrbg(hash3.outputLen, Fn.BYTES, hmac3);
    const sig = drbg(seed, k2sig);
    return sig.toBytes(opts.format);
  }
  function verify5(signature2, message2, publicKey, opts = {}) {
    const { lowS, prehash, format: format2 } = validateSigOpts(opts, defaultSigOpts);
    publicKey = abytes$1(publicKey, void 0, "publicKey");
    message2 = validateMsgAndHash(message2, prehash);
    if (!isBytes$1(signature2)) {
      const end = signature2 instanceof Signature2 ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + end);
    }
    validateSigLength(signature2, format2);
    try {
      const sig = Signature2.fromBytes(signature2, format2);
      const P = Point2.fromBytes(publicKey);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r2, s: s2 } = sig;
      const h = bits2int_modN(message2);
      const is = Fn.inv(s2);
      const u1 = Fn.create(h * is);
      const u2 = Fn.create(r2 * is);
      const R2 = Point2.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R2.is0())
        return false;
      const v = Fn.create(R2.x);
      return v === r2;
    } catch (e2) {
      return false;
    }
  }
  function recoverPublicKey(signature2, message2, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    return Signature2.fromBytes(signature2, "recovered").recoverPublicKey(message2).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils: utils2,
    lengths,
    Point: Point2,
    sign: sign5,
    verify: verify5,
    recoverPublicKey,
    Signature: Signature2,
    hash: hash3
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
const secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
const _2n = /* @__PURE__ */ BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n2, P) * b3 % P;
  const b9 = pow2(b6, _3n2, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n2, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
const Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {
  Fp: Fpk1,
  endo: secp256k1_ENDO
});
const secp256k1$1 = /* @__PURE__ */ ecdsa(Pointk1, sha256$1);
function hashAndVerify(key2, sig, msg, options) {
  const p2 = sha256$2.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise$1(p2)) {
    return p2.then(({ digest: digest10 }) => {
      options?.signal?.throwIfAborted();
      return secp256k1$1.verify(sig, digest10, key2, {
        prehash: false,
        format: "der"
      });
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new VerificationError(String(err));
    });
  }
  try {
    options?.signal?.throwIfAborted();
    return secp256k1$1.verify(sig, p2.digest, key2, {
      prehash: false,
      format: "der"
    });
  } catch (err) {
    throw new VerificationError(String(err));
  }
}
class Secp256k1PublicKey {
  type = "secp256k1";
  raw;
  _key;
  constructor(key2) {
    this._key = validateSecp256k1PublicKey(key2);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity$1.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key2) {
    if (key2 == null || !(key2.raw instanceof Uint8Array)) {
      return false;
    }
    return equals(this.raw, key2.raw);
  }
  verify(data, sig, options) {
    return hashAndVerify(this._key, sig, data, options);
  }
}
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
function compressSecp256k1PublicKey(key2) {
  return secp256k1$1.Point.fromBytes(key2).toBytes();
}
function validateSecp256k1PublicKey(key2) {
  try {
    secp256k1$1.Point.fromBytes(key2);
    return key2;
  } catch (err) {
    throw new InvalidPublicKeyError(String(err));
  }
}
async function generateKeyPair(type, bits) {
  {
    return generateEd25519KeyPair();
  }
}
function publicKeyFromProtobuf(buf, digest10) {
  const { Type, Data } = PublicKey$1.decode(buf);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.RSA:
      return pkixToRSAPublicKey(data, digest10);
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyFromMultihash(digest10) {
  const { Type, Data } = PublicKey$1.decode(digest10.digest);
  const data = Data ?? new Uint8Array();
  switch (Type) {
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError();
  }
}
function publicKeyToProtobuf(key2) {
  return PublicKey$1.encode({
    Type: KeyType[key2.type],
    Data: key2.raw
  });
}
const inspect$1 = Symbol.for("nodejs.util.inspect.custom");
const LIBP2P_KEY_CODE$1 = 114;
class PeerIdImpl {
  type;
  multihash;
  publicKey;
  string;
  constructor(init3) {
    this.type = init3.type;
    this.multihash = init3.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  [peerIdSymbol] = true;
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE$1, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (id?.toMultihash()?.bytes != null) {
      return equals(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [inspect$1]() {
    return `PeerId(${this.toString()})`;
  }
}
class RSAPeerId extends PeerIdImpl {
  type = "RSA";
  publicKey;
  constructor(init3) {
    super({ ...init3, type: "RSA" });
    this.publicKey = init3.publicKey;
  }
}
class Ed25519PeerId extends PeerIdImpl {
  type = "Ed25519";
  publicKey;
  constructor(init3) {
    super({ ...init3, type: "Ed25519" });
    this.publicKey = init3.publicKey;
  }
}
class Secp256k1PeerId extends PeerIdImpl {
  type = "secp256k1";
  publicKey;
  constructor(init3) {
    super({ ...init3, type: "secp256k1" });
    this.publicKey = init3.publicKey;
  }
}
const TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1 = 2336;
class URLPeerId {
  type = "url";
  multihash;
  publicKey;
  url;
  constructor(url) {
    this.url = url.toString();
    this.multihash = identity$1.digest(fromString(this.url));
  }
  [inspect$1]() {
    return `PeerId(${this.url})`;
  }
  [peerIdSymbol] = true;
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString$1(other);
    }
    return other.toString() === this.toString();
  }
}
const LIBP2P_KEY_CODE = 114;
const TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
function peerIdFromString$1(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode$3(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID.parse(str));
  } else {
    {
      throw new InvalidParametersError$1('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey) {
  if (publicKey.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  } else if (publicKey.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey.toCID().multihash,
      publicKey
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey = publicKeyFromMultihash(multihash);
      if (publicKey.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey });
      } else if (publicKey.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey });
      }
    } catch (err) {
      const url = toString$1(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {
    const url = toString$1(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity$1.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha256$2.code;
}
var define_globalThis_process_env_default$2 = {};
async function validateConfig(opts) {
  if (opts.connectionProtector === null && define_globalThis_process_env_default$2?.LIBP2P_FORCE_PNET != null) {
    throw new InvalidParametersError$1("Private network is enforced, but no protector was provided");
  }
  return opts;
}
const e = 1e3, t = e * 60, n = t * 60, r$2 = n * 24, i = r$2 * 7, a = r$2 * 365.25, o = a / 12;
function s$1(e2, t2) {
  if (typeof e2 == `string`) return l(e2);
  if (typeof e2 == `number`) return p(e2, t2);
  throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(e2)}`);
}
var c = s$1;
function l(s2) {
  if (typeof s2 != `string` || s2.length === 0 || s2.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(s2)}`);
  let c2 = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(s2);
  if (!c2?.groups) return NaN;
  let { value: l2, unit: u = `ms` } = c2.groups, d2 = parseFloat(l2), f2 = u.toLowerCase();
  switch (f2) {
    case `years`:
    case `year`:
    case `yrs`:
    case `yr`:
    case `y`:
      return d2 * a;
    case `months`:
    case `month`:
    case `mo`:
      return d2 * o;
    case `weeks`:
    case `week`:
    case `w`:
      return d2 * i;
    case `days`:
    case `day`:
    case `d`:
      return d2 * r$2;
    case `hours`:
    case `hour`:
    case `hrs`:
    case `hr`:
    case `h`:
      return d2 * n;
    case `minutes`:
    case `minute`:
    case `mins`:
    case `min`:
    case `m`:
      return d2 * t;
    case `seconds`:
    case `second`:
    case `secs`:
    case `sec`:
    case `s`:
      return d2 * e;
    case `milliseconds`:
    case `millisecond`:
    case `msecs`:
    case `msec`:
    case `ms`:
      return d2;
    default:
      throw Error(`Unknown unit "${f2}" provided to ms.parse(). value=${JSON.stringify(s2)}`);
  }
}
function d(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? `${Math.round(s2 / a)}y` : c2 >= o ? `${Math.round(s2 / o)}mo` : c2 >= i ? `${Math.round(s2 / i)}w` : c2 >= r$2 ? `${Math.round(s2 / r$2)}d` : c2 >= n ? `${Math.round(s2 / n)}h` : c2 >= t ? `${Math.round(s2 / t)}m` : c2 >= e ? `${Math.round(s2 / e)}s` : `${s2}ms`;
}
function f$1(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? m(s2, c2, a, `year`) : c2 >= o ? m(s2, c2, o, `month`) : c2 >= i ? m(s2, c2, i, `week`) : c2 >= r$2 ? m(s2, c2, r$2, `day`) : c2 >= n ? m(s2, c2, n, `hour`) : c2 >= t ? m(s2, c2, t, `minute`) : c2 >= e ? m(s2, c2, e, `second`) : `${s2} ms`;
}
function p(e2, t2) {
  if (typeof e2 != `number` || !Number.isFinite(e2)) throw Error(`Value provided to ms.format() must be of type number.`);
  return t2?.long ? f$1(e2) : d(e2);
}
function m(e2, t2, n2, r2) {
  let i2 = t2 >= n2 * 1.5;
  return `${Math.round(e2 / n2)} ${r2}${i2 ? `s` : ``}`;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = c;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key2) => {
    createDebug[key2] = env[key2];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash3 = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i2);
      hash3 |= 0;
    }
    return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace, options) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self2 = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      if (options?.onLog != null) {
        options.onLog(...args);
      }
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split2[i2]) {
        continue;
      }
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}
var define_globalThis_process_env_default$1 = {};
const storage = localstorage();
const colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
    return false;
  }
  return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + c(this.diff);
  if (!this.useColors) {
    return;
  }
  const c$1 = "color: " + this.color;
  args.splice(1, 0, c$1, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c$1);
}
const log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage?.setItem("debug", namespaces);
    } else {
      storage?.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r2;
  try {
    r2 = storage?.getItem("debug");
  } catch (error) {
  }
  if (!r2 && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
    r2 = define_globalThis_process_env_default$1.DEBUG;
  }
  return r2;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
const weald = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });
weald.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
weald.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
weald.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
weald.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function formatError(v) {
  const message2 = notEmpty(v.message);
  const stack = notEmpty(v.stack);
  if (message2 != null && stack != null) {
    if (stack.includes(message2)) {
      return stack;
    }
    return `${message2}
${stack}`;
  }
  if (stack != null) {
    return stack;
  }
  if (message2 != null) {
    return message2;
  }
  return v.toString();
}
function isAggregateError(err) {
  return err?.name === "AggregateError";
}
weald.formatters.e = (v) => {
  if (v == null) {
    return "undefined";
  }
  if (isAggregateError(v)) {
    const indent = "      ";
    let output = formatError(v);
    if (v.errors.length > 0) {
      output += `
${indent}${v.errors.map((err) => `  ${formatError(err).split("\n").join(`
${indent}`)}`).join(`
${indent}`)}`;
    } else {
      output += `
${indent}[Error list was empty]`;
    }
    return output.trim();
  }
  return formatError(v);
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function defaultLogger(options) {
  return {
    forComponent(name2) {
      return logger(name2, options);
    }
  };
}
function logger(name2, options) {
  let trace = createDisabledLogger(`${name2}:trace`);
  if (weald.enabled(`${name2}:trace`) && weald.names.map((r2) => r2.toString()).find((n2) => n2.includes(":trace")) != null) {
    trace = weald(`${name2}:trace`, options);
  }
  return Object.assign(weald(name2, options), {
    error: weald(`${name2}:error`, options),
    trace,
    newScope: (scope) => logger(`${name2}:${scope}`, options)
  });
}
function notEmpty(str) {
  if (str == null) {
    return;
  }
  str = str.trim();
  if (str.length === 0) {
    return;
  }
  return str;
}
function mapIterable(iter, map) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString(str) {
  const multihash = decode$3(base58btc.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}
class PeerMap {
  map;
  constructor(map) {
    this.map = /* @__PURE__ */ new Map();
    if (map != null) {
      for (const [key2, value2] of map.entries()) {
        this.map.set(key2.toString(), { key: key2, value: value2 });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value2, key2) => {
      fn(value2.value, value2.key, this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString())?.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value2) {
    this.map.set(peer.toString(), { key: peer, value: value2 });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
}
class PeerSet {
  set;
  constructor(set) {
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key2 of set) {
        this.set.add(key2.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId = peerIdFromString(str);
      predicate(peerId, peerId, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
}
const FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
const FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
const cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size2) {
  const fnvPrime = FNV_PRIMES[size2];
  let hash3 = FNV_OFFSETS[size2];
  for (let index = 0; index < uint8Array.length; index++) {
    hash3 ^= BigInt(uint8Array[index]);
    hash3 = BigInt.asUintN(size2, hash3 * fnvPrime);
  }
  return hash3;
}
function fnv1aEncodeInto(string2, size2, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size2];
  let hash3 = FNV_OFFSETS[size2];
  let remaining = string2;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash3 ^= BigInt(utf8Buffer[index]);
      hash3 = BigInt.asUintN(size2, hash3 * fnvPrime);
    }
  }
  return hash3;
}
function fnv1a$1(value2, { size: size2 = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size2]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value2 === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value2, size2, utf8Buffer);
    }
    value2 = cachedEncoder.encode(value2);
  }
  return fnv1aUint8Array(value2, size2);
}
const fnv1a = {
  hash: (input) => {
    return Number(fnv1a$1(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a.hash(input, seed));
  }
};
function numberToBuffer(num) {
  let hex = num.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString(hex, "base16");
}
const MAX_FINGERPRINT_SIZE = 64;
class Fingerprint {
  fp;
  h;
  seed;
  constructor(buf, hash3, seed, fingerprintSize = 2) {
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash3.hashV(buf, seed);
    const fp = alloc$1(fingerprintSize);
    for (let i2 = 0; i2 < fp.length; i2++) {
      fp[i2] = fnv[i2];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash3;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!(other?.fp instanceof Uint8Array)) {
      return false;
    }
    return equals(this.fp, other.fp);
  }
}
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}
class Bucket {
  contents;
  constructor(size2) {
    this.contents = new Array(size2).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i2 = 0; i2 < this.contents.length; i2++) {
      if (this.contents[i2] == null) {
        this.contents[i2] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i2 = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i2];
    this.contents[i2] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
}
const maxCuckooCount = 500;
class CuckooFilter {
  bucketSize;
  filterSize;
  fingerprintSize;
  buckets;
  count;
  hash;
  seed;
  constructor(init3) {
    this.filterSize = init3.filterSize;
    this.bucketSize = init3.bucketSize ?? 4;
    this.fingerprintSize = init3.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init3.hash ?? fnv1a;
    this.seed = init3.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand3 = [j, k];
    let i2 = rand3[getRandomInt(0, rand3.length - 1)];
    if (this.buckets[i2] == null) {
      this.buckets[i2] = new Bucket(this.bucketSize);
    }
    for (let n2 = 0; n2 < maxCuckooCount; n2++) {
      const swapped = this.buckets[i2].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i2 = (i2 ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i2] == null) {
        this.buckets[i2] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i2].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.has(fingerprint) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return this.buckets[k]?.has(fingerprint) ?? false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.remove(fingerprint) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = this.buckets[k]?.remove(fingerprint) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
}
const MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load2 = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load2);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}
class ScalableCuckooFilter {
  filterSize;
  bucketSize;
  fingerprintSize;
  scale;
  filterSeries;
  hash;
  seed;
  constructor(init3) {
    this.bucketSize = init3.bucketSize ?? 4;
    this.filterSize = init3.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init3.fingerprintSize ?? 2;
    this.scale = init3.scale ?? 2;
    this.hash = init3.hash ?? fnv1a;
    this.seed = init3.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
}
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
  return new ScalableCuckooFilter({
    ...optimize(maxItems, errorRate),
    ...{}
  });
}
function getNetConfig(ma) {
  const components = ma.getComponents();
  const config = {};
  let index = 0;
  if (components[index]?.name === "ip6zone") {
    config.zone = `${components[index].value}`;
    index++;
  }
  if (components[index].name === "ip4" || components[index].name === "ip6") {
    config.type = components[index].name;
    config.host = components[index].value;
    index++;
  } else if (components[index].name === "dns" || components[index].name === "dns4" || components[index].name === "dns6") {
    config.type = components[index].name;
    config.host = components[index].value;
    index++;
  } else if (components[index].name === "dnsaddr") {
    config.type = components[index].name;
    config.host = `_dnsaddr.${components[index].value}`;
    index++;
  }
  if (components[index]?.name === "tcp" || components[index]?.name === "udp") {
    config.protocol = components[index].name === "tcp" ? "tcp" : "udp";
    config.port = parseInt(`${components[index].value}`);
    index++;
  }
  if (components[index]?.name === "ipcidr") {
    if (config.type === "ip4") {
      config.cidr = parseInt(`${components[index].value}`);
    } else if (config.type === "ip6") {
      config.cidr = `${components[index].value}`;
    }
    index++;
  }
  if (config.type == null || config.host == null) {
    throw new InvalidParametersError$1(`Multiaddr ${ma} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);
  }
  if (components[index]?.name === "tls" && components[index + 1]?.name === "sni") {
    config.sni = components[index + 1].value;
    index += 2;
  }
  return config;
}
class Parser {
  index = 0;
  input = "";
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue2 = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue2) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
}
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  const addr = parser.new(input).parseWith(() => parser.readIPAddr());
  if (!addr) {
    return void 0;
  }
  if (mapIPv4ToIPv6 && addr.length === 4) {
    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
  }
  return addr;
}
function allFF(a2, from2, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from2)
      continue;
    if (i2 > to)
      break;
    if (e2 !== 255)
      return false;
    i2++;
  }
  return true;
}
function deepEqual(a2, b, from2, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from2)
      continue;
    if (i2 > to)
      break;
    if (e2 !== b[i2])
      return false;
    i2++;
  }
  return true;
}
function ipToString(ip) {
  switch (ip.length) {
    case IPv4Len: {
      return ip.join(".");
    }
    case IPv6Len: {
      const result = [];
      for (let i2 = 0; i2 < ip.length; i2++) {
        if (i2 % 2 === 0) {
          result.push(ip[i2].toString(16).padStart(2, "0") + ip[i2 + 1].toString(16).padStart(2, "0"));
        }
      }
      return result.join(":");
    }
    default: {
      throw new Error("Invalid ip length");
    }
  }
}
function simpleMaskLength(mask) {
  let ones = 0;
  for (let [index, byte] of mask.entries()) {
    if (byte === 255) {
      ones += 8;
      continue;
    }
    while ((byte & 128) != 0) {
      ones++;
      byte = byte << 1;
    }
    if ((byte & 128) != 0) {
      return -1;
    }
    for (let i2 = index + 1; i2 < mask.length; i2++) {
      if (mask[i2] != 0) {
        return -1;
      }
    }
    break;
  }
  return ones;
}
function maskToHex(mask) {
  let hex = "0x";
  for (const byte of mask) {
    hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
  }
  return hex;
}
const IPv4Len = 4;
const IPv6Len = 16;
const ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);
function maskIp(ip, mask) {
  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
    mask = mask.slice(12);
  }
  if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
    ip = ip.slice(12);
  }
  const n2 = ip.length;
  if (n2 != mask.length) {
    throw new Error("Failed to mask ip");
  }
  const out = new Uint8Array(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    out[i2] = ip[i2] & mask[i2];
  }
  return out;
}
function containsIp(net, ip) {
  if (typeof ip === "string") {
    ip = parseIP(ip);
  }
  if (ip == null)
    throw new Error("Invalid ip");
  if (ip.length !== net.network.length) {
    return false;
  }
  for (let i2 = 0; i2 < ip.length; i2++) {
    if ((net.network[i2] & net.mask[i2]) !== (ip[i2] & net.mask[i2])) {
      return false;
    }
  }
  return true;
}
function parseCidr(s2) {
  const [address, maskString] = s2.split("/");
  if (!address || !maskString)
    throw new Error("Failed to parse given CIDR: " + s2);
  let ipLength = IPv4Len;
  let ip = parseIPv4(address);
  if (ip == null) {
    ipLength = IPv6Len;
    ip = parseIPv6(address);
    if (ip == null)
      throw new Error("Failed to parse given CIDR: " + s2);
  }
  const m2 = parseInt(maskString, 10);
  if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
    throw new Error("Failed to parse given CIDR: " + s2);
  }
  const mask = cidrMask(m2, 8 * ipLength);
  return {
    network: maskIp(ip, mask),
    mask
  };
}
function cidrMask(ones, bits) {
  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)
    throw new Error("Invalid CIDR mask");
  if (ones < 0 || ones > bits)
    throw new Error("Invalid CIDR mask");
  const l2 = bits / 8;
  const m2 = new Uint8Array(l2);
  for (let i2 = 0; i2 < l2; i2++) {
    if (ones >= 8) {
      m2[i2] = 255;
      ones -= 8;
      continue;
    }
    m2[i2] = 255 - (255 >> ones);
    ones = 0;
  }
  return m2;
}
class IpNet {
  /**
   *
   * @param ipOrCidr either network ip or full cidr address
   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
   */
  constructor(ipOrCidr, mask) {
    if (mask == null) {
      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
    } else {
      const ipResult = parseIP(ipOrCidr);
      if (ipResult == null) {
        throw new Error("Failed to parse network");
      }
      mask = String(mask);
      const m2 = parseInt(mask, 10);
      if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
        const maskResult = parseIP(mask);
        if (maskResult == null) {
          throw new Error("Failed to parse mask");
        }
        this.mask = maskResult;
      } else {
        this.mask = cidrMask(m2, 8 * ipResult.length);
      }
      this.network = maskIp(ipResult, this.mask);
    }
  }
  /**
   * Checks if netmask contains ip address
   * @param ip
   * @returns
   */
  contains(ip) {
    return containsIp({ network: this.network, mask: this.mask }, ip);
  }
  /**Serializes back to string format */
  toString() {
    const l2 = simpleMaskLength(this.mask);
    const mask = l2 !== -1 ? String(l2) : maskToHex(this.mask);
    return ipToString(this.network) + "/" + mask;
  }
}
function cidrContains(cidr, ip) {
  const ipnet = new IpNet(cidr);
  return ipnet.contains(ip);
}
function isGlobalUnicast(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip6":
        return cidrContains("2000::/3", config.host);
      default:
        return false;
    }
  } catch {
    return false;
  }
}
function isLinkLocal(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
        return config.host.startsWith("169.254.");
      case "ip6":
        return config.host.toLowerCase().startsWith("fe80");
      default:
        return false;
    }
  } catch (err) {
    return false;
  }
}
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}
function isLoopback(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
      case "ip6":
        return isLoopbackAddr(config.host);
      default:
        return false;
    }
  } catch {
    return false;
  }
}
function isNetworkAddress(ma) {
  try {
    getNetConfig(ma);
    return true;
  } catch {
    return false;
  }
}
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a2, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a2;
}
var Netmask_1;
(function() {
  var Netmask, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a2, b, c2, d2;
    a2 = (long & 255 << 24) >>> 24;
    b = (long & 255 << 16) >>> 16;
    c2 = (long & 255 << 8) >>> 8;
    d2 = long & 255;
    return [a2, b, c2, d2].join(".");
  };
  ip2long = function(ip) {
    var b, c2, i2, j, n2, ref;
    b = [];
    for (i2 = j = 0; j <= 3; i2 = ++j) {
      if (ip.length === 0) {
        break;
      }
      if (i2 > 0) {
        if (ip[0] !== ".") {
          throw new Error("Invalid IP");
        }
        ip = ip.substring(1);
      }
      ref = atob2(ip), n2 = ref[0], c2 = ref[1];
      ip = ip.substring(c2);
      b.push(n2);
    }
    if (ip.length !== 0) {
      throw new Error("Invalid IP");
    }
    switch (b.length) {
      case 1:
        if (b[0] > 4294967295) {
          throw new Error("Invalid IP");
        }
        return b[0] >>> 0;
      case 2:
        if (b[0] > 255 || b[1] > 16777215) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1]) >>> 0;
      case 3:
        if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
      case 4:
        if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  };
  chr = function(b) {
    return b.charCodeAt(0);
  };
  chr0 = chr("0");
  chra = chr("a");
  chrA = chr("A");
  atob2 = function(s2) {
    var base3, dmax, i2, n2, start2;
    n2 = 0;
    base3 = 10;
    dmax = "9";
    i2 = 0;
    if (s2.length > 1 && s2[i2] === "0") {
      if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
        i2 += 2;
        base3 = 16;
      } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
        i2++;
        base3 = 8;
        dmax = "7";
      }
    }
    start2 = i2;
    while (i2 < s2.length) {
      if ("0" <= s2[i2] && s2[i2] <= dmax) {
        n2 = n2 * base3 + (chr(s2[i2]) - chr0) >>> 0;
      } else if (base3 === 16) {
        if ("a" <= s2[i2] && s2[i2] <= "f") {
          n2 = n2 * base3 + (10 + chr(s2[i2]) - chra) >>> 0;
        } else if ("A" <= s2[i2] && s2[i2] <= "F") {
          n2 = n2 * base3 + (10 + chr(s2[i2]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n2 > 4294967295) {
        throw new Error("too large");
      }
      i2++;
    }
    if (i2 === start2) {
      throw new Error("empty octet");
    }
    return [n2, i2];
  };
  Netmask = function() {
    function Netmask2(net, mask) {
      var i2, j, ref;
      if (typeof net !== "string") {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref = net.split("/", 2), net = ref[0], mask = ref[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === "string" && mask.indexOf(".") > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i2 = j = 32; j >= 0; i2 = --j) {
          if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
            this.bitmask = i2;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask2.prototype.contains = function(ip) {
      if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
        ip = new Netmask2(ip);
      }
      if (ip instanceof Netmask2) {
        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
      } else {
        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask2.prototype.next = function(count) {
      if (count == null) {
        count = 1;
      }
      return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
    };
    Netmask2.prototype.forEach = function(fn) {
      var index, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index);
        index++;
        long++;
      }
    };
    Netmask2.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask2;
  }();
  Netmask_1 = Netmask;
}).call(commonjsGlobal);
const PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
const NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new Netmask_1(ipRange));
function ipv4Check(ipAddr) {
  for (const r2 of NETMASK_RANGES) {
    if (r2.contains(ipAddr)) {
      return true;
    }
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip)) {
    return ipv4Check(ip);
  }
  if (isIpv4MappedIpv6(ip)) {
    return ipv4MappedIpv6Check(ip);
  }
  if (isIpv4EmbeddedIpv6(ip)) {
    return ipv4EmbeddedIpv6Check(ip);
  }
  if (isIPv6(ip)) {
    return ipv6Check(ip);
  }
}
function isPrivate(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
      case "ip6":
        return isPrivateIp(config.host) ?? false;
      default:
        return config.host === "localhost";
    }
  } catch {
    return false;
  }
}
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}
class FixedFIFO {
  buffer;
  mask;
  top;
  btm;
  next;
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO {
  size;
  hwm;
  head;
  tail;
  constructor(options = {}) {
    this.hwm = options.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
let AbortError$5 = class AbortError2 extends Error {
  type;
  code;
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};
function pushable(options = {}) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer.isEmpty()) {
        return getNext(buffer);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer.push(next);
          try {
            resolve(getNext(buffer));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push2 = (value2) => {
    if (ended) {
      return pushable2;
    }
    if (options?.objectMode !== true && value2?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push: push2,
    end,
    get readableLength() {
      return buffer.size;
    },
    onEmpty: async (options2) => {
      const signal = options2?.signal;
      signal?.throwIfAborted();
      if (buffer.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError$5());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal?.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push: push2,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}
let TimeoutError$1 = class TimeoutError2 extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
let AbortError$4 = class AbortError3 extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError$4(errorMessage) : new DOMException(errorMessage);
const getAbortedReason$1 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout$1(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason$1(signal));
      }
      abortHandler = () => {
        reject(getAbortedReason$1(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError$1();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && options.signal) {
      options.signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
const normalizeEmitter = (emitter) => {
  const addListener2 = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener2 = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener2 || !removeListener2) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener2.bind(emitter),
    removeListener: removeListener2.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      rejectionMultiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    options.signal?.throwIfAborted();
    const events = [event].flat();
    const items = [];
    const { addListener: addListener2, removeListener: removeListener2 } = normalizeEmitter(emitter);
    const onItem = async (...arguments_) => {
      const value2 = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter) {
        try {
          if (!await options.filter(value2)) {
            return;
          }
        } catch (error) {
          cancel();
          reject(error);
          return;
        }
      }
      items.push(value2);
      if (options.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (...arguments_) => {
      cancel();
      reject(options.rejectionMultiArgs ? arguments_ : arguments_[0]);
    };
    cancel = () => {
      for (const event2 of events) {
        removeListener2(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        if (!events.includes(rejectionEvent)) {
          removeListener2(rejectionEvent, rejectHandler);
        }
      }
    };
    for (const event2 of events) {
      addListener2(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      if (!events.includes(rejectionEvent)) {
        addListener2(rejectionEvent, rejectHandler);
      }
    }
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        rejectHandler(options.signal.reason);
      }, { once: true });
    }
    if (options.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout$1(returnValue, { milliseconds: options.timeout });
    timeout.cancel = () => {
      cancel();
      timeout.clear();
    };
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}
function debounce$1(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}
class RateLimitError extends Error {
  remainingPoints;
  msBeforeNext;
  consumedPoints;
  isFirstInDuration;
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
}
let QueueFullError$1 = class QueueFullError extends Error {
  static name = "QueueFullError";
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
let UnexpectedEOFError$1 = class UnexpectedEOFError extends Error {
  static name = "UnexpectedEOFError";
  name = "UnexpectedEOFError";
};
class MaxEarlyStreamsError extends Error {
  static name = "MaxEarlyStreamsError";
  name = "MaxEarlyStreamsError";
}
class StreamClosedError extends Error {
  static name = "StreamClosedError";
  name = "StreamClosedError";
}
function defaultTranslate(signal) {
  return signal.reason;
}
async function raceSignal$2(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  const translateError = defaultTranslate;
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(translateError(signal));
  }
  let listener;
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(translateError(signal));
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}
let JobRecipient$1 = class JobRecipient {
  deferred;
  signal;
  constructor(signal) {
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError$6());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};
function randomId$1() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
let Job$1 = class Job {
  id;
  fn;
  options;
  recipients;
  status;
  timeline;
  controller;
  constructor(fn, options) {
    this.id = randomId$1();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError$6());
      this.cleanup();
    }
  }
  async join(options = {}) {
    const recipient = new JobRecipient$1(options.signal);
    this.recipients.push(recipient);
    options.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal$2(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};
let Queue$1 = class Queue extends TypedEventEmitter {
  concurrency;
  maxSize;
  queue;
  pending;
  sort;
  paused;
  constructor(init3 = {}) {
    super();
    this.concurrency = init3.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init3.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.paused = false;
    if (init3.metricName != null) {
      init3.metrics?.registerMetricGroup(init3.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init3.sort;
    this.queue = [];
    this.emitEmpty = debounce$1(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce$1(this.emitIdle.bind(this), 1);
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  pause() {
    this.paused = true;
  }
  resume() {
    if (!this.paused) {
      return;
    }
    this.paused = false;
    this.tryToStartAnother();
  }
  tryToStartAnother() {
    if (this.paused) {
      return false;
    }
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    options?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError$1();
    }
    const job = new Job$1(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError$6());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await pEvent(this, "empty", options);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await pEvent(this, "next", {
      ...options,
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await pEvent(this, "idle", options);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    options?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueFailure = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError$6("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("failure", onQueueFailure);
    this.addEventListener("idle", onQueueIdle);
    options?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("failure", onQueueFailure);
      this.removeEventListener("idle", onQueueIdle);
      options?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};
const DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4;
class AbstractMessageStream extends TypedEventEmitter {
  status;
  timeline;
  inactivityTimeout;
  maxReadBufferLength;
  maxWriteBufferLength;
  log;
  direction;
  maxMessageSize;
  readStatus;
  writeStatus;
  remoteReadStatus;
  remoteWriteStatus;
  writableNeedsDrain;
  /**
   * Any data stored here is emitted before any new incoming data.
   *
   * This is used when the stream is paused or if data is pushed onto the stream
   */
  readBuffer;
  writeBuffer;
  sendingData;
  onDrainPromise;
  constructor(init3) {
    super();
    this.status = "open";
    this.log = init3.log;
    this.direction = init3.direction ?? "outbound";
    this.inactivityTimeout = init3.inactivityTimeout ?? 12e4;
    this.maxReadBufferLength = init3.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH;
    this.maxWriteBufferLength = init3.maxWriteBufferLength;
    this.maxMessageSize = init3.maxMessageSize;
    this.readBuffer = new Uint8ArrayList();
    this.writeBuffer = new Uint8ArrayList();
    this.readStatus = "readable";
    this.remoteReadStatus = "readable";
    this.writeStatus = "writable";
    this.remoteWriteStatus = "writable";
    this.sendingData = false;
    this.writableNeedsDrain = false;
    this.timeline = {
      open: Date.now()
    };
    this.processSendQueue = this.processSendQueue.bind(this);
    const continueSendingOnDrain = () => {
      if (this.writableNeedsDrain) {
        this.log.trace("drain event received, continue sending data");
        this.writableNeedsDrain = false;
        this.processSendQueue();
      }
      this.onDrainPromise?.resolve();
    };
    this.addEventListener("drain", continueSendingOnDrain);
    const rejectOnDrainOnClose = (evt) => {
      this.onDrainPromise?.reject(evt.error ?? new StreamClosedError());
    };
    this.addEventListener("close", rejectOnDrainOnClose);
  }
  get readBufferLength() {
    return this.readBuffer.byteLength;
  }
  get writeBufferLength() {
    return this.writeBuffer.byteLength;
  }
  async onDrain(options) {
    if (this.writableNeedsDrain !== true) {
      return Promise.resolve();
    }
    if (this.onDrainPromise == null) {
      this.onDrainPromise = Promise.withResolvers();
    }
    return raceSignal$2(this.onDrainPromise.promise, options?.signal);
  }
  async *[Symbol.asyncIterator]() {
    if (this.readStatus !== "readable" && this.readStatus !== "paused") {
      return;
    }
    const output = pushable();
    const streamAsyncIterableOnMessageListener = (evt) => {
      output.push(evt.data);
    };
    this.addEventListener("message", streamAsyncIterableOnMessageListener);
    const streamAsyncIterableOnCloseListener = (evt) => {
      output.end(evt.error);
    };
    this.addEventListener("close", streamAsyncIterableOnCloseListener);
    const streamAsyncIterableOnRemoteCloseWriteListener = () => {
      output.end();
    };
    this.addEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
    try {
      yield* output;
    } finally {
      this.removeEventListener("message", streamAsyncIterableOnMessageListener);
      this.removeEventListener("close", streamAsyncIterableOnCloseListener);
      this.removeEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
    }
  }
  isReadable() {
    return this.status === "open";
  }
  send(data) {
    if (this.writeStatus === "closed" || this.writeStatus === "closing") {
      throw new StreamStateError(`Cannot write to a stream that is ${this.writeStatus}`);
    }
    this.log.trace("append %d bytes to write buffer", data.byteLength);
    this.writeBuffer.append(data);
    return this.processSendQueue();
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    if (this.status === "aborted" || this.status === "reset" || this.status === "closed") {
      return;
    }
    this.log.error("abort with error - %e", err);
    this.status = "aborted";
    if (this.readBuffer.byteLength > 0) {
      this.readBuffer.consume(this.readBuffer.byteLength);
    }
    if (this.writeBuffer.byteLength > 0) {
      this.writeBuffer.consume(this.writeBuffer.byteLength);
      this.safeDispatchEvent("idle");
    }
    this.writeStatus = "closed";
    this.remoteWriteStatus = "closed";
    this.readStatus = "closed";
    this.remoteReadStatus = "closed";
    this.timeline.close = Date.now();
    try {
      this.sendReset(err);
    } catch (err2) {
      this.log("failed to send reset to remote - %e", err2);
    }
    this.dispatchEvent(new StreamAbortEvent(err));
  }
  pause() {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError("Cannot pause a stream that is closing/closed");
    }
    if (this.readStatus === "paused") {
      return;
    }
    this.readStatus = "paused";
    this.sendPause();
  }
  resume() {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError("Cannot resume a stream that is closing/closed");
    }
    if (this.readStatus === "readable") {
      return;
    }
    this.readStatus = "readable";
    this.dispatchReadBuffer();
    this.sendResume();
  }
  push(data) {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`);
    }
    if (data.byteLength === 0) {
      return;
    }
    this.readBuffer.append(data);
    if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
      this.checkReadBufferLength();
      return;
    }
    setTimeout(() => {
      this.dispatchReadBuffer();
    }, 0);
  }
  unshift(data) {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError(`Cannot push data onto a stream that is ${this.readStatus}`);
    }
    if (data.byteLength === 0) {
      return;
    }
    this.readBuffer.prepend(data);
    if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
      this.checkReadBufferLength();
      return;
    }
    setTimeout(() => {
      this.dispatchReadBuffer();
    }, 0);
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  onData(data) {
    if (data.byteLength === 0) {
      return;
    }
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("ignoring data - read status %s", this.readStatus);
      return;
    }
    this.readBuffer.append(data);
    this.dispatchReadBuffer();
  }
  addEventListener(...args) {
    super.addEventListener.apply(this, args);
    if (args[0] === "message" && this.readBuffer.byteLength > 0) {
      queueMicrotask(() => {
        this.dispatchReadBuffer();
      });
    }
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  onRemoteReset() {
    this.log("remote reset");
    this.status = "reset";
    this.writeStatus = "closed";
    this.remoteWriteStatus = "closed";
    this.remoteReadStatus = "closed";
    this.timeline.close = Date.now();
    if (this.readBuffer.byteLength === 0) {
      this.readStatus = "closed";
    }
    const err = new StreamResetError();
    this.dispatchEvent(new StreamResetEvent(err));
  }
  /**
   * The underlying resource or transport this stream uses has closed - it is
   * not possible to send any more messages though any data still in the read
   * buffer may still be read
   */
  onTransportClosed(err) {
    this.log("transport closed");
    if (this.readStatus === "readable" && this.readBuffer.byteLength === 0) {
      this.log("close readable end after transport closed and read buffer is empty");
      this.readStatus = "closed";
    }
    if (this.remoteReadStatus !== "closed") {
      this.remoteReadStatus = "closed";
    }
    if (this.remoteWriteStatus !== "closed") {
      this.remoteWriteStatus = "closed";
    }
    if (this.writeStatus !== "closed") {
      this.writeStatus = "closed";
    }
    if (err != null) {
      this.abort(err);
    } else {
      if (this.status === "open" || this.status === "closing") {
        this.timeline.close = Date.now();
        this.status = "closed";
        this.writeStatus = "closed";
        this.remoteWriteStatus = "closed";
        this.remoteReadStatus = "closed";
        this.dispatchEvent(new StreamCloseEvent());
      }
    }
  }
  /**
   * Called by extending classes when the remote closes its writable end
   */
  onRemoteCloseWrite() {
    if (this.remoteWriteStatus === "closed") {
      return;
    }
    this.log.trace("on remote close write");
    this.remoteWriteStatus = "closed";
    this.safeDispatchEvent("remoteCloseWrite");
    if (this.writeStatus === "closed") {
      this.onTransportClosed();
    }
  }
  /**
   * Called by extending classes when the remote closes its readable end
   */
  onRemoteCloseRead() {
    this.log.trace("on remote close read");
    this.remoteReadStatus = "closed";
    if (this.writeBuffer.byteLength > 0) {
      this.writeBuffer.consume(this.writeBuffer.byteLength);
      this.safeDispatchEvent("idle");
    }
  }
  processSendQueue() {
    if (this.writableNeedsDrain) {
      this.log.trace("not processing send queue as drain is required");
      this.checkWriteBufferLength();
      return false;
    }
    if (this.writeBuffer.byteLength === 0) {
      this.log.trace("not processing send queue as no bytes to send");
      return true;
    }
    if (this.sendingData) {
      this.log.trace("not processing send queue as already sending data");
      return true;
    }
    this.sendingData = true;
    this.log.trace("processing send queue with %d queued bytes", this.writeBuffer.byteLength);
    try {
      let canSendMore = true;
      const totalBytes = this.writeBuffer.byteLength;
      let sentBytes = 0;
      while (this.writeBuffer.byteLength > 0) {
        const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength);
        if (end === 0) {
          canSendMore = false;
          break;
        }
        const toSend = this.writeBuffer.sublist(0, end);
        const willSend = new Uint8ArrayList(toSend);
        this.writeBuffer.consume(toSend.byteLength);
        const sendResult = this.sendData(toSend);
        canSendMore = sendResult.canSendMore;
        sentBytes += sendResult.sentBytes;
        if (sendResult.sentBytes !== willSend.byteLength) {
          willSend.consume(sendResult.sentBytes);
          this.writeBuffer.prepend(willSend);
        }
        if (!canSendMore) {
          break;
        }
      }
      if (!canSendMore) {
        this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer", sentBytes, totalBytes, this.writeBuffer.byteLength);
        this.writableNeedsDrain = true;
        this.checkWriteBufferLength();
      }
      if (this.writeBuffer.byteLength === 0) {
        this.safeDispatchEvent("idle");
      }
      return canSendMore;
    } finally {
      this.sendingData = false;
    }
  }
  dispatchReadBuffer() {
    try {
      if (this.listenerCount("message") === 0) {
        this.log.trace("not dispatching pause buffer as there are no listeners for the message event");
        return;
      }
      if (this.readBuffer.byteLength === 0) {
        this.log.trace("not dispatching pause buffer as there is no data to dispatch");
        return;
      }
      if (this.readStatus === "paused") {
        this.log.trace("not dispatching pause buffer we are paused");
        return;
      }
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("dropping %d bytes because the readable end is %s", this.readBuffer.byteLength, this.readStatus);
        this.readBuffer.consume(this.readBuffer.byteLength);
        return;
      }
      const buf = this.readBuffer.sublist();
      this.readBuffer.consume(buf.byteLength);
      this.dispatchEvent(new StreamMessageEvent(buf));
    } finally {
      if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === "closed") {
        this.log("close readable end after dispatching read buffer and remote writable end is closed");
        this.readStatus = "closed";
      }
      this.checkReadBufferLength();
    }
  }
  checkReadBufferLength() {
    if (this.readBuffer.byteLength > this.maxReadBufferLength) {
      this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`));
    }
  }
  checkWriteBufferLength() {
    if (this.maxWriteBufferLength == null) {
      return;
    }
    if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {
      this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`));
    }
  }
  onMuxerNeedsDrain() {
    this.writableNeedsDrain = true;
  }
  onMuxerDrain() {
    this.safeDispatchEvent("drain");
  }
}
class AbstractMultiaddrConnection extends AbstractMessageStream {
  remoteAddr;
  metricPrefix;
  metrics;
  constructor(init3) {
    super(init3);
    this.metricPrefix = init3.metricPrefix ?? "";
    this.metrics = init3.metrics;
    this.remoteAddr = init3.remoteAddr;
    this.addEventListener("close", (evt) => {
      this.metrics?.increment({ [`${this.metricPrefix}end`]: true });
      if (evt.error != null) {
        if (evt.local) {
          this.metrics?.increment({ [`${this.metricPrefix}abort`]: true });
        } else {
          this.metrics?.increment({ [`${this.metricPrefix}reset`]: true });
        }
      } else {
        if (evt.local) {
          this.metrics?.increment({ [`${this.metricPrefix}_local_close`]: true });
        } else {
          this.metrics?.increment({ [`${this.metricPrefix}_remote_close`]: true });
        }
      }
    });
  }
  async close(options) {
    if (this.status !== "open") {
      return;
    }
    this.status = "closing";
    this.writeStatus = "closing";
    this.remoteWriteStatus = "closing";
    this.remoteReadStatus = "closing";
    if (this.sendingData || this.writeBuffer.byteLength > 0) {
      this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "idle", {
        ...options,
        rejectionEvents: [
          "close"
        ]
      });
    }
    if (this.writableNeedsDrain) {
      this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "drain", {
        ...options,
        rejectionEvents: [
          "close"
        ]
      });
    }
    await this.sendClose(options);
    this.onTransportClosed();
  }
}
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
class AbstractStreamMuxer extends TypedEventEmitter {
  streams;
  protocol;
  status;
  log;
  maConn;
  streamOptions;
  earlyStreams;
  maxEarlyStreams;
  metrics;
  constructor(maConn, init3) {
    super();
    this.maConn = maConn;
    this.protocol = init3.protocol;
    this.streams = [];
    this.earlyStreams = [];
    this.status = "open";
    this.log = maConn.log.newScope(init3.name);
    this.streamOptions = init3.streamOptions;
    this.maxEarlyStreams = init3.maxEarlyStreams ?? 10;
    this.metrics = init3.metrics;
    const muxerMaConnOnMessage = (evt) => {
      try {
        this.onData(evt.data);
      } catch (err) {
        this.abort(err);
        this.maConn.abort(err);
      }
    };
    this.maConn.addEventListener("message", muxerMaConnOnMessage);
    const muxerMaConnOnDrain = () => {
      this.log("underlying stream drained, signal %d streams to continue writing", this.streams.length);
      this.streams.forEach((stream) => {
        stream.onMuxerDrain();
      });
    };
    this.maConn.addEventListener("drain", muxerMaConnOnDrain);
    const muxerOnMaConnClose = () => {
      this.log("underlying stream closed with status %s and %d streams", this.status, this.streams.length);
      this.onTransportClosed();
    };
    this.maConn.addEventListener("close", muxerOnMaConnClose);
  }
  send(data) {
    const result = this.maConn.send(data);
    if (result === false) {
      this.log("underlying stream saturated, signal %d streams to pause writing", this.streams.length);
      this.streams.forEach((stream) => {
        stream.onMuxerNeedsDrain();
      });
    }
    return result;
  }
  async close(options) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.status = "closing";
    await raceSignal$2(Promise.all([...this.streams].map(async (s2) => {
      await s2.close(options);
    })), options?.signal);
    this.status = "closed";
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.status = "closing";
    [...this.streams].forEach((s2) => {
      s2.abort(err);
    });
    this.status = "closed";
  }
  onTransportClosed(err) {
    this.status = "closing";
    try {
      [...this.streams].forEach((stream) => {
        stream.onTransportClosed(err);
      });
    } catch (err2) {
      this.abort(err2);
    }
    this.status = "closed";
  }
  async createStream(options) {
    if (this.status !== "open") {
      throw new MuxerClosedError();
    }
    let stream = this.onCreateStream({
      ...this.streamOptions,
      ...options
    });
    if (isPromise(stream)) {
      stream = await stream;
    }
    this.streams.push(stream);
    this.cleanUpStream(stream);
    return stream;
  }
  /**
   * Extending classes should invoke this method when a new stream was created
   * by the remote muxer
   */
  onRemoteStream(stream) {
    this.streams.push(stream);
    this.cleanUpStream(stream);
    if (this.listenerCount("stream") === 0) {
      this.earlyStreams.push(stream);
      if (this.earlyStreams.length > this.maxEarlyStreams) {
        this.abort(new MaxEarlyStreamsError(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));
      }
      return;
    }
    this.safeDispatchEvent("stream", {
      detail: stream
    });
  }
  cleanUpStream(stream) {
    const muxerOnStreamEnd = (evt) => {
      const index = this.streams.findIndex((s2) => s2 === stream);
      if (index !== -1) {
        this.streams.splice(index, 1);
      }
      if (evt.error != null) {
        if (evt.local) {
          this.metrics?.increment({ [`${stream.direction}_stream_reset`]: true });
        } else {
          this.metrics?.increment({ [`${stream.direction}_stream_abort`]: true });
        }
      } else {
        this.metrics?.increment({ [`${stream.direction}_stream_end`]: true });
      }
    };
    stream.addEventListener("close", muxerOnStreamEnd);
    this.metrics?.increment({ [`${stream.direction}_stream`]: true });
  }
  addEventListener(...args) {
    super.addEventListener.apply(this, args);
    if (args[0] === "stream" && this.earlyStreams.length > 0) {
      queueMicrotask(() => {
        this.earlyStreams.forEach((stream) => {
          this.safeDispatchEvent("stream", {
            detail: stream
          });
        });
        this.earlyStreams = [];
      });
    }
  }
}
class AbstractStream extends AbstractMessageStream {
  id;
  protocol;
  constructor(init3) {
    super(init3);
    this.id = init3.id;
    this.protocol = init3.protocol ?? "";
  }
  async close(options) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.writeStatus = "closing";
    if (this.sendingData || this.writeBuffer.byteLength > 0) {
      this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "idle", {
        ...options,
        rejectionEvents: [
          "close"
        ]
      });
    }
    if (this.writableNeedsDrain) {
      this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
      await pEvent(this, "drain", {
        ...options,
        rejectionEvents: [
          "close"
        ]
      });
      this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
    }
    await this.sendCloseWrite(options);
    this.writeStatus = "closed";
    this.log("closed writable end gracefully");
    if (this.remoteWriteStatus === "closed") {
      this.onTransportClosed();
    }
  }
  async closeRead(options) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    if (this.readBuffer.byteLength > 0) {
      this.readBuffer.consume(this.readBuffer.byteLength);
    }
    this.readStatus = "closing";
    await this.sendCloseRead(options);
    this.readStatus = "closed";
    this.log("closed readable end gracefully");
  }
}
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear2() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear2;
  return signal;
}
class MovingAverage {
  movingAverage;
  variance;
  deviation;
  forecast;
  timeSpan;
  previousTime;
  constructor(timeSpan) {
    this.timeSpan = timeSpan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t2, pt) {
    return 1 - Math.exp(-(t2 - pt) / this.timeSpan);
  }
  push(value2, time = Date.now()) {
    if (this.previousTime != null) {
      const a2 = this.alpha(time, this.previousTime);
      const diff = value2 - this.movingAverage;
      const incr = a2 * diff;
      this.movingAverage = a2 * value2 + (1 - a2) * this.movingAverage;
      this.variance = (1 - a2) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a2 * diff;
    } else {
      this.movingAverage = value2;
    }
    this.previousTime = time;
  }
}
const DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
const DEFAULT_FAILURE_MULTIPLIER = 2;
const DEFAULT_MIN_TIMEOUT = 5e3;
const DEFAULT_MAX_TIMEOUT = 6e4;
const DEFAULT_INTERVAL = 5e3;
class AdaptiveTimeout {
  success;
  failure;
  next;
  metric;
  timeoutMultiplier;
  failureMultiplier;
  minTimeout;
  maxTimeout;
  constructor(init3 = {}) {
    const interval = init3.interval ?? DEFAULT_INTERVAL;
    this.success = new MovingAverage(interval);
    this.failure = new MovingAverage(interval);
    this.next = new MovingAverage(interval);
    this.failureMultiplier = init3.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init3.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init3.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    this.maxTimeout = init3.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
    if (init3.metricName != null) {
      this.metric = init3.metrics?.registerMetricGroup(init3.metricName);
    }
  }
  getTimeoutSignal(options = {}) {
    let timeout = Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier));
    if (timeout < this.minTimeout) {
      timeout = this.minTimeout;
    }
    if (timeout > this.maxTimeout) {
      timeout = this.maxTimeout;
    }
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal([options.signal, sendTimeout]);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      this.metric?.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      this.metric?.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
}
class InvalidMultiaddrError2 extends Error {
  static name = "InvalidMultiaddrError";
  name = "InvalidMultiaddrError";
}
class ValidationError extends Error {
  static name = "ValidationError";
  name = "ValidationError";
}
class InvalidParametersError2 extends Error {
  static name = "InvalidParametersError";
  name = "InvalidParametersError";
}
class UnknownProtocolError extends Error {
  static name = "UnknownProtocolError";
  name = "UnknownProtocolError";
}
const CODE_IP4 = 4;
const CODE_TCP = 6;
const CODE_UDP = 273;
const CODE_DCCP = 33;
const CODE_IP6 = 41;
const CODE_IP6ZONE = 42;
const CODE_IPCIDR = 43;
const CODE_DNS = 53;
const CODE_DNS4 = 54;
const CODE_DNS6 = 55;
const CODE_DNSADDR = 56;
const CODE_SCTP = 132;
const CODE_UDT = 301;
const CODE_UTP = 302;
const CODE_UNIX = 400;
const CODE_P2P = 421;
const CODE_ONION = 444;
const CODE_ONION3 = 445;
const CODE_GARLIC64 = 446;
const CODE_GARLIC32 = 447;
const CODE_TLS = 448;
const CODE_SNI = 449;
const CODE_NOISE = 454;
const CODE_QUIC = 460;
const CODE_QUIC_V1 = 461;
const CODE_WEBTRANSPORT = 465;
const CODE_CERTHASH = 466;
const CODE_HTTP = 480;
const CODE_HTTP_PATH = 481;
const CODE_HTTPS = 443;
const CODE_WS = 477;
const CODE_WSS = 478;
const CODE_P2P_WEBSOCKET_STAR = 479;
const CODE_P2P_STARDUST = 277;
const CODE_P2P_WEBRTC_STAR = 275;
const CODE_P2P_WEBRTC_DIRECT = 276;
const CODE_WEBRTC_DIRECT = 280;
const CODE_WEBRTC = 281;
const CODE_P2P_CIRCUIT = 290;
const CODE_MEMORY = 777;
function bytesToString(base3) {
  return (buf) => {
    return toString$1(buf, base3);
  };
}
function stringToBytes(base3) {
  return (buf) => {
    return fromString(buf, base3);
  };
}
function bytes2port(buf) {
  const view = new DataView(buf.buffer);
  return view.getUint16(buf.byteOffset).toString();
}
function port2bytes(port) {
  const buf = new ArrayBuffer(2);
  const view = new DataView(buf);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf);
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf = fromString(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
  const addrBytes = buf.subarray(0, buf.length - 2);
  const portBytes = buf.subarray(buf.length - 2);
  const addr = toString$1(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
const ip4ToBytes = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value2 = parseInt(byte, 10);
    if (isNaN(value2) || value2 < 0 || value2 > 255) {
      throw new InvalidMultiaddrError2("Invalid byte value in IP address");
    }
    bytes[index] = value2;
  });
  return bytes;
};
const ip6ToBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i2;
  for (i2 = 0; i2 < sections.length; i2++) {
    const isv4 = isIPv4(sections[i2]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes(sections[i2]);
      sections[i2] = toString$1(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i2 < 8) {
      sections.splice(i2, 0, toString$1(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++) {
    }
    const argv = [i2, 1];
    for (i2 = 9 - sections.length; i2 > 0; i2--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i2 = 0; i2 < sections.length; i2++) {
    if (sections[i2] === "") {
      sections[i2] = "0";
    }
    const word = parseInt(sections[i2], 16);
    if (isNaN(word) || word < 0 || word > 65535) {
      throw new InvalidMultiaddrError2("Invalid byte value in IP address");
    }
    bytes[offset++] = word >> 8 & 255;
    bytes[offset++] = word & 255;
  }
  return bytes;
};
const ip4ToString = function(buf) {
  if (buf.byteLength !== 4) {
    throw new InvalidMultiaddrError2("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf.byteLength; i2++) {
    result.push(buf[i2]);
  }
  return result.join(".");
};
const ip6ToString = function(buf) {
  if (buf.byteLength !== 16) {
    throw new InvalidMultiaddrError2("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf.byteLength; i2 += 2) {
    const byte1 = buf[i2];
    const byte2 = buf[i2 + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError2(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError2(`Invalid IPv6 address "${str}"`);
  }
}
const decoders = Object.values(bases).map((c2) => c2.decoder);
const anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function mb2bytes(mbstr) {
  return anybaseDecoder.decode(mbstr);
}
function bytes2mb(base3) {
  return (buf) => {
    return base3.encoder.encode(buf);
  };
}
function integer(value2) {
  const int = parseInt(value2);
  if (int.toString() !== value2) {
    throw new ValidationError("Value must be an integer");
  }
}
function positive(value2) {
  if (value2 < 0) {
    throw new ValidationError("Value must be a positive integer, or zero");
  }
}
function maxValue(max) {
  return (value2) => {
    if (value2 > max) {
      throw new ValidationError(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate$1(...funcs) {
  return (value2) => {
    for (const fn of funcs) {
      fn(value2);
    }
  };
}
const validatePort = validate$1(integer, positive, maxValue(65535));
const V = -1;
class Registry {
  protocolsByCode = /* @__PURE__ */ new Map();
  protocolsByName = /* @__PURE__ */ new Map();
  getProtocol(key2) {
    let codec;
    if (typeof key2 === "string") {
      codec = this.protocolsByName.get(key2);
    } else {
      codec = this.protocolsByCode.get(key2);
    }
    if (codec == null) {
      throw new UnknownProtocolError(`Protocol ${key2} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code2) {
    const codec = this.protocolsByCode.get(code2);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
}
const registry = new Registry();
const codecs = [{
  code: CODE_IP4,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes,
  bytesToValue: ip4ToString,
  validate: (value2) => {
    if (!isIPv4(value2)) {
      throw new ValidationError(`Invalid IPv4 address "${value2}"`);
    }
  }
}, {
  code: CODE_TCP,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDP,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_DCCP,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_IP6,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes,
  bytesToValue: ip6ToString,
  stringToValue: ip6StringToValue,
  validate: (value2) => {
    if (!isIPv6(value2)) {
      throw new ValidationError(`Invalid IPv6 address "${value2}"`);
    }
  }
}, {
  code: CODE_IP6ZONE,
  name: "ip6zone",
  size: V
}, {
  code: CODE_IPCIDR,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString("base10"),
  valueToBytes: stringToBytes("base10")
}, {
  code: CODE_DNS,
  name: "dns",
  size: V
}, {
  code: CODE_DNS4,
  name: "dns4",
  size: V
}, {
  code: CODE_DNS6,
  name: "dns6",
  size: V
}, {
  code: CODE_DNSADDR,
  name: "dnsaddr",
  size: V
}, {
  code: CODE_SCTP,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDT,
  name: "udt"
}, {
  code: CODE_UTP,
  name: "utp"
}, {
  code: CODE_UNIX,
  name: "unix",
  size: V,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P,
  name: "p2p",
  aliases: ["ipfs"],
  size: V,
  bytesToValue: bytesToString("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes("base58btc")(val);
    }
    return CID.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion,
  valueToBytes: onion2bytes
}, {
  code: CODE_ONION3,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion,
  valueToBytes: onion32bytes
}, {
  code: CODE_GARLIC64,
  name: "garlic64",
  size: V
}, {
  code: CODE_GARLIC32,
  name: "garlic32",
  size: V
}, {
  code: CODE_TLS,
  name: "tls"
}, {
  code: CODE_SNI,
  name: "sni",
  size: V
}, {
  code: CODE_NOISE,
  name: "noise"
}, {
  code: CODE_QUIC,
  name: "quic"
}, {
  code: CODE_QUIC_V1,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT,
  name: "webtransport"
}, {
  code: CODE_CERTHASH,
  name: "certhash",
  size: V,
  bytesToValue: bytes2mb(base64url),
  valueToBytes: mb2bytes
}, {
  code: CODE_HTTP,
  name: "http"
}, {
  code: CODE_HTTP_PATH,
  name: "http-path",
  size: V,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS,
  name: "https"
}, {
  code: CODE_WS,
  name: "ws"
}, {
  code: CODE_WSS,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY,
  name: "memory",
  size: V
}];
codecs.forEach((codec) => {
  registry.addProtocol(codec);
});
function bytesToComponents(bytes) {
  const components = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const code2 = decode$1(bytes, i2);
    const codec = registry.getProtocol(code2);
    const codeLength = encodingLength(code2);
    const size2 = sizeForAddr(codec, bytes, i2 + codeLength);
    let sizeLength = 0;
    if (size2 > 0 && codec.size === V) {
      sizeLength = encodingLength(size2);
    }
    const componentLength = codeLength + sizeLength + size2;
    const component = {
      code: code2,
      name: codec.name,
      bytes: bytes.subarray(i2, i2 + componentLength)
    };
    if (size2 > 0) {
      const valueOffset = i2 + codeLength + sizeLength;
      const valueBytes = bytes.subarray(valueOffset, valueOffset + size2);
      component.value = codec.bytesToValue?.(valueBytes) ?? toString$1(valueBytes);
    }
    components.push(component);
    i2 += componentLength;
  }
  return components;
}
function componentsToBytes(components) {
  let length3 = 0;
  const bytes = [];
  for (const component of components) {
    if (component.bytes == null) {
      const codec = registry.getProtocol(component.code);
      const codecLength = encodingLength(component.code);
      let valueBytes;
      let valueLength = 0;
      let valueLengthLength = 0;
      if (component.value != null) {
        valueBytes = codec.valueToBytes?.(component.value) ?? fromString(component.value);
        valueLength = valueBytes.byteLength;
        if (codec.size === V) {
          valueLengthLength = encodingLength(valueLength);
        }
      }
      const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
      let offset = 0;
      encodeUint8Array(component.code, bytes2, offset);
      offset += codecLength;
      if (valueBytes != null) {
        if (codec.size === V) {
          encodeUint8Array(valueLength, bytes2, offset);
          offset += valueLengthLength;
        }
        bytes2.set(valueBytes, offset);
      }
      component.bytes = bytes2;
    }
    bytes.push(component.bytes);
    length3 += component.bytes.byteLength;
  }
  return concat(bytes, length3);
}
function stringToComponents(string2) {
  if (string2.charAt(0) !== "/") {
    throw new InvalidMultiaddrError2('String multiaddr must start with "/"');
  }
  const components = [];
  let collecting = "protocol";
  let value2 = "";
  let protocol = "";
  for (let i2 = 1; i2 < string2.length; i2++) {
    const char = string2.charAt(i2);
    if (char !== "/") {
      if (collecting === "protocol") {
        protocol += string2.charAt(i2);
      } else {
        value2 += string2.charAt(i2);
      }
    }
    const ended = i2 === string2.length - 1;
    if (char === "/" || ended) {
      const codec = registry.getProtocol(protocol);
      if (collecting === "protocol") {
        if (codec.size == null || codec.size === 0) {
          components.push({
            code: codec.code,
            name: codec.name
          });
          value2 = "";
          protocol = "";
          collecting = "protocol";
          continue;
        } else if (ended) {
          throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
        }
        collecting = "value";
      } else if (collecting === "value") {
        const component = {
          code: codec.code,
          name: codec.name
        };
        if (codec.size != null && codec.size !== 0) {
          if (value2 === "") {
            throw new InvalidMultiaddrError2(`Component ${protocol} was missing value`);
          }
          component.value = codec.stringToValue?.(value2) ?? value2;
        }
        components.push(component);
        value2 = "";
        protocol = "";
        collecting = "protocol";
      }
    }
  }
  if (protocol !== "" && value2 !== "") {
    throw new InvalidMultiaddrError2("Incomplete multiaddr");
  }
  return components;
}
function componentsToString(components) {
  return `/${components.flatMap((component) => {
    if (component.value == null) {
      return component.name;
    }
    const codec = registry.getProtocol(component.code);
    if (codec == null) {
      throw new InvalidMultiaddrError2(`Unknown protocol code ${component.code}`);
    }
    return [
      component.name,
      codec.valueToString?.(component.value) ?? component.value
    ];
  }).join("/")}`;
}
function sizeForAddr(codec, bytes, offset) {
  if (codec.size == null || codec.size === 0) {
    return 0;
  }
  if (codec.size > 0) {
    return codec.size / 8;
  }
  return decode$1(bytes, offset);
}
const inspect = Symbol.for("nodejs.util.inspect.custom");
const symbol = Symbol.for("@multiformats/multiaddr");
function toComponents(addr) {
  if (addr == null) {
    addr = "/";
  }
  if (isMultiaddr(addr)) {
    return addr.getComponents();
  }
  if (addr instanceof Uint8Array) {
    return bytesToComponents(addr);
  }
  if (typeof addr === "string") {
    addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
    if (addr === "") {
      addr = "/";
    }
    return stringToComponents(addr);
  }
  if (Array.isArray(addr)) {
    return addr;
  }
  throw new InvalidMultiaddrError2("Must be a string, Uint8Array, Component[], or another Multiaddr");
}
class Multiaddr {
  [symbol] = true;
  #components;
  // cache string representation
  #string;
  // cache byte representation
  #bytes;
  constructor(addr = "/", options = {}) {
    this.#components = toComponents(addr);
    if (options.validate !== false) {
      validate(this);
    }
  }
  get bytes() {
    if (this.#bytes == null) {
      this.#bytes = componentsToBytes(this.#components);
    }
    return this.#bytes;
  }
  toString() {
    if (this.#string == null) {
      this.#string = componentsToString(this.#components);
    }
    return this.#string;
  }
  toJSON() {
    return this.toString();
  }
  getComponents() {
    return [
      ...this.#components.map((c2) => ({ ...c2 }))
    ];
  }
  encapsulate(addr) {
    const ma = new Multiaddr(addr);
    return new Multiaddr([
      ...this.#components,
      ...ma.getComponents()
    ], {
      validate: false
    });
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i2 = s2.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new InvalidParametersError2(`Address ${this.toString()} does not contain subaddress: ${addrString}`);
    }
    return new Multiaddr(s2.slice(0, i2), {
      validate: false
    });
  }
  decapsulateCode(code2) {
    let index;
    for (let i2 = this.#components.length - 1; i2 > -1; i2--) {
      if (this.#components[i2].code === code2) {
        index = i2;
        break;
      }
    }
    return new Multiaddr(this.#components.slice(0, index), {
      validate: false
    });
  }
  equals(addr) {
    return equals(this.bytes, addr.bytes);
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [inspect]() {
    return `Multiaddr(${this.toString()})`;
  }
}
function validate(addr) {
  addr.getComponents().forEach((component) => {
    const codec = registry.getProtocol(component.code);
    if (component.value == null) {
      return;
    }
    codec.validate?.(component.value);
  });
}
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol]);
}
function multiaddr(addr) {
  return new Multiaddr(addr);
}
let AbortError$3 = class AbortError4 extends Error {
  type;
  code;
  constructor(message2, code2, name2) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.name = name2 ?? "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceSignal$1(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(new AbortError$3(opts?.errorMessage, opts?.errorCode, opts?.errorName));
  }
  let listener;
  const error = new AbortError$3(opts?.errorMessage, opts?.errorCode, opts?.errorName);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}
class QueuelessPushable {
  readNext;
  haveNext;
  ended;
  nextResult;
  error;
  constructor() {
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    this.error = err;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    this.ended = true;
    this.nextResult = result;
    this.haveNext.resolve();
    return result;
  }
  async push(value2, options) {
    await this._push(value2, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value2, options) {
    if (value2 != null && this.ended) {
      throw this.error ?? new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value2 != null) {
      this.nextResult = { done: false, value: value2 };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal$1(this.readNext.promise, options?.signal, options);
  }
}
function queuelessPushable() {
  return new QueuelessPushable();
}
function isAsyncIterable$7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
async function addAllToPushable(sources, output, signal) {
  try {
    await Promise.all(sources.map(async (source) => {
      for await (const item of source) {
        await output.push(item, {
          signal
        });
        signal.throwIfAborted();
      }
    }));
    await output.end(void 0, {
      signal
    });
  } catch (err) {
    await output.end(err, {
      signal
    }).catch(() => {
    });
  }
}
async function* mergeSources(sources) {
  const controller = new AbortController();
  const output = queuelessPushable();
  addAllToPushable(sources, output, controller.signal).catch(() => {
  });
  try {
    yield* output;
  } finally {
    controller.abort();
  }
}
function* mergeSyncSources(syncSources) {
  for (const source of syncSources) {
    yield* source;
  }
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable$7(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return mergeSyncSources(syncSources);
  }
  return mergeSources(sources);
}
function pipe$1(first, ...rest) {
  if (first == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first)) {
    const duplex = first;
    first = () => duplex.source;
  } else if (isIterable(first) || isAsyncIterable$6(first)) {
    const source = first;
    first = () => source;
  }
  const fns = [first, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
const rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
const isAsyncIterable$6 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
const isIterable = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
const isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
const duplexPipelineFn = (duplex) => {
  return (source) => {
    const p2 = duplex.sink(source);
    if (p2?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p2.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable$6(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return merge(stream, sourceWrap());
    }
    return duplex.source;
  };
};
const DEFAULT_MAX_BUFFER_SIZE$1 = 4194304;
class UnwrappedError extends Error {
  static name = "UnwrappedError";
  name = "UnwrappedError";
}
let InvalidMessageLengthError$1 = class InvalidMessageLengthError extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
};
let InvalidDataLengthError$1 = class InvalidDataLengthError extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
};
let InvalidDataLengthLengthError$1 = class InvalidDataLengthLengthError extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
};
function isStream(obj) {
  return typeof obj?.closeRead === "function";
}
function isMultiaddrConnection(obj) {
  return typeof obj?.close === "function";
}
function isEOF(obj) {
  if (isStream(obj)) {
    return obj.remoteWriteStatus !== "writable" && obj.readBufferLength === 0;
  }
  if (isMultiaddrConnection(obj)) {
    return obj.status !== "open";
  }
  return false;
}
function isValid(obj) {
  return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null;
}
function byteStream(stream, opts) {
  const maxBufferSize = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE$1;
  const readBuffer = new Uint8ArrayList();
  let hasBytes;
  let unwrapped = false;
  if (!isValid(stream)) {
    throw new InvalidParametersError$1("Argument should be a Stream or a Multiaddr");
  }
  const byteStreamOnMessageListener = (evt) => {
    readBuffer.append(evt.data);
    if (readBuffer.byteLength > maxBufferSize) {
      const readBufferSize = readBuffer.byteLength;
      readBuffer.consume(readBuffer.byteLength);
      hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize}`));
    }
    hasBytes?.resolve();
  };
  stream.addEventListener("message", byteStreamOnMessageListener);
  const byteStreamOnCloseListener = (evt) => {
    if (evt.error != null) {
      hasBytes?.reject(evt.error);
    } else {
      hasBytes?.resolve();
    }
  };
  stream.addEventListener("close", byteStreamOnCloseListener);
  const byteStreamOnRemoteCloseWrite = () => {
    hasBytes?.resolve();
  };
  stream.addEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
  const byteStream2 = {
    readBuffer,
    // @ts-expect-error options type prevents type inference
    async read(options) {
      if (unwrapped === true) {
        throw new UnwrappedError("Stream was unwrapped");
      }
      if (isEOF(stream)) {
        if (options?.bytes == null) {
          return null;
        }
        if (readBuffer.byteLength < options.bytes) {
          stream.log.error("closed after reading %d/%d bytes", readBuffer.byteLength, options.bytes);
          throw new UnexpectedEOFError$1(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options.bytes} bytes`);
        }
      }
      const bytesToRead = options?.bytes ?? 1;
      hasBytes = Promise.withResolvers();
      while (true) {
        if (readBuffer.byteLength >= bytesToRead) {
          hasBytes.resolve();
          break;
        }
        await raceSignal$2(hasBytes.promise, options?.signal);
        if (isEOF(stream)) {
          if (readBuffer.byteLength === 0 && options?.bytes == null) {
            return null;
          }
          break;
        }
        hasBytes = Promise.withResolvers();
      }
      const toRead = options?.bytes ?? readBuffer.byteLength;
      if (readBuffer.byteLength < toRead) {
        if (isEOF(stream)) {
          stream.log.error("closed while reading %d/%d bytes", readBuffer.byteLength, toRead);
          throw new UnexpectedEOFError$1(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`);
        }
        return byteStream2.read(options);
      }
      const output = readBuffer.sublist(0, toRead);
      readBuffer.consume(toRead);
      return output;
    },
    async write(data, options) {
      if (unwrapped === true) {
        throw new UnwrappedError("Stream was unwrapped");
      }
      if (!stream.send(data)) {
        await pEvent(stream, "drain", {
          signal: options?.signal,
          rejectionEvents: ["close"]
        });
      }
    },
    unwrap() {
      if (unwrapped) {
        return stream;
      }
      unwrapped = true;
      stream.removeEventListener("message", byteStreamOnMessageListener);
      stream.removeEventListener("close", byteStreamOnCloseListener);
      stream.removeEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
      if (readBuffer.byteLength > 0) {
        stream.log("stream unwrapped with %d unread bytes", readBuffer.byteLength);
        stream.push(readBuffer);
      }
      return stream;
    }
  };
  return byteStream2;
}
function lpStream(stream, opts = {}) {
  const bytes = byteStream(stream, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = opts?.lengthDecoder ?? decode$1;
  const encodeLength2 = opts?.lengthEncoder ?? encode$1;
  const lpStream2 = {
    async read(options) {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        const buf2 = await bytes.read({
          ...options,
          bytes: 1
        });
        if (buf2 == null) {
          break;
        }
        lengthBuffer.append(buf2);
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError$1("Invalid message length");
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError$1(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`);
        }
        if (dataLength > -1) {
          break;
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError$1(`Message length too long - ${dataLength} > ${opts.maxDataLength}`);
      }
      const buf = await bytes.read({
        ...options,
        bytes: dataLength
      });
      if (buf == null) {
        stream.log.error("tried to read %d bytes but the stream closed", dataLength);
        throw new UnexpectedEOFError$1(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`);
      }
      if (buf.byteLength !== dataLength) {
        stream.log.error("read %d/%d bytes before the stream closed", buf.byteLength, dataLength);
        throw new UnexpectedEOFError$1(`Unexpected EOF - read ${buf.byteLength}/${dataLength} bytes before the stream closed`);
      }
      return buf;
    },
    async write(data, options) {
      await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options);
    },
    async writeV(data, options) {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength2(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap() {
      return bytes.unwrap();
    }
  };
  return lpStream2;
}
function pbStream(stream, opts) {
  const lp = lpStream(stream, opts);
  const pbStream2 = {
    read: async (proto, options) => {
      const value2 = await lp.read(options);
      return proto.decode(value2);
    },
    write: async (message2, proto, options) => {
      await lp.write(proto.encode(message2), options);
    },
    writeV: async (messages2, proto, options) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
    },
    pb: (proto) => {
      return {
        read: async (options) => pbStream2.read(proto, options),
        write: async (d2, options) => pbStream2.write(d2, proto, options),
        writeV: async (d2, options) => pbStream2.writeV(d2, proto, options),
        unwrap: () => pbStream2
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return pbStream2;
}
function isMessageStream(obj) {
  return obj?.addEventListener != null;
}
function messageStreamToDuplex(stream) {
  const source = pushable();
  let onError;
  const onMessage = (evt) => {
    source.push(evt.data);
  };
  const onRemoteCloseWrite = () => {
    source.end();
    stream.removeEventListener("message", onMessage);
    stream.removeEventListener("close", onClose);
    stream.removeEventListener("remoteCloseWrite", onRemoteCloseWrite);
  };
  const onClose = (evt) => {
    source.end(evt.error);
    if (evt.error != null) {
      onError?.reject(evt.error);
    }
    stream.removeEventListener("message", onMessage);
    stream.removeEventListener("close", onClose);
    stream.removeEventListener("remoteCloseWrite", onRemoteCloseWrite);
  };
  stream.addEventListener("message", onMessage);
  stream.addEventListener("close", onClose, {
    once: true
  });
  stream.addEventListener("remoteCloseWrite", onRemoteCloseWrite, {
    once: true
  });
  return {
    source,
    async sink(source2) {
      async function* toGenerator() {
        yield* source2;
      }
      const gen = toGenerator();
      while (true) {
        onError = Promise.withResolvers();
        const { done, value: value2 } = await Promise.race([
          gen.next(),
          onError.promise
        ]);
        if (stream.writeStatus === "closing" || stream.writeStatus === "closed") {
          break;
        }
        if (value2 != null) {
          if (!stream.send(value2)) {
            await Promise.race([
              pEvent(stream, "drain", {
                rejectionEvents: [
                  "close"
                ]
              })
            ]);
          }
        }
        if (done === true) {
          break;
        }
      }
      await stream.close();
    }
  };
}
function pipe(...input) {
  const sources = input.map((source) => {
    if (isMessageStream(source)) {
      return messageStreamToDuplex(source);
    }
    return source;
  });
  return pipe$1(...sources);
}
const DEFAULT_MAX_BUFFER_SIZE = 1024 * 1024 * 4;
const DEFAULT_MAX_DATA_LENGTH = 1024 * 1024 * 4;
class LengthPrefixedDecoder {
  buffer;
  maxBufferSize;
  lengthDecoder;
  maxDataLength;
  encodingLength;
  constructor(init3 = {}) {
    this.buffer = new Uint8ArrayList();
    this.maxBufferSize = init3.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE;
    this.maxDataLength = init3.maxDataLength ?? DEFAULT_MAX_DATA_LENGTH;
    this.lengthDecoder = init3.lengthDecoder ?? decode$1;
    this.encodingLength = init3.encodingLength ?? encodingLength;
  }
  /**
   * Decodes length-prefixed data
   */
  *decode(buf) {
    this.buffer.append(buf);
    if (this.buffer.byteLength > this.maxBufferSize) {
      throw new InvalidParametersError$1(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);
    }
    while (true) {
      let dataLength;
      try {
        dataLength = this.lengthDecoder(this.buffer);
      } catch (err) {
        if (err instanceof RangeError) {
          break;
        }
        throw err;
      }
      if (dataLength < 0 || dataLength > this.maxDataLength) {
        throw new InvalidMessageLengthError$1("Invalid message length");
      }
      const lengthLength = this.encodingLength(dataLength);
      const chunkLength = lengthLength + dataLength;
      if (this.buffer.byteLength >= chunkLength) {
        const buf2 = this.buffer.sublist(lengthLength, chunkLength);
        this.buffer.consume(chunkLength);
        if (buf2.byteLength > 0) {
          yield buf2;
        }
      } else {
        break;
      }
    }
  }
}
const MAX_LENGTH_LENGTH = 8;
const MAX_DATA_LENGTH = 1024 * 1024 * 4;
class InvalidMessageLengthError2 extends Error {
  name = "InvalidMessageLengthError";
  code = "ERR_INVALID_MSG_LENGTH";
}
class InvalidDataLengthError2 extends Error {
  name = "InvalidDataLengthError";
  code = "ERR_MSG_DATA_TOO_LONG";
}
class InvalidDataLengthLengthError2 extends Error {
  name = "InvalidDataLengthLengthError";
  code = "ERR_MSG_LENGTH_TOO_LONG";
}
class UnexpectedEOFError2 extends Error {
  name = "UnexpectedEOFError";
  code = "ERR_UNEXPECTED_EOF";
}
function isAsyncIterable$5(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function validateMaxDataLength(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError2("Message length too long");
  }
}
const defaultEncoder = (length3) => {
  const lengthLength = encodingLength(length3);
  const lengthBuf = allocUnsafe(lengthLength);
  encode$1(length3, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode(source, options) {
  options = options ?? {};
  const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield(chunk) {
    validateMaxDataLength(chunk, maxDataLength);
    const length3 = encodeLength2(chunk.byteLength);
    if (length3 instanceof Uint8Array) {
      yield length3;
    } else {
      yield* length3;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable$5(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
  validateMaxDataLength(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
const defaultDecoder = (buf) => {
  const length3 = decode$1(buf);
  defaultDecoder.bytes = encodingLength(length3);
  return length3;
};
defaultDecoder.bytes = 0;
function decode(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder;
  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH;
  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError2("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError2("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if (options?.onLength != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError2("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if (options?.onData != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable$5(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError2("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError2("Unexpected end of input");
    }
  }();
}
decode.fromReader = (reader, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode(varByteSource, {
    ...options ?? {},
    onLength
  });
};
class PeerQueue extends Queue$1 {
  has(peerId) {
    return this.find(peerId) != null;
  }
  find(peerId) {
    return this.queue.find((job) => {
      return peerId.equals(job.options.peerId);
    });
  }
}
let PriorityQueue$1 = class PriorityQueue extends Queue$1 {
  constructor(init3 = {}) {
    super({
      ...init3,
      sort: (a2, b) => {
        if (a2.options.priority > b.options.priority) {
          return -1;
        }
        if (a2.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};
class RateLimiter {
  memoryStorage;
  points;
  duration;
  blockDuration;
  keyPrefix;
  constructor(opts = {}) {
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  consume(key2, pointsToConsume = 1, options = {}) {
    const rlKey = this.getKey(key2);
    const secDuration = this._getKeySecDuration(options);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    }
    return res;
  }
  penalty(key2, points = 1, options = {}) {
    const rlKey = this.getKey(key2);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key2, points = 1, options = {}) {
    const rlKey = this.getKey(key2);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key2, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key2), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key2, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key2), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key2) {
    const res = this.memoryStorage.get(this.getKey(key2));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key2) {
    this.memoryStorage.delete(this.getKey(key2));
  }
  _getKeySecDuration(options) {
    if (options?.customDuration != null && options.customDuration >= 0) {
      return options.customDuration;
    }
    return this.duration;
  }
  getKey(key2) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key2}` : key2;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
}
class MemoryStorage {
  storage;
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key2, value2, durationSec) {
    const existing = this.storage.get(key2);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value2;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key2, value2, durationSec);
    }
    return this.set(key2, value2, durationSec);
  }
  set(key2, value2, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key2);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value: value2,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key2, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key2);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key2) {
    const existing = this.storage.get(key2);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key2) {
    const record = this.storage.get(key2);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key2);
      return true;
    }
    return false;
  }
}
function repeatingTask(fn, interval, options) {
  let timeout;
  let shutdownController;
  let running = false;
  function runTask() {
    const opts = {
      signal: shutdownController.signal
    };
    if (options?.timeout != null) {
      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options.timeout)]);
      opts.signal = signal;
    }
    running = true;
    Promise.resolve().then(async () => {
      await fn(opts);
    }).catch(() => {
    }).finally(() => {
      running = false;
      if (shutdownController.signal.aborted) {
        return;
      }
      timeout = setTimeout(runTask, interval);
    });
  }
  const runTaskDebounced = debounce$1(runTask, options?.debounce ?? 100);
  let started = false;
  return {
    setInterval: (ms) => {
      if (interval === ms) {
        return;
      }
      interval = ms;
      if (timeout != null) {
        clearTimeout(timeout);
        timeout = setTimeout(runTask, interval);
      }
    },
    setTimeout: (ms) => {
      options ??= {};
      options.timeout = ms;
    },
    run: () => {
      if (running) {
        return;
      }
      clearTimeout(timeout);
      runTaskDebounced();
    },
    start: () => {
      if (started) {
        return;
      }
      started = true;
      shutdownController = new AbortController();
      setMaxListeners(Infinity, shutdownController.signal);
      if (options?.runImmediately === true) {
        queueMicrotask(() => {
          runTask();
        });
      } else {
        timeout = setTimeout(runTask, interval);
      }
    },
    stop: () => {
      clearTimeout(timeout);
      shutdownController?.abort();
      started = false;
    }
  };
}
class TrackedMap extends Map {
  metric;
  constructor(init3) {
    super();
    const { name: name2, metrics } = init3;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key2, value2) {
    super.set(key2, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key2) {
    const deleted = super.delete(key2);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
}
function trackedMap(config) {
  const { name: name2, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedMap({ name: name2, metrics });
  } else {
    map = /* @__PURE__ */ new Map();
  }
  return map;
}
class PeerFilter {
  filter;
  constructor(size2, errorRate) {
    this.filter = createScalableCuckooFilter(size2, errorRate);
  }
  has(peerId) {
    return this.filter.has(peerId.toMultihash().bytes);
  }
  add(peerId) {
    this.filter.add(peerId.toMultihash().bytes);
  }
  remove(peerId) {
    this.filter.remove?.(peerId.toMultihash().bytes);
  }
}
function peerFilter(size2, errorRate = 1e-3) {
  return new PeerFilter(size2, errorRate);
}
class TrackedPeerMap extends PeerMap {
  metric;
  constructor(init3) {
    super();
    const { name: name2, metrics } = init3;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key2, value2) {
    super.set(key2, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key2) {
    const deleted = super.delete(key2);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
}
function trackedPeerMap(config) {
  const { name: name2, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedPeerMap({ name: name2, metrics });
  } else {
    map = new PeerMap();
  }
  return map;
}
var Envelope$1;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          publicKey: alloc$1(0),
          payloadType: alloc$1(0),
          payload: alloc$1(0),
          signature: alloc$1(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope$1 || (Envelope$1 = {}));
class InvalidSignatureError extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
}
class RecordEnvelope {
  /**
   * Unmarshal a serialized Envelope protobuf message
   */
  static createFromProtobuf = (data) => {
    const envelopeData = Envelope$1.decode(data);
    const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
    return new RecordEnvelope({
      publicKey,
      payloadType: envelopeData.payloadType,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  /**
   * Seal marshals the given Record, places the marshaled bytes inside an Envelope
   * and signs it with the given peerId's private key
   */
  static seal = async (record, privateKey, options) => {
    if (privateKey == null) {
      throw new Error("Missing private key");
    }
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const signature2 = await privateKey.sign(signData.subarray(), options);
    return new RecordEnvelope({
      publicKey: privateKey.publicKey,
      payloadType,
      payload,
      signature: signature2
    });
  };
  /**
   * Open and certify a given marshaled envelope.
   * Data is unmarshaled and the signature validated for the given domain.
   */
  static openAndCertify = async (data, domain, options) => {
    const envelope = RecordEnvelope.createFromProtobuf(data);
    const valid = await envelope.validate(domain, options);
    if (!valid) {
      throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
    }
    return envelope;
  };
  publicKey;
  payloadType;
  payload;
  signature;
  marshaled;
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init3) {
    const { publicKey, payloadType, payload, signature: signature2 } = init3;
    this.publicKey = publicKey;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature2;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope$1.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    if (other == null) {
      return false;
    }
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain, options) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature, options);
  }
}
const formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode$1(domainUint8Array.byteLength);
  const payloadTypeLength = encode$1(payloadType.length);
  const payloadLength = encode$1(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};
const ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
var PeerRecord$1;
(function(PeerRecord2) {
  (function(AddressInfo) {
    let _codec2;
    AddressInfo.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            multiaddr: alloc$1(0)
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo.encode = (obj) => {
      return encodeMessage(obj, AddressInfo.codec());
    };
    AddressInfo.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo.codec(), opts);
    };
  })(PeerRecord2.AddressInfo || (PeerRecord2.AddressInfo = {}));
  let _codec;
  PeerRecord2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(26);
            PeerRecord2.AddressInfo.codec().encode(value2, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          peerId: alloc$1(0),
          seq: 0n,
          addresses: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord2.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord2.encode = (obj) => {
    return encodeMessage(obj, PeerRecord2.codec());
  };
  PeerRecord2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord2.codec(), opts);
  };
})(PeerRecord$1 || (PeerRecord$1 = {}));
function arrayEquals(a2, b) {
  const sort2 = (a3, b2) => a3.toString().localeCompare(b2.toString());
  if (a2.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a2.sort(sort2).every((item, index) => b[index].equals(item));
}
class PeerRecord {
  /**
   * Unmarshal Peer Record Protobuf
   */
  static createFromProtobuf = (buf) => {
    const peerRecord = PeerRecord$1.decode(buf);
    const peerId = peerIdFromMultihash(decode$3(peerRecord.peerId));
    const multiaddrs = (peerRecord.addresses ?? []).map((a2) => multiaddr(a2.multiaddr));
    const seqNumber = peerRecord.seq;
    return new PeerRecord({ peerId, multiaddrs, seqNumber });
  };
  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
  peerId;
  multiaddrs;
  seqNumber;
  domain = PeerRecord.DOMAIN;
  codec = PeerRecord.CODEC;
  marshaled;
  constructor(init3) {
    const { peerId, multiaddrs, seqNumber } = init3;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord$1.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
}
function isAsyncIterable$4(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable$4(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
let AbortError$2 = class AbortError5 extends Error {
  static name = "AbortError";
  name = "AbortError";
  constructor(message2 = "The operation was aborted", ...rest) {
    super(message2, ...rest);
  }
};
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError$2(opts?.errorMessage);
  if (opts?.errorCode != null) {
    error.code = opts.errorCode;
  }
  const errorEvent = opts?.errorEvent ?? "error";
  if (signal?.aborted === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      removeListener(signal, "abort", abortListener);
      removeListener(emitter, eventName, eventListener);
      removeListener(emitter, errorEvent, errorEventListener);
    }
    const eventListener = (evt) => {
      try {
        if (opts?.filter?.(evt) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      if (evt instanceof Error) {
        reject(evt);
        return;
      }
      reject(evt.detail ?? opts?.error ?? new Error(`The "${opts?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    addListener(signal, "abort", abortListener);
    addListener(emitter, eventName, eventListener);
    addListener(emitter, errorEvent, errorEventListener);
  });
}
function addListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.addEventListener(event, listener);
  } else {
    emitter.addListener(event, listener);
  }
}
function removeListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.removeEventListener(event, listener);
  } else {
    emitter.removeListener(event, listener);
  }
}
function isEventTarget(emitter) {
  return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
}
class QueueFullError2 extends Error {
  static name = "QueueFullError";
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
}
let AbortError$1 = class AbortError6 extends Error {
  type;
  code;
  constructor(message2, code2, name2) {
    super(message2 ?? "The operation was aborted");
    this.type = "aborted";
    this.name = name2 ?? "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(new AbortError$1(opts?.errorMessage, opts?.errorCode, opts?.errorName));
  }
  let listener;
  const error = new AbortError$1(opts?.errorMessage, opts?.errorCode, opts?.errorName);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}
class JobRecipient2 {
  deferred;
  signal;
  constructor(signal) {
    this.signal = signal;
    this.deferred = Promise.withResolvers();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError$2());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
}
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
class Job2 {
  id;
  fn;
  options;
  recipients;
  status;
  timeline;
  controller;
  constructor(fn, options) {
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError$2());
      this.cleanup();
    }
  }
  async join(options = {}) {
    const recipient = new JobRecipient2(options.signal);
    this.recipients.push(recipient);
    options.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
}
function debounce(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}
class Queue2 extends TypedEventEmitter {
  concurrency;
  maxSize;
  queue;
  pending;
  sort;
  autoStart;
  constructor(init3 = {}) {
    super();
    this.concurrency = init3.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init3.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.autoStart = init3.autoStart ?? true;
    this.sort = init3.sort;
    this.queue = [];
    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce(this.emitIdle.bind(this), 1);
  }
  [Symbol.asyncIterator]() {
    return this.toGenerator();
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.safeDispatchEvent("next");
        if (this.autoStart) {
          this.tryToStartAnother();
        }
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Start the queue. If the `autoStart` parameter passed to the constructor was
   * not `false` this is a no-op
   */
  start() {
    if (this.autoStart !== false) {
      return;
    }
    this.autoStart = true;
    this.tryToStartAnother();
  }
  /**
   * Prevent further jobs from running - call `.start` to start the queue again
   */
  pause() {
    this.autoStart = false;
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    options?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError2();
    }
    const job = new Job2(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    if (this.autoStart) {
      this.tryToStartAnother();
    }
    return job.join(options).then((result) => {
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError$2());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options?.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options?.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options?.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    options?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail.result);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError$2("Queue aborted"));
    };
    this.addEventListener("success", onQueueJobComplete);
    this.addEventListener("failure", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    options?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("success", onQueueJobComplete);
      this.removeEventListener("failure", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      options?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
}
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
const WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
const WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
const MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
const MASTER_READ_LOCK_ERROR = "lock:master:error-read";
const WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
const WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
const WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
const MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
const MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
const WORKER_FINALIZE = "lock:worker:finalize";
const BROADCAST_CHANNEL_NAME = "mortice";
const defaultOptions$3 = {
  singleProcess: false
};
const handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
  return (event) => {
    if (event.data == null) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    if (requestEvent.type === requestType) {
      emitter.safeDispatchEvent(masterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier,
          handler: async () => {
            channel.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if (event2?.data == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  channel.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              channel.addEventListener("message", releaseEventListener);
            });
          },
          onError: (err) => {
            channel.postMessage({
              type: errorType,
              name: requestEvent.name,
              identifier: requestEvent.identifier,
              error: {
                message: err.message,
                name: err.name,
                stack: err.stack
              }
            });
          }
        }
      });
    }
    if (requestEvent.type === abortType) {
      emitter.safeDispatchEvent(abortMasterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier
        }
      });
    }
    if (requestEvent.type === WORKER_FINALIZE) {
      emitter.safeDispatchEvent("finalizeRequest", {
        detail: {
          name: requestEvent.name
        }
      });
    }
  };
};
const nanoid$1 = (size2 = 10) => {
  return Math.random().toString().substring(2, size2 + 2);
};
class MorticeChannelWorker {
  name;
  channel;
  constructor(name2) {
    this.name = name2;
    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  }
  readLock(options) {
    return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options);
  }
  writeLock(options) {
    return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options);
  }
  finalize() {
    this.channel.postMessage({
      type: WORKER_FINALIZE,
      name: this.name
    });
    this.channel.close();
  }
  async sendRequest(requestType, abortType, grantType, errorType, releaseType, options) {
    options?.signal?.throwIfAborted();
    const id = nanoid$1();
    this.channel.postMessage({
      type: requestType,
      identifier: id,
      name: this.name
    });
    return new Promise((resolve, reject) => {
      const abortListener = () => {
        this.channel.postMessage({
          type: abortType,
          identifier: id,
          name: this.name
        });
      };
      options?.signal?.addEventListener("abort", abortListener, {
        once: true
      });
      const listener = (event) => {
        if (event.data?.identifier !== id) {
          return;
        }
        if (event.data?.type === grantType) {
          this.channel.removeEventListener("message", listener);
          options?.signal?.removeEventListener("abort", abortListener);
          resolve(() => {
            this.channel.postMessage({
              type: releaseType,
              identifier: id,
              name: this.name
            });
          });
        }
        if (event.data.type === errorType) {
          this.channel.removeEventListener("message", listener);
          options?.signal?.removeEventListener("abort", abortListener);
          const err = new Error();
          if (event.data.error != null) {
            err.message = event.data.error.message;
            err.name = event.data.error.name;
            err.stack = event.data.error.stack;
          }
          reject(err);
        }
      };
      this.channel.addEventListener("message", listener);
    });
  }
}
const impl = (options) => {
  options = Object.assign({}, defaultOptions$3, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    const emitter = new TypedEventEmitter();
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return new MorticeChannelWorker(options.name);
};
const mutexes = /* @__PURE__ */ new Map();
let implementation;
function isMortice(obj) {
  return typeof obj?.readLock === "function" && typeof obj?.writeLock === "function";
}
function getImplementation(opts) {
  if (implementation == null) {
    implementation = impl(opts);
    if (!isMortice(implementation)) {
      const emitter = implementation;
      emitter.addEventListener("requestReadLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortReadLockRequest", abortListener);
        void mutex.readLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortReadLockRequest", abortListener);
        });
      });
      emitter.addEventListener("requestWriteLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortWriteLockRequest", abortListener);
        void mutex.writeLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortWriteLockRequest", abortListener);
        });
      });
      emitter.addEventListener("finalizeRequest", (event) => {
        const mutexName = event.detail.name;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        mutex.finalize();
      });
    }
  }
  return implementation;
}
async function createReleasable(queue, options) {
  let res;
  let rej;
  const p2 = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  const listener = () => {
    rej(new AbortError$2());
  };
  options?.signal?.addEventListener("abort", listener, {
    once: true
  });
  queue.add(async () => {
    await new Promise((resolve) => {
      res(() => {
        options?.signal?.removeEventListener("abort", listener);
        resolve();
      });
    });
  }, {
    signal: options?.signal
  }).catch((err) => {
    rej(err);
  });
  return p2;
}
const createMutex = (name2, options) => {
  let mutex = mutexes.get(name2);
  if (mutex != null) {
    return mutex;
  }
  const implementation2 = getImplementation(options);
  if (isMortice(implementation2)) {
    mutex = implementation2;
    mutexes.set(name2, mutex);
    return mutex;
  }
  const masterQueue = new Queue2({
    concurrency: 1
  });
  let readQueue;
  mutex = {
    async readLock(opts) {
      if (readQueue != null) {
        return createReleasable(readQueue, opts);
      }
      readQueue = new Queue2({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleasable(readQueue, opts);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock(opts) {
      readQueue = null;
      return createReleasable(masterQueue, opts);
    },
    finalize: () => {
      mutexes.delete(name2);
    },
    queue: masterQueue
  };
  mutexes.set(name2, mutex);
  if (options.autoFinalize === true) {
    masterQueue.addEventListener("idle", () => {
      mutex.finalize();
    }, {
      once: true
    });
  }
  return mutex;
};
const defaultOptions$2 = {
  name: "lock",
  concurrency: Infinity,
  singleProcess: false,
  autoFinalize: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions$2, options);
  return createMutex(opts.name, opts);
}
const MAX_ADDRESS_AGE = 36e5;
const MAX_PEER_AGE = 216e5;
var Peer$2;
(function(Peer2) {
  (function(Peer$metadataEntry) {
    let _codec2;
    Peer$metadataEntry.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            key: "",
            value: alloc$1(0)
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry.codec());
    };
    Peer$metadataEntry.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry.codec(), opts);
    };
  })(Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  (function(Peer$tagsEntry) {
    let _codec2;
    Peer$tagsEntry.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            key: ""
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry.codec());
    };
    Peer$tagsEntry.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry.codec(), opts);
    };
  })(Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(10);
            Address$1.codec().encode(value2, w);
          }
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key2, value2] of obj.metadata.entries()) {
            w.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key: key2, value: value2 }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key2, value2] of obj.tags.entries()) {
            w.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key: key2, value: value2 }, w);
          }
        }
        if (obj.updated != null) {
          w.uint32(64);
          w.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address$1.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: opts.limits?.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer$2 || (Peer$2 = {}));
var Address$1;
(function(Address3) {
  let _codec;
  Address3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w.uint32(24);
          w.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          multiaddr: alloc$1(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address3.encode = (obj) => {
    return encodeMessage(obj, Address3.codec());
  };
  Address3.decode = (buf, opts) => {
    return decodeMessage(buf, Address3.codec(), opts);
  };
})(Address$1 || (Address$1 = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));
function populatePublicKey(peerId, protobuf) {
  if (peerId.publicKey != null || protobuf.publicKey == null) {
    return peerId;
  }
  let digest10;
  if (peerId.type === "RSA") {
    digest10 = peerId.toMultihash();
  }
  const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest10);
  return peerIdFromPublicKey(publicKey);
}
function bytesToPeer(peerId, buf, maxAddressAge) {
  const peer = Peer$2.decode(buf);
  return pbToPeer(peerId, peer, maxAddressAge);
}
function pbToPeer(peerId, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key2, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key2, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a2, b) => {
    if (a2.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals(a2.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a2, b) => a2 === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => equals(a2, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => a2.value === b.value && a2.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i2 = 0; i2 < arrA.length; i2++) {
    if (!compare(arrA[i2], arrB[i2])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key2, value2] of mapA.entries()) {
    const valueB = mapB.get(key2);
    if (valueB == null) {
      return false;
    }
    if (!compare(value2, valueB)) {
      return false;
    }
  }
  return true;
}
const pathSepS = "/";
const pathSepB = new TextEncoder().encode(pathSepS);
const pathSep = pathSepB[0];
class Key {
  _buf;
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean2) {
    if (typeof s2 === "string") {
      this._buf = fromString(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean2 == null) {
      clean2 = true;
    }
    if (clean2) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString$1(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key2) {
    const list1 = this.list();
    const list2 = key2.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /**
   * Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p2 = this.parent().toString();
    if (!p2.endsWith(pathSepS)) {
      p2 += pathSepS;
    }
    p2 += this.type();
    return new Key(p2);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key2) {
    if (this.toString() === pathSepS) {
      return key2;
    } else if (key2.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key2.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key2) => key2.namespaces()))]);
  }
}
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
const NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId(peerId) || peerId.type == null) {
    throw new InvalidParametersError$1("Invalid PeerId");
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}
async function dedupeFilterAndSortAddresses(peerId, filter2, addresses, existingAddresses, options) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError$1("Multiaddr was invalid");
    }
    if (!await filter2(peerId, addr.multiaddr, options)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a2, b) => {
    return a2.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: ma }) => {
    const addrPeer = ma.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
    if (peerId.equals(addrPeer)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId}`));
    }
    return {
      isCertified,
      multiaddr: ma.bytes
    };
  });
}
async function toPeerPB(peerId, data, strategy, options) {
  if (data == null) {
    throw new InvalidParametersError$1("Invalid PeerData");
  }
  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
    throw new InvalidParametersError$1("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = options.existingPeer?.peer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new InvalidParametersError$1("peer id did not match existing peer id");
  }
  let addresses = existingPeer?.addresses ?? [];
  let protocols = new Set(existingPeer?.protocols ?? []);
  let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
  let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer?.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key2, value2] of metadataEntries) {
        if (value2 == null) {
          metadata.delete(key2);
        } else {
          metadata.set(key2, value2);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key2, value2] of tagsEntries) {
        if (value2 == null) {
          mergedTags.delete(key2);
        } else {
          mergedTags.set(key2, value2);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey;
  if (existingPeer?.id.publicKey != null) {
    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey = publicKeyToProtobuf(data.publicKey);
  } else if (peerId.publicKey != null) {
    publicKey = publicKeyToProtobuf(peerId.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses, options.existingPeer?.peerPB.addresses, options),
    protocols: [...protocols.values()].sort((a2, b) => {
      return a2.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    addr.observed = options.existingPeer?.peerPB.addresses?.find((addr2) => equals(addr2.multiaddr, addr2.multiaddr))?.observed ?? Date.now();
  });
  if (peerId.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options) {
  const output = /* @__PURE__ */ new Map();
  for (const [key2, value2] of entries) {
    if (value2 == null) {
      continue;
    }
    options.validate(key2, value2);
  }
  for (const [key2, value2] of entries.sort(([a2], [b]) => {
    return a2.localeCompare(b);
  })) {
    if (value2 != null) {
      output.set(key2, options.map?.(key2, value2) ?? value2);
    }
  }
  return output;
}
function validateMetadata(key2, value2) {
  if (typeof key2 !== "string") {
    throw new InvalidParametersError$1("Metadata key must be a string");
  }
  if (!(value2 instanceof Uint8Array)) {
    throw new InvalidParametersError$1("Metadata value must be a Uint8Array");
  }
}
function validateTag(key2, tag) {
  if (typeof key2 !== "string") {
    throw new InvalidParametersError$1("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError$1("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError$1("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError$1("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError$1("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key2, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  const output = {
    value: tag.value ?? 0
  };
  if (expiry != null) {
    output.expiry = expiry;
  }
  return output;
}
function keyToPeerId(key2) {
  const base32Str = key2.toString().split("/")[2];
  const buf = CID.parse(base32Str, base32);
  return peerIdFromCID(buf);
}
function decodePeer(key2, value2, maxAddressAge) {
  const peerId = keyToPeerId(key2);
  return bytesToPeer(peerId, value2, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key: key2, value: value2 }) => {
      return fn(decodePeer(key2, value2, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a2, b) => {
      return fn(decodePeer(a2.key, a2.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
class PersistentStore {
  peerId;
  datastore;
  locks;
  addressFilter;
  log;
  maxAddressAge;
  maxPeerAge;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init3.addressFilter;
    this.locks = trackedPeerMap({
      name: "libp2p_peer_store_locks",
      metrics: components.metrics
    });
    this.maxAddressAge = init3.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init3.maxPeerAge ?? MAX_PEER_AGE;
  }
  getLock(peerId) {
    let lock = this.locks.get(peerId);
    if (lock == null) {
      lock = {
        refs: 0,
        lock: createMortice({
          name: peerId.toString(),
          singleProcess: true
        })
      };
      this.locks.set(peerId, lock);
    }
    lock.refs++;
    return lock;
  }
  maybeRemoveLock(peerId, lock) {
    lock.refs--;
    if (lock.refs === 0) {
      lock.lock.finalize();
      this.locks.delete(peerId);
    }
  }
  async getReadLock(peerId, options) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.readLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async getWriteLock(peerId, options) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.writeLock(options);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async has(peerId, options) {
    try {
      await this.load(peerId, options);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId, options) {
    if (this.peerId.equals(peerId)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId), options);
  }
  async load(peerId, options) {
    const key2 = peerIdToDatastoreKey(peerId);
    const buf = await this.datastore.get(key2, options);
    const peer = Peer$2.decode(buf);
    if (this.#peerIsExpired(peerId, peer)) {
      await this.datastore.delete(key2, options);
      throw new NotFoundError$1();
    }
    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
  }
  async save(peerId, data, options) {
    const existingPeer = await this.#findExistingPeer(peerId, options);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options,
      addressFilter: this.addressFilter
    });
    return this.#saveIfDifferent(peerId, peerPb, existingPeer);
  }
  async patch(peerId, data, options) {
    const existingPeer = await this.#findExistingPeer(peerId, options);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options,
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId, peerPb, existingPeer);
  }
  async merge(peerId, data, options) {
    const existingPeer = await this.#findExistingPeer(peerId, options);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return this.#saveIfDifferent(peerId, peerPb, existingPeer);
  }
  async *all(options) {
    for await (const { key: key2, value: value2 } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {
      const peerId = keyToPeerId(key2);
      if (peerId.equals(this.peerId)) {
        continue;
      }
      const peer = Peer$2.decode(value2);
      if (this.#peerIsExpired(peerId, peer)) {
        await this.datastore.delete(key2, options);
        continue;
      }
      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
    }
  }
  async #findExistingPeer(peerId, options) {
    try {
      const key2 = peerIdToDatastoreKey(peerId);
      const buf = await this.datastore.get(key2, options);
      const peerPB = Peer$2.decode(buf);
      if (this.#peerIsExpired(peerId, peerPB)) {
        await this.datastore.delete(key2, options);
        throw new NotFoundError$1();
      }
      return {
        peerPB,
        peer: pbToPeer(peerId, peerPB, this.maxAddressAge)
      };
    } catch (err) {
      if (err.name !== "NotFoundError") {
        this.log.error("invalid peer data found in peer store - %e", err);
      }
    }
  }
  async #saveIfDifferent(peerId, peer, existingPeer, options) {
    peer.updated = Date.now();
    const buf = Peer$2.encode(peer);
    await this.datastore.put(peerIdToDatastoreKey(peerId), buf, options);
    return {
      peer: pbToPeer(peerId, peer, this.maxAddressAge),
      previous: existingPeer?.peer,
      updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
    };
  }
  #peerIsExpired(peerId, peer) {
    if (peer.updated == null) {
      return true;
    }
    if (this.peerId.equals(peerId)) {
      return false;
    }
    const expired = peer.updated < Date.now() - this.maxPeerAge;
    const minAddressObserved = Date.now() - this.maxAddressAge;
    const addrs = peer.addresses.filter((addr) => {
      return addr.observed != null && addr.observed > minAddressObserved;
    });
    return expired && addrs.length === 0;
  }
}
class PersistentPeerStore {
  store;
  events;
  peerId;
  log;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init3);
  }
  [Symbol.toStringTag] = "@libp2p/peer-store";
  async forEach(fn, query) {
    for await (const peer of this.store.all(query)) {
      fn(peer);
    }
  }
  async all(query) {
    return all(this.store.all(query));
  }
  async delete(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      await this.store.delete(peerId, options);
    } finally {
      release();
    }
  }
  async has(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      return await this.store.has(peerId, options);
    } finally {
      this.log.trace("has release read lock");
      release?.();
    }
  }
  async get(peerId, options) {
    const release = await this.store.getReadLock(peerId, options);
    try {
      return await this.store.load(peerId, options);
    } finally {
      release?.();
    }
  }
  async getInfo(peerId, options) {
    const peer = await this.get(peerId, options);
    return {
      id: peer.id,
      multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
  }
  async save(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.save(id, data, options);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async patch(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.patch(id, data, options);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async merge(id, data, options) {
    const release = await this.store.getWriteLock(id, options);
    try {
      const result = await this.store.merge(id, data, options);
      this.#emitIfUpdated(id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async consumePeerRecord(buf, arg1, arg2) {
    const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1?.expectedPeer) ? arg1.expectedPeer : void 0;
    const options = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN, options);
    const peerId = peerIdFromCID(envelope.publicKey.toCID());
    if (expectedPeer?.equals(peerId) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
      return false;
    }
    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId, options);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (peer?.peerRecordEnvelope != null) {
      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    }, options);
    return true;
  }
  #emitIfUpdated(id, result) {
    if (!result.updated) {
      return;
    }
    if (this.peerId.equals(id)) {
      this.events.safeDispatchEvent("self:peer:update", { detail: result });
    } else {
      this.events.safeDispatchEvent("peer:update", { detail: result });
    }
  }
}
function persistentPeerStore(components, init3 = {}) {
  return new PersistentPeerStore(components, init3);
}
class NotFoundError2 extends Error {
  static name = "NotFoundError";
  static code = "ERR_NOT_FOUND";
  name = NotFoundError2.name;
  code = NotFoundError2.code;
  constructor(message2 = "Not Found") {
    super(message2);
  }
}
function isAsyncIterable$3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable$3(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
function peekable(iterable) {
  const [iterator, symbol2] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value2) => {
      queue.push(value2);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol2]() {
      return this;
    }
  };
}
function isAsyncIterable$2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable$2(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable$1 = peekable(source);
  const { value: value2, done } = peekable$1.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value2, index++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value2;
      }
      for (const entry of peekable$1) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  const func = fn;
  return function* () {
    if (res === true) {
      yield value2;
    }
    for (const entry of peekable$1) {
      if (func(entry, index++)) {
        yield entry;
      }
    }
  }();
}
function isAsyncIterable$1(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable$1(source)) {
    return async function* () {
      const arr = await all(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = all(source);
    yield* arr.sort(sorter);
  }();
}
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
class BaseDatastore {
  put(key2, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key2, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key2, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key2, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key: key2, value: value2 } of source) {
      await this.put(key2, value2, options);
      yield key2;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key2 of source) {
      yield {
        key: key2,
        value: await this.get(key2, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key2 of source) {
      await this.delete(key2, options);
      yield key2;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key2, value2) {
        puts.push({ key: key2, value: value2 });
      },
      delete(key2) {
        dels.push(key2);
      },
      commit: async (options) => {
        await drain(this.putMany(puts, options));
        puts = [];
        await drain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = filter(it, (e2) => e2.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      const offset = q.offset;
      it = filter(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = filter(it, (key2) => key2.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i2 = 0;
      it = filter(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = take(it, q.limit);
    }
    return it;
  }
}
class MemoryDatastore extends BaseDatastore {
  data;
  constructor() {
    super();
    this.data = /* @__PURE__ */ new Map();
  }
  put(key2, val, options) {
    options?.signal?.throwIfAborted();
    this.data.set(key2.toString(), val);
    return key2;
  }
  get(key2, options) {
    options?.signal?.throwIfAborted();
    const result = this.data.get(key2.toString());
    if (result == null) {
      throw new NotFoundError2();
    }
    return result;
  }
  has(key2, options) {
    options?.signal?.throwIfAborted();
    return this.data.has(key2.toString());
  }
  delete(key2, options) {
    options?.signal?.throwIfAborted();
    this.data.delete(key2.toString());
  }
  *_all(q, options) {
    options?.signal?.throwIfAborted();
    for (const [key2, value2] of this.data.entries()) {
      yield { key: new Key(key2), value: value2 };
      options?.signal?.throwIfAborted();
    }
  }
  *_allKeys(q, options) {
    options?.signal?.throwIfAborted();
    for (const key2 of this.data.keys()) {
      yield new Key(key2);
      options?.signal?.throwIfAborted();
    }
  }
}
const code = (code2) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code2) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
const value = (code2, value2) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code2) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value2 != null && component.value !== value2) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
const not = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return false;
    }
  };
};
const optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
const or = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    }
  };
};
const and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches,
    exactMatch
  };
}
const _PEER_ID = value(CODE_P2P);
const PEER_ID = fmt(_PEER_ID);
const _DNS4 = value(CODE_DNS4);
const _DNS6 = value(CODE_DNS6);
const _DNSADDR = value(CODE_DNSADDR);
const _DNS = value(CODE_DNS);
fmt(_DNS4, optional(value(CODE_P2P)));
fmt(_DNS6, optional(value(CODE_P2P)));
fmt(_DNSADDR, optional(value(CODE_P2P)));
fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)));
const _IP4 = and(value(CODE_IP4), optional(value(CODE_IPCIDR)));
const _IP6 = and(optional(value(CODE_IP6ZONE)), value(CODE_IP6), optional(value(CODE_IPCIDR)));
const _IP = or(_IP4, _IP6);
const _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
const IP_OR_DOMAIN = fmt(or(_IP, and(or(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P)))));
const IP4 = fmt(_IP4);
const IP6 = fmt(_IP6);
fmt(_IP);
const _TCP = and(_IP_OR_DOMAIN, value(CODE_TCP));
const _UDP = and(_IP_OR_DOMAIN, value(CODE_UDP));
const TCP = fmt(and(_TCP, optional(value(CODE_P2P))));
fmt(_UDP);
const _QUIC = and(_UDP, code(CODE_QUIC), optional(value(CODE_P2P)));
const _QUIC_V1 = and(_UDP, code(CODE_QUIC_V1), optional(value(CODE_P2P)));
const QUIC_V0_OR_V1 = or(_QUIC, _QUIC_V1);
fmt(_QUIC);
const QUIC_V1 = fmt(_QUIC_V1);
const _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUIC_V1);
const _WebSockets = or(and(_WEB, code(CODE_WS), optional(value(CODE_P2P))));
const WebSockets$1 = fmt(_WebSockets);
const _WebSocketsSecure = or(and(_WEB, code(CODE_WSS), optional(value(CODE_P2P))), and(_WEB, code(CODE_TLS), optional(value(CODE_SNI)), code(CODE_WS), optional(value(CODE_P2P))));
const WebSocketsSecure = fmt(_WebSocketsSecure);
const _WebRTCDirect = and(_UDP, code(CODE_WEBRTC_DIRECT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
const WebRTCDirect = fmt(_WebRTCDirect);
const _WebTransport = and(_QUIC_V1, code(CODE_WEBTRANSPORT), optional(value(CODE_CERTHASH)), optional(value(CODE_CERTHASH)), optional(value(CODE_P2P)));
const WebTransport = fmt(_WebTransport);
const _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(value(CODE_P2P))), and(QUIC_V0_OR_V1, optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, optional(value(CODE_P2P))), _WebRTCDirect, _WebTransport, value(CODE_P2P));
const P2P = fmt(_P2P);
const _Circuit = and(optional(_P2P), code(CODE_P2P_CIRCUIT), not(code(CODE_WEBRTC)), optional(value(CODE_P2P)));
const Circuit$1 = fmt(_Circuit);
const _WebRTC = or(and(_P2P, code(CODE_P2P_CIRCUIT), code(CODE_WEBRTC), optional(value(CODE_P2P))), and(_P2P, code(CODE_WEBRTC), optional(value(CODE_P2P))), and(code(CODE_WEBRTC), optional(value(CODE_P2P))));
const WebRTC = fmt(_WebRTC);
const _HTTP = or(and(_IP_OR_DOMAIN, value(CODE_TCP), code(CODE_HTTP), optional(value(CODE_P2P))), and(_IP_OR_DOMAIN, code(CODE_HTTP), optional(value(CODE_P2P))));
fmt(_HTTP);
const _HTTPS = and(_IP_OR_DOMAIN, or(and(value(CODE_TCP, "443"), code(CODE_HTTP)), and(value(CODE_TCP), code(CODE_HTTPS)), and(value(CODE_TCP), code(CODE_TLS), code(CODE_HTTP)), and(code(CODE_TLS), code(CODE_HTTP)), code(CODE_TLS), code(CODE_HTTPS)), optional(value(CODE_P2P)));
fmt(_HTTPS);
const _Memory = or(and(value(CODE_MEMORY), optional(value(CODE_P2P))));
fmt(_Memory);
const _Unix = or(and(value(CODE_UNIX), optional(value(CODE_P2P))));
fmt(_Unix);
const MAX_DATE = 864e13;
class DNSMappings {
  log;
  mappings;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_dns_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === config.sni) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain);
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i2 = 0; i2 < addresses.length; i2++) {
      const address = addresses[i2].multiaddr;
      if (!isNetworkAddress(address)) {
        continue;
      }
      const config = getNetConfig(address);
      for (const [ip, mapping] of this.mappings.entries()) {
        if (config.host !== ip) {
          continue;
        }
        const maWithSni = this.maybeAddSNIComponent(address, mapping.domain);
        if (maWithSni != null) {
          addresses.splice(i2, 1);
          i2--;
          dnsMappedAddresses.push({
            multiaddr: maWithSni,
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNIComponent(ma, domain) {
    const components = ma.getComponents();
    for (let j = 0; j < components.length; j++) {
      if (components[j].code === CODE_TLS && components[j + 1]?.code !== CODE_SNI) {
        components.splice(j + 1, 0, {
          name: "sni",
          code: CODE_SNI,
          value: domain
        });
        return multiaddr(components);
      }
    }
  }
  confirm(ma, ttl) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    const host = config.sni ?? config.host;
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
}
class IPMappings {
  log;
  mappings;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_ip_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key2 = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key2) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key2, mappings);
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [key2, mappings] of this.mappings.entries()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i2, 1);
          i2--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key2);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      if (!isNetworkAddress(ma)) {
        continue;
      }
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        continue;
      }
      let key2;
      if (config.protocol === "tcp") {
        key2 = `${config.host}-${config.port}-tcp`;
      } else if (config.protocol === "udp") {
        key2 = `${config.host}-${config.port}-udp`;
      }
      if (key2 == null) {
        continue;
      }
      const mappings = this.mappings.get(key2);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        ipMappedAddresses.push({
          multiaddr: this.maybeOverrideIp(ma, mapping.externalIp, mapping.externalFamily, mapping.protocol, mapping.externalPort),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  maybeOverrideIp(ma, externalIp, externalFamily, protocol, externalPort) {
    const components = ma.getComponents();
    const ipIndex = components.findIndex((c2) => c2.code === CODE_IP4 || c2.code === CODE_IP6);
    const portIndex = components.findIndex((c2) => c2.name === protocol);
    if (ipIndex > -1 && portIndex > -1) {
      components[ipIndex].value = externalIp;
      components[ipIndex].code = externalFamily === 4 ? CODE_IP4 : CODE_IP6;
      components[portIndex].value = `${externalPort}`;
      return multiaddr(components);
    }
    return ma;
  }
  confirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
}
const defaultValues$3 = {
  maxObservedAddresses: 10
};
class ObservedAddresses {
  log;
  addresses;
  maxObservedAddresses;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_observed_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init3.maxObservedAddresses ?? defaultValues$3.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key2 of this.addresses.keys()) {
      if (key2.toString().startsWith(prefix)) {
        this.addresses.delete(key2);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
}
const defaultValues$2 = {
  maxObservedAddresses: 10
};
class TransportAddresses {
  log;
  addresses;
  maxObservedAddresses;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_transport_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init3.maxObservedAddresses ?? defaultValues$2.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key2 = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key2);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key2, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key2 = this.toKey(ma);
    return this.addresses.has(key2);
  }
  remove(ma) {
    const key2 = this.toKey(ma);
    const startingConfidence = this.addresses.get(key2)?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key2);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key2 = this.toKey(ma);
    const metadata = this.addresses.get(key2) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key2, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key2 = this.toKey(ma);
    const metadata = this.addresses.get(key2) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key2, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (!isNetworkAddress(ma)) {
      return ma.toString();
    }
    const config = getNetConfig(ma);
    return `${config.host}-${config.port}-${config.protocol}`;
  }
}
const ONE_MINUTE = 6e4;
const defaultValues$1 = {
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
const defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId) {
  const observedPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString$1(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
class AddressManager {
  log;
  components;
  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
  listen;
  announce;
  appendAnnounce;
  announceFilter;
  observed;
  dnsMappings;
  ipMappings;
  transportAddresses;
  observedAddressFilter;
  addressVerificationTTL;
  addressVerificationRetry;
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init3 = {}) {
    const { listen = [], announce = [], appendAnnounce = [] } = init3;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init3);
    this.dnsMappings = new DNSMappings(components, init3);
    this.ipMappings = new IPMappings(components, init3);
    this.transportAddresses = new TransportAddresses(components, init3);
    this.announceFilter = init3.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init3.addressVerificationTTL ?? defaultValues$1.addressVerificationTTL;
    this.addressVerificationRetry = init3.addressVerificationRetry ?? defaultValues$1.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce$1(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  [Symbol.toStringTag] = "@libp2p/address-manager";
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses - %e", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a2) => multiaddr(a2));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const config = getNetConfig(addr);
    let socketAddress;
    switch (config.type) {
      case "ip4": {
        socketAddress = `${config.host}:${config.port}`;
        break;
      }
      case "ip6": {
        socketAddress = `[${config.host}]:${config.port}`;
        break;
      }
      default: {
        return;
      }
    }
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if (options?.type === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options?.type === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options?.type === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options?.type === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, options?.ttl ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    if (this.observed.has(addr)) {
      this.observed.remove(addr);
    }
    if (this.transportAddresses.has(addr)) {
      this.transportAddresses.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
    }
    if (this.dnsMappings.has(addr)) {
      this.dnsMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
    }
    if (this.ipMappings.has(addr)) {
      this.ipMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry);
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      const ma = multiaddr(str);
      const lastComponent = ma.getComponents().pop();
      if (lastComponent?.value === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
    if (appendAnnounceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
      });
      addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      })));
    }
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    if (config.type !== "ip4" || isPrivateIp(config.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets$1.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
      (ma2) => TCP.exactMatch(ma2),
      (ma2) => QUIC_V1.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return getNetConfig(ma2).type === "ip4" && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return !isLoopback(ma2);
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = getNetConfig(linkLocalAddr);
      if (linkLocalOptions.port == null) {
        return false;
      }
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, config.host, config.port, config.protocol);
      return true;
    }
    return false;
  }
}
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
class MissingServiceError extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
}
class UnmetServiceDependenciesError extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
}
class NoContentRoutersError extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
}
class NoPeerRoutersError extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
}
class QueriedForSelfError extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
}
class UnhandledProtocolError extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
}
class DuplicateProtocolHandlerError extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
}
class DialDeniedError extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
}
class UnsupportedListenAddressError extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
}
class UnsupportedListenAddressesError extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
}
class NoValidAddressesError extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
}
class ConnectionInterceptedError extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
}
class ConnectionDeniedError extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
}
class MuxerUnavailableError extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
}
class EncryptionFailedError extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
}
class TransportUnavailableError extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
}
class RecursionLimitError extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
}
class DefaultComponents {
  components = {};
  _started = false;
  constructor(init3 = {}) {
    this.components = {};
    for (const [key2, value2] of Object.entries(init3)) {
      this.components[key2] = value2;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable[methodName]?.();
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
}
const OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
const NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init3 = {}) {
  const components = new DefaultComponents(init3);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value2) {
      if (typeof prop === "string") {
        components.components[prop] = value2;
      } else {
        Reflect.set(target, prop, value2);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service?.[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service?.[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
}
function connectionGater(gater = {}) {
  if (gater.denyDialMultiaddr == null) {
    gater.denyDialMultiaddr = (multiaddr2) => {
      if (WebSockets$1.matches(multiaddr2)) {
        return true;
      }
      return isPrivate(multiaddr2);
    };
  }
  return gater;
}
class CustomProgressEvent extends Event {
  type;
  detail;
  constructor(type, detail) {
    super(type);
    this.type = type;
    this.detail = detail;
  }
}
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  let multiaddrs = Array.isArray(peer) ? peer : [peer];
  let peerId;
  if (multiaddrs.length > 0) {
    const peerIdStr = multiaddrs[0].getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
    peerId = peerIdStr == null ? void 0 : peerIdFromString$1(peerIdStr);
    multiaddrs.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError$1("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new InvalidParametersError$1("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString$1(maPeerIdStr);
        if (peerId?.equals(maPeerId) !== true) {
          throw new InvalidParametersError$1("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  multiaddrs = multiaddrs.filter((ma) => {
    return !PEER_ID.exactMatch(ma);
  });
  return {
    peerId,
    multiaddrs
  };
}
const DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options) {
  const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
  const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await connection?.close(options);
  } catch (err) {
    connection?.abort(err);
  }
}
function multiaddrToIpNet(ma) {
  const config = getNetConfig(ma);
  let mask = config.cidr;
  if (config.type !== "ip4" && config.type !== "ip6") {
    throw new InvalidParametersError$1(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
  }
  if (mask == null) {
    switch (config.type) {
      case "ip4": {
        mask = 32;
        break;
      }
      case "ip6": {
        mask = 128;
        break;
      }
      default: {
        throw new InvalidParametersError$1(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
      }
    }
  }
  return new IpNet(config.host, mask);
}
function isDirect(ma) {
  return !Circuit$1.exactMatch(ma);
}
function findExistingConnection(peerId, connections, dialAddresses) {
  if (peerId == null || connections == null) {
    return;
  }
  const existingConnection = connections.sort((a2, b) => {
    if (a2.direct) {
      return -1;
    }
    if (b.direct) {
      return 1;
    }
    return 0;
  }).find((con) => con.limits == null);
  if (existingConnection == null || existingConnection.direct || dialAddresses == null) {
    return existingConnection;
  }
  const wouldUpgradeToDirect = dialAddresses.some((ma) => isDirect(ma));
  if (wouldUpgradeToDirect) {
    return;
  }
  return existingConnection;
}
class ConnectionPruner {
  connectionManager;
  peerStore;
  allow;
  events;
  log;
  constructor(components, init3 = {}) {
    this.allow = (init3.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections - %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const maxConnections = this.connectionManager.getMaxConnections();
    this.log("checking max connections limit %d/%d", numConnections, maxConnections);
    if (numConnections <= maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags - %e", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        if (isNetworkAddress(connection.remoteAddr)) {
          const config = getNetConfig(connection.remoteAddr);
          return ipNet.contains(config.host);
        }
        return true;
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a2, b) => {
      const connectionALifespan = a2.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a2.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.streams.length > b.streams.length) {
        return 1;
      }
      if (a2.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      const peerAValue = peerValues.get(a2.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
}
const DIAL_TIMEOUT = 1e4;
const CONNECTION_CLOSE_TIMEOUT = 1e3;
const INBOUND_UPGRADE_TIMEOUT = 1e4;
const PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
const MAX_PEER_ADDRS_TO_DIAL = 25;
const INBOUND_CONNECTION_THRESHOLD = 5;
const MAX_INCOMING_PENDING_CONNECTIONS = 10;
const MAX_PARALLEL_RECONNECTS = 5;
const LAST_DIAL_FAILURE_KEY = "last-dial-failure";
const LAST_DIAL_SUCCESS_KEY = "last-dial-success";
const MAX_DIAL_QUEUE_LENGTH = 500;
const MAX_RECURSIVE_DEPTH = 32;
const MAX_CONNECTIONS$1 = 100;
const MAX_PARALLEL_DIALS = 50;
function reliableTransportsFirst(a2, b) {
  const isATcp = TCP.exactMatch(a2.multiaddr);
  const isBTcp = TCP.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a2.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets$1.exactMatch(a2.multiaddr);
  const isBWebSocket = WebSockets$1.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC.exactMatch(a2.multiaddr);
  const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect.exactMatch(a2.multiaddr);
  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport.exactMatch(a2.multiaddr);
  const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a2, b) {
  const isALoopback = isLoopback(a2.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a2, b) {
  const isAPrivate = isPrivate(a2.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a2, b) {
  if (a2.isCertified && !b.isCertified) {
    return -1;
  } else if (!a2.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a2, b) {
  const isACircuit = Circuit$1.exactMatch(a2.multiaddr);
  const isBCircuit = Circuit$1.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}
var eventemitter3 = { exports: {} };
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener2(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name2;
    if (this._eventsCount === 0) return names;
    for (name2 in events = this._events) {
      if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length3 = listeners.length, j;
      for (i2 = 0; i2 < length3; i2++) {
        if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener2(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener2(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length3 = listeners.length; i2 < length3; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
          events.push(listeners[i2]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError3 extends Error {
  name = "TimeoutError";
  constructor(message2, options) {
    super(message2, options);
    Error.captureStackTrace?.(this, TimeoutError3);
  }
}
const getAbortedReason = (signal) => signal.reason ?? new DOMException("This operation was aborted.", "AbortError");
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout },
    signal
  } = options;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (signal?.aborted) {
      reject(getAbortedReason(signal));
      return;
    }
    if (signal) {
      abortHandler = () => {
        reject(getAbortedReason(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    promise.then(resolve, reject);
    if (milliseconds === Number.POSITIVE_INFINITY) {
      return;
    }
    const timeoutError = new TimeoutError3();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && signal) {
      signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value2, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value2) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
class PriorityQueue2 {
  #queue = [];
  enqueue(run, options) {
    const { priority = 0, id } = options ?? {};
    const element = {
      priority,
      id,
      run
    };
    if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {
      this.#queue.push(element);
      return;
    }
    const index = lowerBound(this.#queue, element, (a2, b) => b.priority - a2.priority);
    this.#queue.splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = this.#queue.findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = this.#queue.splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
}
class PQueue extends EventEmitter {
  #carryoverIntervalCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #rateLimitedInInterval = false;
  #rateLimitFlushScheduled = false;
  #interval;
  #intervalEnd = 0;
  #lastExecutionTime = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  // Use to assign a unique identifier to a promise function, if not explicitly specified
  #idAssigner = 1n;
  // Track currently running tasks for debugging
  #runningTasks = /* @__PURE__ */ new Map();
  /**
      Get or set the default timeout for all tasks. Can be changed at runtime.
  
      Operations will throw a `TimeoutError` if they don't complete within the specified time.
  
      The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.
  
      @example
      ```
      const queue = new PQueue({timeout: 5000});
  
      // Change timeout for all future tasks
      queue.timeout = 10000;
      ```
      */
  timeout;
  constructor(options) {
    super();
    options = {
      carryoverIntervalCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue2,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
    }
    this.#carryoverIntervalCount = options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false;
    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
    this.#intervalCap = options.intervalCap;
    this.#interval = options.interval;
    this.#queue = new options.queueClass();
    this.#queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    if (options.timeout !== void 0 && !(Number.isFinite(options.timeout) && options.timeout > 0)) {
      throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${options.timeout}\` (${typeof options.timeout})`);
    }
    this.timeout = options.timeout;
    this.#isPaused = options.autoStart === false;
    this.#setupRateLimitTracking();
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    if (this.#pending === 0) {
      this.emit("pendingZero");
    }
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = void 0;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === void 0) {
      const delay = this.#intervalEnd - now;
      if (delay < 0) {
        if (this.#lastExecutionTime > 0) {
          const timeSinceLastExecution = now - this.#lastExecutionTime;
          if (timeSinceLastExecution < this.#interval) {
            this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);
            return true;
          }
        }
        this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;
      } else {
        this.#createIntervalTimeout(delay);
        return true;
      }
    }
    return false;
  }
  #createIntervalTimeout(delay) {
    if (this.#timeoutId !== void 0) {
      return;
    }
    this.#timeoutId = setTimeout(() => {
      this.#onResumeInterval();
    }, delay);
  }
  #clearIntervalTimer() {
    if (this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = void 0;
    }
  }
  #clearTimeoutTimer() {
    if (this.#timeoutId) {
      clearTimeout(this.#timeoutId);
      this.#timeoutId = void 0;
    }
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      this.#clearIntervalTimer();
      this.emit("empty");
      if (this.#pending === 0) {
        this.#clearTimeoutTimer();
        this.emit("idle");
      }
      return false;
    }
    let taskStarted = false;
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!this.#isIntervalIgnored) {
          this.#intervalCount++;
          this.#scheduleRateLimitUpdate();
        }
        this.emit("active");
        this.#lastExecutionTime = Date.now();
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        taskStarted = true;
      }
    }
    return taskStarted;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      this.#clearIntervalTimer();
    }
    this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;
    this.#processQueue();
    this.#scheduleRateLimitUpdate();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 0, id: '🦀'});
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦄', {priority: 1});
  
      queue.setPriority('🦀', 2);
      ```
  
      In this case, the promise function with `id: '🦀'` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 1, id: '🦀'});
      queue.add(async () => '🦄');
      queue.add(async () => '🦄', {priority: 0});
  
      queue.setPriority('🦀', -1);
      ```
      Here, the promise function with `id: '🦀'` executes last.
      */
  setPriority(id, priority) {
    if (typeof priority !== "number" || !Number.isFinite(priority)) {
      throw new TypeError(`Expected \`priority\` to be a finite number, got \`${priority}\` (${typeof priority})`);
    }
    this.#queue.setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ??= (this.#idAssigner++).toString();
    options = {
      timeout: this.timeout,
      ...options
    };
    return new Promise((resolve, reject) => {
      const taskSymbol = Symbol(`task-${options.id}`);
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#runningTasks.set(taskSymbol, {
          id: options.id,
          priority: options.priority ?? 0,
          // Match priority-queue default
          startTime: Date.now(),
          timeout: options.timeout
        });
        try {
          try {
            options.signal?.throwIfAborted();
          } catch (error) {
            if (!this.#isIntervalIgnored) {
              this.#intervalCount--;
            }
            this.#runningTasks.delete(taskSymbol);
            throw error;
          }
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), {
              milliseconds: options.timeout,
              message: `Task timed out after ${options.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`
            });
          }
          if (options.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        } finally {
          this.#runningTasks.delete(taskSymbol);
          queueMicrotask(() => {
            this.#next();
          });
        }
      }, options);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
    this.#updateRateLimitState();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  /**
      The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.
  
      @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.
      */
  async onPendingZero() {
    if (this.#pending === 0) {
      return;
    }
    await this.#onEvent("pendingZero");
  }
  /**
  @returns A promise that settles when the queue becomes rate-limited due to intervalCap.
  */
  async onRateLimit() {
    if (this.isRateLimited) {
      return;
    }
    await this.#onEvent("rateLimit");
  }
  /**
  @returns A promise that settles when the queue is no longer rate-limited.
  */
  async onRateLimitCleared() {
    if (!this.isRateLimited) {
      return;
    }
    await this.#onEvent("rateLimitCleared");
  }
  /**
      @returns A promise that rejects when any task in the queue errors.
  
      Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.
  
      Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.
  
      @example
      ```
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      queue.add(() => fetchData(1)).catch(() => {});
      queue.add(() => fetchData(2)).catch(() => {});
      queue.add(() => fetchData(3)).catch(() => {});
  
      // Stop processing on first error
      try {
          await Promise.race([
              queue.onError(),
              queue.onIdle()
          ]);
      } catch (error) {
          queue.pause(); // Stop processing remaining tasks
          console.error('Queue failed:', error);
      }
      ```
      */
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  async onError() {
    return new Promise((_resolve, reject) => {
      const handleError3 = (error) => {
        this.off("error", handleError3);
        reject(error);
      };
      this.on("error", handleError3);
    });
  }
  async #onEvent(event, filter2) {
    return new Promise((resolve) => {
      const listener = () => {
        if (filter2 && !filter2()) {
          return;
        }
        this.off(event, listener);
        resolve();
      };
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return this.#queue.filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
  #setupRateLimitTracking() {
    if (this.#isIntervalIgnored) {
      return;
    }
    this.on("add", () => {
      if (this.#queue.size > 0) {
        this.#scheduleRateLimitUpdate();
      }
    });
    this.on("next", () => {
      this.#scheduleRateLimitUpdate();
    });
  }
  #scheduleRateLimitUpdate() {
    if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {
      return;
    }
    this.#rateLimitFlushScheduled = true;
    queueMicrotask(() => {
      this.#rateLimitFlushScheduled = false;
      this.#updateRateLimitState();
    });
  }
  #updateRateLimitState() {
    const previous = this.#rateLimitedInInterval;
    const shouldBeRateLimited = !this.#isIntervalIgnored && this.#intervalCount >= this.#intervalCap && this.#queue.size > 0;
    if (shouldBeRateLimited !== previous) {
      this.#rateLimitedInInterval = shouldBeRateLimited;
      this.emit(shouldBeRateLimited ? "rateLimit" : "rateLimitCleared");
    }
  }
  /**
  Whether the queue is currently rate-limited due to intervalCap.
  */
  get isRateLimited() {
    return this.#rateLimitedInInterval;
  }
  /**
      Whether the queue is saturated. Returns `true` when:
      - All concurrency slots are occupied and tasks are waiting, OR
      - The queue is rate-limited and tasks are waiting
  
      Useful for detecting backpressure and potential hanging tasks.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Backpressure handling
      if (queue.isSaturated) {
          console.log('Queue is saturated, waiting for capacity...');
          await queue.onSizeLessThan(queue.concurrency);
      }
  
      // Monitoring for stuck tasks
      setInterval(() => {
          if (queue.isSaturated) {
              console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);
          }
      }, 60000);
      ```
      */
  get isSaturated() {
    return this.#pending === this.#concurrency && this.#queue.size > 0 || this.isRateLimited && this.#queue.size > 0;
  }
  /**
      The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).
  
      Returns an array of task info objects.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Add tasks with IDs for better debugging
      queue.add(() => fetchUser(123), {id: 'user-123'});
      queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});
  
      // Check what's running
      console.log(queue.runningTasks);
      // => [{
      //   id: 'user-123',
      //   priority: 0,
      //   startTime: 1759253001716,
      //   timeout: undefined
      // }, {
      //   id: 'posts-456',
      //   priority: 1,
      //   startTime: 1759253001916,
      //   timeout: undefined
      // }]
      ```
      */
  get runningTasks() {
    return [...this.#runningTasks.values()].map((task) => ({ ...task }));
  }
}
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}
const DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString$1(answer.data) : answer.data
      };
    })
  };
}
const DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init3 = {}) {
  const httpQueue = new PQueue({
    concurrency: init3.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    options.onProgress?.(new CustomProgressEvent("dns:query", fqdn));
    const response = await httpQueue.add(async () => {
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options?.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      options.onProgress?.(new CustomProgressEvent("dns:response", response2));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}
var hashlru = function(max) {
  if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
  var size2 = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
  function update5(key2, value2) {
    cache2[key2] = value2;
    size2++;
    if (size2 >= max) {
      size2 = 0;
      _cache = cache2;
      cache2 = /* @__PURE__ */ Object.create(null);
    }
  }
  return {
    has: function(key2) {
      return cache2[key2] !== void 0 || _cache[key2] !== void 0;
    },
    remove: function(key2) {
      if (cache2[key2] !== void 0)
        cache2[key2] = void 0;
      if (_cache[key2] !== void 0)
        _cache[key2] = void 0;
    },
    get: function(key2) {
      var v = cache2[key2];
      if (v !== void 0) return v;
      if ((v = _cache[key2]) !== void 0) {
        update5(key2, v);
        return v;
      }
    },
    set: function(key2, value2) {
      if (cache2[key2] !== void 0) cache2[key2] = value2;
      else update5(key2, value2);
    },
    clear: function() {
      cache2 = /* @__PURE__ */ Object.create(null);
      _cache = /* @__PURE__ */ Object.create(null);
    }
  };
};
const hashlru$1 = /* @__PURE__ */ getDefaultExportFromCjs(hashlru);
class CachedAnswers {
  lru;
  constructor(maxSize) {
    this.lru = hashlru$1(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key2 = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key2);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value: value2 }) => ({
        ...value2,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value2.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key2);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key2 = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key2) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key2, answers);
  }
  remove(domain, type) {
    const key2 = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key2);
  }
  clear() {
    this.lru.clear();
  }
}
function cache(size2) {
  return new CachedAnswers(size2);
}
const DEFAULT_ANSWER_CACHE_SIZE = 1e3;
class DNS {
  resolvers;
  cache;
  constructor(init3) {
    this.resolvers = {};
    this.cache = cache(init3.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init3.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      options.onProgress?.(new CustomProgressEvent("dns:cache", cached));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers) {
      if (options.signal?.aborted === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        options.onProgress?.(new CustomProgressEvent("dns:error", err));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
}
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init3 = {}) {
  return new DNS(init3);
}
class DNSAddrResolver {
  dns;
  canResolve(ma) {
    return ma.getComponents().some(({ name: name2 }) => name2 === "dnsaddr");
  }
  async resolve(ma, options) {
    const hostname = ma.getComponents().find((component) => component.name === "dnsaddr")?.value;
    if (hostname == null) {
      return [ma];
    }
    const resolver = this.getDNS(options);
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options?.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId = ma.getComponents().find((component) => component.name === "p2p")?.value;
    const output = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId != null && !addr.includes(peerId)) {
        continue;
      }
      output.push(multiaddr(addr));
    }
    return output;
  }
  getDNS(options) {
    if (options.dns != null) {
      return options.dns;
    }
    if (this.dns == null) {
      this.dns = dns();
    }
    return this.dns;
  }
}
const dnsaddrResolver = new DNSAddrResolver();
async function resolveMultiaddr(address, resolvers, options) {
  const depth = options.depth ?? 0;
  if (depth > (options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH)) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  let resolved = false;
  const output = [];
  for (const resolver of Object.values(resolvers)) {
    if (resolver.canResolve(address)) {
      resolved = true;
      const addresses = await resolver.resolve(address, options);
      for (const address2 of addresses) {
        output.push(...await resolveMultiaddr(address2, resolvers, {
          ...options,
          depth: depth + 1
        }));
      }
    }
  }
  if (resolved === false) {
    output.push(address);
  }
  return output;
}
const defaultOptions$1 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
class DialQueue {
  queue;
  components;
  addressSorter;
  maxPeerAddrsToDial;
  maxDialQueueLength;
  dialTimeout;
  shutDownController;
  connections;
  log;
  resolvers;
  constructor(components, init3 = {}) {
    this.addressSorter = init3.addressSorter;
    this.maxPeerAddrsToDial = init3.maxPeerAddrsToDial ?? defaultOptions$1.maxPeerAddrsToDial;
    this.maxDialQueueLength = init3.maxDialQueueLength ?? defaultOptions$1.maxDialQueueLength;
    this.dialTimeout = init3.dialTimeout ?? defaultOptions$1.dialTimeout;
    this.connections = init3.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.resolvers = init3.resolvers ?? defaultOptions$1.resolvers;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.queue = new PriorityQueue$1({
      concurrency: init3.maxParallelDials ?? defaultOptions$1.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("failure", (event) => {
      if (event.detail?.error.name !== AbortError$6.name) {
        this.log.error("error in dial queue - %e", event.detail.error);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId != null && options.force !== true) {
      const existingConnection = findExistingConnection(peerId, this.connections.get(peerId), multiaddrs);
      if (existingConnection != null) {
        this.log("already connected to %a", existingConnection.remoteAddr);
        options.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
    }
    const existingDial = this.queue.queue.find((job) => {
      if (peerId?.equals(job.options.peerId) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      options.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
    options.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options2) => {
      options2.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options2.signal
      ]);
      try {
        return await this.dialPeer(options2, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options.onProgress
    });
  }
  async dialPeer(options, signal) {
    const peerId = options.peerId;
    const multiaddrs = options.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {
        ...options,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId, addrsToDial.map((ma) => ma.multiaddr.toString()));
      options?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
          throw new DialError("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p - %e", peerId, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a - %e", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId != null) {
            try {
              await this.components.peerStore.merge(peerId, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p - %e", peerId, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError$2(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw new DialError("Tried to dial self");
      }
      if (await this.components.connectionGater.denyDialPeer?.(peerId) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.components.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId, options);
          this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {
        dns: this.components.dns,
        log: this.log,
        ...options
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastComponent = addr.multiaddr.getComponents().pop();
        if (lastComponent?.name !== "p2p") {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      if (peerId != null && addrPeerId != null) {
        return peerId.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
      if (options.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit$1.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
}
const objectToString = Object.prototype.toString;
const isError = (value2) => objectToString.call(value2) === "[object Error]";
const errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError(error) {
  const isValid2 = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid2) {
    return false;
  }
  const { message: message2, stack } = error;
  if (message2 === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error;
  }
  if (message2.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message2);
}
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name2, value2, { min = 0, allowInfinity = false } = {}) {
  if (value2 === void 0) {
    return;
  }
  if (typeof value2 !== "number" || Number.isNaN(value2)) {
    throw new TypeError(`Expected \`${name2}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value2)) {
    throw new TypeError(`Expected \`${name2}\` to be a finite number.`);
  }
  if (value2 < min) {
    throw new TypeError(`Expected \`${name2}\` to be ≥ ${min}.`);
  }
}
class AbortError7 extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
}
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout = Math.min(timeout, options.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start2, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start2);
}
async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError7) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref) {
        timeoutToken.unref?.();
      }
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1e3;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {
  };
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
  validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
  validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
  validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure({
        error,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
class ReconnectQueue {
  log;
  queue;
  started;
  peerStore;
  retries;
  retryInterval;
  backoffFactor;
  connectionManager;
  events;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init3.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init3.retries ?? 5;
    this.backoffFactor = init3.backoffFactor;
    this.retryInterval = init3.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId)) {
      return;
    }
    this.queue.add(async (options) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId, {
            signal: options?.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options?.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key2) => {
        if (key2.startsWith(KEEP_ALIVE)) {
          tags[key2] = void 0;
        }
      });
      await this.peerStore.merge(peerId, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error("could not open connection to keepalive peer - %e", err);
        });
      }));
    }).catch((err) => {
      this.log.error("error reconnect to peers after start - %e", err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
}
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}
const DEFAULT_DIAL_PRIORITY = 50;
const defaultOptions = {
  maxConnections: MAX_CONNECTIONS$1,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
class DefaultConnectionManager {
  started;
  connections;
  allow;
  deny;
  maxIncomingPendingConnections;
  incomingPendingConnections;
  outboundPendingConnections;
  maxConnections;
  dialQueue;
  reconnectQueue;
  connectionPruner;
  inboundConnectionRateLimiter;
  peerStore;
  metrics;
  events;
  log;
  peerId;
  constructor(components, init3 = {}) {
    this.maxConnections = init3.maxConnections ?? defaultOptions.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError$1("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init3.allow ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.deny = (init3.deny ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init3.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init3.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      allow: init3.allow?.map((a2) => multiaddr(a2))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init3.addressSorter,
      maxParallelDials: init3.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init3.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init3.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init3.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init3.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init3.reconnectRetries,
      retryInterval: init3.reconnectRetryInterval,
      backoffFactor: init3.reconnectBackoffFactor,
      maxParallelReconnects: init3.maxParallelReconnects
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-manager";
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key2 = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key2] = (metric[key2] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key2 = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key2] = (streams[key2] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a2, b) => a2 - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push(Promise.all([
          pEvent(connection, "close", {
            signal: AbortSignal.timeout(500)
          }),
          connection.close({
            signal: AbortSignal.timeout(500)
          })
        ]).catch((err) => {
          connection.abort(err);
        }));
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  setMaxConnections(maxConnections) {
    if (this.maxConnections < 1) {
      throw new InvalidParametersError$1("Connection Manager maxConnections must be greater than 0");
    }
    let needsPrune = false;
    if (maxConnections < this.maxConnections) {
      needsPrune = true;
    }
    this.maxConnections = maxConnections;
    if (needsPrune) {
      this.connectionPruner.maybePruneConnections();
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error("could not connect - %e", err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId);
    const storedConns = this.connections.get(peerId) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId, storedConns);
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId = connection.remotePeer;
    const peerConns = this.connections.get(peerId) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log.trace("peer %p disconnected, removing connection map entry", peerId);
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: peerId });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c2 of this.connections.values()) {
      conns = conns.concat(c2);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      options.signal?.throwIfAborted();
      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId != null && options.force !== true) {
        this.log("dial %p", peerId);
        const existingConnection = findExistingConnection(peerId, this.getConnections(peerId), multiaddrs);
        if (existingConnection != null) {
          this.log("had an existing connection to %p as %a", peerId, existingConnection.remoteAddr);
          options.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError$1("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async openStream(peerIdOrMultiaddr, protocol, options = {}) {
    const connection = await this.openConnection(peerIdOrMultiaddr, options);
    return connection.newStream(protocol, options);
  }
  async closeConnections(peerId, options = {}) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await Promise.all([
          pEvent(connection, "close", options),
          connection.close(options)
        ]);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return false;
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return true;
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (isNetworkAddress(maConn.remoteAddr)) {
      const config = getNetConfig(maConn.remoteAddr);
      try {
        this.inboundConnectionRateLimiter.consume(config.host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, config.host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options = {}) {
    return this.dialQueue.isDialable(multiaddr2, options);
  }
}
const DEFAULT_PING_INTERVAL_MS = 1e4;
const PROTOCOL_VERSION = "1.0.0";
const PROTOCOL_NAME = "ping";
const PROTOCOL_PREFIX = "ipfs";
const PING_LENGTH = 32;
const DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
class ConnectionMonitor {
  protocol;
  components;
  log;
  heartbeatInterval;
  pingIntervalMs;
  abortController;
  timeout;
  abortConnectionOnPingFailure;
  constructor(components, init3 = {}) {
    this.components = components;
    this.protocol = `/${init3.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init3.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init3.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init3.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  [Symbol.toStringTag] = "@libp2p/connection-monitor";
  [serviceCapabilities] = [
    "@libp2p/connection-monitor"
  ];
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: this.abortController?.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes(PING_LENGTH), {
                signal
              }),
              bs.read({
                bytes: PING_LENGTH,
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await stream.close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat - %e", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    this.abortController?.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
}
class CompoundContentRouting {
  routers;
  started;
  components;
  constructor(components, init3) {
    this.routers = init3.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = components.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value2, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value2.id.toString()]
        };
      }
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.provide;
    this.cancelReprovide = components.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.cancelReprovide;
    this.put = components.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key2]) => {
        return {
          key: toString$1(key2, "base36")
        };
      }
    }) ?? this.put;
    this.get = components.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key2]) => {
        return {
          key: toString$1(key2, "base36")
        };
      }
    }) ?? this.get;
  }
  [Symbol.toStringTag] = "@libp2p/content-routing";
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key2, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self2 = this;
    const seen2 = new PeerSet();
    for await (const peer of merge(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key2, options)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen2.has(peer.id)) {
        continue;
      }
      seen2.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key2, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
      await router.provide(key2, options);
    }));
  }
  async cancelReprovide(key2, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
      await router.cancelReprovide(key2, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key2, value2, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
      await router.put(key2, value2, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key2, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
      return router.get(key2, options);
    }));
  }
}
const CustomEvent$1 = globalThis.CustomEvent ?? Event;
async function* parallel(source, options = {}) {
  let concurrency = options.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options.ordered ?? false;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent$1("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent$1("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent$1("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent$1("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (ops[i2].done) {
          const op = ops[i2];
          ops.splice(i2, 1);
          i2--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}
class DefaultPeerRouting {
  log;
  peerId;
  peerStore;
  routers;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init3.routers ?? [];
    this.findPeer = components.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key2], attrs) => {
        return {
          ...attrs,
          key: toString$1(key2, "base36")
        };
      },
      getAttributesFromYieldedValue: (value2, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value2.id.toString()]
        };
      }
    }) ?? this.getClosestPeers;
  }
  [Symbol.toStringTag] = "@libp2p/peer-routing";
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self2 = this;
    const source = merge(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        self2.log.error("router failed to find peer - %e", err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      return peer;
    }
    throw new NotFoundError$1();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key2, options = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self2 = this;
    const seen2 = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = merge(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key2, options)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self2.findPeer(peer2.id, {
                ...options,
                useCache: false
              });
            } catch (err) {
              self2.log.error("could not find peer multiaddrs - %e", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options);
      }
      if (seen2.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen2.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
}
class RandomWalk extends TypedEventEmitter {
  peerRouting;
  log;
  walking;
  walkers;
  shutdownController;
  walkController;
  needNext;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  [Symbol.toStringTag] = "@libp2p/random-walk";
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options) {
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options?.signal]);
    try {
      while (true) {
        this.needNext?.resolve();
        this.needNext = pDefer();
        const event = await pEvent(this, "walk:peer", {
          signal,
          rejectionEvents: [
            "walk:error"
          ]
        });
        yield event.detail;
      }
    } catch (err) {
      if (err.detail != null) {
        throw err.detail;
      }
      throw err;
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        this.walkController?.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes(32);
          let s2 = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal$2(this.needNext.promise, signal);
            }
            s2 = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored - %e", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored - %e", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
}
const DEFAULT_MAX_INBOUND_STREAMS = 32;
const DEFAULT_MAX_OUTBOUND_STREAMS = 64;
class Registrar {
  log;
  topologies;
  handlers;
  components;
  middleware;
  constructor(components) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:registrar");
    this.middleware = /* @__PURE__ */ new Map();
    this.topologies = /* @__PURE__ */ new Map();
    components.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
      calculate: () => {
        const output = {};
        for (const [key2, value2] of this.topologies) {
          output[key2] = value2.size;
        }
        return output;
      }
    });
    this.handlers = trackedMap({
      name: "libp2p_registrar_protocol_handlers",
      metrics: components.metrics
    });
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  [Symbol.toStringTag] = "@libp2p/registrar";
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol) && opts?.force !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    this.handlers.set(protocol, {
      handler,
      options: {
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS,
        ...opts
      }
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    }, opts);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols, options) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    }, options);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError$1("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  use(protocol, middleware) {
    this.middleware.set(protocol, middleware);
  }
  unuse(protocol) {
    this.middleware.delete(protocol);
  }
  getMiddleware(protocol) {
    return this.middleware.get(protocol) ?? [];
  }
  /**
   * Remove a disconnected peer from the record
   */
  async _onDisconnect(evt) {
    const remotePeer = evt.detail;
    const options = {
      signal: AbortSignal.timeout(5e3)
    };
    try {
      const peer = await this.components.peerStore.get(remotePeer, options);
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (topology.filter?.has(remotePeer) === false) {
            return;
          }
          topology.filter?.remove(remotePeer);
          await topology.onDisconnect?.(remotePeer);
        }));
      }
    } catch (err) {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p - %e", remotePeer, err);
    }
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  async _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = (previous?.protocols ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    try {
      for (const protocol of removed) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (topology.filter?.has(peer.id) === false) {
            return;
          }
          topology.filter?.remove(peer.id);
          await topology.onDisconnect?.(peer.id);
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer %p - %e", peer.id, err);
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  async _onPeerIdentify(evt) {
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId = evt.detail.peerId;
    try {
      for (const protocol of protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
            return;
          }
          if (topology.filter?.has(peerId) === true) {
            return;
          }
          topology.filter?.add(peerId);
          await topology.onConnect?.(peerId, connection);
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer after identify %p - %e", peerId, err);
    }
  }
}
class DefaultTransportManager {
  log;
  components;
  transports;
  listeners;
  faultTolerance;
  started;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = trackedMap({
      name: "libp2p_transport_manager_transports",
      metrics: this.components.metrics
    });
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init3.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  [Symbol.toStringTag] = "@libp2p/transport-manager";
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError$1("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError$1(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key2, listeners] of this.listeners) {
      this.log("closing listeners for %s", key2);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key2 of this.listeners.keys()) {
      this.listeners.set(key2, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    options?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key2, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key2, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key2) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key2, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l2) => l2 === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP4.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP6.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP4.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP6.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key2, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${getErrorMessage(err)}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key2) {
    const listeners = this.listeners.get(key2) ?? [];
    this.log.trace("removing transport %s", key2);
    const tasks = [];
    this.log.trace("closing listeners for %s", key2);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key2);
    this.listeners.delete(key2);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key2 of this.transports.keys()) {
      tasks.push(this.remove(key2));
    }
    await Promise.all(tasks);
  }
}
function getErrorMessage(err) {
  if (err.stack != null && err.stack.trim() !== "") {
    return err.stack;
  }
  if (err.message != null) {
    return err.message;
  }
  return err.toString();
}
const PROTOCOL_ID = "/multistream/1.0.0";
const MAX_PROTOCOL_LENGTH = 1024;
const NewLine = fromString("\n");
async function readString(reader, options) {
  const buf = await reader.read(options);
  const arr = buf.subarray();
  if (arr.byteLength === 0 || arr[arr.length - 1] !== NewLine[0]) {
    throw new InvalidMessageError("Missing newline");
  }
  return toString$1(arr).trimEnd();
}
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 0) {
    throw new Error("At least one protocol must be specified");
  }
  const log2 = stream.log.newScope("mss:select");
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  for (let i2 = 0; i2 < protocols.length; i2++) {
    const protocol = protocols[i2];
    let response;
    if (i2 === 0) {
      log2.trace('write ["%s", "%s"]', PROTOCOL_ID, protocol);
      const p1 = fromString(`${PROTOCOL_ID}
`);
      const p2 = fromString(`${protocol}
`);
      await lp.writeV([p1, p2], options);
      log2.trace("reading multistream-select header");
      response = await readString(lp, options);
      log2.trace('read "%s"', response);
      if (response !== PROTOCOL_ID) {
        log2.error("did not read multistream-select header from response");
        break;
      }
    } else {
      log2.trace('write "%s"', protocol);
      await lp.write(fromString(`${protocol}
`), options);
    }
    log2.trace("reading protocol response");
    response = await readString(lp, options);
    log2.trace('read "%s"', response);
    if (response === protocol) {
      log2.trace('selected "%s" after negotiation', response);
      lp.unwrap();
      return protocol;
    }
  }
  throw new UnsupportedProtocolError(`Protocol selection failed - could not negotiate ${protocols}`);
}
async function handle(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const log2 = stream.log.newScope("mss:handle");
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    log2.trace("reading incoming string");
    const protocol = await readString(lp, options);
    log2.trace('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log2.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await lp.write(fromString(`${PROTOCOL_ID}
`), options);
      log2.trace('responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols.includes(protocol)) {
      log2.trace('respond with "%s" for "%s"', protocol, protocol);
      await lp.write(fromString(`${protocol}
`), options);
      log2.trace('responded with "%s" for "%s"', protocol, protocol);
      lp.unwrap();
      return protocol;
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p2) => encode.single(fromString(`${p2}
`))), fromString("\n"));
      log2.trace('respond with "%s" for %s', protocols, protocol);
      await lp.write(protos, options);
      log2.trace('responded with "%s" for %s', protocols, protocol);
      continue;
    }
    log2.trace('respond with "na" for "%s"', protocol);
    await lp.write(fromString("na\n"), options);
    log2('responded with "na" for "%s"', protocol);
  }
}
class Connection extends TypedEventEmitter {
  id;
  remoteAddr;
  remotePeer;
  direction;
  timeline;
  direct;
  multiplexer;
  encryption;
  limits;
  log;
  maConn;
  muxer;
  components;
  outboundStreamProtocolNegotiationTimeout;
  inboundStreamProtocolNegotiationTimeout;
  closeTimeout;
  constructor(components, init3) {
    super();
    this.components = components;
    this.id = init3.id;
    this.remoteAddr = init3.maConn.remoteAddr;
    this.remotePeer = init3.remotePeer;
    this.direction = init3.direction ?? "outbound";
    this.timeline = init3.maConn.timeline;
    this.encryption = init3.cryptoProtocol;
    this.limits = init3.limits;
    this.maConn = init3.maConn;
    this.log = init3.maConn.log;
    this.outboundStreamProtocolNegotiationTimeout = init3.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init3.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.closeTimeout = init3.closeTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.direct = isDirect(init3.maConn.remoteAddr);
    this.onIncomingStream = this.onIncomingStream.bind(this);
    if (this.remoteAddr.getComponents().find((component) => component.code === CODE_P2P) == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    if (init3.muxer != null) {
      this.multiplexer = init3.muxer.protocol;
      this.muxer = init3.muxer;
      this.muxer.addEventListener("stream", this.onIncomingStream);
    }
    this.maConn.addEventListener("close", (evt) => {
      this.dispatchEvent(new StreamCloseEvent(evt.local, evt.error));
    });
  }
  [Symbol.toStringTag] = "Connection";
  [connectionSymbol] = true;
  get streams() {
    return this.muxer?.streams ?? [];
  }
  get status() {
    return this.maConn.status;
  }
  /**
   * Create a new stream over this connection
   */
  newStream = async (protocols, options = {}) => {
    if (this.muxer == null) {
      throw new MuxerUnavailableError("Connection is not multiplexed");
    }
    if (this.muxer.status !== "open") {
      throw new ConnectionClosedError(`The connection muxer is "${this.muxer.status}" and not "open"`);
    }
    if (this.maConn.status !== "open") {
      throw new ConnectionClosedError(`The connection is "${this.status}" and not "open"`);
    }
    if (this.limits != null && options?.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    this.log.trace("starting new stream for protocols %s", protocols);
    const muxedStream = await this.muxer.createStream({
      ...options,
      // most underlying transports only support negotiating a single protocol
      // so only pass the early protocol if a single protocol has been requested
      // otherwise fall back to mss
      protocol: protocols.length === 1 ? protocols[0] : void 0
    });
    this.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
    try {
      if (options.signal == null) {
        muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
        const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      if (muxedStream.protocol === "") {
        muxedStream.log.trace("selecting protocol from protocols %s", protocols);
        muxedStream.protocol = await select(muxedStream, protocols, options);
        muxedStream.log("negotiated protocol %s", muxedStream.protocol);
      } else {
        muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
      }
      const outgoingLimit = findOutgoingStreamLimit(muxedStream.protocol, this.components.registrar, options);
      const streamCount = countStreams(muxedStream.protocol, "outbound", this);
      if (streamCount > outgoingLimit) {
        const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${muxedStream.protocol}" - ${streamCount}/${outgoingLimit}`);
        muxedStream.abort(err);
        throw err;
      }
      await this.components.peerStore.merge(this.remotePeer, {
        protocols: [muxedStream.protocol]
      });
      this.components.metrics?.trackProtocolStream(muxedStream);
      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
      return await this.runMiddlewareChain(muxedStream, this, middleware);
    } catch (err) {
      if (muxedStream.status === "open") {
        muxedStream.abort(err);
      } else {
        this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", this.direction === "inbound" ? "from" : "to", this.remoteAddr, protocols, err);
      }
      throw err;
    }
  };
  async onIncomingStream(evt) {
    const muxedStream = evt.detail;
    const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
    muxedStream.log("start protocol negotiation, timing out after %dms", this.inboundStreamProtocolNegotiationTimeout);
    try {
      if (muxedStream.protocol === "") {
        const protocols = this.components.registrar.getProtocols();
        muxedStream.log.trace("selecting protocol from protocols %s", protocols);
        muxedStream.protocol = await handle(muxedStream, protocols, {
          signal
        });
        muxedStream.log("negotiated protocol %s", muxedStream.protocol);
      } else {
        muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
      }
      const incomingLimit = findIncomingStreamLimit(muxedStream.protocol, this.components.registrar);
      const streamCount = countStreams(muxedStream.protocol, "inbound", this);
      if (streamCount > incomingLimit) {
        throw new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${muxedStream.protocol}" - limit ${incomingLimit}`);
      }
      await this.components.peerStore.merge(this.remotePeer, {
        protocols: [muxedStream.protocol]
      }, {
        signal
      });
      this.components.metrics?.trackProtocolStream(muxedStream);
      const { handler, options } = this.components.registrar.getHandler(muxedStream.protocol);
      if (this.limits != null && options.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
      middleware.push(async (stream, connection, next) => {
        await handler(stream, connection);
        next(stream, connection);
      });
      await this.runMiddlewareChain(muxedStream, this, middleware);
    } catch (err) {
      muxedStream.abort(err);
    }
  }
  async runMiddlewareChain(stream, connection, middleware) {
    for (let i2 = 0; i2 < middleware.length; i2++) {
      const mw = middleware[i2];
      stream.log.trace("running middleware", i2, mw);
      await new Promise((resolve, reject) => {
        try {
          const result = mw(stream, connection, (s2, c2) => {
            stream = s2;
            connection = c2;
            resolve();
          });
          if (result instanceof Promise) {
            result.catch(reject);
          }
        } catch (err) {
          reject(err);
        }
      });
      stream.log.trace("ran middleware", i2, mw);
    }
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    this.log("closing connection to %a", this.remoteAddr);
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.closeTimeout);
      options = {
        ...options,
        signal
      };
    }
    await this.muxer?.close(options);
    await this.maConn.close(options);
  }
  abort(err) {
    this.muxer?.abort(err);
    this.maConn.abort(err);
  }
}
function createConnection(components, init3) {
  return new Connection(components, init3);
}
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    if (options.maxInboundStreams != null) {
      return options.maxInboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
class Upgrader {
  components;
  connectionEncrypters;
  streamMuxers;
  inboundUpgradeTimeout;
  inboundStreamProtocolNegotiationTimeout;
  outboundStreamProtocolNegotiationTimeout;
  events;
  metrics;
  connectionCloseTimeout;
  constructor(components, init3) {
    this.components = components;
    this.connectionEncrypters = trackedMap({
      name: "libp2p_upgrader_connection_encrypters",
      metrics: this.components.metrics
    });
    init3.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = trackedMap({
      name: "libp2p_upgrader_stream_multiplexers",
      metrics: this.components.metrics
    });
    init3.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init3.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init3.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init3.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.connectionCloseTimeout = init3.connectionCloseTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
      inboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
      outboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
    };
  }
  [Symbol.toStringTag] = "@libp2p/upgrader";
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    return output;
  }
  async upgradeInbound(maConn, opts) {
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      this.metrics.dials?.increment({
        inbound: true
      });
      accepted = this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await raceSignal$2(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      this.metrics.errors?.increment({
        inbound: true
      });
      this.metrics.inboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  async upgradeOutbound(maConn, opts) {
    try {
      this.metrics.dials?.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString$1(idStr);
        await raceSignal$2(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      this.metrics.errors?.increment({
        outbound: true
      });
      this.metrics.outboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    let stream = maConn;
    let remotePeer;
    let muxerFactory;
    let muxer;
    let cryptoProtocol;
    const id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    maConn.log = maConn.log.newScope(`${direction}:${id}`);
    this.components.metrics?.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        stream = await protector.protect(stream, opts);
      }
    }
    try {
      if (isEncryptionSkipped(opts)) {
        if (opts.remotePeer == null) {
          throw new InvalidMultiaddrError$1(`${direction} connection that skipped encryption must have a peer id`);
        }
        cryptoProtocol = "native";
        remotePeer = opts.remotePeer;
      } else {
        const peerIdString = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
        let remotePeerFromMultiaddr;
        if (peerIdString != null) {
          remotePeerFromMultiaddr = peerIdFromString$1(peerIdString);
        }
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          connection: stream,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        }) : this._encryptOutbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        })));
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn);
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        muxerFactory = await (direction === "inbound" ? this._multiplexInbound(stream, this.streamMuxers, opts) : this._multiplexOutbound(stream, this.streamMuxers, opts));
      }
    } catch (err) {
      maConn.log.error("failed to upgrade %s connection %s %a - %e", direction, direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    if (muxerFactory != null) {
      maConn.log("create muxer %s", muxerFactory.protocol);
      muxer = muxerFactory.createStreamMuxer(stream);
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    const conn = this._createConnection({
      id,
      cryptoProtocol,
      direction,
      maConn,
      stream,
      muxer,
      remotePeer,
      limits: opts?.limits,
      closeTimeout: this.connectionCloseTimeout
    });
    conn.log("successfully upgraded connection");
    return conn;
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const connection = createConnection(this.components, {
      ...opts,
      outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,
      inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout
    });
    connection.addEventListener("close", () => {
      this.events.safeDispatchEvent("connection:close", {
        detail: connection
      });
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      const protocol = await handle(connection, protocols, options);
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection using %s", protocol);
      return {
        ...await encrypter.secureInbound(connection, options),
        protocol
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const protocol = await select(connection, protocols, options);
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection using %s", protocol);
      return {
        ...await encrypter.secureOutbound(connection, options),
        protocol
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(maConn, muxers, options) {
    const protocols = Array.from(muxers.keys());
    maConn.log("outbound selecting muxer %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol = await select(maConn, protocols, options);
      const muxerFactory = muxers.get(protocol);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing outbound connection - %e", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(maConn, muxers, options) {
    const protocols = Array.from(muxers.keys());
    maConn.log("inbound handling muxers %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol = await handle(maConn, protocols, options);
      const muxerFactory = muxers.get(protocol);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing inbound connection - %e", err);
      throw err;
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
}
function isEncryptionSkipped(opts) {
  return opts.skipEncryption === true;
}
const version$2 = "3.0.7";
const name = "js-libp2p";
function userAgent(name$12, version3) {
  return `${name$12 ?? name}/${version3 ?? version$2} browser/${globalThis.navigator.userAgent}`;
}
class Libp2p extends TypedEventEmitter {
  peerId;
  peerStore;
  contentRouting;
  peerRouting;
  metrics;
  services;
  logger;
  status;
  components;
  log;
  // eslint-disable-next-line complexity
  constructor(init3) {
    super();
    this.status = "stopped";
    const events = new TypedEventEmitter();
    const originalDispatch = events.dispatchEvent.bind(events);
    events.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    this.peerId = init3.peerId;
    this.logger = init3.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = init3.nodeInfo?.name ?? name;
    const nodeInfoVersion = init3.nodeInfo?.version ?? version$2;
    const components = this.components = defaultComponents({
      peerId: init3.peerId,
      privateKey: init3.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: init3.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events,
      datastore: init3.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init3.connectionGater),
      dns: init3.dns
    });
    if (init3.metrics != null) {
      this.metrics = this.configureComponent("metrics", init3.metrics(this.components));
    }
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init3.peerStore
    }));
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a2) => a2.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init3.connectionProtector != null) {
      this.configureComponent("connectionProtector", init3.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init3.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init3.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init3.connectionManager?.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: init3.connectionManager?.inboundStreamProtocolNegotiationTimeout,
      outboundStreamProtocolNegotiationTimeout: init3.connectionManager?.outboundStreamProtocolNegotiationTimeout,
      connectionCloseTimeout: init3.connectionManager?.connectionCloseTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init3.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init3.connectionManager));
    if (init3.connectionMonitor?.enabled !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init3.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init3.addresses));
    const peerRouters = (init3.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init3.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init3.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.#onDiscoveryPeer(evt);
      });
    });
    init3.transports?.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init3.services != null) {
      for (const name2 of Object.keys(init3.services)) {
        const createService = init3.services[name2];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name2);
          continue;
        }
        this.services[name2] = service;
        this.configureComponent(name2, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name2);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name2);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name2);
          service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
            this.#onDiscoveryPeer(evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name2, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name2);
    }
    this.components[name2] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await this.components.beforeStart?.();
      await this.components.start();
      await this.components.afterStart?.();
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started with peer id %p", this.peerId);
    } catch (err) {
      this.log.error("an error occurred starting libp2p - %e", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await this.components.beforeStop?.();
    await this.components.stop();
    await this.components.afterStop?.();
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options
    });
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new InvalidParametersError$1("no protocols were provided to open a stream");
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new InvalidParametersError$1("no protocols were provided to open a stream");
    }
    return this.components.connectionManager.openStream(peer, protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString$1(peer.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  async getPublicKey(peer, options = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer, options);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options);
    const publicKey = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey
    }, options);
    return publicKey;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol, options);
    }));
  }
  async register(protocol, topology, options) {
    return this.components.registrar.register(protocol, topology, options);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  use(protocol, middleware) {
    this.components.registrar.use(protocol, Array.isArray(middleware) ? middleware : [middleware]);
  }
  unuse(protocol) {
    this.components.registrar.unuse(protocol);
  }
  async isDialable(multiaddr2, options = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options);
  }
  /**
   * Called whenever peer discovery services emit `peer` events and adds peers
   * to the peer store.
   */
  #onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      this.log.error("peer discovery mechanism discovered self");
      return;
    }
    void this.components.peerStore.merge(peer.id, {
      multiaddrs: peer.multiaddrs
    }).catch((err) => {
      this.log.error("could not update multiaddrs of discovered peer - %e", err);
    });
  }
}
async function createLibp2p(options = {}) {
  options.privateKey ??= await generateKeyPair();
  const node = new Libp2p({
    ...await validateConfig(options),
    peerId: peerIdFromPrivateKey(options.privateKey)
  });
  if (options.start !== false) {
    await node.start();
  }
  return node;
}
var Message$1;
(function(Message2) {
  (function(Flag2) {
    Flag2["FIN"] = "FIN";
    Flag2["STOP_SENDING"] = "STOP_SENDING";
    Flag2["RESET"] = "RESET";
    Flag2["FIN_ACK"] = "FIN_ACK";
  })(Message2.Flag || (Message2.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
    __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag2) {
    Flag2.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Message2.Flag || (Message2.Flag = {}));
  let _codec;
  Message2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.flag != null) {
          w.uint32(8);
          Message2.Flag.codec().encode(obj.flag, w);
        }
        if (obj.message != null) {
          w.uint32(18);
          w.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.flag = Message2.Flag.codec().decode(reader);
              break;
            }
            case 2: {
              obj.message = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message2.encode = (obj) => {
    return encodeMessage(obj, Message2.codec());
  };
  Message2.decode = (buf, opts) => {
    return decodeMessage(buf, Message2.codec(), opts);
  };
})(Message$1 || (Message$1 = {}));
const DEFAULT_ICE_SERVERS = [
  "stun:stun.l.google.com:19302",
  "stun:global.stun.twilio.com:3478",
  "stun:stun.cloudflare.com:3478",
  "stun:stun.services.mozilla.com:3478"
];
Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
const MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
const MAX_MESSAGE_SIZE = 16 * 1024;
function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE) {
  const messageLength = encodingLength(maxMessageSize - encodingLength(maxMessageSize));
  const flagField = 1 + encodingLength(Object.keys(Message$1.Flag).length - 1);
  const messageFieldIdType = 1;
  const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
  const messageFieldLengthLength = encodingLength(available);
  return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
}
const PROTOBUF_OVERHEAD = calculateProtobufOverhead();
const DEFAULT_FIN_ACK_TIMEOUT = 1e4;
const MUXER_PROTOCOL = "/webrtc";
const SIGNALING_PROTOCOL = "/webrtc-signaling/0.0.1";
var __spreadArray = function(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name2, version3, os) {
      this.name = name2;
      this.version = version3;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version3) {
      this.version = version3;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name2, version3, os, bot) {
      this.name = name2;
      this.version = version3;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent2) {
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
const browser = detect();
const isFirefox = browser != null && browser.name === "firefox";
async function getRtcConfiguration(config) {
  config = config ?? {};
  if (typeof config === "function") {
    config = await config();
  }
  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
    urls: [
      url
    ]
  }));
  return config;
}
class WebRTCStream extends AbstractStream {
  /**
   * The data channel used to send and receive data
   */
  channel;
  /**
   * push data from the underlying datachannel to the length prefix decoder
   * and then the protobuf decoder.
   */
  incomingData;
  maxBufferedAmount;
  receivedFinAck;
  finAckTimeout;
  constructor(init3) {
    super({
      ...init3,
      maxMessageSize: (init3.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD
    });
    this.channel = init3.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.maxBufferedAmount = init3.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
    this.finAckTimeout = init3.finAckTimeout ?? DEFAULT_FIN_ACK_TIMEOUT;
    this.channel.onclose = () => {
      this.log.trace("received datachannel close event");
      this.onRemoteCloseWrite();
      this.onTransportClosed();
    };
    this.channel.onerror = (evt) => {
      const err = evt.error;
      this.log.trace("received datachannel error event - %e", err);
      this.abort(err);
    };
    this.channel.onmessage = async (event) => {
      this.log("incoming message %d bytes", event.data.byteLength);
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    this.channel.bufferedAmountLowThreshold = 0;
    this.channel.onbufferedamountlow = () => {
      if (this.writableNeedsDrain) {
        this.safeDispatchEvent("drain");
      }
    };
    Promise.resolve().then(async () => {
      for await (const buf of decode(this.incomingData)) {
        this.processIncomingProtobuf(buf);
      }
    }).catch((err) => {
      this.log.error("error processing incoming data channel messages - %e", err);
    });
    const cleanUpDatachannelOnClose = () => {
      if (this.channel.readyState === "open") {
        this.log.trace("stream closed, closing underlying datachannel");
        this.channel.close();
      }
    };
    this.addEventListener("close", cleanUpDatachannelOnClose);
    if (this.channel.readyState !== "open") {
      this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
      pEvent(this.channel, "open", {
        rejectionEvents: [
          "close",
          "error"
        ]
      }).then(() => {
        this.log('channel ready state is now "%s", dispatching drain', this.channel.readyState);
        this.safeDispatchEvent("drain");
      }).catch((err) => {
        this.abort(err.error ?? err);
      });
    }
  }
  sendNewStream() {
  }
  _sendMessage(data) {
    if (this.channel.readyState !== "open") {
      throw new StreamStateError(`Invalid datachannel state - ${this.channel.readyState}`);
    }
    this.log.trace('sending message, channel state "%s"', this.channel.readyState);
    if (isFirefox) {
      this.channel.send(data.subarray());
      return;
    }
    for (const buf of data) {
      this.channel.send(buf);
    }
  }
  sendData(data) {
    if (this.channel.readyState !== "open") {
      return {
        sentBytes: 0,
        canSendMore: false
      };
    }
    this._sendMessage(encode.single(Message$1.encode({
      message: data.subarray()
    })));
    return {
      sentBytes: data.byteLength,
      canSendMore: this.channel.bufferedAmount < this.maxBufferedAmount
    };
  }
  sendReset(err) {
    try {
      this.log.error("sending reset - %e", err);
      this._sendFlag(Message$1.Flag.RESET);
      this.receivedFinAck?.reject(err);
    } catch (err2) {
      this.log.error("failed to send reset - %e", err2);
    }
  }
  async sendCloseWrite(options) {
    this._sendFlag(Message$1.Flag.FIN);
    options?.signal?.throwIfAborted();
    this.receivedFinAck = Promise.withResolvers();
    const signal = options?.signal ?? AbortSignal.timeout(this.finAckTimeout);
    const eventPromises = [
      pEvent(this.channel, "close", {
        signal
      }),
      pEvent(this.channel, "error", {
        signal
      })
    ];
    await Promise.any([
      raceSignal$2(this.receivedFinAck.promise, signal),
      ...eventPromises
    ]).finally(() => {
      eventPromises.forEach((p2) => p2.cancel());
    });
  }
  async sendCloseRead(options) {
    this._sendFlag(Message$1.Flag.STOP_SENDING);
    options?.signal?.throwIfAborted();
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer) {
    const message2 = Message$1.decode(buffer);
    if (message2.message != null && (this.readStatus === "readable" || this.readStatus === "paused")) {
      this.onData(new Uint8ArrayList(message2.message));
    }
    if (message2.flag !== void 0) {
      this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
      if (message2.flag === Message$1.Flag.FIN) {
        this._sendFlag(Message$1.Flag.FIN_ACK);
        this.onRemoteCloseWrite();
      }
      if (message2.flag === Message$1.Flag.RESET) {
        this.receivedFinAck?.reject(new StreamResetError("The stream was reset"));
        this.onRemoteReset();
      }
      if (message2.flag === Message$1.Flag.STOP_SENDING) {
        this.onRemoteCloseRead();
      }
      if (message2.flag === Message$1.Flag.FIN_ACK) {
        this.receivedFinAck?.resolve();
      }
    }
  }
  _sendFlag(flag) {
    if (this.channel.readyState !== "open") {
      this.log.trace('not sending flag %s because channel is "%s" and not "open"', flag.toString(), this.channel.readyState);
      return false;
    }
    this.log.trace("sending flag %s", flag.toString());
    const messageBuf = Message$1.encode({ flag });
    const prefixedBuf = encode.single(messageBuf);
    try {
      this._sendMessage(prefixedBuf);
      return true;
    } catch (err) {
      this.log.error("could not send flag %s - %e", flag.toString(), err);
    }
    return false;
  }
  sendPause() {
  }
  sendResume() {
  }
}
function createStream(options) {
  const { channel, direction, isHandshake } = options;
  return new WebRTCStream({
    ...options,
    id: `${channel.id}`,
    log: options.log.newScope(`${isHandshake === true ? "handshake" : direction}:${channel.id}`),
    protocol: ""
  });
}
class DataChannelMuxerFactory {
  protocol;
  /**
   * WebRTC Peer Connection
   */
  peerConnection;
  metrics;
  dataChannelOptions;
  earlyDataChannels;
  constructor(init3) {
    this.onEarlyDataChannel = this.onEarlyDataChannel.bind(this);
    this.peerConnection = init3.peerConnection;
    this.metrics = init3.metrics;
    this.protocol = init3.protocol ?? MUXER_PROTOCOL;
    this.dataChannelOptions = init3.dataChannelOptions ?? {};
    this.peerConnection.addEventListener("datachannel", this.onEarlyDataChannel);
    this.earlyDataChannels = [];
  }
  onEarlyDataChannel(evt) {
    this.earlyDataChannels.push(evt.channel);
  }
  createStreamMuxer(maConn) {
    this.peerConnection.removeEventListener("datachannel", this.onEarlyDataChannel);
    return new DataChannelMuxer(maConn, {
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      protocol: this.protocol,
      earlyDataChannels: this.earlyDataChannels
    });
  }
}
class DataChannelMuxer extends AbstractStreamMuxer {
  peerConnection;
  dataChannelOptions;
  constructor(maConn, init3) {
    super(maConn, {
      ...init3,
      name: "muxer"
    });
    this.peerConnection = init3.peerConnection;
    this.protocol = init3.protocol ?? MUXER_PROTOCOL;
    this.dataChannelOptions = init3.dataChannelOptions ?? {};
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.onDataChannel(channel);
    };
    queueMicrotask(() => {
      if (this.status !== "open") {
        init3.earlyDataChannels.forEach((channel) => {
          channel.close();
        });
        return;
      }
      init3.earlyDataChannels.forEach((channel) => {
        this.onDataChannel(channel);
      });
    });
  }
  onDataChannel(channel) {
    this.log("incoming datachannel with channel id %d, protocol %s and status %s", channel.id, channel.protocol, channel.readyState);
    if (channel.label === "init") {
      this.log.trace("closing init channel %d", channel.id);
      channel.close();
      return;
    }
    const stream = createStream({
      ...this.streamOptions,
      ...this.dataChannelOptions,
      channel,
      direction: "inbound",
      log: this.log
    });
    this.onRemoteStream(stream);
  }
  async onCreateStream(options) {
    const channel = this.peerConnection.createDataChannel("", {
      // TODO: pre-negotiate stream protocol
      // protocol: options?.protocol
    });
    this.log("open channel %d for protocol %s", channel.id, options?.protocol);
    const stream = createStream({
      ...options,
      ...this.dataChannelOptions,
      channel,
      direction: "outbound",
      log: this.log
    });
    return stream;
  }
  onData() {
  }
}
class RTCPeerConnectionMultiaddrConnection extends AbstractMultiaddrConnection {
  peerConnection;
  constructor(init3) {
    super(init3);
    this.peerConnection = init3.peerConnection;
    const initialState = init3.peerConnection.connectionState;
    this.peerConnection.onconnectionstatechange = () => {
      this.log.trace("peer connection state change %s initial state %s", this.peerConnection.connectionState, initialState);
      if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") {
        this.onTransportClosed();
        this.peerConnection.close();
      }
    };
  }
  sendData(data) {
    return {
      sentBytes: data.byteLength,
      canSendMore: true
    };
  }
  async sendClose(options) {
    this.peerConnection.close();
    options?.signal?.throwIfAborted();
  }
  sendReset() {
    this.peerConnection.close();
  }
  sendPause() {
  }
  sendResume() {
  }
}
const toMultiaddrConnection = (init3) => {
  return new RTCPeerConnectionMultiaddrConnection(init3);
};
const RTCPeerConnection$1 = globalThis.RTCPeerConnection;
const RTCSessionDescription = globalThis.RTCSessionDescription;
const RTCIceCandidate = globalThis.RTCIceCandidate;
class WebRTCTransportError extends Error {
  constructor(msg) {
    super(`WebRTC transport error: ${msg}`);
    this.name = "WebRTCTransportError";
  }
}
class SDPHandshakeFailedError extends WebRTCTransportError {
  constructor(message2 = "SDP handshake failed") {
    super(message2);
    this.name = "SDPHandshakeFailedError";
  }
}
var Message;
(function(Message2) {
  (function(Type) {
    Type["SDP_OFFER"] = "SDP_OFFER";
    Type["SDP_ANSWER"] = "SDP_ANSWER";
    Type["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Message2.Type || (Message2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type) {
    Type.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Message2.Type || (Message2.Type = {}));
  let _codec;
  Message2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message2.Type.codec().encode(obj.type, w);
        }
        if (obj.data != null) {
          w.uint32(18);
          w.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.data = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message2.encode = (obj) => {
    return encodeMessage(obj, Message2.codec());
  };
  Message2.decode = (buf, opts) => {
    return decodeMessage(buf, Message2.codec(), opts);
  };
})(Message || (Message = {}));
const readCandidatesUntilConnected = async (pc, stream, options) => {
  try {
    const connectedPromise = Promise.withResolvers();
    resolveOnConnected(pc, connectedPromise);
    while (true) {
      const message2 = await Promise.race([
        connectedPromise.promise,
        stream.read({
          signal: options.signal
        })
      ]);
      if (message2 == null) {
        options.signal?.throwIfAborted();
        break;
      }
      if (message2.type !== Message.Type.ICE_CANDIDATE) {
        throw new InvalidMessageError("ICE candidate message expected");
      }
      const candidateInit = JSON.parse(message2.data ?? "null");
      if (candidateInit === "" || candidateInit === null) {
        options.onProgress?.(new CustomProgressEvent("webrtc:end-of-ice-candidates"));
        options.log.trace("end-of-candidates received");
        continue;
      }
      const candidate = new RTCIceCandidate(candidateInit);
      options.log.trace("%s received new ICE candidate %o", options.direction, candidateInit);
      try {
        options.onProgress?.(new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
        await pc.addIceCandidate(candidate);
      } catch (err) {
        options.log.error("%s bad candidate received %o - %e", options.direction, candidateInit, err);
      }
    }
  } catch (err) {
    options.log.error("%s error parsing ICE candidate - %e", options.direction, err);
    if (options.signal?.aborted === true && pc.connectionState !== "connected") {
      throw err;
    }
  }
};
function resolveOnConnected(pc, promise) {
  if (pc.connectionState === "connected") {
    promise.resolve();
    return;
  }
  pc.onconnectionstatechange = (_) => {
    switch (pc.connectionState) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new ConnectionFailedError(`RTCPeerConnection connection state became "${pc.connectionState}"`));
        break;
    }
  };
}
function getRemotePeer(ma) {
  let remotePeer;
  for (const component of ma.getComponents()) {
    if (component.name === "p2p") {
      remotePeer = peerIdFromString$1(component.value ?? "");
    }
  }
  if (remotePeer == null) {
    throw new InvalidMultiaddrError$1("Remote peerId must be present in multiaddr");
  }
  return remotePeer;
}
async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log2, logger: logger2, onProgress }) {
  const { circuitAddress, targetPeer } = splitAddr(ma);
  metrics?.dialerEvents.increment({ open: true });
  log2.trace("dialing circuit address: %a", circuitAddress);
  const connections = connectionManager.getConnections(targetPeer);
  let connection;
  if (connections.length === 0) {
    onProgress?.(new CustomProgressEvent("webrtc:dial-relay"));
    connection = await transportManager.dial(circuitAddress, {
      signal,
      onProgress
    });
  } else {
    onProgress?.(new CustomProgressEvent("webrtc:reuse-relay-connection"));
    connection = connections[0];
  }
  onProgress?.(new CustomProgressEvent("webrtc:open-signaling-stream"));
  const stream = await connection.newStream(SIGNALING_PROTOCOL, {
    signal,
    runOnLimitedConnection: true
  });
  const messageStream = pbStream(stream).pb(Message);
  const peerConnection = new RTCPeerConnection$1(rtcConfiguration);
  peerConnection.addEventListener("connectionstatechange", () => {
    switch (peerConnection.connectionState) {
      case "closed":
        peerConnection.close();
        break;
    }
  });
  const muxerFactory = new DataChannelMuxerFactory({
    // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
    peerConnection,
    dataChannelOptions: dataChannel
  });
  try {
    const channel = peerConnection.createDataChannel("init");
    peerConnection.onicecandidate = ({ candidate }) => {
      if (peerConnection.connectionState === "connected") {
        log2.trace("ignore new ice candidate as peer connection is already connected");
        return;
      }
      if (candidate == null || candidate?.candidate === "") {
        log2.trace("initiator detected end of ICE candidates");
        return;
      }
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log2.trace("initiator sending ICE candidate %o", candidate);
      void messageStream.write({
        type: Message.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log2.error("error sending ICE candidate - %e", err);
      });
    };
    peerConnection.onicecandidateerror = (event) => {
      log2.error("initiator ICE candidate error", event);
    };
    const offerSdp = await peerConnection.createOffer().catch((err) => {
      log2.error("could not execute createOffer - %e", err);
      throw new SDPHandshakeFailedError("Failed to set createOffer");
    });
    log2.trace("initiator send SDP offer %s", offerSdp.sdp);
    onProgress?.(new CustomProgressEvent("webrtc:send-sdp-offer"));
    await messageStream.write({ type: Message.Type.SDP_OFFER, data: offerSdp.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(offerSdp).catch((err) => {
      log2.error("could not execute setLocalDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    onProgress?.(new CustomProgressEvent("webrtc:read-sdp-answer"));
    log2.trace("initiator read SDP answer");
    const answerMessage = await messageStream.read({
      signal
    });
    if (answerMessage.type !== Message.Type.SDP_ANSWER) {
      throw new SDPHandshakeFailedError("Remote should send an SDP answer");
    }
    log2.trace("initiator received SDP answer %s", answerMessage.data);
    const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
    await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
      log2.error("could not execute setRemoteDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    log2.trace("initiator read candidates until connected");
    onProgress?.(new CustomProgressEvent("webrtc:read-ice-candidates"));
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "initiator",
      signal,
      log: log2,
      onProgress
    });
    log2.trace("initiator connected");
    if (channel.readyState !== "open") {
      log2.trace("wait for init channel to open");
      await pEvent(channel, "open", {
        signal
      });
    }
    log2.trace("closing init channel");
    channel.close();
    log2.trace("waiting for init channel to close");
    await pEvent(channel, "close", {
      signal
    });
    onProgress?.(new CustomProgressEvent("webrtc:close-signaling-stream"));
    log2.trace("closing signaling channel");
    await stream.close({
      signal
    });
    log2.trace("initiator connected to remote address %s", ma);
    return {
      remoteAddress: ma,
      // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
      peerConnection,
      muxerFactory
    };
  } catch (err) {
    log2.error("outgoing signaling error - %e", err);
    peerConnection.close();
    stream.abort(err);
    throw err;
  } finally {
    peerConnection.onicecandidate = null;
    peerConnection.onicecandidateerror = null;
  }
}
const Circuit = fmt(P2P.matchers[0], code(CODE_P2P_CIRCUIT));
class WebRTCPeerListener extends TypedEventEmitter {
  transportManager;
  shutdownController;
  events;
  constructor(components, init3) {
    super();
    this.transportManager = components.transportManager;
    this.events = components.events;
    this.shutdownController = init3.shutdownController;
    this.onTransportListening = this.onTransportListening.bind(this);
  }
  async listen() {
    this.events.addEventListener("transport:listening", this.onTransportListening);
  }
  onTransportListening(event) {
    const circuitAddresses = event.detail.getAddrs().filter((ma) => Circuit.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    });
    if (circuitAddresses.length > 0) {
      this.safeDispatchEvent("listening");
    }
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l2) => !(l2 instanceof WebRTCPeerListener)).map((l2) => l2.getAddrs().filter((ma) => Circuit.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    })).flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.events.removeEventListener("transport:listening", this.onTransportListening);
    this.shutdownController.abort();
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
}
async function handleIncomingStream(stream, connection, { peerConnection, signal, log: log2 }) {
  log2.trace("new inbound signaling stream");
  const messageStream = pbStream(stream).pb(Message);
  try {
    peerConnection.onicecandidate = ({ candidate }) => {
      if (peerConnection.connectionState === "connected") {
        log2.trace("ignore new ice candidate as peer connection is already connected");
        return;
      }
      if (candidate == null || candidate?.candidate === "") {
        log2.trace("recipient detected end of ICE candidates");
        return;
      }
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log2.trace("recipient sending ICE candidate %s", data);
      messageStream.write({
        type: Message.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log2.error("error sending ICE candidate - %e", err);
      });
    };
    log2.trace("recipient read SDP offer");
    const pbOffer = await messageStream.read({
      signal
    });
    if (pbOffer.type !== Message.Type.SDP_OFFER) {
      throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
    }
    log2.trace("recipient received SDP offer %s", pbOffer.data);
    const offer = new RTCSessionDescription({
      type: "offer",
      sdp: pbOffer.data
    });
    await peerConnection.setRemoteDescription(offer).catch((err) => {
      log2.error("could not execute setRemoteDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    const answer = await peerConnection.createAnswer().catch((err) => {
      log2.error("could not execute createAnswer - %e", err);
      throw new SDPHandshakeFailedError("Failed to create answer");
    });
    log2.trace("recipient send SDP answer %s", answer.sdp);
    await messageStream.write({ type: Message.Type.SDP_ANSWER, data: answer.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(answer).catch((err) => {
      log2.error("could not execute setLocalDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    log2.trace("recipient read candidates until connected");
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "recipient",
      signal,
      log: log2
    });
  } catch (err) {
    if (peerConnection.connectionState !== "connected") {
      log2.error("error while handling signaling stream from peer %a - %e", connection.remoteAddr, err);
      peerConnection.close();
      throw err;
    } else {
      log2("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
  }
  const remotePeer = getRemotePeer(connection.remoteAddr);
  const remoteAddress = multiaddr(`/webrtc/p2p/${remotePeer}`);
  log2.trace("recipient connected to remote address %s", remoteAddress);
  return {
    remoteAddress,
    remotePeer
  };
}
class WebRTCTransport {
  components;
  init;
  log;
  _started = false;
  metrics;
  shutdownController;
  constructor(components, init3 = {}) {
    this.components = components;
    this.init = init3;
    this.log = components.logger.forComponent("libp2p:webrtc");
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dialer events by type"
        }),
        listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
          label: "event",
          help: "Total count of WebRTC listener events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/webrtc";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  [serviceDependencies] = [
    "@libp2p/identify",
    "@libp2p/circuit-relay-v2-transport"
  ];
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTOCOL, (stream, connection) => {
      const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
      this._onProtocol(stream, connection, signal).catch((err) => {
        this.log.error("failed to handle incoming connect from %p - %e", connection.remotePeer, err);
      }).finally(() => {
        signal.clear();
      });
    }, {
      runOnLimitedConnection: true
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
    this._started = false;
  }
  createListener(options) {
    return new WebRTCPeerListener(this.components, {
      shutdownController: this.shutdownController
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTC.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options) {
    this.log.trace("dialing address: %a", ma);
    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
      dataChannel: this.init.dataChannel,
      multiaddr: ma,
      dataChannelOptions: this.init.dataChannel,
      signal: options.signal,
      connectionManager: this.components.connectionManager,
      transportManager: this.components.transportManager,
      log: this.log,
      logger: this.components.logger,
      onProgress: options.onProgress
    });
    const webRTCConn = toMultiaddrConnection({
      peerConnection,
      remoteAddr: remoteAddress,
      metrics: this.metrics?.dialerEvents,
      direction: "outbound",
      log: this.components.logger.forComponent("libp2p:webrtc:connection")
    });
    const connection = await options.upgrader.upgradeOutbound(webRTCConn, {
      skipProtection: true,
      skipEncryption: true,
      remotePeer: getRemotePeer(ma),
      muxerFactory,
      onProgress: options.onProgress,
      signal: options.signal
    });
    this._closeOnShutdown(peerConnection, webRTCConn);
    return connection;
  }
  async _onProtocol(stream, connection, signal) {
    const peerConnection = new RTCPeerConnection$1(await getRtcConfiguration(this.init.rtcConfiguration));
    peerConnection.addEventListener("connectionstatechange", () => {
      switch (peerConnection.connectionState) {
        case "closed":
          peerConnection.close();
          break;
      }
    });
    const muxerFactory = new DataChannelMuxerFactory({
      // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
      peerConnection,
      dataChannelOptions: this.init.dataChannel
    });
    try {
      const { remoteAddress, remotePeer } = await handleIncomingStream(stream, connection, {
        peerConnection,
        signal,
        log: this.log
      });
      await stream.close({
        signal
      });
      const webRTCConn = toMultiaddrConnection({
        // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
        peerConnection,
        remoteAddr: remoteAddress,
        metrics: this.metrics?.listenerEvents,
        direction: "inbound",
        log: this.components.logger.forComponent("libp2p:webrtc:connection")
      });
      await this.components.upgrader.upgradeInbound(webRTCConn, {
        skipEncryption: true,
        skipProtection: true,
        remotePeer,
        muxerFactory,
        signal
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
    } catch (err) {
      this.log.error("incoming signaling error - %e", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    }
  }
  _closeOnShutdown(pc, webRTCConn) {
    const shutDownListener = () => {
      webRTCConn.close().catch((err) => {
        this.log.error("could not close WebRTCMultiaddrConnection - %e", err);
      });
    };
    this.shutdownController.signal.addEventListener("abort", shutDownListener);
    pc.addEventListener("close", () => {
      this.shutdownController.signal.removeEventListener("abort", shutDownListener);
    });
  }
}
function splitAddr(ma) {
  const target = ma.getComponents().filter(({ name: name2 }) => name2 === "p2p").map(({ value: value2 }) => value2).pop();
  if (target == null) {
    throw new InvalidParametersError$1("Destination peer id was missing");
  }
  const circuitAddress = multiaddr(ma.getComponents().filter(({ name: name2 }) => name2 !== "webrtc"));
  return { circuitAddress, targetPeer: peerIdFromString$1(target) };
}
var define_globalThis_process_env_default = {};
const NOISE_MSG_MAX_LENGTH_BYTES = 65535;
const NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
const DUMP_SESSION_KEYS = Boolean(define_globalThis_process_env_default?.DUMP_SESSION_KEYS);
const CHACHA_TAG_LENGTH = 16;
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes(value2, length3, title = "") {
  const bytes = isBytes(value2);
  const len = value2?.length;
  const needsLen = length3 !== void 0;
  if (!bytes || needsLen && len !== length3) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length3}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function checkOpts(defaults2, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function equalBytes(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
const wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
  function wrappedCipher(key2, ...args) {
    abytes(key2, void 0, "key");
    if (!isLE)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      abytes(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0)
      abytes(args[1], void 0, "AAD");
    const cipher = constructor(key2, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes(output, void 0, "output");
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes(data);
        if (tagl && data.length < tagl)
          throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32$1(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function u64Lengths(dataLength, aadLength, isLE2) {
  abool(isLE2);
  const num = new Uint8Array(16);
  const view = createView(num);
  view.setBigUint64(0, BigInt(aadLength), isLE2);
  view.setBigUint64(8, BigInt(dataLength), isLE2);
  return num;
}
function isAligned32$1(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
const encodeStr = (str) => Uint8Array.from(str.split(""), (c2) => c2.charCodeAt(0));
const sigma16 = encodeStr("expand 16-byte k");
const sigma32 = encodeStr("expand 32-byte k");
const sigma16_32 = u32(sigma16);
const sigma32_32 = u32(sigma32);
function rotl(a2, b) {
  return a2 << b | a2 >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
const BLOCK_LEN = 64;
const BLOCK_LEN32 = 16;
const MAX_COUNTER = 2 ** 32 - 1;
const U32_EMPTY = Uint32Array.of();
function runCipher(core2, sigma, key2, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core2(sigma, key2, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take2 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take2 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take2; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take2;
  }
}
function createCipher(core2, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core2 !== "function")
    throw new Error("core must be a function");
  anumber(counterLength);
  anumber(rounds);
  abool(counterRight);
  abool(allowShortKeys);
  return (key2, nonce, data, output, counter = 0) => {
    abytes(key2, void 0, "key");
    abytes(nonce, void 0, "nonce");
    abytes(data, void 0, "data");
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes(output, void 0, "output");
    anumber(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l2 = key2.length;
    let k;
    let sigma;
    if (l2 === 32) {
      toClean.push(k = copyBytes(key2));
      sigma = sigma32_32;
    } else if (l2 === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key2);
      k.set(key2, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      abytes(key2, 32, "arx key");
      throw new Error("invalid key size");
    }
    if (!isAligned32(nonce))
      toClean.push(nonce = copyBytes(nonce));
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core2, sigma, k32, n32, data, output, counter, rounds);
    clean(...toClean);
    return output;
  };
}
function u8to16(a2, i2) {
  return a2[i2++] & 255 | (a2[i2++] & 255) << 8;
}
class Poly1305 {
  blockLen = 16;
  outputLen = 16;
  buffer = new Uint8Array(16);
  r = new Uint16Array(10);
  // Allocating 1 array with .subarray() here is slower than 3
  h = new Uint16Array(10);
  pad = new Uint16Array(8);
  pos = 0;
  finished = false;
  // Can be speed-up using BigUint64Array, at the cost of complexity
  constructor(key2) {
    key2 = copyBytes(abytes(key2, 32, "key"));
    const t0 = u8to16(key2, 0);
    const t1 = u8to16(key2, 2);
    const t2 = u8to16(key2, 4);
    const t3 = u8to16(key2, 6);
    const t4 = u8to16(key2, 8);
    const t5 = u8to16(key2, 10);
    const t6 = u8to16(key2, 12);
    const t7 = u8to16(key2, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to16(key2, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r: r2 } = this;
    const r0 = r2[0];
    const r1 = r2[1];
    const r22 = r2[2];
    const r3 = r2[3];
    const r4 = r2[4];
    const r5 = r2[5];
    const r6 = r2[6];
    const r7 = r2[7];
    const r8 = r2[8];
    const r9 = r2[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c2 = 0;
    let d0 = c2 + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c2 = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
    c2 += d0 >>> 13;
    d0 &= 8191;
    let d1 = c2 + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c2 = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
    c2 += d1 >>> 13;
    d1 &= 8191;
    let d2 = c2 + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c2 = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c2 += d2 >>> 13;
    d2 &= 8191;
    let d3 = c2 + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c2 = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c2 += d3 >>> 13;
    d3 &= 8191;
    let d4 = c2 + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
    c2 = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c2 += d4 >>> 13;
    d4 &= 8191;
    let d5 = c2 + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
    c2 = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c2 += d5 >>> 13;
    d5 &= 8191;
    let d6 = c2 + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
    c2 = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c2 += d6 >>> 13;
    d6 &= 8191;
    let d7 = c2 + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c2 = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c2 += d7 >>> 13;
    d7 &= 8191;
    let d8 = c2 + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c2 = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c2 += d8 >>> 13;
    d8 &= 8191;
    let d9 = c2 + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c2 = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
    c2 += d9 >>> 13;
    d9 &= 8191;
    c2 = (c2 << 2) + c2 | 0;
    c2 = c2 + d0 | 0;
    d0 = c2 & 8191;
    c2 = c2 >>> 13;
    d1 += c2;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad2 } = this;
    const g = new Uint16Array(10);
    let c2 = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c2;
      c2 = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c2 * 5;
    c2 = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c2;
    c2 = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c2;
    g[0] = h[0] + 5;
    c2 = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c2;
      c2 = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c2 ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f2 = h[0] + pad2[0];
    h[0] = f2 & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f2 = (h[i2] + pad2[i2] | 0) + (f2 >>> 16) | 0;
      h[i2] = f2 & 65535;
    }
    clean(g);
  }
  update(data) {
    aexists(this);
    abytes(data);
    data = copyBytes(data);
    const { buffer, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
}
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key2) => hashCons(key2).update(msg).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key2) => hashCons(key2);
  return hashC;
}
const poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey((key2) => new Poly1305(key2)))();
function chachaCore(s2, k, n2, out, cnt, rounds = 20) {
  let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r2 = 0; r2 < rounds; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
const ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
const updatePadded = (h, msg) => {
  h.update(msg);
  const leftover = msg.length % 16;
  if (leftover)
    h.update(ZEROS16.subarray(leftover));
};
const ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key2, nonce, ciphertext, AAD) {
  if (AAD !== void 0)
    abytes(AAD, void 0, "AAD");
  const authKey = fn(key2, nonce, ZEROS32);
  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, ciphertext);
  h.update(lengths);
  const res = h.digest();
  clean(authKey, lengths);
  return res;
}
const _poly1305_aead = (xorStream) => (key2, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key2, nonce, oPlain, oPlain, 1);
      const tag = computeTag(xorStream, key2, nonce, oPlain, AAD);
      output.set(tag, plength);
      clean(tag);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key2, nonce, data, AAD);
      if (!equalBytes(passedTag, tag))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key2, nonce, output, output, 1);
      clean(tag);
      return output;
    }
  };
};
const chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
function extract(hash3, ikm, salt) {
  ahash(hash3);
  if (salt === void 0)
    salt = new Uint8Array(hash3.outputLen);
  return hmac$2(hash3, salt, ikm);
}
const HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
const EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
function expand(hash3, prk, info, length3 = 32) {
  ahash(hash3);
  anumber$1(length3, "length");
  const olen = hash3.outputLen;
  if (length3 > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks = Math.ceil(length3 / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  else
    abytes$1(info, void 0, "info");
  const okm = new Uint8Array(blocks * olen);
  const HMAC = hmac$2.create(hash3, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  clean$1(T, HKDF_COUNTER);
  return okm.slice(0, length3);
}
const pureJsCrypto = {
  hashSHA256(data) {
    return sha256$1(data.subarray());
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha256$1, ikm, ck);
    const okmU8Array = expand(sha256$1, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomSecretKey();
    const publicKey = x25519.getPublicKey(secretKey);
    return {
      publicKey,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey = x25519.getPublicKey(seed);
    return {
      publicKey,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey) {
    return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray());
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
  }
};
const defaultCrypto = pureJsCrypto;
function wrapCrypto(crypto2) {
  return {
    generateKeypair: crypto2.generateX25519KeyPair,
    dh: (keypair, publicKey) => crypto2.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
    encrypt: crypto2.chaCha20Poly1305Encrypt,
    decrypt: crypto2.chaCha20Poly1305Decrypt,
    hash: crypto2.hashSHA256,
    hkdf: crypto2.getHKDF
  };
}
const uint16BEEncode = (value2) => {
  const target = allocUnsafe(2);
  target[0] = value2 >> 8;
  target[1] = value2;
  return target;
};
uint16BEEncode.bytes = 2;
const uint16BEDecode = (data) => {
  if (data.length < 2) {
    throw RangeError("Could not decode int16BE");
  }
  if (data instanceof Uint8Array) {
    let value2 = 0;
    value2 += data[0] << 8;
    value2 += data[1];
    return value2;
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}
function logLocalStaticKeys(s2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (s2) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$1(s2.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$1(s2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local static keys.");
  }
}
function logLocalEphemeralKeys(e2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (e2) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$1(e2.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$1(e2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$1(rs.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote static public key.");
  }
}
function logRemoteEphemeralKey(re, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$1(re.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote ephemeral keys.");
  }
}
function logCipherState(cs1, cs2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString$1(cs1.k, "hex")}`);
  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString$1(cs2.k, "hex")}`);
}
class InvalidCryptoExchangeError2 extends Error {
  code;
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.code = InvalidCryptoExchangeError2.code;
  }
  static code = "ERR_INVALID_CRYPTO_EXCHANGE";
}
const MIN_NONCE = 0;
const MAX_NONCE = 4294967295;
const ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
class Nonce {
  n;
  bytes;
  view;
  constructor(n2 = MIN_NONCE) {
    this.n = n2;
    this.bytes = alloc$1(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n2, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
}
const ZEROLEN = alloc$1(0);
class CipherState {
  k;
  n;
  crypto;
  constructor(crypto2, k = void 0, n2 = 0) {
    this.crypto = crypto2;
    this.k = k;
    this.n = new Nonce(n2);
  }
  hasKey() {
    return Boolean(this.k);
  }
  encryptWithAd(ad, plaintext) {
    if (!this.hasKey()) {
      return plaintext;
    }
    this.n.assertValue();
    const e2 = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
    this.n.increment();
    return e2;
  }
  decryptWithAd(ad, ciphertext, dst) {
    if (!this.hasKey()) {
      return ciphertext;
    }
    this.n.assertValue();
    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
    this.n.increment();
    return plaintext;
  }
}
class SymmetricState {
  cs;
  ck;
  h;
  crypto;
  constructor(crypto2, protocolName) {
    this.crypto = crypto2;
    const protocolNameBytes = fromString(protocolName, "utf-8");
    this.h = hashProtocolName(crypto2, protocolNameBytes);
    this.ck = this.h;
    this.cs = new CipherState(crypto2);
  }
  mixKey(ikm) {
    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
    this.ck = ck;
    this.cs = new CipherState(this.crypto, tempK);
  }
  mixHash(data) {
    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
  }
  encryptAndHash(plaintext) {
    const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
    this.mixHash(ciphertext);
    return ciphertext;
  }
  decryptAndHash(ciphertext) {
    const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
    this.mixHash(ciphertext);
    return plaintext;
  }
  split() {
    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
  }
}
class AbstractHandshakeState {
  ss;
  s;
  e;
  rs;
  re;
  initiator;
  crypto;
  constructor(init3) {
    const { crypto: crypto2, protocolName, prologue, initiator, s: s2, e: e2, rs, re } = init3;
    this.crypto = crypto2;
    this.ss = new SymmetricState(crypto2, protocolName);
    this.ss.mixHash(prologue);
    this.initiator = initiator;
    this.s = s2;
    this.e = e2;
    this.rs = rs;
    this.re = re;
  }
  writeE() {
    if (this.e) {
      throw new Error("ephemeral keypair is already set");
    }
    const e2 = this.crypto.generateKeypair();
    this.ss.mixHash(e2.publicKey);
    this.e = e2;
    return e2.publicKey;
  }
  writeS() {
    if (!this.s) {
      throw new Error("static keypair is not set");
    }
    return this.ss.encryptAndHash(this.s.publicKey);
  }
  writeEE() {
    if (!this.e) {
      throw new Error("ephemeral keypair is not set");
    }
    if (!this.re) {
      throw new Error("remote ephemeral public key is not set");
    }
    this.ss.mixKey(this.crypto.dh(this.e, this.re));
  }
  writeES() {
    if (this.initiator) {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    } else {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    }
  }
  writeSE() {
    if (this.initiator) {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    } else {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    }
  }
  readE(message2, offset = 0) {
    if (this.re) {
      throw new Error("remote ephemeral public key is already set");
    }
    if (message2.byteLength < offset + 32) {
      throw new Error("message is not long enough");
    }
    this.re = message2.sublist(offset, offset + 32);
    this.ss.mixHash(this.re);
  }
  readS(message2, offset = 0) {
    if (this.rs) {
      throw new Error("remote static public key is already set");
    }
    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
    if (message2.byteLength < offset + cipherLength) {
      throw new Error("message is not long enough");
    }
    const temp = message2.sublist(offset, offset + cipherLength);
    this.rs = this.ss.decryptAndHash(temp);
    return cipherLength;
  }
  readEE() {
    this.writeEE();
  }
  readES() {
    this.writeES();
  }
  readSE() {
    this.writeSE();
  }
}
class XXHandshakeState extends AbstractHandshakeState {
  // e
  writeMessageA(payload) {
    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
  }
  // e, ee, s, es
  writeMessageB(payload) {
    const e2 = this.writeE();
    this.writeEE();
    const encS = this.writeS();
    this.writeES();
    return new Uint8ArrayList(e2, encS, this.ss.encryptAndHash(payload));
  }
  // s, se
  writeMessageC(payload) {
    const encS = this.writeS();
    this.writeSE();
    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
  }
  // e
  readMessageA(message2) {
    try {
      this.readE(message2);
      return this.ss.decryptAndHash(message2.sublist(32));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e2.message}`);
    }
  }
  // e, ee, s, es
  readMessageB(message2) {
    try {
      this.readE(message2);
      this.readEE();
      const consumed = this.readS(message2, 32);
      this.readES();
      return this.ss.decryptAndHash(message2.sublist(32 + consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e2.message}`);
    }
  }
  // s, se
  readMessageC(message2) {
    try {
      const consumed = this.readS(message2);
      this.readSE();
      return this.ss.decryptAndHash(message2.sublist(consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e2.message}`);
    }
  }
}
function hashProtocolName(crypto2, protocolName) {
  if (protocolName.length <= 32) {
    const h = alloc$1(32);
    h.set(protocolName);
    return h;
  } else {
    return crypto2.hash(protocolName);
  }
}
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value2 of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value2);
          }
        }
        if (obj.streamMuxers != null) {
          for (const value2 of obj.streamMuxers) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          webtransportCerthashes: [],
          streamMuxers: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
              }
              obj.webtransportCerthashes.push(reader.bytes());
              break;
            }
            case 2: {
              if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
              }
              obj.streamMuxers.push(reader.string());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseExtensions2.codec(), opts);
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          identityKey: alloc$1(0),
          identitySig: alloc$1(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.identityKey = reader.bytes();
              break;
            }
            case 2: {
              obj.identitySig = reader.bytes();
              break;
            }
            case 4: {
              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.extensions
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf, opts) => {
    return decodeMessage(buf, NoiseHandshakePayload2.codec(), opts);
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
  return NoiseHandshakePayload.encode({
    identityKey: publicKeyToProtobuf(privateKey.publicKey),
    identitySig,
    extensions
  });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
  try {
    const payload = NoiseHandshakePayload.decode(payloadBytes);
    const publicKey = publicKeyFromProtobuf(payload.identityKey);
    if (remoteIdentityKey?.equals(publicKey) === false) {
      throw new Error(`Payload identity key ${publicKey} does not match expected remote identity key ${remoteIdentityKey}`);
    }
    if (!remoteStaticKey) {
      throw new Error("Remote static does not exist");
    }
    const signaturePayload = getSignaturePayload(remoteStaticKey);
    if (!await publicKey.verify(signaturePayload, payload.identitySig)) {
      throw new Error("Invalid payload signature");
    }
    return payload;
  } catch (e2) {
    throw new UnexpectedPeerError(e2.message);
  }
}
function getSignaturePayload(publicKey) {
  const prefix = fromString("noise-libp2p-static-key:");
  if (publicKey instanceof Uint8Array) {
    return concat([prefix, publicKey], prefix.length + publicKey.length);
  }
  publicKey.prepend(prefix);
  return publicKey;
}
class EncryptedMessageStream extends AbstractMessageStream {
  stream;
  handshake;
  metrics;
  decoder;
  constructor(stream, handshake, metrics) {
    super({
      log: stream.log,
      inactivityTimeout: stream.inactivityTimeout,
      maxReadBufferLength: stream.maxReadBufferLength,
      direction: stream.direction
    });
    this.stream = stream;
    this.handshake = handshake;
    this.metrics = metrics;
    this.decoder = new LengthPrefixedDecoder({
      lengthDecoder: uint16BEDecode,
      maxBufferSize: 16 * 1024 * 1024,
      encodingLength: () => 2
    });
    const noiseOnMessageDecrypt = (evt) => {
      try {
        for (const buf of this.decoder.decode(evt.data)) {
          this.onData(this.decrypt(buf));
        }
      } catch (err) {
        this.abort(err);
      }
    };
    this.stream.addEventListener("message", noiseOnMessageDecrypt);
    const noiseOnClose = (evt) => {
      if (evt.error != null) {
        if (evt.local === true) {
          this.abort(evt.error);
        } else {
          this.onRemoteReset();
        }
      } else {
        this.onTransportClosed();
      }
    };
    this.stream.addEventListener("close", noiseOnClose);
    const noiseOnDrain = () => {
      this.safeDispatchEvent("drain");
    };
    this.stream.addEventListener("drain", noiseOnDrain);
    const noiseOnRemoteCloseWrite = () => {
      this.onRemoteCloseWrite();
    };
    this.stream.addEventListener("remoteCloseWrite", noiseOnRemoteCloseWrite);
  }
  encrypt(chunk) {
    const output = new Uint8ArrayList();
    for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
      let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
      if (end > chunk.byteLength) {
        end = chunk.byteLength;
      }
      let data;
      if (chunk instanceof Uint8Array) {
        data = this.handshake.encrypt(chunk.subarray(i2, end));
      } else {
        data = this.handshake.encrypt(chunk.sublist(i2, end));
      }
      this.metrics?.encryptedPackets.increment();
      output.append(uint16BEEncode(data.byteLength));
      output.append(data);
    }
    return output;
  }
  decrypt(chunk) {
    const output = new Uint8ArrayList();
    for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
      let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
      if (end > chunk.byteLength) {
        end = chunk.byteLength;
      }
      if (end - CHACHA_TAG_LENGTH < i2) {
        throw new Error("Invalid chunk");
      }
      let encrypted;
      if (chunk instanceof Uint8Array) {
        encrypted = chunk.subarray(i2, end);
      } else {
        encrypted = chunk.sublist(i2, end);
      }
      const dst = chunk.subarray(i2, end - CHACHA_TAG_LENGTH);
      try {
        const plaintext = this.handshake.decrypt(encrypted, dst);
        this.metrics?.decryptedPackets.increment();
        output.append(plaintext);
      } catch (e2) {
        this.metrics?.decryptErrors.increment();
        throw e2;
      }
    }
    return output;
  }
  close(options) {
    return this.stream.close(options);
  }
  sendPause() {
    this.stream.pause();
  }
  sendResume() {
    this.stream.resume();
  }
  sendReset(err) {
    this.stream.abort(err);
  }
  sendData(data) {
    return {
      sentBytes: data.byteLength,
      canSendMore: this.stream.send(this.encrypt(data))
    };
  }
}
function toMessageStream(connection, handshake, metrics) {
  return new EncryptedMessageStream(connection, handshake, metrics);
}
async function performHandshakeInitiator(init3, options) {
  const { log: log2, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init3;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: true,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log2);
  log2.trace("Stage 0 - Initiator starting to send first message.");
  await connection.write(xx.writeMessageA(ZEROLEN), options);
  log2.trace("Stage 0 - Initiator finished sending first message.");
  logLocalEphemeralKeys(xx.e, log2);
  log2.trace("Stage 1 - Initiator waiting to receive first message from responder...");
  const plaintext = xx.readMessageB(await connection.read(options));
  log2.trace("Stage 1 - Initiator received the message.");
  logRemoteEphemeralKey(xx.re, log2);
  logRemoteStaticKey(xx.rs, log2);
  log2.trace("Initiator going to check remote's signature...");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  log2.trace("All good with the signature!");
  log2.trace("Stage 2 - Initiator sending third handshake message.");
  await connection.write(xx.writeMessageC(payload), options);
  log2.trace("Stage 2 - Initiator sent message with signed payload.");
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log2);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
async function performHandshakeResponder(init3, options) {
  const { log: log2, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init3;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: false,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log2);
  log2.trace("Stage 0 - Responder waiting to receive first message.");
  xx.readMessageA(await connection.read(options));
  log2.trace("Stage 0 - Responder received first message.");
  logRemoteEphemeralKey(xx.re, log2);
  log2.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
  await connection.write(xx.writeMessageB(payload), options);
  log2.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
  logLocalEphemeralKeys(xx.e, log2);
  log2.trace("Stage 2 - Responder waiting for third handshake message...");
  const plaintext = xx.readMessageC(await connection.read(options));
  log2.trace("Stage 2 - Responder received the message, finished handshake.");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log2);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
class Noise {
  protocol = "/noise";
  crypto;
  prologue;
  staticKey;
  extensions;
  metrics;
  components;
  log;
  constructor(components, init3 = {}) {
    const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes } = init3;
    const { metrics } = components;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:noise");
    const _crypto = crypto2 ?? defaultCrypto;
    this.crypto = wrapCrypto(_crypto);
    this.extensions = {
      webtransportCerthashes: [],
      ...extensions
    };
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKey = _crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? alloc$1(0);
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
  [serviceCapabilities] = [
    "@libp2p/connection-encryption",
    "@chainsafe/libp2p-noise"
  ];
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureOutbound(connection, options) {
    const log2 = connection.log?.newScope("noise") ?? this.log;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, log2, options?.remotePeer?.publicKey, options);
    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey),
      streamMuxer: options?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  getStreamMuxer(protocols) {
    if (protocols == null || protocols.length === 0) {
      return;
    }
    const streamMuxers = this.components.upgrader.getStreamMuxers();
    if (streamMuxers != null) {
      for (const protocol of protocols) {
        const streamMuxer = streamMuxers.get(protocol);
        if (streamMuxer != null) {
          return streamMuxer;
        }
      }
    }
    if (protocols.length) {
      throw new InvalidCryptoExchangeError$1("Early muxer negotiation was requested but the initiator and responder had no common muxers");
    }
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureInbound(connection, options) {
    const log2 = connection.log?.newScope("noise") ?? this.log;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, log2, options?.remotePeer?.publicKey, options);
    const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey(publicKey),
      streamMuxer: options?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  /**
   * Perform XX handshake as initiator.
   */
  async performHandshakeInitiator(connection, privateKey, log2, remoteIdentityKey, options) {
    let result;
    const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeInitiator({
        connection,
        privateKey,
        remoteIdentityKey,
        log: log2.newScope("xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e2) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
  /**
   * Perform XX handshake as responder.
   */
  async performHandshakeResponder(connection, privateKey, log2, remoteIdentityKey, options) {
    let result;
    const streamMuxers = options?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeResponder({
        connection,
        privateKey,
        remoteIdentityKey,
        log: log2.newScope("xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e2) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
}
function noise(init3 = {}) {
  return (components) => new Noise(components, init3);
}
function webRTC(init3) {
  return (components) => new WebRTCTransport(components, init3);
}
const ASSUME_HTTP_CODES = [
  CODE_TCP,
  CODE_DNS,
  CODE_DNSADDR,
  CODE_DNS4,
  CODE_DNS6
];
function extractSNI(ma) {
  return extractTuple("sni", ma)?.value;
}
function extractPort(ma) {
  const port = extractTuple("tcp", ma)?.value;
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name2, ma) {
  return ma.find((component) => component.name === name2);
}
function hasTLS(ma) {
  return ma.some(({ code: code2 }) => code2 === CODE_TLS);
}
function interpretNext(head, rest) {
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${head.name}`);
  }
  const restVal = interpreter(head, rest);
  if (head.code === CODE_IP6) {
    return `[${restVal}]`;
  }
  return restVal;
}
const interpreters = {
  ip4: (head, rest) => head.value,
  ip6: (head, rest) => {
    if (rest.length === 0) {
      return head.value;
    }
    return `[${head.value}]`;
  },
  tcp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tail, rest)}:${head.value}`;
  },
  udp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tail, rest)}:${head.value}`;
  },
  dnsaddr: (head, rest) => head.value,
  dns4: (head, rest) => head.value,
  dns6: (head, rest) => head.value,
  dns: (head, rest) => head.value,
  ipfs: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  p2p: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  http: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tail, rest);
    const decodedValue = decodeURIComponent(head.value ?? "");
    return `${baseVal}${decodedValue}`;
  },
  tls: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  sni: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  https: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const components = ma.getComponents();
  const head = components.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${head.name}`);
  }
  let uri = interpreter(head, components) ?? "";
  if (ASSUME_HTTP_CODES.includes(head.code)) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head.value === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}
function createListener$1() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}
const DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4;
const DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10;
class WebSocketMultiaddrConnection extends AbstractMultiaddrConnection {
  websocket;
  maxBufferedAmount;
  checkBufferedAmountTask;
  constructor(init3) {
    super(init3);
    this.websocket = init3.websocket;
    this.maxBufferedAmount = init3.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT;
    this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init3.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL);
    this.websocket.addEventListener("close", (evt) => {
      this.log('closed - code %d, reason "%s", wasClean %s', evt.code, evt.reason, evt.wasClean);
      this.checkBufferedAmountTask.stop();
      if (!evt.wasClean) {
        this.onRemoteReset();
        return;
      }
      this.onTransportClosed();
    }, { once: true });
    this.websocket.addEventListener("message", (evt) => {
      try {
        let buf;
        if (typeof evt.data === "string") {
          buf = fromString(evt.data);
        } else if (evt.data instanceof ArrayBuffer) {
          buf = new Uint8Array(evt.data, 0, evt.data.byteLength);
        } else {
          this.abort(new Error("Incorrect binary type"));
          return;
        }
        this.onData(buf);
      } catch (err) {
        this.log.error("error receiving data - %e", err);
      }
    });
  }
  sendData(data) {
    for (const buf of data) {
      this.websocket.send(buf);
    }
    const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount;
    if (!canSendMore) {
      this.checkBufferedAmountTask.start();
    }
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.websocket.close(1006);
  }
  async sendClose(options) {
    this.websocket.close();
    options?.signal?.throwIfAborted();
  }
  sendPause() {
  }
  sendResume() {
  }
  checkBufferedAmount() {
    this.log("buffered amount now %d", this.websocket.bufferedAmount);
    if (this.websocket.bufferedAmount === 0) {
      this.checkBufferedAmountTask.stop();
      this.safeDispatchEvent("drain");
    }
  }
}
function webSocketToMaConn(init3) {
  return new WebSocketMultiaddrConnection(init3);
}
class WebSockets {
  log;
  init;
  logger;
  metrics;
  components;
  constructor(components, init3 = {}) {
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init3;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "@libp2p/websockets";
  [serviceCapabilities] = [
    "@libp2p/transport"
  ];
  async dial(ma, options) {
    this.log("dialing %s", ma);
    options = options ?? {};
    const maConn = webSocketToMaConn({
      websocket: await this._connect(ma, options),
      remoteAddr: ma,
      metrics: this.metrics?.dialerEvents,
      direction: "outbound",
      log: this.components.logger.forComponent("libp2p:websockets:connection"),
      maxBufferedAmount: this.init.maxBufferedAmount,
      bufferedAmountPollInterval: this.init.bufferedAmountPollInterval
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn, options);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    options?.signal?.throwIfAborted();
    const uri = multiaddrToUri(ma);
    this.log("create websocket connection to %s", uri);
    const websocket = new WebSocket(uri);
    websocket.binaryType = "arraybuffer";
    try {
      options.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
      await pEvent(websocket, "open", options);
    } catch (err) {
      if (options.signal?.aborted) {
        this.metrics?.dialerEvents.increment({ abort: true });
        throw new ConnectionFailedError(`Could not connect to ${uri}`);
      } else {
        this.metrics?.dialerEvents.increment({ error: true });
      }
      try {
        websocket.close();
      } catch {
      }
      throw err;
    }
    this.log("connected %s", ma);
    this.metrics?.dialerEvents.increment({ connect: true });
    return websocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener$1({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options
    });
  }
  listenFilter(multiaddrs) {
    return multiaddrs.filter((ma) => WebSockets$1.exactMatch(ma) || WebSocketsSecure.exactMatch(ma));
  }
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
}
function webSockets(init3 = {}) {
  return (components) => {
    return new WebSockets(components, init3);
  };
}
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
Object.values(Flag).filter((x) => typeof x !== "string");
const YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
const HEADER_LENGTH = 12;
class ProtocolError extends Error {
  static name = "ProtocolError";
  reason;
  constructor(message2, reason) {
    super(message2);
    this.name = "ProtocolError";
    this.reason = reason;
  }
}
function isProtocolError(err) {
  return err?.reason !== null;
}
class InvalidFrameError extends ProtocolError {
  static name = "InvalidFrameError";
  constructor(message2 = "The frame was invalid") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "InvalidFrameError";
  }
}
class UnRequestedPingError extends ProtocolError {
  static name = "UnRequestedPingError";
  constructor(message2 = "Un-requested ping error") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "UnRequestedPingError";
  }
}
class NotMatchingPingError extends ProtocolError {
  static name = "NotMatchingPingError";
  constructor(message2 = "Not matching ping error") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "NotMatchingPingError";
  }
}
class ReceiveWindowExceededError extends ProtocolError {
  static name = "ReceiveWindowExceededError";
  constructor(message2 = "Receive window exceeded") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "ReceiveWindowExceededError";
  }
}
const INITIAL_STREAM_WINDOW = 256 * 1024;
const MAX_STREAM_WINDOW = 16 * 1024 * 1024;
const defaultConfig = {
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3
};
function verifyConfig(config) {
  if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {
    throw new InvalidParametersError$1("keep-alive interval must be positive");
  }
  if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {
    throw new InvalidParametersError$1("max inbound streams must be larger or equal 0");
  }
  if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {
    throw new InvalidParametersError$1("max outbound streams must be larger or equal 0");
  }
  if (config.maxMessageSize != null && config.maxMessageSize < 1024) {
    throw new InvalidParametersError$1("MaxMessageSize must be greater than a kilobyte");
  }
  if (config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new InvalidParametersError$1("InitialStreamWindowSize must be larger or equal 256 kB");
  }
  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize < config.streamOptions?.initialStreamWindowSize) {
    throw new InvalidParametersError$1("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
  }
  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new InvalidParametersError$1("MaxStreamWindowSize must be less than equal MAX_UINT32");
  }
}
function isDataFrame(frame) {
  return frame.header.type === FrameType.Data && frame.data !== null;
}
const twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new InvalidFrameError("Invalid frame version");
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
class Decoder2 {
  /** Buffer for in-progress frames */
  buffer;
  constructor() {
    this.buffer = new Uint8ArrayList();
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  *emitFrames(buf) {
    this.buffer.append(buf);
    while (true) {
      const frame = this.readFrame();
      if (frame === void 0) {
        break;
      }
      yield frame;
    }
  }
  readFrame() {
    let frameSize = HEADER_LENGTH;
    if (this.buffer.byteLength < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    if (header.type === FrameType.Data) {
      frameSize += header.length;
      if (this.buffer.byteLength < frameSize) {
        return;
      }
      const data = this.buffer.sublist(HEADER_LENGTH, frameSize);
      this.buffer.consume(frameSize);
      return { header, data };
    }
    this.buffer.consume(frameSize);
    return { header };
  }
}
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
  StreamState2[StreamState2["Paused"] = 5] = "Paused";
})(StreamState || (StreamState = {}));
class YamuxStream extends AbstractStream {
  streamId;
  state;
  /** The number of available bytes to send */
  sendWindowCapacity;
  /** The number of bytes available to receive in a full window */
  recvWindow;
  /** The number of available bytes to receive */
  recvWindowCapacity;
  maxStreamWindowSize;
  /**
   * An 'epoch' is the time it takes to process and read data
   *
   * Used in conjunction with RTT to determine whether to increase the recvWindow
   */
  epochStart;
  getRTT;
  sendFrame;
  constructor(init3) {
    const initialWindowSize = init3.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW;
    super({
      ...init3,
      maxMessageSize: initialWindowSize - HEADER_LENGTH
    });
    this.streamId = init3.streamId;
    this.state = init3.state;
    this.sendWindowCapacity = initialWindowSize;
    this.recvWindow = initialWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.maxStreamWindowSize = init3.maxStreamWindowSize ?? MAX_STREAM_WINDOW;
    this.epochStart = Date.now();
    this.getRTT = init3.getRTT;
    this.sendFrame = init3.sendFrame;
    const setStateToFinishedOnCloseListener = () => {
      this.state = StreamState.Finished;
    };
    this.addEventListener("close", setStateToFinishedOnCloseListener);
  }
  /**
   * Send a data message to the remote muxer
   */
  sendData(buf) {
    const totalBytes = buf.byteLength;
    let sentBytes = 0;
    let canSendMore = true;
    this.log?.trace("send window capacity is %d bytes", this.sendWindowCapacity);
    while (buf.byteLength > 0) {
      if (this.sendWindowCapacity === 0) {
        canSendMore = false;
        this.log?.trace("sent %d/%d bytes, exhausted send window, waiting for window update", sentBytes, totalBytes);
        break;
      }
      const toSend = Math.min(this.sendWindowCapacity, buf.byteLength);
      const flags = this.getSendFlags();
      const data = buf.sublist(0, toSend);
      buf.consume(toSend);
      const muxerSendMore = this.sendFrame({
        type: FrameType.Data,
        flag: flags,
        streamID: this.streamId,
        length: toSend
      }, data);
      this.sendWindowCapacity -= toSend;
      sentBytes += toSend;
      if (!muxerSendMore) {
        canSendMore = muxerSendMore;
        this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity", sentBytes, totalBytes);
        break;
      }
    }
    return {
      sentBytes,
      canSendMore
    };
  }
  /**
   * Send a reset message to the remote muxer
   */
  sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream - this is a no-op on Yamux streams
   */
  async sendCloseRead(options) {
    options?.signal?.throwIfAborted();
  }
  /**
   * Stop sending window updates temporarily - in the interim the the remote
   * send window will exhaust and the remote will stop sending data
   */
  sendPause() {
    this.state = StreamState.Paused;
  }
  /**
   * Start sending window updates as normal
   */
  sendResume() {
    this.state = StreamState.Established;
    this.sendWindowUpdate();
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(frame) {
    this.processFlags(frame.header.flag);
    this.sendWindowCapacity += frame.header.length;
    this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH;
    if (this.maxMessageSize < 0) {
      this.maxMessageSize = 0;
    }
    if (this.maxMessageSize === 0) {
      return;
    }
    if (this.writeBuffer.byteLength > 0) {
      this.log?.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s", frame.header.length, this.writeBuffer.byteLength, this.sendingData);
      this.safeDispatchEvent("drain");
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  handleData(frame) {
    if (!isDataFrame(frame)) {
      throw new InvalidFrameError("Frame was not data frame");
    }
    this.processFlags(frame.header.flag);
    if (this.recvWindowCapacity < frame.header.length) {
      throw new ReceiveWindowExceededError("Receive window exceeded");
    }
    this.recvWindowCapacity -= frame.header.length;
    this.onData(frame.data);
    this.sendWindowUpdate();
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.onRemoteCloseWrite();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.onRemoteReset();
    }
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * Potentially sends a window update enabling further remote writes to take
   * place.
   */
  sendWindowUpdate() {
    if (this.state === StreamState.Paused) {
      this.epochStart = Date.now();
      return;
    }
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > -1 && now - this.epochStart <= rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: delta
    });
  }
}
function debugFrame(header) {
  return {
    type: FrameType[header.type],
    flags: [
      (header.flag & Flag.SYN) === Flag.SYN ? "SYN" : void 0,
      (header.flag & Flag.ACK) === Flag.ACK ? "ACK" : void 0,
      (header.flag & Flag.FIN) === Flag.FIN ? "FIN" : void 0,
      (header.flag & Flag.RST) === Flag.RST ? "RST" : void 0
    ].filter(Boolean),
    streamID: header.streamID,
    length: header.length
  };
}
const YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
class Yamux {
  protocol = YAMUX_PROTOCOL_ID;
  _init;
  constructor(init3 = {}) {
    this._init = init3;
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
  [serviceCapabilities] = [
    "@libp2p/stream-multiplexing"
  ];
  createStreamMuxer(maConn) {
    return new YamuxMuxer(maConn, {
      ...this._init
    });
  }
}
class YamuxMuxer extends AbstractStreamMuxer {
  /** The next stream id to be used when initiating a new stream */
  nextStreamID;
  /** The next ping id to be used when pinging */
  nextPingID;
  /** Tracking info for the currently active ping */
  activePing;
  /** Round trip time */
  rtt;
  /** True if client, false if server */
  client;
  localGoAway;
  remoteGoAway;
  /** Number of tracked inbound streams */
  numInboundStreams;
  /** Number of tracked outbound streams */
  numOutboundStreams;
  decoder;
  keepAlive;
  enableKeepAlive;
  keepAliveInterval;
  maxInboundStreams;
  maxOutboundStreams;
  constructor(maConn, init3 = {}) {
    super(maConn, {
      ...init3,
      protocol: YAMUX_PROTOCOL_ID,
      name: "yamux"
    });
    this.client = maConn.direction === "outbound";
    verifyConfig(init3);
    this.enableKeepAlive = init3.enableKeepAlive ?? defaultConfig.enableKeepAlive;
    this.keepAliveInterval = init3.keepAliveInterval ?? defaultConfig.keepAliveInterval;
    this.maxInboundStreams = init3.maxInboundStreams ?? defaultConfig.maxInboundStreams;
    this.maxOutboundStreams = init3.maxOutboundStreams ?? defaultConfig.maxOutboundStreams;
    this.decoder = new Decoder2();
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = -1;
    this.log.trace("muxer created");
    if (this.enableKeepAlive) {
      this.log.trace("muxer keepalive enabled interval=%s", this.keepAliveInterval);
      this.keepAlive = repeatingTask(async (options) => {
        try {
          await this.ping(options);
        } catch (err) {
          this.log.error("ping error: %s", err);
        }
      }, this.keepAliveInterval, {
        // send an initial ping to establish RTT
        runImmediately: true
      });
      this.keepAlive.start();
    }
  }
  onData(buf) {
    for (const frame of this.decoder.emitFrames(buf)) {
      this.handleFrame(frame);
    }
  }
  onCreateStream() {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.maxOutboundStreams) {
      throw new TooManyOutboundProtocolStreamsError("max outbound streams exceeded");
    }
    this.log.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, StreamState.Init, "outbound");
    this.numOutboundStreams++;
    queueMicrotask(() => {
      stream.sendWindowUpdate();
    });
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping(options) {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError("Muxer closed locally");
    }
    if (this.activePing != null) {
      return raceSignal$2(this.activePing.promise, options?.signal);
    }
    this.activePing = Object.assign(Promise.withResolvers(), {
      id: this.nextPingID++,
      start: Date.now()
    });
    this.sendPing(this.activePing.id);
    try {
      this.rtt = await raceSignal$2(this.activePing.promise, options?.signal);
    } finally {
      this.activePing = void 0;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(options = {}) {
    if (this.status !== "open") {
      return;
    }
    try {
      const reason = options?.reason ?? GoAwayCode.NormalTermination;
      this.log.trace("muxer close reason=%s", GoAwayCode[reason]);
      await super.close(options);
      this.sendGoAway(reason);
    } finally {
      this.keepAlive?.stop();
    }
  }
  abort(err) {
    if (this.status !== "open") {
      return;
    }
    try {
      super.abort(err);
      let reason = GoAwayCode.InternalError;
      if (isProtocolError(err)) {
        reason = err.reason;
      }
      this.log.error("muxer abort reason=%s error=%s", reason, err);
      this.sendGoAway(reason);
    } finally {
      this.keepAlive?.stop();
    }
  }
  onTransportClosed() {
    try {
      super.onTransportClosed();
    } finally {
      this.keepAlive?.stop();
    }
  }
  /** Create a new stream */
  _newStream(streamId, state, direction) {
    if (this.streams.find((s2) => s2.streamId === streamId) != null) {
      throw new InvalidParametersError$1("Stream already exists with that id");
    }
    const stream = new YamuxStream({
      ...this.streamOptions,
      id: `${streamId}`,
      streamId,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      log: this.log.newScope(`${direction}:${streamId}`),
      getRTT: this.getRTT.bind(this)
    });
    stream.addEventListener("close", () => {
      this.closeStream(streamId);
    }, {
      once: true
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
  }
  handleFrame(frame) {
    const { streamID, type, length: length3 } = frame.header;
    this.log.trace("received frame %o", debugFrame(frame.header));
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(frame.header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length3);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    } else {
      switch (frame.header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          this.handleStreamMessage(frame);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new InvalidFrameError("Invalid frame flag");
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new UnRequestedPingError("ping not requested");
    }
    if (this.activePing.id !== pingId) {
      throw new NotMatchingPingError("ping doesn't match our id");
    }
    this.activePing.resolve(Date.now() - this.activePing.start);
  }
  handleGoAway(reason) {
    this.log.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    if (reason === GoAwayCode.NormalTermination) {
      this.onTransportClosed();
    } else {
      this.abort(new Error("Remote sent GoAway"));
    }
  }
  handleStreamMessage(frame) {
    const { streamID, flag, type } = frame.header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this.streams.find((s2) => s2.streamId === streamID);
    if (stream === void 0) {
      this.log.trace("frame for missing stream id=%s", streamID);
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(frame);
        return;
      }
      case FrameType.Data: {
        stream.handleData(frame);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new InvalidParametersError$1("Both endpoints are clients");
    }
    if (this.streams.find((s2) => s2.streamId === id)) {
      return;
    }
    this.log.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.maxInboundStreams) {
      this.log("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this.onRemoteStream(stream);
  }
  sendFrame(header, data) {
    let encoded;
    if (header.type === FrameType.Data) {
      if (data == null) {
        throw new InvalidFrameError("Invalid frame");
      }
      encoded = new Uint8ArrayList(encodeHeader(header), data);
    } else {
      encoded = encodeHeader(header);
    }
    this.log.trace("sending frame %o", debugFrame(header));
    return this.send(encoded);
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
}
function yamux(init3 = {}) {
  return () => new Yamux(init3);
}
const IDENTIFY_PROTOCOL_VERSION = "0.1.0";
const MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
const MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var Identify$1;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value2 of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(26);
            w.string(value2);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf, opts) => {
    return decodeMessage(buf, Identify2.codec(), opts);
  };
})(Identify$1 || (Identify$1 = {}));
const defaultValues = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnLimitedConnection: true
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
async function consumeIdentifyMessage(peerStore, events, log2, connection, message2) {
  log2("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey = publicKeyFromProtobuf(message2.publicKey);
    const peerId = peerIdFromPublicKey(publicKey);
    if (!peerId.equals(connection.remotePeer)) {
      throw new InvalidMessageError("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log2.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope2 = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord.DOMAIN);
    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log2("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope2;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log2("%p did not send a signed peer record", connection.remotePeer);
  }
  log2.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    log2.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
class AbstractIdentify {
  host;
  components;
  protocol;
  started;
  timeout;
  maxInboundStreams;
  maxOutboundStreams;
  maxMessageSize;
  maxObservedAddresses;
  runOnLimitedConnection;
  log;
  constructor(components, init3) {
    this.protocol = init3.protocol;
    this.started = false;
    this.components = components;
    this.log = init3.log;
    this.timeout = init3.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init3.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init3.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxMessageSize = init3.maxMessageSize ?? defaultValues.maxMessageSize;
    this.maxObservedAddresses = init3.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnLimitedConnection = init3.runOnLimitedConnection ?? defaultValues.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init3.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: components.nodeInfo.userAgent
    };
    this.handleProtocol = this.handleProtocol.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.merge(this.components.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.components.registrar.handle(this.protocol, this.handleProtocol, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
}
class Identify extends AbstractIdentify {
  constructor(components, init3 = {}) {
    super(components, {
      ...init3,
      protocol: `/${init3.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    if (init3.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch(() => {
        });
      });
    }
  }
  [serviceCapabilities] = [
    "@libp2p/identify"
  ];
  async _identify(connection, options = {}) {
    let stream;
    let log2;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options = {
        ...options,
        signal
      };
    }
    this.log("run identify on new connection %a", connection.remoteAddr);
    try {
      stream = await connection.newStream(this.protocol, {
        ...options,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      log2 = stream.log.newScope("identify");
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify$1);
      const message2 = await pb.read(options);
      await pb.unwrap().unwrap().close(options);
      return message2;
    } catch (err) {
      log2?.error("identify failed - %e", err);
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new InvalidMessageError("Public key was missing from identify message");
    }
    const key2 = publicKeyFromProtobuf(publicKey);
    const id = peerIdFromCID(key2.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError("Identified peer does not match the expected peer");
    }
    if (this.components.peerId.equals(id)) {
      throw new InvalidMessageError("Identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("completed for peer %p and protocols %o", id, protocols);
    return consumeIdentifyMessage(this.components.peerStore, this.components.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      return;
    }
    const tuples = cleanObservedAddr.getComponents();
    if ((tuples[0].code === CODE_IP6 || tuples[0].code === CODE_IP6ZONE && tuples[1].code === CODE_IP6) && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.components.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(stream, connection) {
    const log2 = stream.log.newScope("identify");
    log2("responding to identify");
    const signal = AbortSignal.timeout(this.timeout);
    const peerData = await this.components.peerStore.get(this.components.peerId, {
      signal
    });
    const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P));
    let signedPeerRecord = peerData.peerRecordEnvelope;
    if (multiaddrs.length > 0 && signedPeerRecord == null) {
      const peerRecord = new PeerRecord({
        peerId: this.components.peerId,
        multiaddrs
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.privateKey, {
        signal
      });
      signedPeerRecord = envelope.marshal().subarray();
    }
    let observedAddr = connection.remoteAddr.bytes;
    if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
      observedAddr = void 0;
    }
    const pb = pbStream(stream).pb(Identify$1);
    log2("send response");
    await pb.write({
      protocolVersion: this.host.protocolVersion,
      agentVersion: this.host.agentVersion,
      publicKey: publicKeyToProtobuf(this.components.privateKey.publicKey),
      listenAddrs: multiaddrs.map((addr) => addr.bytes),
      signedPeerRecord,
      observedAddr,
      protocols: peerData.protocols
    }, {
      signal
    });
    log2("close write");
    await pb.unwrap().unwrap().close({
      signal
    });
  }
}
function identify(init3 = {}) {
  return (components) => new Identify(components, init3);
}
const DEFAULT_RESERVATION_CONCURRENCY = 1;
const DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 5e3;
const DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
const KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
BigInt(1 << 17);
const RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
const RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
const MAX_CONNECTIONS = 300;
const DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
const DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;
var HopMessage;
(function(HopMessage2) {
  (function(Type) {
    Type["RESERVE"] = "RESERVE";
    Type["CONNECT"] = "CONNECT";
    Type["STATUS"] = "STATUS";
  })(HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type) {
    Type.codec = () => {
      return enumeration(__TypeValues);
    };
  })(HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer$1.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer$1.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  (function(Type) {
    Type["CONNECT"] = "CONNECT";
    Type["STATUS"] = "STATUS";
  })(StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type) {
    Type.codec = () => {
      return enumeration(__TypeValues);
    };
  })(StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer$1.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer$1.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer$1;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          id: alloc$1(0),
          addrs: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer$1 || (Peer$1 = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          Envelope.codec().encode(obj.voucher, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = Envelope.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.voucher
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf, opts) => {
    return decodeMessage(buf, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {};
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf, opts) => {
    return decodeMessage(buf, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          relay: alloc$1(0),
          peer: alloc$1(0),
          expiration: 0n
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf, opts) => {
    return decodeMessage(buf, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null) {
          w.uint32(26);
          ReservationVoucher.codec().encode(obj.payload, w);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          publicKey: alloc$1(0),
          payloadType: alloc$1(0),
          signature: alloc$1(0)
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.payload
              });
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));
class HadEnoughRelaysError extends Error {
  static name = "HadEnoughRelaysError";
  name = "HadEnoughRelaysError";
}
class DoubleRelayError extends Error {
  static name = "DoubleRelayError";
  name = "DoubleRelayError";
}
class RelayQueueFullError extends Error {
  static name = "RelayQueueFullError";
  name = "RelayQueueFullError";
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
class LimitTracker {
  expires;
  bytes;
  constructor(limits) {
    if (limits?.duration != null && limits?.duration !== 0) {
      this.expires = Date.now() + limits.duration * 1e3;
    }
    this.bytes = limits?.data;
    if (this.bytes === 0n) {
      this.bytes = void 0;
    }
    this.onData = this.onData.bind(this);
  }
  onData(buf) {
    if (this.bytes == null) {
      return;
    }
    this.bytes -= BigInt(buf.byteLength);
    if (this.bytes < 0n) {
      this.bytes = 0n;
    }
  }
  getLimits() {
    if (this.expires == null && this.bytes == null) {
      return;
    }
    const output = {};
    if (this.bytes != null) {
      const self2 = this;
      Object.defineProperty(output, "bytes", {
        get() {
          return self2.bytes;
        }
      });
    }
    if (this.expires != null) {
      const self2 = this;
      Object.defineProperty(output, "seconds", {
        get() {
          return Math.round(((self2.expires ?? 0) - Date.now()) / 1e3);
        }
      });
    }
    return output;
  }
}
const CircuitListen = fmt(and(P2P.matchers[0], code(CODE_P2P_CIRCUIT)));
const CircuitSearch = fmt(code(CODE_P2P_CIRCUIT));
class RelayDiscovery extends TypedEventEmitter {
  components;
  started;
  running;
  topologyId;
  log;
  discoveryController;
  filter;
  queue;
  constructor(components, init3 = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.components = components;
    this.started = false;
    this.running = false;
    this.filter = init3.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.dialPeer = this.dialPeer.bind(this);
    this.onPeer = this.onPeer.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId) => {
        this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId, this.queue?.size, this.queue?.running);
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.components.registrar.unregister(this.topologyId);
    }
    if (this.running) {
      this.stopDiscovery();
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully
   * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.components.events.addEventListener("peer:discovery", this.onPeer);
    Promise.resolve().then(async () => {
      this.log("searching peer store for relays");
      const peers = await this.components.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          // randomize
          () => Math.random() < 0.5 ? 1 : -1,
          // prefer peers we've connected to in the past
          (a2, b) => {
            const lastDialA = getLastDial(a2);
            const lastDialB = getLastDial(b);
            if (lastDialA > lastDialB) {
              return -1;
            }
            if (lastDialB > lastDialA) {
              return 1;
            }
            return 0;
          }
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = this.queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (this.components.connectionManager.getConnections(peer.id)?.length > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        if (queue.queued > 10) {
          this.log.trace("wait for space in queue for %p", peer.id);
          await queue.onSizeLessThan(10, {
            signal: this.discoveryController.signal
          });
        }
        this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
        queue.add(this.dialPeer, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p - %e", peer.id, err);
        });
      }
      this.log("stop random walk");
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network - %e", err);
      }
    });
  }
  stopDiscovery() {
    this.log("stop discovery");
    this.running = false;
    this.discoveryController?.abort();
    this.queue?.clear();
    this.components.events.removeEventListener("peer:discovery", this.onPeer);
  }
  onPeer(evt) {
    this.log.trace("maybe dialing discovered peer %p", evt.detail.id);
    this.maybeDialPeer(evt).catch((err) => {
      this.log.trace("error dialing discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async maybeDialPeer(evt) {
    if (this.queue == null) {
      return;
    }
    const peerId = evt.detail.id;
    const multiaddrs = evt.detail.multiaddrs;
    if (this.queue.has(peerId)) {
      this.log.trace("random peer %p was already in queue", peerId);
      return;
    }
    if (this.components.connectionManager.getConnections(peerId)?.length > 0) {
      this.log.trace("random peer %p was already connected", peerId);
      return;
    }
    if (!await this.components.connectionManager.isDialable(multiaddrs)) {
      this.log.trace("random peer %p was not dialable", peerId);
      return;
    }
    this.queue?.add(this.dialPeer, {
      peerId: evt.detail.id,
      signal: this.discoveryController.signal
    }).catch((err) => {
      this.log.error("error opening connection to discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async dialPeer({ peerId, signal }) {
    const combinedSignal = anySignal([AbortSignal.timeout(5e3), signal]);
    try {
      await this.components.connectionManager.openConnection(peerId, {
        signal: combinedSignal
      });
    } finally {
      combinedSignal.clear();
    }
  }
}
function getLastDial(peer) {
  const lastDial = peer.metadata.get("last-dial-success");
  if (lastDial == null) {
    return 0;
  }
  return new Date(toString$1(lastDial)).getTime();
}
class CircuitRelayTransportListener extends TypedEventEmitter {
  connectionManager;
  addressManager;
  reservationStore;
  listeningAddrs;
  log;
  listenTimeout;
  reservationId;
  relay;
  constructor(components, init3 = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.addressManager = components.addressManager;
    this.reservationStore = components.reservationStore;
    this.listeningAddrs = [];
    this.listenTimeout = init3.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
  }
  _onRemoveRelayPeer = (evt) => {
    this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, this.relay?.equals(evt.detail.relay));
    if (this.relay?.equals(evt.detail.relay) !== true) {
      return;
    }
    this.log("relay peer removed %p", evt.detail.relay);
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.removeObservedAddr(ma);
    });
    this.listeningAddrs = [];
    this.safeDispatchEvent("listening");
  };
  _onAddRelayPeer = (evt) => {
    const { details } = evt.detail;
    if (details.type === "configured") {
      return;
    }
    if (details.id !== this.reservationId) {
      return;
    }
    this.addedRelay(evt.detail);
  };
  async listen(addr) {
    if (CircuitSearch.exactMatch(addr)) {
      this.log("searching for circuit relay servers");
      this.reservationId = this.reservationStore.reserveRelay();
    } else if (CircuitListen.exactMatch(addr)) {
      this.log("listen on specific relay server %a", addr);
      const signal = AbortSignal.timeout(this.listenTimeout);
      const relayAddr = addr.decapsulate("/p2p-circuit");
      const relayConn = await this.connectionManager.openConnection(relayAddr, {
        signal
      });
      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
        this.log("making reservation on peer %p", relayConn.remotePeer);
        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
        this.addedRelay(reservation);
      }
    } else {
      throw new ListenError(`Could not listen on p2p-circuit address "${addr}"`);
    }
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.reservationStore.cancelReservations();
    this.listeningAddrs = [];
    this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
  addedRelay(reservation) {
    this.log("relay peer added %p", reservation.relay);
    this.relay = reservation.relay;
    this.listeningAddrs = reservation.details.reservation.addrs.map((buf) => multiaddr(buf).encapsulate("/p2p-circuit"));
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.confirmObservedAddr(ma, {
        type: "transport"
      });
    });
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
}
function createListener(options) {
  return new CircuitRelayTransportListener(options);
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size2 = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
  while (size2--) {
    id += urlAlphabet[bytes[size2] & 63];
  }
  return id;
};
const REFRESH_WINDOW = 60 * 1e3 * 10;
const REFRESH_TIMEOUT = 60 * 1e3 * 5;
const REFRESH_TIMEOUT_MIN = 30 * 1e3;
class ReservationStore extends TypedEventEmitter {
  peerId;
  connectionManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  pendingReservations;
  maxReservationQueueLength;
  reservationCompletionTimeout;
  started;
  log;
  relayFilter;
  constructor(components, init3) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.pendingReservations = [];
    this.maxReservationQueueLength = init3?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = init3?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createScalableCuckooFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: init3?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("connection:close", (evt) => {
      const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
      if (reservation == null) {
        return;
      }
      this.#removeReservation(evt.detail.remotePeer).catch((err) => {
        this.log("could not remove relay %p - %e", evt.detail, err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    void Promise.resolve().then(async () => {
      const relayPeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE_TAG);
        }]
      });
      this.log("removing tag from %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => {
        await this.peerStore.merge(peer.id, {
          tags: {
            [KEEP_ALIVE_TAG]: void 0
          }
        });
      }));
      this.log("redialing %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
      this.#checkReservationCount();
    }).catch((err) => {
      this.log.error("failed to clean up and redial old relays during afterStart - %e", err);
    });
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  reserveRelay() {
    const id = nanoid();
    this.pendingReservations.push(id);
    this.#checkReservationCount();
    return id;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log.trace("not trying to use self as relay");
      throw new ListenError("Cannot use self as relay");
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      throw new RelayQueueFullError("The reservation queue is full");
    }
    const existingJob = this.reserveQueue.find(peerId);
    if (existingJob != null) {
      this.log.trace("potential relay peer %p is already in the reservation queue", peerId);
      return existingJob.join();
    }
    if (this.relayFilter.has(peerId.toMultihash().bytes)) {
      throw new ListenError("The relay was previously invalid");
    }
    this.log.trace("try to reserve relay slot with %p", peerId);
    return this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          const connections = this.connectionManager.getConnections(peerId);
          let connected = false;
          if (connections.length === 0) {
            this.log("already have relay reservation with %p but we are no longer connected", peerId);
          }
          if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
            this.log("already have relay reservation with %p and the original connection is still open", peerId);
            connected = true;
          }
          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId);
            return {
              relay: peerId,
              details: existingReservation
            };
          }
          await this.#removeReservation(peerId);
        }
        if (type === "discovered" && this.pendingReservations.length === 0) {
          throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (Circuit$1.matches(connection.remoteAddr)) {
          throw new DoubleRelayError("not creating reservation over relayed connection");
        }
        const reservation = await this.#createReservation(connection, {
          signal
        });
        const expiration = getExpirationMilliseconds(reservation.expire);
        this.log("created reservation on relay peer %p, expiry date is %s", peerId, new Date(Date.now() + expiration).toString());
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.log("refresh reservation to relay %p", peerId);
          this.addRelay(peerId, type).catch(async (err) => {
            this.log.error("could not refresh reservation to relay %p - %e", peerId, err);
            await this.#removeReservation(peerId);
          }).catch((err) => {
            this.log.error("could not remove expired reservation to relay %p - %e", peerId, err);
          });
        }, timeoutDuration);
        let res;
        if (type === "discovered") {
          const id = this.pendingReservations.pop();
          if (id == null) {
            throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
          }
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id,
            id
          };
        } else {
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id
          };
        }
        this.reservations.set(peerId, res);
        await this.peerStore.merge(peerId, {
          tags: {
            [KEEP_ALIVE_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        this.#checkReservationCount();
        const result = {
          relay: peerId,
          details: res
        };
        this.safeDispatchEvent("relay:created-reservation", {
          detail: result
        });
        return result;
      } catch (err) {
        if (!(type === "discovered" && err.name === "HadEnoughRelaysError")) {
          this.log.error("could not reserve slot on %p after %dms - %e", peerId, Date.now() - start2, err);
        }
        if (err.name === "DialError" || err.name === "UnsupportedProtocolError") {
          this.relayFilter.add(peerId.toMultihash().bytes);
        }
        this.#removeReservation(peerId).catch((err2) => {
          this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId, err2);
        });
        throw err;
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    return this.reservations.get(peerId)?.reservation;
  }
  reservationCount(type) {
    if (type == null) {
      return this.reservations.size;
    }
    return [...this.reservations.values()].reduce((acc, curr) => {
      if (curr.type === type) {
        acc++;
      }
      return acc;
    }, 0);
  }
  cancelReservations() {
    [...this.reservations.values()].forEach((reservation) => {
      clearTimeout(reservation.timeout);
    });
    this.reservations.clear();
  }
  async #createReservation(connection, options) {
    options.signal?.throwIfAborted();
    this.log("requesting reservation from %p", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    this.log.trace("send RESERVE to %p", connection.remotePeer);
    await hopstr.write({ type: HopMessage.Type.RESERVE }, options);
    let response;
    try {
      this.log.trace("reading response from %p", connection.remotePeer);
      response = await hopstr.read(options);
    } catch (err) {
      stream.abort(err);
      throw err;
    } finally {
      if (stream.status !== "closed") {
        await stream.close(options);
      }
    }
    this.log.trace("read response %s", response.status);
    if (response.status === Status.OK && response.reservation != null) {
      const addresses = /* @__PURE__ */ new Set();
      addresses.add(connection.remoteAddr.toString());
      for (const buf of response.reservation.addrs) {
        let ma = multiaddr(buf);
        if (ma.getComponents().find((c2) => c2.code === CODE_P2P) == null) {
          ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
        }
        ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
        addresses.add(ma.toString());
      }
      response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    this.log.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  async #removeReservation(peerId) {
    const reservation = this.reservations.get(peerId);
    if (reservation == null) {
      return;
    }
    this.log("removing relay reservation with %p from local store", peerId);
    clearTimeout(reservation.timeout);
    this.reservations.delete(peerId);
    if (reservation.type === "discovered") {
      this.pendingReservations.push(reservation.id);
    }
    await this.peerStore.merge(peerId, {
      tags: {
        [KEEP_ALIVE_TAG]: void 0
      }
    });
    this.safeDispatchEvent("relay:removed", {
      detail: {
        relay: peerId,
        details: reservation
      }
    });
    this.#checkReservationCount();
  }
  #checkReservationCount() {
    if (this.pendingReservations.length === 0) {
      this.log.trace("have discovered enough relays");
      this.reserveQueue.clear();
      this.safeDispatchEvent("relay:found-enough-relays");
      return;
    }
    this.relayFilter = createScalableCuckooFilter(100);
    this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
    this.safeDispatchEvent("relay:not-enough-relays");
  }
}
class StreamMultiaddrConnection extends AbstractMultiaddrConnection {
  stream;
  init;
  constructor(init3) {
    super({
      ...init3,
      direction: init3.stream.direction
    });
    this.init = init3;
    this.stream = init3.stream;
    this.stream.addEventListener("close", (evt) => {
      this.onTransportClosed(evt.error);
    });
    this.stream.addEventListener("remoteCloseWrite", (evt) => {
      this.onRemoteCloseWrite();
      this.close().catch((err) => {
        this.abort(err);
      });
    });
    this.stream.addEventListener("message", (evt) => {
      init3.onDataRead?.(evt.data);
      this.onData(evt.data);
    });
    this.stream.addEventListener("drain", () => {
      this.safeDispatchEvent("drain");
    });
  }
  sendData(data) {
    this.init.onDataWrite?.(data);
    return {
      sentBytes: data.byteLength,
      canSendMore: this.stream.send(data)
    };
  }
  async sendClose(options) {
    await this.stream.close(options);
  }
  sendReset() {
    this.stream.abort(new Error("An error occurred"));
  }
  sendPause() {
    this.stream.pause();
  }
  sendResume() {
    this.stream.resume();
  }
}
function streamToMaConnection(init3) {
  return new StreamMultiaddrConnection(init3);
}
const isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
const defaults = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS
};
class CircuitRelayTransport {
  components;
  discovery;
  reservationStore;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  started;
  log;
  shutdownController;
  constructor(components, init3 = {}) {
    this.components = components;
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.maxInboundStopStreams = init3.maxInboundStopStreams ?? defaults.maxInboundStopStreams;
    this.maxOutboundStopStreams = init3.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.shutdownController = new AbortController();
    this.discovery = new RelayDiscovery(components, {
      filter: init3.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
    });
    this.discovery.addEventListener("relay:discover", (evt) => {
      this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
        if (err.name !== "HadEnoughRelaysError" && err.name !== "RelayQueueFullError") {
          this.log.error("could not add discovered relay %p - %e", evt.detail, err);
        }
      });
    });
    this.reservationStore = new ReservationStore(components, init3);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:found-enough-relays", () => {
      this.discovery?.stopDiscovery();
    });
    this.started = false;
    this.onStop = this.onStop.bind(this);
  }
  [Symbol.toStringTag] = "@libp2p/circuit-relay-v2-transport";
  [serviceCapabilities] = [
    "@libp2p/transport",
    "@libp2p/circuit-relay-v2-transport"
  ];
  get [serviceDependencies]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  [transportSymbol] = true;
  isStarted() {
    return this.started;
  }
  async start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    await this.components.registrar.handle(RELAY_V2_STOP_CODEC, this.onStop, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    this.shutdownController.abort();
    await stop(this.discovery, this.reservationStore);
    await this.components.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
    const destinationId = destinationAddr.getComponents().find((c2) => c2.code === CODE_P2P)?.value;
    if (relayId == null || destinationId == null) {
      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
      this.log.error(`c${errMsg}`);
      throw new DialError(`C${errMsg}`);
    }
    const relayPeer = peerIdFromString$1(relayId);
    const destinationPeer = peerIdFromString$1(destinationId);
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      options.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);
    } else {
      options.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      options.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options);
      const hopstr = pbStream(stream).pb(HopMessage);
      options.onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toMultihash().bytes,
          addrs: [multiaddr(destinationAddr).bytes]
        }
      }, options);
      options.onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read(options);
      if (status.status !== Status.OK) {
        throw new InvalidMessageError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`);
      }
      const limits = new LimitTracker(status.limit);
      const maConn = streamToMaConnection({
        stream: hopstr.unwrap().unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      const conn = await this.components.upgrader.upgradeOutbound(maConn, {
        ...options,
        limits: limits.getLimits()
      });
      conn.log("outbound relayed connection established to %p with limits %o, over connection %s", conn.remotePeer, status.limit ?? "none", relayConnection.id);
      return conn;
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed - %e", destinationPeer, relayPeer, err);
      stream?.abort(err);
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    return createListener({
      peerId: this.components.peerId,
      connectionManager: this.components.connectionManager,
      addressManager: this.components.addressManager,
      reservationStore: this.reservationStore,
      logger: this.components.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit$1.exactMatch(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop(stream, connection) {
    const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
    try {
      if (!this.reservationStore.hasReservation(connection.remotePeer)) {
        try {
          this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
          await this.components.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
        } catch (err) {
          this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e", err);
        }
      }
      const stopStream = pbStream(stream).pb(StopMessage);
      const request = await stopStream.read({
        signal
      });
      this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
      if (request?.type === void 0) {
        this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (request.type !== StopMessage.Type.CONNECT) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (!isValidStop(request)) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      const remotePeerId = peerIdFromMultihash(decode$3(request.peer.id));
      if (await this.components.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
        this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      this.log.trace("sending success response to %p", connection.remotePeer);
      await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
        signal
      });
      const limits = new LimitTracker(request.limit);
      const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
      const localAddr = this.components.addressManager.getAddresses()[0];
      const maConn = streamToMaConnection({
        stream: stopStream.unwrap().unwrap(),
        remoteAddr,
        localAddr,
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      await this.components.upgrader.upgradeInbound(maConn, {
        limits: limits.getLimits(),
        signal
      });
      maConn.log("inbound relayed connection established to %p with limits %o, over connection %s", remotePeerId, request.limit ?? "none", connection.id);
    } finally {
      signal?.clear();
    }
  }
}
function circuitRelayTransport(init3 = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init3);
  };
}
const DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
const DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
const DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
class Bootstrap extends TypedEventEmitter {
  static tag = "bootstrap";
  log;
  timer;
  list;
  timeout;
  components;
  _init;
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = options.list.map((str) => multiaddr(str)).filter((ma) => {
      if (!P2P.matches(ma)) {
        this.log.error("invalid multiaddr %a", ma);
        return false;
      }
      const peerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value;
      if (peerIdStr == null) {
        this.log.error("invalid bootstrap multiaddr without peer id");
        return false;
      }
      return true;
    }).map((ma) => {
      return {
        id: peerIdFromString$1(ma.getComponents().findLast((c2) => c2.code === CODE_P2P)?.value ?? ""),
        multiaddrs: [ma]
      };
    });
    this._init = options;
  }
  [peerDiscoverySymbol] = this;
  [Symbol.toStringTag] = "@libp2p/bootstrap";
  [serviceCapabilities] = [
    "@libp2p/peer-discovery"
  ];
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error("failed to discover bootstrap peers - %e", err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p - %e", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
}
function bootstrap(init3) {
  return (components) => new Bootstrap(components, init3);
}
const second = 1e3;
const minute = 60 * second;
const FloodsubID = "/floodsub/1.0.0";
const GossipsubIDv10 = "/meshsub/1.0.0";
const GossipsubIDv11 = "/meshsub/1.1.0";
const GossipsubIDv12 = "/meshsub/1.2.0";
const GossipsubD = 6;
const GossipsubDlo = 4;
const GossipsubDhi = 12;
const GossipsubDscore = 4;
const GossipsubDout = 2;
const GossipsubHistoryLength = 5;
const GossipsubHistoryGossip = 3;
const GossipsubDlazy = 6;
const GossipsubGossipFactor = 0.25;
const GossipsubGossipRetransmission = 3;
const GossipsubHeartbeatInitialDelay = 100;
const GossipsubHeartbeatInterval = second;
const GossipsubFanoutTTL = minute;
const GossipsubPrunePeers = 16;
const GossipsubPruneBackoff = minute;
const GossipsubUnsubscribeBackoff = 10 * second;
const GossipsubPruneBackoffTicks = 15;
const GossipsubDirectConnectTicks = 300;
const GossipsubDirectConnectInitialDelay = second;
const GossipsubOpportunisticGraftTicks = 60;
const GossipsubOpportunisticGraftPeers = 2;
const GossipsubGraftFloodThreshold = 10 * second;
const GossipsubMaxIHaveLength = 5e3;
const GossipsubMaxIHaveMessages = 10;
const GossipsubIWantFollowupTime = 3 * second;
const GossipsubSeenTTL = 2 * minute;
const TimeCacheDuration = 120 * 1e3;
const ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
const ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
const ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
const BACKOFF_SLACK = 1;
const GossipsubIdontwantMinDataSize = 512;
const GossipsubIdontwantMaxMessages = 512;
const defaultDecodeRpcLimits = {
  maxSubscriptions: Infinity,
  maxMessages: Infinity,
  maxIhaveMessageIDs: Infinity,
  maxIwantMessageIDs: Infinity,
  maxIdontwantMessageIDs: Infinity,
  maxControlMessages: Infinity,
  maxPeerInfos: Infinity
};
var RPC;
(function(RPC2) {
  (function(SubOpts) {
    let _codec2;
    SubOpts.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.subscribe != null) {
            w.uint32(8);
            w.bool(obj.subscribe);
          }
          if (obj.topic != null) {
            w.uint32(18);
            w.string(obj.topic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {};
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.subscribe = reader.bool();
                break;
              }
              case 2: {
                obj.topic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    SubOpts.encode = (obj) => {
      return encodeMessage(obj, SubOpts.codec());
    };
    SubOpts.decode = (buf, opts) => {
      return decodeMessage(buf, SubOpts.codec(), opts);
    };
  })(RPC2.SubOpts || (RPC2.SubOpts = {}));
  (function(Message2) {
    let _codec2;
    Message2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.from != null) {
            w.uint32(10);
            w.bytes(obj.from);
          }
          if (obj.data != null) {
            w.uint32(18);
            w.bytes(obj.data);
          }
          if (obj.seqno != null) {
            w.uint32(26);
            w.bytes(obj.seqno);
          }
          if (obj.topic != null && obj.topic !== "") {
            w.uint32(34);
            w.string(obj.topic);
          }
          if (obj.signature != null) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (obj.key != null) {
            w.uint32(50);
            w.bytes(obj.key);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            topic: ""
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.from = reader.bytes();
                break;
              }
              case 2: {
                obj.data = reader.bytes();
                break;
              }
              case 3: {
                obj.seqno = reader.bytes();
                break;
              }
              case 4: {
                obj.topic = reader.string();
                break;
              }
              case 5: {
                obj.signature = reader.bytes();
                break;
              }
              case 6: {
                obj.key = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Message2.encode = (obj) => {
      return encodeMessage(obj, Message2.codec());
    };
    Message2.decode = (buf, opts) => {
      return decodeMessage(buf, Message2.codec(), opts);
    };
  })(RPC2.Message || (RPC2.Message = {}));
  (function(ControlMessage) {
    let _codec2;
    ControlMessage.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.ihave != null) {
            for (const value2 of obj.ihave) {
              w.uint32(10);
              RPC2.ControlIHave.codec().encode(value2, w);
            }
          }
          if (obj.iwant != null) {
            for (const value2 of obj.iwant) {
              w.uint32(18);
              RPC2.ControlIWant.codec().encode(value2, w);
            }
          }
          if (obj.graft != null) {
            for (const value2 of obj.graft) {
              w.uint32(26);
              RPC2.ControlGraft.codec().encode(value2, w);
            }
          }
          if (obj.prune != null) {
            for (const value2 of obj.prune) {
              w.uint32(34);
              RPC2.ControlPrune.codec().encode(value2, w);
            }
          }
          if (obj.idontwant != null) {
            for (const value2 of obj.idontwant) {
              w.uint32(42);
              RPC2.ControlIDontWant.codec().encode(value2, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            ihave: [],
            iwant: [],
            graft: [],
            prune: [],
            idontwant: []
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {
                  throw new MaxLengthError('Decode error - map field "ihave" had too many elements');
                }
                obj.ihave.push(RPC2.ControlIHave.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.ihave$
                }));
                break;
              }
              case 2: {
                if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {
                  throw new MaxLengthError('Decode error - map field "iwant" had too many elements');
                }
                obj.iwant.push(RPC2.ControlIWant.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.iwant$
                }));
                break;
              }
              case 3: {
                if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {
                  throw new MaxLengthError('Decode error - map field "graft" had too many elements');
                }
                obj.graft.push(RPC2.ControlGraft.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.graft$
                }));
                break;
              }
              case 4: {
                if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {
                  throw new MaxLengthError('Decode error - map field "prune" had too many elements');
                }
                obj.prune.push(RPC2.ControlPrune.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.prune$
                }));
                break;
              }
              case 5: {
                if (opts.limits?.idontwant != null && obj.idontwant.length === opts.limits.idontwant) {
                  throw new MaxLengthError('Decode error - map field "idontwant" had too many elements');
                }
                obj.idontwant.push(RPC2.ControlIDontWant.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.idontwant$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlMessage.encode = (obj) => {
      return encodeMessage(obj, ControlMessage.codec());
    };
    ControlMessage.decode = (buf, opts) => {
      return decodeMessage(buf, ControlMessage.codec(), opts);
    };
  })(RPC2.ControlMessage || (RPC2.ControlMessage = {}));
  (function(ControlIHave) {
    let _codec2;
    ControlIHave.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              case 2: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIHave.encode = (obj) => {
      return encodeMessage(obj, ControlIHave.codec());
    };
    ControlIHave.decode = (buf, opts) => {
      return decodeMessage(buf, ControlIHave.codec(), opts);
    };
  })(RPC2.ControlIHave || (RPC2.ControlIHave = {}));
  (function(ControlIWant) {
    let _codec2;
    ControlIWant.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(10);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIWant.encode = (obj) => {
      return encodeMessage(obj, ControlIWant.codec());
    };
    ControlIWant.decode = (buf, opts) => {
      return decodeMessage(buf, ControlIWant.codec(), opts);
    };
  })(RPC2.ControlIWant || (RPC2.ControlIWant = {}));
  (function(ControlGraft) {
    let _codec2;
    ControlGraft.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {};
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlGraft.encode = (obj) => {
      return encodeMessage(obj, ControlGraft.codec());
    };
    ControlGraft.decode = (buf, opts) => {
      return decodeMessage(buf, ControlGraft.codec(), opts);
    };
  })(RPC2.ControlGraft || (RPC2.ControlGraft = {}));
  (function(ControlPrune) {
    let _codec2;
    ControlPrune.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (obj.peers != null) {
            for (const value2 of obj.peers) {
              w.uint32(18);
              RPC2.PeerInfo.codec().encode(value2, w);
            }
          }
          if (obj.backoff != null) {
            w.uint32(24);
            w.uint64Number(obj.backoff);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            peers: []
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              case 2: {
                if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {
                  throw new MaxLengthError('Decode error - map field "peers" had too many elements');
                }
                obj.peers.push(RPC2.PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.peers$
                }));
                break;
              }
              case 3: {
                obj.backoff = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlPrune.encode = (obj) => {
      return encodeMessage(obj, ControlPrune.codec());
    };
    ControlPrune.decode = (buf, opts) => {
      return decodeMessage(buf, ControlPrune.codec(), opts);
    };
  })(RPC2.ControlPrune || (RPC2.ControlPrune = {}));
  (function(PeerInfo) {
    let _codec2;
    PeerInfo.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peerID != null) {
            w.uint32(10);
            w.bytes(obj.peerID);
          }
          if (obj.signedPeerRecord != null) {
            w.uint32(18);
            w.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {};
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peerID = reader.bytes();
                break;
              }
              case 2: {
                obj.signedPeerRecord = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo.encode = (obj) => {
      return encodeMessage(obj, PeerInfo.codec());
    };
    PeerInfo.decode = (buf, opts) => {
      return decodeMessage(buf, PeerInfo.codec(), opts);
    };
  })(RPC2.PeerInfo || (RPC2.PeerInfo = {}));
  (function(ControlIDontWant) {
    let _codec2;
    ControlIDontWant.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(10);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length3, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length3 == null ? reader.len : reader.pos + length3;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIDontWant.encode = (obj) => {
      return encodeMessage(obj, ControlIDontWant.codec());
    };
    ControlIDontWant.decode = (buf, opts) => {
      return decodeMessage(buf, ControlIDontWant.codec(), opts);
    };
  })(RPC2.ControlIDontWant || (RPC2.ControlIDontWant = {}));
  let _codec;
  RPC2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.subscriptions != null) {
          for (const value2 of obj.subscriptions) {
            w.uint32(10);
            RPC2.SubOpts.codec().encode(value2, w);
          }
        }
        if (obj.messages != null) {
          for (const value2 of obj.messages) {
            w.uint32(18);
            RPC2.Message.codec().encode(value2, w);
          }
        }
        if (obj.control != null) {
          w.uint32(26);
          RPC2.ControlMessage.codec().encode(obj.control, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          subscriptions: [],
          messages: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {
                throw new MaxLengthError('Decode error - map field "subscriptions" had too many elements');
              }
              obj.subscriptions.push(RPC2.SubOpts.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.subscriptions$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
              }
              obj.messages.push(RPC2.Message.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.messages$
              }));
              break;
            }
            case 3: {
              obj.control = RPC2.ControlMessage.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.control
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RPC2.encode = (obj) => {
    return encodeMessage(obj, RPC2.codec());
  };
  RPC2.decode = (buf, opts) => {
    return decodeMessage(buf, RPC2.codec(), opts);
  };
})(RPC || (RPC = {}));
class MessageCache {
  gossip;
  msgs = /* @__PURE__ */ new Map();
  msgIdToStrFn;
  history = [];
  /** Track with accounting of messages in the mcache that are not yet validated */
  notValidatedCount = 0;
  /**
   * Holds history of messages in timebounded history arrays
   */
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    this.gossip = gossip;
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i2 = 0; i2 < historyCapacity; i2++) {
      this.history[i2] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  /**
   * Adds a message to the current window and the cache
   * Returns true if the message is not known and is inserted in the cache
   */
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    if (!validated) {
      this.notValidatedCount++;
    }
    return true;
  }
  observeDuplicate(msgId2, fromPeerIdStr) {
    const entry = this.msgs.get(msgId2);
    if (entry != null && // if the message is already validated, we don't need to store extra peers sending us
    // duplicates as the message has already been forwarded
    !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  /**
   * Retrieves a message from the cache by its ID, if it is still present
   */
  get(msgId2) {
    return this.msgs.get(this.msgIdToStrFn(msgId2))?.message;
  }
  /**
   * Increases the iwant count for the given message by one and returns the message together
   * with the iwant if the message exists.
   */
  getWithIWantCount(msgIdStr, p2) {
    const msg = this.msgs.get(msgIdStr);
    if (msg == null) {
      return null;
    }
    const count = (msg.iwantCounts.get(p2) ?? 0) + 1;
    msg.iwantCounts.set(p2, count);
    return { msg: msg.message, count };
  }
  /**
   * Retrieves a list of message IDs for a set of topics
   */
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < this.gossip; i2++) {
      this.history[i2].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if ((msg?.validated ?? false) && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (msgIds == null) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  /**
   * Gets a message with msgId and tags it as validated.
   * This function also returns the known peers that have sent us this message. This is used to
   * prevent us sending redundant messages to peers who have already propagated it.
   */
  validate(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (entry == null) {
      return null;
    }
    if (!entry.validated) {
      this.notValidatedCount--;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  /**
   * Shifts the current window, discarding messages older than this.history.length of the cache
   */
  shift() {
    const lastCacheEntries = this.history[this.history.length - 1];
    lastCacheEntries.forEach((cacheEntry) => {
      const entry = this.msgs.get(cacheEntry.msgIdStr);
      if (entry != null) {
        this.msgs.delete(cacheEntry.msgIdStr);
        if (!entry.validated) {
          this.notValidatedCount--;
        }
      }
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId2) {
    const entry = this.msgs.get(msgId2);
    if (entry == null) {
      return null;
    }
    this.msgs.delete(msgId2);
    return entry;
  }
}
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case TopicValidatorResult.Ignore:
      return RejectReason.Ignore;
    case TopicValidatorResult.Reject:
      return RejectReason.Reject;
    default:
      throw new Error("Unreachable");
  }
}
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    /* Metrics for static config */
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    /* Metrics per known topic */
    /**
     * Status of our subscription to this topic. This metric allows analyzing other topic metrics
     * filtered by our current subscription status.
     * = rust-libp2p `topic_subscription_status`
     */
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    /**
     * Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
     * regardless of our subscription status.
     */
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    /* Metrics regarding mesh state */
    /**
     * Number of peers in our mesh. This metric should be updated with the count of peers for a
     * topic in the mesh regardless of inclusion and churn events.
     * = rust-libp2p `mesh_peer_counts`
     */
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    /**
     * Number of times we include peers in a topic mesh for different reasons.
     * = rust-libp2p `mesh_peer_inclusion_events`
     */
    meshPeerInclusionEventsFanout: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
      help: "Number of times we include peers in a topic mesh for fanout reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsRandom: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_random_total",
      help: "Number of times we include peers in a topic mesh for random reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsSubscribed: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
      help: "Number of times we include peers in a topic mesh for subscribed reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOutbound: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
      help: "Number of times we include peers in a topic mesh for outbound reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsNotEnough: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
      help: "Number of times we include peers in a topic mesh for not_enough reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOpportunistic: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
      help: "Number of times we include peers in a topic mesh for opportunistic reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsUnknown: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
      help: "Number of times we include peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /**
     * Number of times we remove peers in a topic mesh for different reasons.
     * = rust-libp2p `mesh_peer_churn_events`
     */
    meshPeerChurnEventsDisconnected: register.gauge({
      name: "gossipsub_peer_churn_events_disconnected_total",
      help: "Number of times we remove peers in a topic mesh for disconnected reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsBadScore: register.gauge({
      name: "gossipsub_peer_churn_events_bad_score_total",
      help: "Number of times we remove peers in a topic mesh for bad_score reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsPrune: register.gauge({
      name: "gossipsub_peer_churn_events_prune_total",
      help: "Number of times we remove peers in a topic mesh for prune reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsExcess: register.gauge({
      name: "gossipsub_peer_churn_events_excess_total",
      help: "Number of times we remove peers in a topic mesh for excess reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsUnknown: register.gauge({
      name: "gossipsub_peer_churn_events_unknown_total",
      help: "Number of times we remove peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /* General Metrics */
    /**
     * Gossipsub supports floodsub, gossipsub v1.0, v1.1, and v1.2. Peers are classified based
     * on which protocol they support. This metric keeps track of the number of peers that are
     * connected of each type.
     */
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    /** The time it takes to complete one iteration of the heartbeat. */
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
      buckets: [0.01, 0.1, 1]
    }),
    /** Heartbeat run took longer than heartbeat interval so next is skipped */
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    /**
     * Message validation results for each topic.
     * Invalid == Reject?
     * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages`
     */
    acceptedMessagesTotal: register.gauge({
      name: "gossipsub_accepted_messages_total",
      help: "Total accepted messages for each topic",
      labelNames: ["topic"]
    }),
    ignoredMessagesTotal: register.gauge({
      name: "gossipsub_ignored_messages_total",
      help: "Total ignored messages for each topic",
      labelNames: ["topic"]
    }),
    rejectedMessagesTotal: register.gauge({
      name: "gossipsub_rejected_messages_total",
      help: "Total rejected messages for each topic",
      labelNames: ["topic"]
    }),
    unknownValidationResultsTotal: register.gauge({
      name: "gossipsub_unknown_validation_results_total",
      help: "Total unknown validation results for each topic",
      labelNames: ["topic"]
    }),
    /**
     * When the user validates a message, it tries to re propagate it to its mesh peers. If the
     * message expires from the memcache before it can be validated, we count this a cache miss
     * and it is an indicator that the memcache size should be increased.
     * = rust-libp2p `mcache_misses`
     */
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    asyncValidationDelayFromFirstSeenSec: register.histogram({
      name: "gossipsub_async_validation_delay_from_first_seen",
      help: "Async validation report delay from first seen in second",
      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]
    }),
    asyncValidationUnknownFirstSeen: register.gauge({
      name: "gossipsub_async_validation_unknown_first_seen_count_total",
      help: "Async validation report unknown first seen value for message"
    }),
    // peer stream
    peerReadStreamError: register.gauge({
      name: "gossipsub_peer_read_stream_err_count_total",
      help: "Peer read stream error"
    }),
    // RPC outgoing. Track byte length + data structure sizes
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
    rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
    /** Total count of RPC dropped because acceptFrom() == false */
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    // RPC incoming. Track byte length + data structure sizes
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    rpcSentIDontWant: register.gauge({ name: "gossipsub_rpc_sent_idontwant_total", help: "RPC sent" }),
    // publish message. Track peers sent to and bytes
    /** Total count of msg published by topic */
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we publish a msg to */
    msgPublishPeersByTopic: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of peers (by group) that we publish a msg to */
    directPeersPublishedTotal: register.gauge({
      name: "gossipsub_direct_peers_published_total",
      help: "Total direct peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    floodsubPeersPublishedTotal: register.gauge({
      name: "gossipsub_floodsub_peers_published_total",
      help: "Total floodsub peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    meshPeersPublishedTotal: register.gauge({
      name: "gossipsub_mesh_peers_published_total",
      help: "Total mesh peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    fanoutPeersPublishedTotal: register.gauge({
      name: "gossipsub_fanout_peers_published_total",
      help: "Total fanout peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of msg publish data.length bytes */
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    /** Total time in seconds to publish a message */
    msgPublishTime: register.histogram({
      name: "gossipsub_msg_publish_seconds",
      help: "Total time in seconds to publish a message",
      buckets: [1e-3, 2e-3, 5e-3, 0.01, 0.1, 0.5, 1],
      labelNames: ["topic"]
    }),
    /** Total count of msg forwarded by topic */
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we forward a msg to */
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs before any validation */
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs error */
    msgReceivedError: register.gauge({
      name: "gossipsub_msg_received_error_total",
      help: "Total count of recv msgs error",
      labelNames: ["topic"]
    }),
    /** Tracks distribution of recv msgs by duplicate, invalid, valid */
    prevalidationInvalidTotal: register.gauge({
      name: "gossipsub_pre_validation_invalid_total",
      help: "Total count of invalid messages received",
      labelNames: ["topic"]
    }),
    prevalidationValidTotal: register.gauge({
      name: "gossipsub_pre_validation_valid_total",
      help: "Total count of valid messages received",
      labelNames: ["topic"]
    }),
    prevalidationDuplicateTotal: register.gauge({
      name: "gossipsub_pre_validation_duplicate_total",
      help: "Total count of duplicate messages received",
      labelNames: ["topic"]
    }),
    prevalidationUnknownTotal: register.gauge({
      name: "gossipsub_pre_validation_unknown_status_total",
      help: "Total count of unknown_status messages received",
      labelNames: ["topic"]
    }),
    /** Tracks specific reason of invalid */
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["error"]
    }),
    msgReceivedInvalidByTopic: register.gauge({
      name: "gossipsub_msg_received_invalid_by_topic_total",
      help: "Tracks specific invalid message by topic",
      labelNames: ["topic"]
    }),
    /** Track duplicate message delivery time */
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        Number(opts.maxMeshMessageDeliveriesWindowSec),
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    /** Total count of late msg delivery total by topic */
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    duplicateMsgIgnored: register.gauge({
      name: "gossisub_ignored_published_duplicate_msgs_total",
      help: "Total count of published duplicate message ignored by topic",
      labelNames: ["topic"]
    }),
    /* Metrics related to scoring */
    /** Total times score() is called */
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    /** Total times score() call actually computed computeScore(), no cache */
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    /** Current count of peers by score threshold */
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores"
    }),
    /**
     * Separate score weights
     * Need to use 2-label metrics in this case to debug the score weights
     */
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    /** Histogram of the scores for each mesh topic. */
    // TODO: Not implemented
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    /** A counter of the kind of penalties being applied to peers. */
    // TODO: Not fully implemented
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        Number(opts.behaviourPenaltyThreshold),
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    // TODO:
    // - iasked per peer (on heartbeat)
    // - when promise is resolved, track messages from promises
    /** Total received IHAVE messages that we ignore for some reason */
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    /** Total received IHAVE messages by topic */
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    /**
     * Total messages per topic we don't have. Not actual requests.
     * The number of times we have decided that an IWANT control message is required for this
     * topic. A very high metric might indicate an underperforming network.
     * = rust-libp2p `topic_iwant_msgs`
     */
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    /** Total received IWANT messages by topic */
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    /** Total requested messageIDs that we don't have */
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    /** Total received IDONTWANT messages */
    idontwantRcvMsgids: register.gauge({
      name: "gossipsub_idontwant_rcv_msgids_total",
      help: "Total received IDONTWANT messages"
    }),
    /** Total received IDONTWANT messageIDs that we don't have */
    idontwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_idontwant_rcv_dont_have_msgids_total",
      help: "Total received IDONTWANT messageIDs that we do not have in mcache"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    /** Total count of resolved IWANT promises */
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    /** Total count of resolved IWANT promises from duplicate messages */
    iwantPromiseResolvedFromDuplicate: register.gauge({
      name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
      help: "Total count of resolved IWANT promises from duplicate messages"
    }),
    /** Total count of peers we have asked IWANT promises that are resolved */
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantMessagePruned: register.gauge({
      name: "gossipsub_iwant_message_pruned",
      help: "Total count of pruned IWANT messages"
    }),
    /** Histogram of delivery time of resolved IWANT promises */
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        Number(opts.gossipPromiseExpireSec),
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    iwantPromiseUntracked: register.gauge({
      name: "gossip_iwant_promise_untracked",
      help: "Total count of untracked IWANT promise"
    }),
    /** Backoff time */
    connectedPeersBackoffSec: register.histogram({
      name: "gossipsub_connected_peers_backoff_seconds",
      help: "Backoff time in seconds",
      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.
      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.
      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case
      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters
      buckets: [1, 2, 4, 10, 20, 60, 120]
    }),
    /* Data structure sizes */
    /** Unbounded cache sizes */
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    /** Current mcache msg count */
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    mcacheNotValidatedCount: register.gauge({
      name: "gossipsub_mcache_not_validated_count",
      help: "Current mcache msg count not validated"
    }),
    fastMsgIdCacheCollision: register.gauge({
      name: "gossipsub_fastmsgid_cache_collision_total",
      help: "Total count of key collisions on fastmsgid cache put"
    }),
    newConnectionCount: register.gauge({
      name: "gossipsub_new_connection_total",
      help: "Total new connection by status",
      labelNames: ["status"]
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    /** We joined a topic */
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** We left a topic */
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** Register the inclusion of peers in our mesh due to some reason. */
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case InclusionReason.Fanout:
          this.meshPeerInclusionEventsFanout.inc({ topic }, count);
          break;
        case InclusionReason.Random:
          this.meshPeerInclusionEventsRandom.inc({ topic }, count);
          break;
        case InclusionReason.Subscribed:
          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);
          break;
        case InclusionReason.Outbound:
          this.meshPeerInclusionEventsOutbound.inc({ topic }, count);
          break;
        case InclusionReason.NotEnough:
          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);
          break;
        case InclusionReason.Opportunistic:
          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);
          break;
        default:
          this.meshPeerInclusionEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /** Register the removal of peers in our mesh due to some reason */
    // - remove_peer_from_mesh()
    // - heartbeat() Churn::BadScore
    // - heartbeat() Churn::Excess
    // - on_disconnect() Churn::Ds
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case ChurnReason.Dc:
          this.meshPeerChurnEventsDisconnected.inc({ topic }, count);
          break;
        case ChurnReason.BadScore:
          this.meshPeerChurnEventsBadScore.inc({ topic }, count);
          break;
        case ChurnReason.Prune:
          this.meshPeerChurnEventsPrune.inc({ topic }, count);
          break;
        case ChurnReason.Excess:
          this.meshPeerChurnEventsExcess.inc({ topic }, count);
          break;
        default:
          this.meshPeerChurnEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /**
     * Update validation result to metrics
     *
     * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report
     */
    onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {
      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? "hit" : "miss" });
      if (messageRecord != null) {
        const topic = this.toTopic(messageRecord.message.topic);
        switch (acceptance) {
          case TopicValidatorResult.Accept:
            this.acceptedMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Ignore:
            this.ignoredMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Reject:
            this.rejectedMessagesTotal.inc({ topic });
            break;
          default:
            this.unknownValidationResultsTotal.inc({ topic });
            break;
        }
      }
      if (firstSeenTimestampMs != null) {
        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1e3);
      } else {
        this.asyncValidationUnknownFirstSeen.inc();
      }
    },
    /**
     * - in handle_graft() Penalty::GraftBackoff
     * - in apply_iwant_penalties() Penalty::BrokenPromise
     * - in metric_score() P3 Penalty::MessageDeficit
     * - in metric_score() P6 Penalty::IPColocation
     */
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onIdontwantRcv(idontwant, idontwantDonthave) {
      this.idontwantRcvMsgids.inc(idontwant);
      this.idontwantRcvDonthaveMsgids.inc(idontwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);
      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);
      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);
      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);
      this.msgPublishTime.observe({ topic }, ms / 1e3);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvError(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedError.inc({ topic }, 1);
    },
    onPrevalidationResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      switch (status) {
        case MessageStatus.duplicate:
          this.prevalidationDuplicateTotal.inc({ topic });
          break;
        case MessageStatus.invalid:
          this.prevalidationInvalidTotal.inc({ topic });
          break;
        case MessageStatus.valid:
          this.prevalidationValidTotal.inc({ topic });
          break;
        default:
          this.prevalidationUnknownTotal.inc({ topic });
          break;
      }
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ error }, 1);
      this.msgReceivedInvalidByTopic.inc({ topic }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onPublishDuplicateMsg(topicStr) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgIgnored.inc({ topic }, 1);
    },
    onPeerReadStreamError() {
      this.peerReadStreamError.inc(1);
    },
    onRpcRecvError() {
      this.rpcRecvError.inc(1);
    },
    onRpcDataError() {
      this.rpcDataError.inc(1);
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions != null) {
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      }
      if (rpc.messages != null) {
        this.rpcRecvMessage.inc(rpc.messages.length);
      }
      if (rpc.control != null) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave != null) {
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        }
        if (rpc.control.iwant != null) {
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        }
        if (rpc.control.graft != null) {
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        }
        if (rpc.control.prune != null) {
          this.rpcRecvPrune.inc(rpc.control.prune.length);
        }
      }
    },
    onRpcSent(rpc, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions != null) {
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      }
      if (rpc.messages != null) {
        this.rpcSentMessage.inc(rpc.messages.length);
      }
      if (rpc.control != null) {
        const ihave = rpc.control.ihave?.length ?? 0;
        const iwant = rpc.control.iwant?.length ?? 0;
        const graft = rpc.control.graft?.length ?? 0;
        const prune = rpc.control.prune?.length ?? 0;
        const idontwant = rpc.control.idontwant?.length ?? 0;
        if (ihave > 0) {
          this.rpcSentIHave.inc(ihave);
        }
        if (iwant > 0) {
          this.rpcSentIWant.inc(iwant);
        }
        if (graft > 0) {
          this.rpcSentGraft.inc(graft);
        }
        if (prune > 0) {
          this.rpcSentPrune.inc(prune);
        }
        if (idontwant > 0) {
          this.rpcSentIDontWant.inc(idontwant);
        }
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0 || idontwant > 0) {
          this.rpcSentControl.inc(1);
        }
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold) {
          graylist++;
        }
        if (score >= scoreThresholds.publishThreshold) {
          publish++;
        }
        if (score >= scoreThresholds.gossipThreshold) {
          gossip++;
        }
        if (score >= 0) {
          mesh++;
        }
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (peersInMesh == null) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p2) => peersInMesh?.add(p2));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}
class InvalidPeerScoreParamsError extends Error {
  static name = "InvalidPeerScoreParamsError";
  constructor(message2 = "Invalid peer score params") {
    super(message2);
    this.name = "InvalidPeerScoreParamsError";
  }
}
const defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
const defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p2 = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p2,
    topics: p2.topics != null ? Object.entries(p2.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p2 = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p2
  };
}
function validatePeerScoreParams(p2) {
  for (const [topic, params] of Object.entries(p2.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e2) {
      throw new InvalidPeerScoreParamsError(`invalid score parameters for topic ${topic}: ${e2.message}`);
    }
  }
  if (p2.topicScoreCap < 0) {
    throw new InvalidPeerScoreParamsError("invalid topic score cap; must be positive (or 0 for no cap)");
  }
  if (p2.appSpecificScore === null || p2.appSpecificScore === void 0) {
    throw new InvalidPeerScoreParamsError("missing application specific score function");
  }
  if (p2.IPColocationFactorWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");
  }
  if (p2.IPColocationFactorWeight !== 0 && p2.IPColocationFactorThreshold < 1) {
    throw new InvalidPeerScoreParamsError("invalid IPColocationFactorThreshold; must be at least 1");
  }
  if (p2.behaviourPenaltyWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");
  }
  if (p2.behaviourPenaltyWeight !== 0 && (p2.behaviourPenaltyDecay <= 0 || p2.behaviourPenaltyDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyDecay; must be between 0 and 1");
  }
  if (p2.decayInterval < 1e3) {
    throw new InvalidPeerScoreParamsError("invalid DecayInterval; must be at least 1s");
  }
  if (p2.decayToZero <= 0 || p2.decayToZero >= 1) {
    throw new InvalidPeerScoreParamsError("invalid DecayToZero; must be between 0 and 1");
  }
}
function validateTopicScoreParams(p2) {
  if (p2.topicWeight < 0) {
    throw new InvalidPeerScoreParamsError("invalid topic weight; must be >= 0");
  }
  if (p2.timeInMeshQuantum === 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be non zero");
  }
  if (p2.timeInMeshWeight < 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshWeight; must be positive (or 0 to disable)");
  }
  if (p2.timeInMeshWeight !== 0 && p2.timeInMeshQuantum <= 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be positive");
  }
  if (p2.timeInMeshWeight !== 0 && p2.timeInMeshCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshCap; must be positive");
  }
  if (p2.firstMessageDeliveriesWeight < 0) {
    throw new InvalidPeerScoreParamsError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");
  }
  if (p2.firstMessageDeliveriesWeight !== 0 && (p2.firstMessageDeliveriesDecay <= 0 || p2.firstMessageDeliveriesDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");
  }
  if (p2.firstMessageDeliveriesWeight !== 0 && p2.firstMessageDeliveriesCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesCap; must be positive");
  }
  if (p2.meshMessageDeliveriesWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && (p2.meshMessageDeliveriesDecay <= 0 || p2.meshMessageDeliveriesDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesCap; must be positive");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesThreshold <= 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesThreshold; must be positive");
  }
  if (p2.meshMessageDeliveriesWindow < 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWindow; must be non-negative");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesActivation < 1e3) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesActivation; must be at least 1s");
  }
  if (p2.meshFailurePenaltyWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");
  }
  if (p2.meshFailurePenaltyWeight !== 0 && (p2.meshFailurePenaltyDecay <= 0 || p2.meshFailurePenaltyDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyDecay; must be between 0 and 1");
  }
  if (p2.invalidMessageDeliveriesWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");
  }
  if (p2.invalidMessageDeliveriesDecay <= 0 || p2.invalidMessageDeliveriesDecay >= 1) {
    throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1");
  }
}
const defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p2 = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p2
  };
}
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0) {
    return subset;
  }
  for (const id of superSet) {
    if (subset.size >= ineed) {
      break;
    }
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
class MapDef extends Map {
  getDefault;
  constructor(getDefault) {
    super();
    this.getDefault = getDefault;
  }
  getOrDefault(key2) {
    let value2 = super.get(key2);
    if (value2 === void 0) {
      value2 = this.getDefault();
      this.set(key2, value2);
    }
    return value2;
  }
}
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}
function Denque(array, options) {
  var options = options || {};
  this._capacity = options.capacity;
  this._head = 0;
  this._tail = 0;
  if (Array.isArray(array)) {
    this._fromArray(array);
  } else {
    this._capacityMask = 3;
    this._list = new Array(4);
  }
}
Denque.prototype.peekAt = function peekAt(index) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  var len = this.size();
  if (i2 >= len || i2 < -len) return void 0;
  if (i2 < 0) i2 += len;
  i2 = this._head + i2 & this._capacityMask;
  return this._list[i2];
};
Denque.prototype.get = function get(i2) {
  return this.peekAt(i2);
};
Denque.prototype.peek = function peek() {
  if (this._head === this._tail) return void 0;
  return this._list[this._head];
};
Denque.prototype.peekFront = function peekFront() {
  return this.peek();
};
Denque.prototype.peekBack = function peekBack() {
  return this.peekAt(-1);
};
Object.defineProperty(Denque.prototype, "length", {
  get: function length2() {
    return this.size();
  }
});
Denque.prototype.size = function size() {
  if (this._head === this._tail) return 0;
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.unshift = function unshift(item) {
  if (arguments.length === 0) return this.size();
  var len = this._list.length;
  this._head = this._head - 1 + len & this._capacityMask;
  this._list[this._head] = item;
  if (this._tail === this._head) this._growArray();
  if (this._capacity && this.size() > this._capacity) this.pop();
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.shift = function shift() {
  var head = this._head;
  if (head === this._tail) return void 0;
  var item = this._list[head];
  this._list[head] = void 0;
  this._head = head + 1 & this._capacityMask;
  if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
  return item;
};
Denque.prototype.push = function push(item) {
  if (arguments.length === 0) return this.size();
  var tail = this._tail;
  this._list[tail] = item;
  this._tail = tail + 1 & this._capacityMask;
  if (this._tail === this._head) {
    this._growArray();
  }
  if (this._capacity && this.size() > this._capacity) {
    this.shift();
  }
  if (this._head < this._tail) return this._tail - this._head;
  else return this._capacityMask + 1 - (this._head - this._tail);
};
Denque.prototype.pop = function pop() {
  var tail = this._tail;
  if (tail === this._head) return void 0;
  var len = this._list.length;
  this._tail = tail - 1 + len & this._capacityMask;
  var item = this._list[this._tail];
  this._list[this._tail] = void 0;
  if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
  return item;
};
Denque.prototype.removeOne = function removeOne(index) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size2 = this.size();
  var len = this._list.length;
  if (i2 >= size2 || i2 < -size2) return void 0;
  if (i2 < 0) i2 += size2;
  i2 = this._head + i2 & this._capacityMask;
  var item = this._list[i2];
  var k;
  if (index < size2 / 2) {
    for (k = index; k > 0; k--) {
      this._list[i2] = this._list[i2 = i2 - 1 + len & this._capacityMask];
    }
    this._list[i2] = void 0;
    this._head = this._head + 1 + len & this._capacityMask;
  } else {
    for (k = size2 - 1 - index; k > 0; k--) {
      this._list[i2] = this._list[i2 = i2 + 1 + len & this._capacityMask];
    }
    this._list[i2] = void 0;
    this._tail = this._tail - 1 + len & this._capacityMask;
  }
  return item;
};
Denque.prototype.remove = function remove(index, count) {
  var i2 = index;
  var removed;
  var del_count = count;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  if (this._head === this._tail) return void 0;
  var size2 = this.size();
  var len = this._list.length;
  if (i2 >= size2 || i2 < -size2 || count < 1) return void 0;
  if (i2 < 0) i2 += size2;
  if (count === 1 || !count) {
    removed = new Array(1);
    removed[0] = this.removeOne(i2);
    return removed;
  }
  if (i2 === 0 && i2 + count >= size2) {
    removed = this.toArray();
    this.clear();
    return removed;
  }
  if (i2 + count > size2) count = size2 - i2;
  var k;
  removed = new Array(count);
  for (k = 0; k < count; k++) {
    removed[k] = this._list[this._head + i2 + k & this._capacityMask];
  }
  i2 = this._head + i2 & this._capacityMask;
  if (index + count === size2) {
    this._tail = this._tail - count + len & this._capacityMask;
    for (k = count; k > 0; k--) {
      this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (index === 0) {
    this._head = this._head + count + len & this._capacityMask;
    for (k = count - 1; k > 0; k--) {
      this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
    }
    return removed;
  }
  if (i2 < size2 / 2) {
    this._head = this._head + index + count + len & this._capacityMask;
    for (k = index; k > 0; k--) {
      this.unshift(this._list[i2 = i2 - 1 + len & this._capacityMask]);
    }
    i2 = this._head - 1 + len & this._capacityMask;
    while (del_count > 0) {
      this._list[i2 = i2 - 1 + len & this._capacityMask] = void 0;
      del_count--;
    }
    if (index < 0) this._tail = i2;
  } else {
    this._tail = i2;
    i2 = i2 + count + len & this._capacityMask;
    for (k = size2 - (count + index); k > 0; k--) {
      this.push(this._list[i2++]);
    }
    i2 = this._tail;
    while (del_count > 0) {
      this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
      del_count--;
    }
  }
  if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
  return removed;
};
Denque.prototype.splice = function splice(index, count) {
  var i2 = index;
  if (i2 !== (i2 | 0)) {
    return void 0;
  }
  var size2 = this.size();
  if (i2 < 0) i2 += size2;
  if (i2 > size2) return void 0;
  if (arguments.length > 2) {
    var k;
    var temp;
    var removed;
    var arg_len = arguments.length;
    var len = this._list.length;
    var arguments_index = 2;
    if (!size2 || i2 < size2 / 2) {
      temp = new Array(i2);
      for (k = 0; k < i2; k++) {
        temp[k] = this._list[this._head + k & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i2 > 0) {
          this._head = this._head + i2 + len & this._capacityMask;
        }
      } else {
        removed = this.remove(i2, count);
        this._head = this._head + i2 + len & this._capacityMask;
      }
      while (arg_len > arguments_index) {
        this.unshift(arguments[--arg_len]);
      }
      for (k = i2; k > 0; k--) {
        this.unshift(temp[k - 1]);
      }
    } else {
      temp = new Array(size2 - (i2 + count));
      var leng = temp.length;
      for (k = 0; k < leng; k++) {
        temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
      }
      if (count === 0) {
        removed = [];
        if (i2 != size2) {
          this._tail = this._head + i2 + len & this._capacityMask;
        }
      } else {
        removed = this.remove(i2, count);
        this._tail = this._tail - leng + len & this._capacityMask;
      }
      while (arguments_index < arg_len) {
        this.push(arguments[arguments_index++]);
      }
      for (k = 0; k < leng; k++) {
        this.push(temp[k]);
      }
    }
    return removed;
  } else {
    return this.remove(i2, count);
  }
};
Denque.prototype.clear = function clear() {
  this._list = new Array(this._list.length);
  this._head = 0;
  this._tail = 0;
};
Denque.prototype.isEmpty = function isEmpty() {
  return this._head === this._tail;
};
Denque.prototype.toArray = function toArray() {
  return this._copyArray(false);
};
Denque.prototype._fromArray = function _fromArray(array) {
  var length3 = array.length;
  var capacity = this._nextPowerOf2(length3);
  this._list = new Array(capacity);
  this._capacityMask = capacity - 1;
  this._tail = length3;
  for (var i2 = 0; i2 < length3; i2++) this._list[i2] = array[i2];
};
Denque.prototype._copyArray = function _copyArray(fullCopy, size2) {
  var src2 = this._list;
  var capacity = src2.length;
  var length3 = this.length;
  size2 = size2 | length3;
  if (size2 == length3 && this._head < this._tail) {
    return this._list.slice(this._head, this._tail);
  }
  var dest = new Array(size2);
  var k = 0;
  var i2;
  if (fullCopy || this._head > this._tail) {
    for (i2 = this._head; i2 < capacity; i2++) dest[k++] = src2[i2];
    for (i2 = 0; i2 < this._tail; i2++) dest[k++] = src2[i2];
  } else {
    for (i2 = this._head; i2 < this._tail; i2++) dest[k++] = src2[i2];
  }
  return dest;
};
Denque.prototype._growArray = function _growArray() {
  if (this._head != 0) {
    var newList = this._copyArray(true, this._list.length << 1);
    this._tail = this._list.length;
    this._head = 0;
    this._list = newList;
  } else {
    this._tail = this._list.length;
    this._list.length <<= 1;
  }
  this._capacityMask = this._capacityMask << 1 | 1;
};
Denque.prototype._shrinkArray = function _shrinkArray() {
  this._list.length >>>= 1;
  this._capacityMask >>>= 1;
};
Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
  var log2 = Math.log(num) / Math.log(2);
  var nextPow2 = 1 << log2 + 1;
  return Math.max(nextPow2, 4);
};
var denque = Denque;
const Denque$1 = /* @__PURE__ */ getDefaultExportFromCjs(denque);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
class MessageDeliveries {
  records;
  queue;
  constructor() {
    this.records = /* @__PURE__ */ new Map();
    this.queue = new Denque$1();
  }
  getRecord(msgIdStr) {
    return this.records.get(msgIdStr);
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec != null) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeenTsMs: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head != null && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
}
class PeerScore {
  params;
  metrics;
  /**
   * Per-peer stats for score calculation
   */
  peerStats = /* @__PURE__ */ new Map();
  /**
   * IP colocation tracking; maps IP => set of peers.
   */
  peerIPs = new MapDef(() => /* @__PURE__ */ new Set());
  /**
   * Cache score up to decayInterval if topic stats are unchanged.
   */
  scoreCache = /* @__PURE__ */ new Map();
  /**
   * Recent message delivery timing/participants
   */
  deliveryRecords = new MessageDeliveries();
  _backgroundInterval;
  scoreCacheValidityMs;
  computeScore;
  log;
  constructor(params, metrics, componentLogger, opts) {
    this.params = params;
    this.metrics = metrics;
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
    this.log = componentLogger.forComponent("libp2p:gossipsub:score");
  }
  get size() {
    return this.peerStats.size;
  }
  /**
   * Start PeerScore instance
   */
  start() {
    if (this._backgroundInterval != null) {
      this.log("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => {
      this.background();
    }, this.params.decayInterval);
    this.log("started");
  }
  /**
   * Stop PeerScore instance
   */
  stop() {
    if (this._backgroundInterval == null) {
      this.log("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    this.log("stopped");
  }
  /**
   * Periodic maintenance
   */
  background() {
    this.refreshScores();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  messageFirstSeenTimestampMs(msgIdStr) {
    const drec = this.deliveryRecords.getRecord(msgIdStr);
    return drec != null ? drec.firstSeenTsMs : null;
  }
  /**
   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
   */
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPsForPeer(id, pstats.knownIPs);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  /**
   * Return the score for a peer
   */
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (pstats == null) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry != null && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry != null) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  /**
   * Apply a behavioural penalty to a peer
   */
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      knownIPs: /* @__PURE__ */ new Set(),
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
  }
  /** Adds a new IP to a peer, if the peer is not known the update is ignored */
  addIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.knownIPs.add(ip);
    }
    this.peerIPs.getOrDefault(ip).add(id);
  }
  /** Remove peer association with IP */
  removeIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.knownIPs.delete(ip);
    }
    const peersWithIP = this.peerIPs.get(ip);
    if (peersWithIP != null) {
      peersWithIP.delete(id);
      if (peersWithIP.size === 0) {
        this.peerIPs.delete(ip);
      }
    }
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (pstats == null) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPsForPeer(id, pstats.knownIPs);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  /** Handles scoring functionality as a peer GRAFTs to a topic. */
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  /** Handles scoring functionality as a peer PRUNEs from a topic. */
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from2, msgIdStr, topic) {
    this.markFirstMessageDelivery(from2, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from2, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p2) => {
      if (p2 !== from2.toString()) {
        this.markDuplicateMessageDelivery(p2, topic);
      }
    });
  }
  /**
   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
   */
  rejectInvalidMessage(from2, topic) {
    this.markInvalidMessageDelivery(from2, topic);
  }
  rejectMessage(from2, msgIdStr, topic, reason) {
    switch (reason) {
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from2, topic);
        return;
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from2, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from2, topic);
    drec.peers.forEach((p2) => {
      this.markInvalidMessageDelivery(p2, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from2, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from2)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from2);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from2);
        this.markDuplicateMessageDelivery(from2, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from2, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  /**
   * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
   */
  markInvalidMessageDelivery(from2, topic) {
    const pstats = this.peerStats.get(from2);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  /**
   * Increments the "first message deliveries" counter for all scored topics the message is published in,
   * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
   */
  markFirstMessageDelivery(from2, topic) {
    const pstats = this.peerStats.get(from2);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  /**
   * Increments the "mesh message deliveries" counter for messages we've seen before,
   * as long the message was received within the P3 window.
   */
  markDuplicateMessageDelivery(from2, topic, validatedTime) {
    const pstats = this.peerStats.get(from2);
    if (pstats != null) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  /**
   * Removes an IP list from the tracking list for a peer.
   */
  removeIPsForPeer(id, ipsToRemove) {
    for (const ipToRemove of ipsToRemove) {
      const peerSet = this.peerIPs.get(ipToRemove);
      if (peerSet != null) {
        peerSet.delete(id);
        if (peerSet.size === 0) {
          this.peerIPs.delete(ipToRemove);
        }
      }
    }
  }
  /**
   * Returns topic stats if they exist, otherwise if the supplied parameters score the
   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
   */
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
}
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (topicScores == null) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats != null) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (swTopic == null) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}
class OutboundStream {
  rawStream;
  constructor(rawStream, errCallback, opts) {
    this.rawStream = rawStream;
    if (opts.maxBufferSize != null) {
      rawStream.maxWriteBufferLength = opts.maxBufferSize;
    }
    rawStream.addEventListener("close", (evt) => {
      if (evt.error != null) {
        errCallback(evt.error);
      }
    });
  }
  get protocol() {
    return this.rawStream.protocol;
  }
  async push(data) {
    return this.pushPrefixed(encode.single(data));
  }
  /**
   * Same to push() but this is prefixed data so no need to encode length prefixed again
   */
  pushPrefixed(data) {
    this.rawStream.send(data);
  }
  async close(options) {
    await this.rawStream.close(options).catch((err) => {
      this.rawStream.abort(err);
    });
  }
}
class InboundStream {
  source;
  rawStream;
  closeController;
  constructor(rawStream, opts = {}) {
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.closeController.signal.addEventListener("abort", () => {
      rawStream.close().catch((err) => {
        rawStream.abort(err);
      });
    });
    this.source = pipe(this.rawStream, (source) => decode(source, opts));
  }
  async close() {
    this.closeController.abort();
  }
}
class IWantTracer {
  gossipsubIWantFollowupMs;
  msgIdToStrFn;
  metrics;
  /**
   * Promises to deliver a message
   * Map per message id, per peer, promise expiration time
   */
  promises = /* @__PURE__ */ new Map();
  /**
   * First request time by msgId. Used for metrics to track expire times.
   * Necessary to know if peers are actually breaking promises or simply sending them a bit later
   */
  requestMsByMsg = /* @__PURE__ */ new Map();
  requestMsByMsgExpire;
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  /**
   * Track a promise to deliver a message from a list of msgIds we are requesting
   */
  addPromise(from2, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId2 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId2);
    let expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer == null) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from2)) {
      expireByPeer.set(from2, now + this.gossipsubIWantFollowupMs);
      if (this.metrics != null) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  /**
   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
   *
   * This should be called not too often relative to the expire times, since it iterates over the whole data.
   */
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId2) => {
      expireByPeer.forEach((expire, p2) => {
        if (expire < now) {
          result.set(p2, (result.get(p2) ?? 0) + 1);
          expireByPeer.delete(p2);
          brokenPromises++;
        }
      });
      if (expireByPeer.size === 0) {
        this.promises.delete(msgId2);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  /**
   * Someone delivered a message, stop tracking promises for it
   */
  deliverMessage(msgIdStr, isDuplicate = false) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer != null) {
      this.promises.delete(msgIdStr);
      if (this.metrics != null) {
        this.metrics.iwantPromiseResolved.inc(1);
        if (isDuplicate) {
          this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
        }
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  /**
   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
   * unless its an obviously invalid message.
   */
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    let count = 0;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
        count++;
      } else {
        break;
      }
    }
    this.metrics?.iwantMessagePruned.inc(count);
  }
  trackMessage(msgIdStr) {
    if (this.metrics != null) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
}
const SignPrefix = fromString("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toMultihash().bytes,
        data: transformedData,
        seqno: randomBytes(8),
        topic,
        signature: void 0,
        // Exclude signature field for signing
        key: void 0
        // Exclude key field for signing
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsg)]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString$1(rpcMsg.seqno ?? new Uint8Array(0), "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: publicKeyFromProtobuf(rpcMsg.key)
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
    default:
      throw new Error("Unreachable");
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null) {
        return { valid: false, error: ValidateError.SignaturePresent };
      }
      if (msg.seqno != null) {
        return { valid: false, error: ValidateError.SeqnoPresent };
      }
      if (msg.key != null) {
        return { valid: false, error: ValidateError.FromPresent };
      }
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      if (msg.from == null) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let fromPeerId;
      try {
        fromPeerId = peerIdFromMultihash(decode$3(msg.from));
      } catch (e2) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey;
      if (msg.key != null) {
        publicKey = publicKeyFromProtobuf(msg.key);
        if (fromPeerId.publicKey !== void 0 && !publicKey.equals(fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey = fromPeerId.publicKey;
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        // Exclude signature field for signing
        key: void 0
        // Exclude key field for signing
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign)]);
      if (!await publicKey.verify(bytes, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString$1(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: msg.key != null ? publicKeyFromProtobuf(msg.key) : publicKey
        }
      };
    }
    default:
      throw new Error("Unreachable");
  }
}
function createGossipRpc(messages2 = [], control) {
  return {
    subscriptions: [],
    messages: messages2,
    control: control !== void 0 ? {
      graft: control.graft ?? [],
      prune: control.prune ?? [],
      ihave: control.ihave ?? [],
      iwant: control.iwant ?? [],
      idontwant: control.idontwant ?? []
    } : void 0
  };
}
function ensureControl(rpc) {
  if (rpc.control === void 0) {
    rpc.control = {
      graft: [],
      prune: [],
      ihave: [],
      iwant: [],
      idontwant: []
    };
  }
  return rpc;
}
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}
function messageIdToString(msgId2) {
  return toString$1(msgId2, "base64");
}
function getPublishConfigFromPeerId(signaturePolicy, peerId, privateKey) {
  switch (signaturePolicy) {
    case StrictSign: {
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: publicKeyToProtobuf(privateKey.publicKey),
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}
const msgId = (key2, seqno) => {
  const seqnoBytes = fromString(seqno.toString(16).padStart(16, "0"), "base16");
  const keyBytes = publicKeyToProtobuf(key2);
  const msgId2 = new Uint8Array(keyBytes.byteLength + seqnoBytes.length);
  msgId2.set(keyBytes, 0);
  msgId2.set(seqnoBytes, keyBytes.byteLength);
  return msgId2;
};
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null) {
    throw Error("missing seqno field");
  }
  return msgId(msg.from.publicKey ?? msg.key, msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return sha256$2.encode(msg.data);
}
function multiaddrToIPStr(multiaddr2) {
  if (isNetworkAddress(multiaddr2)) {
    const config = getNetConfig(multiaddr2);
    switch (config.type) {
      case "ip4":
      case "ip6":
        return config.host;
    }
  }
  return null;
}
class SimpleTimeCache {
  entries = /* @__PURE__ */ new Map();
  validityMs;
  constructor(opts) {
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  /** Returns true if there was a key collision and the entry is dropped */
  put(key2, value2) {
    if (this.entries.has(key2)) {
      return true;
    }
    this.entries.set(key2, { value: value2, validUntilMs: Date.now() + this.validityMs });
    return false;
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key2) {
    return this.entries.has(key2);
  }
  get(key2) {
    const value2 = this.entries.get(key2);
    return value2 != null && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
}
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
class GossipSub extends TypedEventEmitter {
  /**
   * The signature policy to follow by default
   */
  globalSignaturePolicy;
  protocols = [GossipsubIDv12, GossipsubIDv11, GossipsubIDv10];
  publishConfig;
  dataTransform;
  // State
  peers = /* @__PURE__ */ new Map();
  streamsInbound = /* @__PURE__ */ new Map();
  streamsOutbound = /* @__PURE__ */ new Map();
  /** Ensures outbound streams are created sequentially */
  outboundInflightQueue = pushable({ objectMode: true });
  /** Direct peers */
  direct = /* @__PURE__ */ new Set();
  /** Floodsub peers */
  floodsubPeers = /* @__PURE__ */ new Set();
  /** Cache of seen messages */
  seenCache;
  /**
   * Map of peer id and AcceptRequestWhileListEntry
   */
  acceptFromWhitelist = /* @__PURE__ */ new Map();
  /**
   * Map of topics to which peers are subscribed to
   */
  topics = /* @__PURE__ */ new Map();
  /**
   * List of our subscriptions
   */
  subscriptions = /* @__PURE__ */ new Set();
  /**
   * Map of topic meshes
   * topic => peer id set
   */
  mesh = /* @__PURE__ */ new Map();
  /**
   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership
   * topic => peer id set
   */
  fanout = /* @__PURE__ */ new Map();
  /**
   * Map of last publish time for fanout topics
   * topic => last publish time
   */
  fanoutLastpub = /* @__PURE__ */ new Map();
  /**
   * Map of pending messages to gossip
   * peer id => control messages
   */
  gossip = /* @__PURE__ */ new Map();
  /**
   * Map of control messages
   * peer id => control message
   */
  control = /* @__PURE__ */ new Map();
  /**
   * Number of IHAVEs received from peer in the last heartbeat
   */
  peerhave = /* @__PURE__ */ new Map();
  /** Number of messages we have asked from peer in the last heartbeat */
  iasked = /* @__PURE__ */ new Map();
  /** Prune backoff map */
  backoff = /* @__PURE__ */ new Map();
  /**
   * Connection direction cache, marks peers with outbound connections
   * peer id => direction
   */
  outbound = /* @__PURE__ */ new Map();
  msgIdFn;
  /**
   * A fast message id function used for internal message de-duplication
   */
  fastMsgIdFn;
  msgIdToStrFn;
  /** Maps fast message-id to canonical message-id */
  fastMsgIdCache;
  /**
   * Short term cache for published message ids. This is used for penalizing peers sending
   * our own messages back if the messages are anonymous or use a random author.
   */
  publishedMessageIds;
  /**
   * A message cache that contains the messages for last few heartbeat ticks
   */
  mcache;
  /** Peer score tracking */
  score;
  /**
   * Custom validator function per topic.
   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.
   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the
   * validation result through `Gossipsub.reportValidationResult`
   */
  topicValidators = /* @__PURE__ */ new Map();
  /**
   * Make this protected so child class may want to redirect to its own log.
   */
  log;
  /**
   * Number of heartbeats since the beginning of time
   * This allows us to amortize some resource cleanup -- eg: backoff cleanup
   */
  heartbeatTicks = 0;
  /**
   * Tracks IHAVE/IWANT promises broken by peers
   */
  gossipTracer;
  /**
   * Tracks IDONTWANT messages received by peers in the current heartbeat
   */
  idontwantCounts = /* @__PURE__ */ new Map();
  /**
   * Tracks IDONTWANT messages received by peers and the heartbeat they were received in
   *
   * idontwants are stored for `mcacheLength` heartbeats before being pruned,
   * so this map is bounded by peerCount * idontwantMaxMessages * mcacheLength
   */
  idontwants = /* @__PURE__ */ new Map();
  components;
  directPeerInitial = null;
  static multicodec = GossipsubIDv12;
  // Options
  opts;
  decodeRpcLimits;
  metrics;
  status = { code: GossipStatusCode.stopped };
  maxInboundStreams;
  maxOutboundStreams;
  runOnLimitedConnection;
  allowedTopics;
  heartbeatTimer = null;
  constructor(components, options = {}) {
    super();
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      batchPublish: false,
      tagMeshPeers: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      unsubcribeBackoff: GossipsubUnsubscribeBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      gossipFactor: GossipsubGossipFactor,
      idontwantMinDataSize: GossipsubIdontwantMinDataSize,
      idontwantMaxMessages: GossipsubIdontwantMaxMessages,
      ...options,
      scoreParams: createPeerScoreParams(options.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
    };
    this.components = components;
    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.protocols.push(FloodsubID);
    }
    this.log = components.logger.forComponent(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p2) => p2.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options.msgIdFn != null) {
      this.msgIdFn = options.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
        default:
          throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`);
      }
    }
    if (options.fastMsgIdFn != null) {
      this.fastMsgIdFn = options.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
    this.mcache = options.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options.dataTransform != null) {
      this.dataTransform = options.dataTransform;
    }
    if (options.metricsRegister != null) {
      if (options.metricsTopicStrToLabel == null) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => {
        this.onScrapeMetrics(metrics);
      });
      for (const protocol of this.protocols) {
        metrics.protocolsEnabled.set({ protocol }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options.maxInboundStreams;
    this.maxOutboundStreams = options.maxOutboundStreams;
    this.runOnLimitedConnection = options.runOnLimitedConnection;
    this.allowedTopics = opts.allowedTopics != null ? new Set(opts.allowedTopics) : null;
  }
  [Symbol.toStringTag] = "@chainsafe/libp2p-gossipsub";
  [serviceCapabilities] = [
    "@libp2p/pubsub"
  ];
  [serviceDependencies] = [
    "@libp2p/identify"
  ];
  getPeers() {
    return [...this.peers.values()];
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  // LIFECYCLE METHODS
  /**
   * Mounts the gossipsub protocol onto the libp2p node and sends our
   * our subscriptions to every peer connected
   */
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId, this.components.privateKey);
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe$1(this.outboundInflightQueue, async (source) => {
      for await (const { peerId, connection } of source) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e2) => {
      this.log.error("outbound inflight queue error", e2);
    });
    await Promise.all(this.opts.directPeers.map(async (p2) => {
      await this.components.peerStore.merge(p2.id, {
        multiaddrs: p2.addrs
      });
    }));
    const registrar = this.components.registrar;
    await Promise.all(this.protocols.map(async (protocol) => registrar.handle(protocol, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    })));
    const topology = {
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this),
      notifyOnLimitedConnection: this.runOnLimitedConnection
    };
    const registrarTopologyIds = await Promise.all(this.protocols.map(async (protocol) => registrar.register(protocol, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)));
      }).catch((err) => {
        this.log(err);
      });
    }, GossipsubDirectConnectInitialDelay);
    if (this.opts.tagMeshPeers) {
      this.addEventListener("gossipsub:graft", this.tagMeshPeer);
      this.addEventListener("gossipsub:prune", this.untagMeshPeer);
    }
    this.log("started");
  }
  /**
   * Unmounts the gossipsub protocol and shuts down every connection
   */
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    if (this.opts.tagMeshPeers) {
      this.removeEventListener("gossipsub:graft", this.tagMeshPeer);
      this.removeEventListener("gossipsub:prune", this.untagMeshPeer);
    }
    const registrar = this.components.registrar;
    await Promise.all(this.protocols.map(async (protocol) => registrar.unhandle(protocol)));
    registrarTopologyIds.forEach((id) => {
      registrar.unregister(id);
    });
    this.outboundInflightQueue.end();
    const closePromises = [];
    for (const outboundStream of this.streamsOutbound.values()) {
      closePromises.push(outboundStream.close());
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      closePromises.push(inboundStream.close());
    }
    this.streamsInbound.clear();
    await Promise.all(closePromises);
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer != null) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache != null) {
      this.fastMsgIdCache.clear();
    }
    if (this.directPeerInitial != null) {
      clearTimeout(this.directPeerInitial);
    }
    this.idontwantCounts.clear();
    this.idontwants.clear();
    this.log("stopped");
  }
  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  /**
   * On an inbound stream opened
   */
  onIncomingStream(stream, connection) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.direction, connection.remoteAddr);
    this.createInboundStream(peerId, stream);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  onPeerConnected(peerId, connection) {
    this.metrics?.newConnectionCount.inc({ status: connection.status });
    if (!this.isStarted() || connection.status !== "open") {
      return;
    }
    this.addPeer(peerId, connection.direction, connection.remoteAddr);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.protocols, {
        runOnLimitedConnection: this.runOnLimitedConnection
      }), (e2) => {
        this.log.error("outbound pipe error", e2);
      }, { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream);
      const protocol = stream.protocol;
      if (protocol === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e2) {
      this.log.error("createOutboundStream error", e2);
    }
  }
  createInboundStream(peerId, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close().catch((err) => {
        this.log.error(err);
      });
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => {
      this.log(err);
    });
  }
  /**
   * Add a peer to the router
   */
  addPeer(peerId, direction, addr) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.peers.set(id, peerId);
      this.score.addPeer(id);
      const currentIP = multiaddrToIPStr(addr);
      if (currentIP !== null) {
        this.score.addIP(id, currentIP);
      } else {
        this.log("Added peer has no IP in current address %s %s", id, addr.toString());
      }
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  /**
   * Removes a peer from the router
   */
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream != null) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close().catch((err) => {
      this.log.error(err);
    });
    inboundStream?.close().catch((err) => {
      this.log.error(err);
    });
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id)) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.idontwantCounts.delete(id);
    this.idontwants.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  // API METHODS
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  /**
   * Get a the peer-ids in a topic mesh
   */
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic != null ? Array.from(peersInTopic) : [];
  }
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic != null ? Array.from(peersInTopic) : []).map((str) => this.peers.get(str) ?? peerIdFromString$1(str));
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    return Array.from(this.subscriptions);
  }
  // TODO: Reviewing Pubsub API
  // MESSAGE METHODS
  /**
   * Responsible for processing each RPC message received by other peers.
   */
  async pipePeerReadStream(peerId, stream) {
    try {
      await pipe$1(stream, async (source) => {
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = RPC.decode(rpcBytes, {
              limits: {
                subscriptions: this.decodeRpcLimits.maxSubscriptions,
                messages: this.decodeRpcLimits.maxMessages,
                control$: {
                  ihave: this.decodeRpcLimits.maxIhaveMessageIDs,
                  iwant: this.decodeRpcLimits.maxIwantMessageIDs,
                  graft: this.decodeRpcLimits.maxControlMessages,
                  prune: this.decodeRpcLimits.maxControlMessages,
                  prune$: {
                    peers: this.decodeRpcLimits.maxPeerInfos
                  },
                  idontwant: this.decodeRpcLimits.maxControlMessages,
                  idontwant$: {
                    messageIDs: this.decodeRpcLimits.maxIdontwantMessageIDs
                  }
                }
              }
            });
            this.metrics?.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              try {
                await this.handleReceivedRpc(peerId, rpc);
              } catch (err) {
                this.metrics?.onRpcRecvError();
                this.log(err);
              }
            } else {
              this.handleReceivedRpc(peerId, rpc).catch((err) => {
                this.metrics?.onRpcRecvError();
                this.log(err);
              });
            }
          } catch (e2) {
            this.metrics?.onRpcDataError();
            this.log(e2);
          }
        }
      });
    } catch (err) {
      this.metrics?.onPeerReadStreamError();
      this.handlePeerReadStreamError(err, peerId);
    }
  }
  /**
   * Handle error when read stream pipe throws, less of the functional use but more
   * to for testing purposes to spy on the error handling
   */
  handlePeerReadStreamError(err, peerId) {
    this.log.error(err);
    this.onPeerDisconnected(peerId);
  }
  /**
   * Handles an rpc request from a peer
   */
  async handleReceivedRpc(from2, rpc) {
    if (!this.acceptFrom(from2.toString())) {
      this.log("received message from unacceptable peer %p", from2);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    const subscriptions = rpc.subscriptions != null ? rpc.subscriptions.length : 0;
    const messages2 = rpc.messages != null ? rpc.messages.length : 0;
    let ihave = 0;
    let iwant = 0;
    let graft = 0;
    let prune = 0;
    if (rpc.control != null) {
      if (rpc.control.ihave != null) {
        ihave = rpc.control.ihave.length;
      }
      if (rpc.control.iwant != null) {
        iwant = rpc.control.iwant.length;
      }
      if (rpc.control.graft != null) {
        graft = rpc.control.graft.length;
      }
      if (rpc.control.prune != null) {
        prune = rpc.control.prune.length;
      }
    }
    this.log(`rpc.from ${from2.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
    if (rpc.subscriptions != null && rpc.subscriptions.length > 0) {
      const subscriptions2 = [];
      rpc.subscriptions.forEach((subOpt) => {
        const topic = subOpt.topic;
        const subscribe = subOpt.subscribe === true;
        if (topic != null) {
          if (this.allowedTopics != null && !this.allowedTopics.has(topic)) {
            return;
          }
          this.handleReceivedSubscription(from2, topic, subscribe);
          subscriptions2.push({ topic, subscribe });
        }
      });
      this.safeDispatchEvent("subscription-change", {
        detail: { peerId: from2, subscriptions: subscriptions2 }
      });
    }
    for (const message2 of rpc.messages) {
      if (this.allowedTopics != null && !this.allowedTopics.has(message2.topic)) {
        continue;
      }
      const handleReceivedMessagePromise = this.handleReceivedMessage(from2, message2).catch((err) => {
        this.metrics?.onMsgRecvError(message2.topic);
        this.log(err);
      });
      if (this.opts.awaitRpcMessageHandler) {
        await handleReceivedMessagePromise;
      }
    }
    if (rpc.control != null) {
      await this.handleControlMessage(from2.toString(), rpc.control);
    }
  }
  /**
   * Handles a subscription change from a peer
   */
  handleReceivedSubscription(from2, topic, subscribe) {
    this.log("subscription update from %p topic %s", from2, topic);
    let topicSet = this.topics.get(topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(topic, topicSet);
    }
    if (subscribe) {
      topicSet.add(from2.toString());
    } else {
      topicSet.delete(from2.toString());
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async handleReceivedMessage(from2, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from2, rpcMsg);
    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code);
    const validationCode = validationResult.code;
    switch (validationCode) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from2.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from2.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr != null) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from2.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from2.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.peerId.equals(from2);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from2,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from2.toString());
        }
        break;
      default:
        throw new Error(`Invalid validation result: ${validationCode}`);
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr !== void 0 ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached != null) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform != null) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e2) {
      this.log("Invalid message, transform failed", e2);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const messageId = { msgId: msgId2, msgIdStr };
    if (fastMsgIdStr !== void 0 && this.fastMsgIdCache != null) {
      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
      if (collision) {
        this.metrics?.fastMsgIdCacheCollision.inc();
      }
    }
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    if ((rpcMsg.data?.length ?? 0) >= this.opts.idontwantMinDataSize) {
      this.sendIDontWants(msgId2, rpcMsg.topic, propagationSource.toString());
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(propagationSource, msg);
      } catch (e2) {
        const errCode = e2.code;
        if (errCode === ERR_TOPIC_VALIDATOR_IGNORE) {
          acceptance = TopicValidatorResult.Ignore;
        }
        if (errCode === ERR_TOPIC_VALIDATOR_REJECT) {
          acceptance = TopicValidatorResult.Reject;
        } else {
          acceptance = TopicValidatorResult.Ignore;
        }
      }
      if (acceptance !== TopicValidatorResult.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  /**
   * Return score of a peer.
   */
  getScore(peerId) {
    return this.score.score(peerId);
  }
  /**
   * Send an rpc object to a peer with subscriptions
   */
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe })),
      messages: []
    });
  }
  /**
   * Handles an rpc control message from a peer
   */
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave?.length > 0 ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant?.length > 0 ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft?.length > 0 ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune?.length > 0 && await this.handlePrune(id, controlMsg.prune);
    controlMsg.idontwant?.length > 0 && this.handleIdontwant(id, controlMsg.idontwant);
    if (iwant.length === 0 && ihave.length === 0 && prune.length === 0) {
      return;
    }
    const sent = this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
    const iwantMessageIds = iwant[0]?.messageIDs;
    if (iwantMessageIds != null) {
      if (sent) {
        this.gossipTracer.addPromise(id, iwantMessageIds);
      } else {
        this.metrics?.iwantPromiseUntracked.inc(1);
      }
    }
  }
  /**
   * Whether to accept a message from a peer
   */
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry != null && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  /**
   * Handles IHAVE messages
   */
  handleIHave(id, ihave) {
    if (ihave.length === 0) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (topicID == null || messageIDs == null || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId2);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (iwant.size === 0) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  /**
   * Handles IWANT messages
   * Returns messages to send back to peer
   */
  handleIWant(id, iwant) {
    if (iwant.length === 0) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs?.forEach((msgId2) => {
        const msgIdStr = this.msgIdToStrFn(msgId2);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (ihave.size === 0) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  /**
   * Handles Graft messages
   */
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (topicID == null) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (peersInMesh == null) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      const backoffExpiry = this.backoff.get(topicID)?.get(id);
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
      } else if (typeof backoffExpiry === "number" && now < backoffExpiry) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = backoffExpiry + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
      } else if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
      } else if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
      } else {
        this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
        this.score.graft(id, topicID);
        peersInMesh.add(id);
        this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
      }
      this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
    });
    if (prune.length === 0) {
      return [];
    }
    const onUnsubscribe = false;
    return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));
  }
  /**
   * Handles Prune messages
   */
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (peersInMesh == null) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers != null && peers.length > 0) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
        } else {
          await this.pxConnect(peers);
        }
      }
      this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
    }
  }
  handleIdontwant(id, idontwant) {
    let idontwantCount = this.idontwantCounts.get(id) ?? 0;
    if (idontwantCount >= this.opts.idontwantMaxMessages) {
      return;
    }
    const startIdontwantCount = idontwantCount;
    let idontwants = this.idontwants.get(id);
    if (idontwants == null) {
      idontwants = /* @__PURE__ */ new Map();
      this.idontwants.set(id, idontwants);
    }
    let idonthave = 0;
    out: for (const { messageIDs } of idontwant) {
      for (const msgId2 of messageIDs) {
        if (idontwantCount >= this.opts.idontwantMaxMessages) {
          break out;
        }
        idontwantCount++;
        const msgIdStr = this.msgIdToStrFn(msgId2);
        idontwants.set(msgIdStr, this.heartbeatTicks);
        if (!this.mcache.msgs.has(msgIdStr)) {
          idonthave++;
        }
      }
    }
    this.idontwantCounts.set(id, idontwantCount);
    const total = idontwantCount - startIdontwantCount;
    this.metrics?.onIdontwantRcv(total, idonthave);
  }
  /**
   * Add standard backoff log for a peer in a topic
   */
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  /**
   * Add backoff expiry interval for a peer in a topic
   *
   * @param id
   * @param topic
   * @param intervalMs - backoff duration in milliseconds
   */
  doAddBackoff(id, topic, intervalMs) {
    let backoff = this.backoff.get(topic);
    if (backoff == null) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + intervalMs;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  /**
   * Apply penalties from broken IHAVE/IWANT promises
   */
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p2) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p2, count);
      this.score.addPenalty(p2, count, ScorePenalty.BrokenPromise);
    });
  }
  /**
   * Clear expired backoff expiries
   */
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  /**
   * Maybe reconnect to direct peers
   */
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => this.connect(id)));
  }
  /**
   * Maybe attempt connection given signed peer records
   */
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (pi.peerID == null) {
        return;
      }
      const peer = peerIdFromMultihash(decode$3(pi.peerID));
      const p2 = peer.toString();
      if (this.peers.has(p2)) {
        return;
      }
      if (pi.signedPeerRecord == null) {
        toconnect.push(p2);
        return;
      }
      try {
        if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, {
          expectedPeer: peer
        })) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p2);
      } catch (e2) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (toconnect.length === 0) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => this.connect(id)));
  }
  /**
   * Connect to a peer using the gossipsub protocol
   */
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString$1(id);
    const connection = await this.components.connectionManager.openConnection(peerId);
    for (const protocol of this.protocols) {
      for (const topology of this.components.registrar.getTopologies(protocol)) {
        topology.onConnect?.(peerId, connection);
      }
    }
  }
  /**
   * Subscribes to a topic
   */
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  /**
   * Unsubscribe to a topic
   */
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic);
  }
  /**
   * Join topic
   */
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const backoff = this.backoff.get(topic);
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers != null) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
        // filter direct peers and peers with negative score
        !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true
      ));
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  /**
   * Leave topic
   */
  leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers != null) {
      Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        await this.sendPrune(id, topic);
      })).catch((err) => {
        this.log("Error sending prunes to mesh peers", err);
      });
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic != null) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers != null && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic != null) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers != null && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
          if (meshPeers.size < this.opts.D) {
            const topicPeers = this.getRandomGossipPeers(topic, this.opts.D - meshPeers.size, (id) => {
              return !meshPeers.has(id) && !this.direct.has(id) && !this.floodsubPeers.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            topicPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.mesh++;
            });
          }
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers != null && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  /**
   * Forwards a message from our peers.
   *
   * For messages published by us (the app layer), this class uses `publish`
   */
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource != null) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    tosend.forEach((id) => {
      this.sendRpc(id, createGossipRpc([rawMsg]));
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  /**
   * App layer publishes a message to peers, return number of peers this message is published to
   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
   *
   * For messages not from us, this class uses `forwardMessage`.
   */
  async publish(topic, data, opts) {
    const startMs = Date.now();
    const transformedData = this.dataTransform != null ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId2 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId2);
    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;
    if (this.seenCache.has(msgIdStr)) {
      if (ignoreDuplicatePublishError) {
        this.metrics?.onPublishDuplicateMsg(topic);
        return { recipients: [] };
      }
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic);
    const allowPublishToZeroTopicPeers = opts?.allowPublishToZeroTopicPeers ?? this.opts.allowPublishToZeroTopicPeers;
    if (tosend.size === 0 && !allowPublishToZeroTopicPeers && !willSendToSelf) {
      throw Error("PublishError.NoPeersSubscribedToTopic");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
    this.gossipTracer.deliverMessage(msgIdStr);
    this.publishedMessageIds.put(msgIdStr);
    const batchPublish = opts?.batchPublish ?? this.opts.batchPublish;
    const rpc = createGossipRpc([rawMsg]);
    if (batchPublish) {
      this.sendRpcInBatch(tosend, rpc);
    } else {
      for (const id of tosend) {
        const sent = this.sendRpc(id, rpc);
        if (!sent) {
          tosend.delete(id);
        }
      }
    }
    const durationMs = Date.now() - startMs;
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);
    if (willSendToSelf) {
      tosend.add(this.components.peerId.toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.peerId,
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => this.peers.get(str) ?? peerIdFromString$1(str))
    };
  }
  /**
   * Send the same data in batch to tosend list without considering cached control messages
   * This is not only faster but also avoid allocating memory for each peer
   * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344
   */
  sendRpcInBatch(tosend, rpc) {
    const rpcBytes = RPC.encode(rpc);
    const prefixedData = encode.single(rpcBytes);
    for (const id of tosend) {
      const outboundStream = this.streamsOutbound.get(id);
      if (outboundStream == null) {
        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
        tosend.delete(id);
        continue;
      }
      try {
        outboundStream.pushPrefixed(prefixedData);
      } catch (e2) {
        tosend.delete(id);
        this.log.error(`Cannot send rpc to ${id}`, e2);
      }
      this.metrics?.onRpcSent(rpc, rpcBytes.length);
    }
  }
  /**
   * This function should be called when `asyncValidation` is `true` after
   * the message got validated by the caller. Messages are stored in the `mcache` and
   * validation is expected to be fast enough that the messages should still exist in the cache.
   * There are three possible validation outcomes and the outcome is given in acceptance.
   *
   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
   * network. The `propagation_source` parameter indicates who the message was received by and
   * will not be forwarded back to that peer.
   *
   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
   * and the P₄ penalty will be applied to the `propagationSource`.
   *
   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
   * but no P₄ penalty will be applied.
   *
   * This function will return true if the message was found in the cache and false if was not
   * in the cache anymore.
   *
   * This should only be called once per message.
   */
  reportMessageValidationResult(msgId2, propagationSource, acceptance) {
    let cacheEntry;
    if (acceptance === TopicValidatorResult.Accept) {
      cacheEntry = this.mcache.validate(msgId2);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource, msgId2, rawMsg.topic);
        this.forwardMessage(msgId2, cacheEntry.message, propagationSource, originatingPeers);
      }
    } else {
      cacheEntry = this.mcache.remove(msgId2);
      if (cacheEntry != null) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource, msgId2, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
        }
      }
    }
    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId2);
    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);
  }
  /**
   * Sends a GRAFT message to a peer
   */
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    const out = createGossipRpc([], { graft });
    this.sendRpc(id, out);
  }
  /**
   * Sends a PRUNE message to a peer
   */
  async sendPrune(id, topic) {
    const onUnsubscribe = true;
    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];
    const out = createGossipRpc([], { prune });
    this.sendRpc(id, out);
  }
  sendIDontWants(msgId2, topic, source) {
    const ids = this.mesh.get(topic);
    if (ids == null) {
      return;
    }
    const tosend = new Set(ids);
    tosend.delete(source);
    for (const id of tosend) {
      if (this.streamsOutbound.get(id)?.protocol !== GossipsubIDv12) {
        tosend.delete(id);
      }
    }
    const idontwantRpc = createGossipRpc([], { idontwant: [{ messageIDs: [msgId2] }] });
    this.sendRpcInBatch(tosend, idontwantRpc);
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(id, rpc) {
    const outboundStream = this.streamsOutbound.get(id);
    if (outboundStream == null) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl != null) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave != null) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc);
    try {
      outboundStream.push(rpcBytes);
    } catch (e2) {
      this.log.error(`Cannot send rpc to ${id}`, e2);
      if (ctrl != null) {
        this.control.set(id, ctrl);
      }
      if (ihave != null) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc, rpcBytes.length);
    if (rpc.control?.graft != null) {
      for (const topic of rpc.control?.graft) {
        if (topic.topicID != null) {
          this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
        }
      }
    }
    if (rpc.control?.prune != null) {
      for (const topic of rpc.control?.prune) {
        if (topic.topicID != null) {
          this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
        }
      }
    }
    return true;
  }
  /** Mutates `outRpc` adding graft and prune control messages */
  piggybackControl(id, outRpc, ctrl) {
    const rpc = ensureControl(outRpc);
    for (const graft of ctrl.graft) {
      if (graft.topicID != null && (this.mesh.get(graft.topicID)?.has(id) ?? false)) {
        rpc.control.graft.push(graft);
      }
    }
    for (const prune of ctrl.prune) {
      if (prune.topicID != null && !(this.mesh.get(prune.topicID)?.has(id) ?? false)) {
        rpc.control.prune.push(prune);
      }
    }
  }
  /** Mutates `outRpc` adding ihave control messages */
  piggybackGossip(id, outRpc, ihave) {
    const rpc = ensureControl(outRpc);
    rpc.control.ihave = ihave;
  }
  /**
   * Send graft and prune messages
   *
   * @param tograft - peer id => topic[]
   * @param toprune - peer id => topic[]
   */
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    const onUnsubscribe = false;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning != null) {
        prune = await Promise.all(pruning.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
        toprune.delete(id);
      }
      this.sendRpc(id, createGossipRpc([], { graft, prune }));
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
      this.sendRpc(id, createGossipRpc([], { prune }));
    }
  }
  /**
   * Emits gossip - Send IHAVE messages to a random set of gossip peers
   */
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  /**
   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
   * We also exclude direct peers, as there is no reason to emit gossip to them
   *
   * @param topic
   * @param candidateToGossip - peers to gossip
   * @param messageIDs - message ids to gossip
   */
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (messageIDs.length === 0) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (candidateToGossip.size === 0) {
      return;
    }
    let target = this.opts.Dlazy;
    const gossipFactor = this.opts.gossipFactor;
    const factor = gossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  /**
   * Flush gossip and control messages
   */
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { ihave }));
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      const out = createGossipRpc([], { graft: control.graft, prune: control.prune });
      this.sendRpc(peer, out);
    }
  }
  /**
   * Adds new IHAVE messages to pending gossip
   */
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) ?? [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  /**
   * Make a PRUNE control message for a peer in a topic
   */
  async makePrune(id, topic, doPX, onUnsubscribe) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id)?.protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;
    const backoff = backoffMs / 1e3;
    this.doAddBackoff(id, topic, backoffMs);
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = this.peers.get(peerId) ?? peerIdFromString$1(peerId);
      let peerInfo;
      try {
        peerInfo = await this.components.peerStore.get(id2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      return {
        peerID: id2.toMultihash().bytes,
        signedPeerRecord: peerInfo?.peerRecordEnvelope
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  runHeartbeat = () => {
    const timer = this.metrics?.heartbeatDuration.startTimer();
    this.heartbeat().catch((err) => {
      this.log("Error running heartbeat", err);
    }).finally(() => {
      if (timer != null) {
        timer();
      }
      if (this.status.code === GossipStatusCode.started) {
        clearTimeout(this.status.heartbeatTimeout);
        let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
        if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
          msToNextHeartbeat += this.opts.heartbeatInterval;
          this.metrics?.heartbeatSkipped.inc();
        }
        this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
      }
    });
  };
  /**
   * Maintains the mesh and fanout maps in gossipsub.
   */
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s2 = scores.get(id);
      if (s2 === void 0) {
        s2 = this.score.score(id);
        scores.set(id, s2);
      }
      return s2;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    this.idontwantCounts.clear();
    for (const idontwants of this.idontwants.values()) {
      for (const [msgId2, heartbeatTick] of idontwants) {
        if (this.heartbeatTicks - heartbeatTick >= this.opts.mcacheLength) {
          idontwants.delete(msgId2);
        }
      }
    }
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic != null) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams != null && this.protocols.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (backoff?.has(id) !== true && score >= 0) {
              candidateMeshPeers.add(id);
            }
            if (score >= this.opts.scoreThresholds.gossipThreshold) {
              peersToGossip.add(id);
            }
          }
        }
      }
      const prunePeer = (id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) {
          peersToGossip.add(id);
        }
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (topics == null) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (topics == null) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p2) => {
          graftPeer(p2, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a2, b) => getScore(b) - getScore(a2));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p2) => {
          if (this.outbound.get(p2) ?? false) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i2) => {
            const p2 = peersArray[i2];
            for (let j = i2; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p2;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i2 = 1; i2 < D && ihave > 0; i2++) {
              if (this.outbound.get(peersArray[i2]) ?? false) {
                rotate(i2);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i2 = D; i2 < peersArray.length && ineed > 0; i2++) {
            if (this.outbound.get(peersArray[i2]) ?? false) {
              rotate(i2);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p2) => {
          prunePeer(p2, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p2) => {
          if (this.outbound.get(p2) ?? false) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p2) => {
            graftPeer(p2, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a2, b) => getScore(a2) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!(topicPeers?.has(id) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic != null) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams != null && this.protocols.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold) {
              candidateFanoutPeers.push(id);
            }
            if (score >= this.opts.scoreThresholds.gossipThreshold) {
              peersToGossip.add(id);
            }
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  /**
   * Given a topic, returns up to count peers subscribed to that topic
   * that pass an optional filter function
   *
   * @param topic
   * @param count
   * @param filter - a function to filter acceptable peers
   */
  getRandomGossipPeers(topic, count, filter2 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic == null) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (peerStreams == null) {
        return;
      }
      if (this.protocols.includes(peerStreams.protocol) && filter2(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    const now = Date.now();
    metrics.connectedPeersBackoffSec.reset();
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
      for (const [peer, expiredMs] of backoff.entries()) {
        if (this.peers.has(peer)) {
          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1e3);
        }
      }
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    let idontwantsCount = 0;
    for (const idontwant of this.idontwants.values()) {
      idontwantsCount += idontwant.size;
    }
    metrics.cacheSize.set({ cache: "idontwants" }, idontwantsCount);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
  tagMeshPeer = (evt) => {
    const { peerId, topic } = evt.detail;
    this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString$1(peerId), {
      tags: {
        [topic]: {
          value: 100
        }
      }
    }).catch((err) => {
      this.log.error("Error tagging peer %s with topic %s", peerId, topic, err);
    });
  };
  untagMeshPeer = (evt) => {
    const { peerId, topic } = evt.detail;
    this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString$1(peerId), {
      tags: {
        [topic]: void 0
      }
    }).catch((err) => {
      this.log.error("Error untagging peer %s with topic %s", peerId, topic, err);
    });
  };
}
const StrictSign = "StrictSign";
const StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
function gossipsub(init3 = {}) {
  return (components) => new GossipSub(components, init3);
}
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length3, opts = {}) => {
        const obj = {
          publicKey: alloc$1(0),
          addrs: []
        };
        const end = length3 == null ? reader.len : reader.pos + length3;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
const TOPIC = "_peer-discovery._p2p._pubsub";
class PubSubPeerDiscovery extends TypedEventEmitter {
  [peerDiscoverySymbol] = true;
  [Symbol.toStringTag] = "@libp2p/pubsub-peer-discovery";
  interval;
  listenOnly;
  topics;
  intervalId;
  components;
  log;
  constructor(components, init3 = {}) {
    super();
    const { interval, topics, listenOnly } = init3;
    this.components = components;
    this.interval = interval ?? 1e4;
    this.listenOnly = listenOnly ?? false;
    this.log = components.logger.forComponent("libp2p:discovery:pubsub");
    if (Array.isArray(topics) && topics.length > 0) {
      this.topics = topics;
    } else {
      this.topics = [TOPIC];
    }
    this._onMessage = this._onMessage.bind(this);
  }
  isStarted() {
    return this.intervalId != null;
  }
  start() {
  }
  /**
   * Subscribes to the discovery topic on `libp2p.pubsub` and performs a broadcast
   * immediately, and every `this.interval`
   */
  afterStart() {
    if (this.intervalId != null) {
      return;
    }
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.subscribe(topic);
      pubsub.addEventListener("message", this._onMessage);
    }
    if (this.listenOnly) {
      return;
    }
    this._broadcast();
    this.intervalId = setInterval(() => {
      this._broadcast();
    }, this.interval);
  }
  beforeStop() {
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.unsubscribe(topic);
      pubsub.removeEventListener("message", this._onMessage);
    }
  }
  /**
   * Unsubscribes from the discovery topic
   */
  stop() {
    if (this.intervalId != null) {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    }
  }
  /**
   * Performs a broadcast via Pubsub publish
   */
  _broadcast() {
    const peerId = this.components.peerId;
    if (peerId.publicKey == null) {
      throw new Error("PeerId was missing public key");
    }
    const peer = {
      publicKey: publicKeyToProtobuf(peerId.publicKey),
      addrs: this.components.addressManager.getAddresses().map((ma) => ma.bytes)
    };
    const encodedPeer = Peer.encode(peer);
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      if (pubsub.getSubscribers(topic).length === 0) {
        this.log("skipping broadcasting our peer data on topic %s because there are no peers present", topic);
        continue;
      }
      this.log("broadcasting our peer data on topic %s", topic);
      void pubsub.publish(topic, encodedPeer);
    }
  }
  /**
   * Handles incoming pubsub messages for our discovery topic
   */
  _onMessage(event) {
    if (!this.isStarted()) {
      return;
    }
    const message2 = event.detail;
    if (!this.topics.includes(message2.topic)) {
      return;
    }
    try {
      const peer = Peer.decode(message2.data);
      const publicKey = publicKeyFromProtobuf(peer.publicKey);
      const peerId = peerIdFromPublicKey(publicKey);
      if (peerId.equals(this.components.peerId)) {
        return;
      }
      this.log("discovered peer %p on %s", peerId, message2.topic);
      this.safeDispatchEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: peer.addrs.map((b) => multiaddr(b))
        }
      });
    } catch (err) {
      this.log.error("error handling incoming message", err);
    }
  }
}
function pubsubPeerDiscovery(init3 = {}) {
  return (components) => new PubSubPeerDiscovery(components, init3);
}
var cryptoJs = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core.exports;
  hasRequiredCore = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require$$0$1;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash3 = this._doFinalize();
            return hash3;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message2, cfg) {
              return new hasher.init(cfg).finalize(message2);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message2, key2) {
              return new C_algo.HMAC.init(hasher, key2).finalize(message2);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  })(core);
  return core.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core) return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        C_x64.Word = Base2.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i2 = 0; i2 < x64WordsLength; i2++) {
              var x64Word = x64Words[i2];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i2 = 0; i2 < wordsLength; i2++) {
              words[i2] = words[i2].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays) return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
              words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16) return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 2) {
              var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i2 = 0; i2 < utf16StrLength; i2++) {
              words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64) return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url) return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2 += 3) {
              var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
              var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i2 = 0; i2 < base64StrLength; i2++) {
            if (i2 % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5.exports;
  hasRequiredMd5 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 64; i2++) {
            T[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher2.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a2 = H[0];
            var b = H[1];
            var c2 = H[2];
            var d2 = H[3];
            a2 = FF(a2, b, c2, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a2, b, c2, M_offset_1, 12, T[1]);
            c2 = FF(c2, d2, a2, b, M_offset_2, 17, T[2]);
            b = FF(b, c2, d2, a2, M_offset_3, 22, T[3]);
            a2 = FF(a2, b, c2, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a2, b, c2, M_offset_5, 12, T[5]);
            c2 = FF(c2, d2, a2, b, M_offset_6, 17, T[6]);
            b = FF(b, c2, d2, a2, M_offset_7, 22, T[7]);
            a2 = FF(a2, b, c2, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a2, b, c2, M_offset_9, 12, T[9]);
            c2 = FF(c2, d2, a2, b, M_offset_10, 17, T[10]);
            b = FF(b, c2, d2, a2, M_offset_11, 22, T[11]);
            a2 = FF(a2, b, c2, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a2, b, c2, M_offset_13, 12, T[13]);
            c2 = FF(c2, d2, a2, b, M_offset_14, 17, T[14]);
            b = FF(b, c2, d2, a2, M_offset_15, 22, T[15]);
            a2 = GG(a2, b, c2, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a2, b, c2, M_offset_6, 9, T[17]);
            c2 = GG(c2, d2, a2, b, M_offset_11, 14, T[18]);
            b = GG(b, c2, d2, a2, M_offset_0, 20, T[19]);
            a2 = GG(a2, b, c2, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a2, b, c2, M_offset_10, 9, T[21]);
            c2 = GG(c2, d2, a2, b, M_offset_15, 14, T[22]);
            b = GG(b, c2, d2, a2, M_offset_4, 20, T[23]);
            a2 = GG(a2, b, c2, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a2, b, c2, M_offset_14, 9, T[25]);
            c2 = GG(c2, d2, a2, b, M_offset_3, 14, T[26]);
            b = GG(b, c2, d2, a2, M_offset_8, 20, T[27]);
            a2 = GG(a2, b, c2, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a2, b, c2, M_offset_2, 9, T[29]);
            c2 = GG(c2, d2, a2, b, M_offset_7, 14, T[30]);
            b = GG(b, c2, d2, a2, M_offset_12, 20, T[31]);
            a2 = HH(a2, b, c2, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a2, b, c2, M_offset_8, 11, T[33]);
            c2 = HH(c2, d2, a2, b, M_offset_11, 16, T[34]);
            b = HH(b, c2, d2, a2, M_offset_14, 23, T[35]);
            a2 = HH(a2, b, c2, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a2, b, c2, M_offset_4, 11, T[37]);
            c2 = HH(c2, d2, a2, b, M_offset_7, 16, T[38]);
            b = HH(b, c2, d2, a2, M_offset_10, 23, T[39]);
            a2 = HH(a2, b, c2, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a2, b, c2, M_offset_0, 11, T[41]);
            c2 = HH(c2, d2, a2, b, M_offset_3, 16, T[42]);
            b = HH(b, c2, d2, a2, M_offset_6, 23, T[43]);
            a2 = HH(a2, b, c2, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a2, b, c2, M_offset_12, 11, T[45]);
            c2 = HH(c2, d2, a2, b, M_offset_15, 16, T[46]);
            b = HH(b, c2, d2, a2, M_offset_2, 23, T[47]);
            a2 = II(a2, b, c2, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a2, b, c2, M_offset_7, 10, T[49]);
            c2 = II(c2, d2, a2, b, M_offset_14, 15, T[50]);
            b = II(b, c2, d2, a2, M_offset_5, 21, T[51]);
            a2 = II(a2, b, c2, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a2, b, c2, M_offset_3, 10, T[53]);
            c2 = II(c2, d2, a2, b, M_offset_10, 15, T[54]);
            b = II(b, c2, d2, a2, M_offset_1, 21, T[55]);
            a2 = II(a2, b, c2, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a2, b, c2, M_offset_15, 10, T[57]);
            c2 = II(c2, d2, a2, b, M_offset_6, 15, T[58]);
            b = II(b, c2, d2, a2, M_offset_13, 21, T[59]);
            a2 = II(a2, b, c2, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a2, b, c2, M_offset_11, 10, T[61]);
            c2 = II(c2, d2, a2, b, M_offset_2, 15, T[62]);
            b = II(b, c2, d2, a2, M_offset_9, 21, T[63]);
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash3 = this._hash;
            var H = hash3.words;
            for (var i2 = 0; i2 < 4; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash3;
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a2, b, c2, d2, x, s2, t2) {
          var n2 = a2 + (b & c2 | ~b & d2) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function GG(a2, b, c2, d2, x, s2, t2) {
          var n2 = a2 + (b & d2 | c2 & ~d2) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function HH(a2, b, c2, d2, x, s2, t2) {
          var n2 = a2 + (b ^ c2 ^ d2) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        function II(a2, b, c2, d2, x, s2, t2) {
          var n2 = a2 + (c2 ^ (b | ~d2)) + x + t2;
          return (n2 << s2 | n2 >>> 32 - s2) + b;
        }
        C.MD5 = Hasher2._createHelper(MD5);
        C.HmacMD5 = Hasher2._createHmacHelper(MD5);
      })(Math);
      return CryptoJS2.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA12 = C_algo.SHA1 = Hasher2.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a2 = H[0];
            var b = H[1];
            var c2 = H[2];
            var d2 = H[3];
            var e2 = H[4];
            for (var i2 = 0; i2 < 80; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                W[i2] = n2 << 1 | n2 >>> 31;
              }
              var t2 = (a2 << 5 | a2 >>> 27) + e2 + W[i2];
              if (i2 < 20) {
                t2 += (b & c2 | ~b & d2) + 1518500249;
              } else if (i2 < 40) {
                t2 += (b ^ c2 ^ d2) + 1859775393;
              } else if (i2 < 60) {
                t2 += (b & c2 | b & d2 | c2 & d2) - 1894007588;
              } else {
                t2 += (b ^ c2 ^ d2) - 899497514;
              }
              e2 = d2;
              d2 = c2;
              c2 = b << 30 | b >>> 2;
              b = a2;
              a2 = t2;
            }
            H[0] = H[0] + a2 | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c2 | 0;
            H[3] = H[3] + d2 | 0;
            H[4] = H[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher2._createHelper(SHA12);
        C.HmacSHA1 = Hasher2._createHmacHelper(SHA12);
      })();
      return CryptoJS2.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha256 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256.exports;
  hasRequiredSha256 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K2 = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K2[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W = [];
        var SHA2562 = C_algo.SHA256 = Hasher2.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e2 = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e2 & f2 ^ ~e2 & g;
              var maj = a2 & b ^ a2 & c2 ^ b & c2;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h + sigma1 + ch + K2[i2] + W[i2];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e2;
              e2 = d2 + t1 | 0;
              d2 = c2;
              c2 = b;
              b = a2;
              a2 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e2 | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher2._createHelper(SHA2562);
        C.HmacSHA256 = Hasher2._createHmacHelper(SHA2562);
      })(Math);
      return CryptoJS2.SHA256;
    });
  })(sha256);
  return sha256.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA2562 = C_algo.SHA256;
        var SHA2242 = C_algo.SHA224 = SHA2562.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash3 = SHA2562._doFinalize.call(this);
            hash3.sigBytes -= 4;
            return hash3;
          }
        });
        C.SHA224 = SHA2562._createHelper(SHA2242);
        C.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
      })();
      return CryptoJS2.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher2 = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K2 = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i2 = 0; i2 < 80; i2++) {
            W[i2] = X64Word_create();
          }
        })();
        var SHA5122 = C_algo.SHA512 = Hasher2.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i2 = 0; i2 < 80; i2++) {
              var Wil;
              var Wih;
              var Wi = W[i2];
              if (i2 < 16) {
                Wih = Wi.high = M[offset + i2 * 2] | 0;
                Wil = Wi.low = M[offset + i2 * 2 + 1] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i2 - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i2 - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i2 - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K2[i2];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash3 = this._hash.toX32();
            return hash3;
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher2._createHelper(SHA5122);
        C.HmacSHA512 = Hasher2._createHmacHelper(SHA5122);
      })();
      return CryptoJS2.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA5122 = C_algo.SHA512;
        var SHA3842 = C_algo.SHA384 = SHA5122.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash3 = SHA5122._doFinalize.call(this);
            hash3.sigBytes -= 16;
            return hash3;
          }
        });
        C.SHA384 = SHA5122._createHelper(SHA3842);
        C.HmacSHA384 = SHA5122._createHmacHelper(SHA3842);
      })();
      return CryptoJS2.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3$1 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3$1.exports;
  hasRequiredSha3 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x + 5 * y] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i2 = 0; i2 < 24; i2++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i2 = 0; i2 < 25; i2++) {
            T[i2] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher2.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher2.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
              var M2i = M[offset + 2 * i2];
              var M2i1 = M[offset + 2 * i2 + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i2];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i2 = 0; i2 < outputLengthLanes; i2++) {
              var lane = state[i2];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i2 = 0; i2 < 25; i2++) {
              state[i2] = state[i2].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher2._createHelper(SHA3);
        C.HmacSHA3 = Hasher2._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  })(sha3$1);
  return sha3$1.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher2 = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD1602 = C_algo.RIPEMD160 = Hasher2.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al + M[offset + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl2(t2, sl[i2]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl2(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M[offset + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl2(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl2(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash3 = this._hash;
            var H = hash3.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash3;
          },
          clone: function() {
            var clone = Hasher2.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl2(x, n2) {
          return x << n2 | x >>> 32 - n2;
        }
        C.RIPEMD160 = Hasher2._createHelper(RIPEMD1602);
        C.HmacRIPEMD160 = Hasher2._createHmacHelper(RIPEMD1602);
      })();
      return CryptoJS2.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac$1 = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac$1.exports;
  hasRequiredHmac = 1;
  (function(module2, exports) {
    (function(root, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        C_algo.HMAC = Base2.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key2) {
            hasher = this._hasher = new hasher.init();
            if (typeof key2 == "string") {
              key2 = Utf8.parse(key2);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key2.sigBytes > hasherBlockSizeBytes) {
              key2 = hasher.finalize(key2);
            }
            key2.clamp();
            var oKey = this._oKey = key2.clone();
            var iKey = this._iKey = key2.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i2 = 0; i2 < hasherBlockSize; i2++) {
              oKeyWords[i2] ^= 1549556828;
              iKeyWords[i2] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac3 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac3;
          }
        });
      })();
    });
  })(hmac$1);
  return hmac$1.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha256(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA2562 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: SHA2562,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac3 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac3.update(salt).finalize(blockIndex);
              hmac3.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i2 = 1; i2 < iterations; i2++) {
                intermediate = hmac3.finalize(intermediate);
                hmac3.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf) return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base2.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i2 = 1; i2 < iterations; i2++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore) return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base2 = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base2.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key2, cfg) {
            return this.create(this._ENC_XFORM_MODE, key2, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key2, cfg) {
            return this.create(this._DEC_XFORM_MODE, key2, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key2, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key2;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key2) {
              if (typeof key2 == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message2, key2, cfg) {
                  return selectCipherStrategy(key2).encrypt(cipher, message2, key2, cfg);
                },
                decrypt: function(ciphertext, key2, cfg) {
                  return selectCipherStrategy(key2).decrypt(cipher, ciphertext, key2, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base2.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= block[i2];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base2.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base2.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base2.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message2, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key2, cfg);
            var ciphertext = encryptor.finalize(message2);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key: key2,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key2, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key2, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format2) {
            if (typeof ciphertext == "string") {
              return format2.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key2 = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key2 = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key2.words.slice(keySize), ivSize * 4);
            key2.sigBytes = keySize * 4;
            return CipherParams.create({ key: key2, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message2, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message2, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb) return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i2 = 0; i2 < blockSize; i2++) {
            words[offset + i2] ^= keystream[i2];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr) return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman) return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb) return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb) return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923) return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126) return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971) return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS2.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding) return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i2 = data.sigBytes - 1;
          for (var i2 = data.sigBytes - 1; i2 >= 0; i2--) {
            if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
              data.sigBytes = i2 + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding) return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex) return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes.exports;
  hasRequiredAes = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            if (i2 < 128) {
              d2[i2] = i2 << 1;
            } else {
              d2[i2] = i2 << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i2 = 0; i2 < 256; i2++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d2[x];
            var x4 = d2[x2];
            var x8 = d2[x4];
            var t2 = d2[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d2[d2[d2[x8 ^ x2]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key2 = this._keyPriorReset = this._key;
            var keyWords = key2.words;
            var keySize = key2.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t2 = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t2;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t2;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes) return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keyBits = [];
            for (var i2 = 0; i2 < 56; i2++) {
              var keyBitPos = PC1[i2] - 1;
              keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i2 = 0; i2 < 24; i2++) {
                subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i2 = 1; i2 < 7; i2++) {
                subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i2 = 0; i2 < 16; i2++) {
              invSubKeys[i2] = subKeys[15 - i2];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i2 = 0; i2 < 8; i2++) {
                f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset;
        }
        function exchangeRL(offset, mask) {
          var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key22 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key22));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4) return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key2 = this._key;
            var keyWords = key2.words;
            var keySigBytes = key2.sigBytes;
            var S2 = this._S = [];
            for (var i2 = 0; i2 < 256; i2++) {
              S2[i2] = i2;
            }
            for (var i2 = 0, j = 0; i2 < 256; i2++) {
              var keyByteIndex = i2 % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S2[i2] + keyByte) % 256;
              var t2 = S2[i2];
              S2[i2] = S2[j];
              S2[j] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i2 = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n2 = 0; n2 < 4; n2++) {
            i2 = (i2 + 1) % 256;
            j = (j + S2[i2]) % 256;
            var t2 = S2[i2];
            S2[i2] = S2[j];
            S2[j] = t2;
            keystreamWord |= S2[(S2[i2] + S2[j]) % 256] << 24 - n2 * 8;
          }
          this._i = i2;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i2 = this.cfg.drop; i2 > 0; i2--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit) return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            for (var i2 = 0; i2 < 4; i2++) {
              K2[i2] = (K2[i2] << 8 | K2[i2] >>> 24) & 16711935 | (K2[i2] << 24 | K2[i2] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C2 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M[offset + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy) return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K2 = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K2[0],
              K2[3] << 16 | K2[2] >>> 16,
              K2[1],
              K2[0] << 16 | K2[3] >>> 16,
              K2[2],
              K2[1] << 16 | K2[0] >>> 16,
              K2[3],
              K2[2] << 16 | K2[1] >>> 16
            ];
            var C2 = this._C = [
              K2[2] << 16 | K2[2] >>> 16,
              K2[0] & 4294901760 | K2[1] & 65535,
              K2[3] << 16 | K2[3] >>> 16,
              K2[1] & 4294901760 | K2[2] & 65535,
              K2[0] << 16 | K2[0] >>> 16,
              K2[2] & 4294901760 | K2[3] & 65535,
              K2[1] << 16 | K2[1] >>> 16,
              K2[3] & 4294901760 | K2[0] & 65535
            ];
            this._b = 0;
            for (var i2 = 0; i2 < 4; i2++) {
              nextState.call(this);
            }
            for (var i2 = 0; i2 < 8; i2++) {
              C2[i2] ^= X[i2 + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i22 & 4294901760;
              var i3 = i22 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i22;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i22;
              C2[7] ^= i3;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S2[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S2[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S2[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S2[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i2 = 0; i2 < 4; i2++) {
              S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
              M[offset + i2] ^= S2[i2];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i2 = 0; i2 < 8; i2++) {
            C_[i2] = C2[i2];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i2 = 0; i2 < 8; i2++) {
            var gx = X[i2] + C2[i2];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i2] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
var blowfish = { exports: {} };
var hasRequiredBlowfish;
function requireBlowfish() {
  if (hasRequiredBlowfish) return blowfish.exports;
  hasRequiredBlowfish = 1;
  (function(module2, exports) {
    (function(root, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a2 = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c2 = x >> 8 & 255;
          let d2 = x & 255;
          let y = ctx.sbox[0][a2] + ctx.sbox[1][b];
          y = y ^ ctx.sbox[2][c2];
          y = y + ctx.sbox[3][d2];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = 0; i2 < N; ++i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i2 = N + 1; i2 > 1; --i2) {
            Xl = Xl ^ ctx.pbox[i2];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key2, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key2[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i2 = 0; i2 < N + 2; i2 += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i2] = Data1;
            ctx.pbox[i2 + 1] = Data2;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i2][j] = Data1;
              ctx.sbox[i2][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key2 = this._keyPriorReset = this._key;
            var keyWords = key2.words;
            var keySize = key2.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          decryptBlock: function(M, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  })(blowfish);
  return blowfish.exports;
}
(function(module2, exports) {
  (function(root, factory, undef) {
    {
      module2.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
    }
  })(commonjsGlobal, function(CryptoJS2) {
    return CryptoJS2;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
const CryptoJS = /* @__PURE__ */ getDefaultExportFromCjs(cryptoJsExports);
var elliptic = {};
const version$1 = "6.6.1";
const require$$0 = {
  version: version$1
};
var utils$m = {};
var bn = { exports: {} };
bn.exports;
(function(module2) {
  (function(module3, exports) {
    function assert2(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number, base3, endian) {
      if (BN2.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base3 === "le" || base3 === "be") {
          endian = base3;
          base3 = 10;
        }
        this._init(number || 0, base3 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require$$0$1.Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN2.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN2.prototype._init = function init3(number, base3, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base3, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base3, endian);
      }
      if (base3 === "hex") {
        base3 = 16;
      }
      assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start2 = 0;
      if (number[0] === "-") {
        start2++;
        this.negative = 1;
      }
      if (start2 < number.length) {
        if (base3 === 16) {
          this._parseHex(number, start2, endian);
        } else {
          this._parseBase(number, base3, start2);
          if (endian === "le") {
            this._initArray(this.toArray(), base3, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number, base3, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le") return;
      this._initArray(this.toArray(), base3, endian);
    };
    BN2.prototype._initArray = function _initArray(number, base3, endian) {
      assert2(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i2 = number.length - 1, j = 0; i2 >= 0; i2 -= 3) {
          w = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j = 0; i2 < number.length; i2 += 3) {
          w = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string2, index) {
      var c2 = string2.charCodeAt(index);
      if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        return c2 - 48 & 15;
      }
    }
    function parseHexByte(string2, lowerBound2, index) {
      var r2 = parseHex4Bits(string2, index);
      if (index - 1 >= lowerBound2) {
        r2 |= parseHex4Bits(string2, index - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number, start2, endian) {
      this.length = Math.ceil((number.length - start2) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === "be") {
        for (i2 = number.length - 1; i2 >= start2; i2 -= 2) {
          w = parseHexByte(number, start2, i2) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start2;
        for (i2 = parseLength % 2 === 0 ? start2 + 1 : start2; i2 < number.length; i2 += 2) {
          w = parseHexByte(number, start2, i2) << off;
          this.words[j] |= w & 67108863;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str, start2, end, mul5) {
      var r2 = 0;
      var len = Math.min(str.length, end);
      for (var i2 = start2; i2 < len; i2++) {
        var c2 = str.charCodeAt(i2) - 48;
        r2 *= mul5;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number, base3, start2) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base3 | 0;
      var total = number.length - start2;
      var mod2 = total % limbLen;
      var end = Math.min(total, total - mod2) + start2;
      var word = 0;
      for (var i2 = start2; i2 < end; i2 += limbLen) {
        word = parseBase(number, i2, i2 + limbLen, base3);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod2 !== 0) {
        var pow = 1;
        word = parseBase(number, i2, number.length, base3);
        for (i2 = 0; i2 < mod2; i2++) {
          pow *= base3;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect7() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base3, padding) {
      base3 = base3 || 10;
      padding = padding | 0 || 1;
      var out;
      if (base3 === 16 || base3 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = this.words[i2];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
        var groupSize = groupSizes[base3];
        var groupBase = groupBases[base3];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base3);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON2() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer(endian, length3) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length3);
    };
    BN2.prototype.toArray = function toArray3(endian, length3) {
      return this.toArrayLike(Array, endian, length3);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
      var byteLength = this.byteLength();
      var reqLength = length3 || Math.max(1, byteLength);
      assert2(byteLength <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i2;
      var q = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q.isZero(); i2++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i2 - 1] = b;
        }
      } else {
        for (i2 = 0; !q.isZero(); i2++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i2] = b;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w) {
        var t2 = w;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0) return 26;
      var t2 = w;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b = this._zeroBits(this.words[i2]);
        r2 += b;
        if (b !== 26) break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg4() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or2(num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i2 = 0; i2 < b.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and2(num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b;
      if (this.length > num.length) {
        a2 = this;
        b = num;
      } else {
        a2 = num;
        b = this;
      }
      for (var i2 = 0; i2 < b.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b;
      if (this.length > num.length) {
        a2 = this;
        b = num;
      } else {
        a2 = num;
        b = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add6(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b;
      if (cmp > 0) {
        a2 = this;
        b = num;
      } else {
        a2 = num;
        b = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r2 = a2 * b;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i2 = k - j | 0;
          a2 = self2.words[i2] | 0;
          b = num.words[j] | 0;
          r2 = a2 * b + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i2 = k - j;
          var a2 = self2.words[i2] | 0;
          var b = num.words[j] | 0;
          var r2 = a2 * b;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t2 = new Array(N);
      var l2 = BN2.prototype._countBits(N) - 1;
      for (var i2 = 0; i2 < N; i2++) {
        t2[i2] = this.revBin(i2, l2, N);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x, l2, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x & 1) << l2 - i2 - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i2 = 0; i2 < N; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s2 = 1; s2 < N; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0; j < s2; j++) {
            var re = rtws[p2 + j];
            var ie = itws[p2 + j];
            var ro = rtws[p2 + j + s2];
            var io = itws[p2 + j + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j] = re + ro;
            itws[p2 + j] = ie + io;
            rtws[p2 + j + s2] = re - ro;
            itws[p2 + j + s2] = ie - io;
            if (j !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N = Math.max(m2, n2) | 1;
      var odd = N & 1;
      var i2 = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;
      for (var i2 = 0; i2 < N / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N - i2 - 1];
        rws[N - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N - i2 - 1];
        iws[N - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i2 = 0; i2 < N / 2; i2++) {
        var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
        ws[i2] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i2 = 0; i2 < len; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len; i2 < N; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i2 = 0; i2 < N; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul5(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w = (this.words[i2] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      this.length = num === 0 ? 1 : this.length;
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
        if (w[i2] !== 0) break;
      }
      if (++i2 < w.length) {
        for (var q = res.sqr(); i2 < w.length; i2++, q = q.sqr()) {
          if (w[i2] === 0) continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h -= s2;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0) ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
        var word = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word >>> r2;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) return false;
      var w = this.words[s2];
      return !!(w & q);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul5, shift2) {
      var len = num.length + shift2;
      var i2;
      this._expand(len);
      var w;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w = (this.words[i2 + shift2] | 0) + carry;
        var right = (num.words[i2] | 0) * mul5;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift2] = w & 67108863;
      }
      for (; i2 < this.length - shift2; i2++) {
        w = (this.words[i2 + shift2] | 0) + carry;
        carry = w >> 26;
        this.words[i2 + shift2] = w & 67108863;
      }
      if (carry === 0) return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w = -(this.words[i2] | 0) + carry;
        carry = w >> 26;
        this.words[i2] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift2 = this.length - num.length;
      var a2 = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift2 = 26 - bhiBits;
      if (shift2 !== 0) {
        b = b.ushln(shift2);
        a2.iushln(shift2);
        bhi = b.words[b.length - 1] | 0;
      }
      var m2 = a2.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN2(null);
        q.length = m2 + 1;
        q.words = new Array(q.length);
        for (var i2 = 0; i2 < q.length; i2++) {
          q.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q) {
          q.words[m2] = 1;
        }
      }
      for (var j = m2 - 1; j >= 0; j--) {
        var qj = (a2.words[b.length + j] | 0) * 67108864 + (a2.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b, qj, j);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b, 1, j);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a2.strip();
      if (mode !== "div" && shift2 !== 0) {
        a2.iushrn(shift2);
      }
      return {
        div: q || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode, positive2) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod2, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive2 && mod2.negative !== 0) {
            mod2.iadd(num);
          }
        }
        return {
          div,
          mod: mod2
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod2 = res.mod.neg();
          if (positive2 && mod2.negative !== 0) {
            mod2.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod2
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod2(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) return dm.div;
      var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod2.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x = this;
      var y = p2.clone();
      if (x.negative !== 0) {
        x = x.umod(p2);
      } else {
        x = x.clone();
      }
      var A = new BN2(1);
      var B = new BN2(0);
      var C = new BN2(0);
      var D = new BN2(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i2 = 0, im = 1; (x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
        if (i2 > 0) {
          x.iushrn(i2);
          while (i2-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b.clone();
      while (a2.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b) >= 0) {
          a2.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a2 = this.clone();
      var b = num.clone();
      a2.negative = 0;
      b.negative = 0;
      for (var shift2 = 0; a2.isEven() && b.isEven(); shift2++) {
        a2.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r2 = a2.cmp(b);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b;
          b = t2;
        } else if (r2 === 0 || b.cmpn(1) === 0) {
          break;
        }
        a2.isub(b);
      } while (true);
      return b.iushln(shift2);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q;
        return this;
      }
      var carry = q;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w = this.words[i2] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i2] = w;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b = num.words[i2] | 0;
        if (a2 === b) continue;
        if (a2 < b) {
          res = -1;
        } else if (a2 > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq6(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split2(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split2(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next = input.words[i2] | 0;
        input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w = num.words[i2] | 0;
        lo += w * 977;
        num.words[i2] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2]) return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b) {
      assert2((a2.negative | b.negative) === 0, "red works only with positives");
      assert2(
        a2.red && a2.red === b.red,
        "red works only with red numbers"
      );
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg4(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add6(a2, b) {
      this._verify2(a2, b);
      var res = a2.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b) {
      this._verify2(a2, b);
      var res = a2.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b) {
      this._verify2(a2, b);
      var res = a2.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b) {
      this._verify2(a2, b);
      var res = a2.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b) {
      this._verify2(a2, b);
      return this.imod(a2.imul(b));
    };
    Red.prototype.mul = function mul5(a2, b) {
      this._verify2(a2, b);
      return this.imod(a2.mul(b));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero()) return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q = this.m.subn(1);
      var s2 = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s2++;
        q.iushrn(1);
      }
      assert2(!q.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN2(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c2 = this.pow(z, q);
      var r2 = this.pow(a2, q.addn(1).iushrn(1));
      var t2 = this.pow(a2, q);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b);
        c2 = b.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero()) return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0) return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start2 = num.bitLength() % 26;
      if (start2 === 0) {
        start2 = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word = num.words[i2];
        for (var j = start2 - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start2 = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b) {
      if (a2.isZero() || b.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t2.isub(c2).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul5(a2, b) {
      if (a2.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t2.isub(c2).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
var minimalisticAssert = assert$f;
function assert$f(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$f.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils$l = {};
(function(exports) {
  var utils2 = exports;
  function toArray3(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray3;
  function zero22(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode3(arr, enc) {
    if (enc === "hex")
      return toHex3(arr);
    else
      return arr;
  };
})(utils$l);
(function(exports) {
  var utils2 = exports;
  var BN2 = bnExports;
  var minAssert = minimalisticAssert;
  var minUtils = utils$l;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    var i2;
    for (i2 = 0; i2 < naf.length; i2 += 1) {
      naf[i2] = 0;
    }
    var ws = 1 << w + 1;
    var k = num.clone();
    for (i2 = 0; i2 < naf.length; i2++) {
      var z;
      var mod2 = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod2 > (ws >> 1) - 1)
          z = (ws >> 1) - mod2;
        else
          z = mod2;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i2] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes) {
    return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes) {
    return new BN2(bytes, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$m);
var brorand = { exports: {} };
var r$1;
brorand.exports = function rand(len) {
  if (!r$1)
    r$1 = new Rand(null);
  return r$1.generate(len);
};
function Rand(rand3) {
  this.rand = rand3;
}
brorand.exports.Rand = Rand;
Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};
Rand.prototype._rand = function _rand(n2) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n2);
  var res = new Uint8Array(n2);
  for (var i2 = 0; i2 < res.length; i2++)
    res[i2] = this.rand.getByte();
  return res;
};
if (typeof self === "object") {
  if (self.crypto && self.crypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n2) {
      var arr = new Uint8Array(n2);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n2) {
      var arr = new Uint8Array(n2);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else if (typeof window === "object") {
    Rand.prototype._rand = function() {
      throw new Error("Not implemented yet");
    };
  }
} else {
  try {
    var crypto$1 = require$$0$1;
    if (typeof crypto$1.randomBytes !== "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function _rand2(n2) {
      return crypto$1.randomBytes(n2);
    };
  } catch (e2) {
  }
}
var brorandExports = brorand.exports;
var curve = {};
var BN$7 = bnExports;
var utils$k = utils$m;
var getNAF = utils$k.getNAF;
var getJSF = utils$k.getJSF;
var assert$e = utils$k.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$7(conf.p, 16);
  this.red = conf.prime ? BN$7.red(conf.prime) : BN$7.mont(this.p);
  this.zero = new BN$7(0).toRed(this.red);
  this.one = new BN$7(1).toRed(this.red);
  this.two = new BN$7(2).toRed(this.red);
  this.n = conf.n && new BN$7(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate2() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k) {
  assert$e(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l2 = j + doubles.step - 1; l2 >= j; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i2 = I; i2 > 0; i2--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i2)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i2)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a2 = a2.add(b);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p2, k) {
  var w = 4;
  var nafPoints = p2._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k, w, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z = naf[i2];
    assert$e(z !== 0);
    if (p2.type === "affine") {
      if (z > 0)
        acc = acc.mixedAdd(wnd[z - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      if (z > 0)
        acc = acc.add(wnd[z - 1 >> 1]);
      else
        acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max = 0;
  var i2;
  var j;
  var p2;
  for (i2 = 0; i2 < len; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a2].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [
      points[a2],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b]
      /* 7 */
    ];
    if (points[a2].y.cmp(points[b].y) === 0) {
      comb[1] = points[a2].add(points[b]);
      comb[2] = points[a2].toJ().mixedAdd(points[b].neg());
    } else if (points[a2].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b]);
      comb[2] = points[a2].add(points[b].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b]);
      comb[2] = points[a2].toJ().mixedAdd(points[b].neg());
    }
    var index = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a2] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a2][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max; i2 >= 0; i2--) {
    var k = 0;
    while (i2 >= 0) {
      var zero3 = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i2] | 0;
        if (tmp[j] !== 0)
          zero3 = false;
      }
      if (!zero3)
        break;
      k++;
      i2--;
    }
    if (i2 >= 0)
      k++;
    acc = acc.dblp(k);
    if (i2 < 0)
      break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      if (z === 0)
        continue;
      else if (z > 0)
        p2 = wnd[j][z - 1 >> 1];
      else if (z < 0)
        p2 = wnd[j][-z - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate3() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils$k.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$e(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$e(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x);
  return [4].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode2(enc, compact) {
  return utils$k.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl5 = max === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max; i2++)
    res[i2] = res[i2 - 1].add(dbl5);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k) {
  var r2 = this;
  for (var i2 = 0; i2 < k; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
var utils$j = utils$m;
var BN$6 = bnExports;
var inherits$3 = inherits_browserExports;
var Base$2 = base;
var assert$d = utils$j.assert;
function ShortCurve(conf) {
  Base$2.call(this, "short", conf);
  this.a = new BN$6(conf.a, 16).toRed(this.red);
  this.b = new BN$6(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$6(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$6(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$d(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$6(vec.a, 16),
        b: new BN$6(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$6.mont(num);
  var tinv = new BN$6(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN$6(1);
  var y1 = new BN$6(0);
  var x2 = new BN$6(0);
  var y2 = new BN$6(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r2 = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v = u;
    u = r2;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r2.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1, k2 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN$6(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate4(point5) {
  if (point5.inf)
    return true;
  var x = point5.x;
  var y = point5.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split2 = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split2.k1.negative) {
      split2.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split2.k2.negative) {
      split2.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split2.k1;
    ncoeffs[i2 * 2 + 1] = split2.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j = 0; j < i2 * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point$2(curve2, x, y, isRed) {
  Base$2.BasePoint.call(this, curve2, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$6(x, 16);
    this.y = new BN$6(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$3(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function point2(x, y, isRed) {
  return new Point$2(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};
Point$2.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$2.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$2.fromJSON = function fromJSON(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$2.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$2.prototype.add = function add2(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function mul(k) {
  k = new BN$6(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k]);
  else
    return this.curve._wnafMul(this, k);
};
Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$2.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$2.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$2.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x, y, z) {
  Base$2.BasePoint.call(this, curve2, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$6(0);
  } else {
    this.x = new BN$6(x, 16);
    this.y = new BN$6(y, 16);
    this.z = new BN$6(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$3(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add3(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b = this.y.redSqr();
    var c2 = b.redSqr();
    var d2 = this.x.redAdd(b).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k, kbase) {
  k = new BN$6(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var BN$5 = bnExports;
var inherits$2 = inherits_browserExports;
var Base$1 = base;
var utils$i = utils$m;
function MontCurve(conf) {
  Base$1.call(this, "mont", conf);
  this.a = new BN$5(conf.a, 16).toRed(this.red);
  this.b = new BN$5(conf.b, 16).toRed(this.red);
  this.i4 = new BN$5(4).toRed(this.red).redInvm();
  this.two = new BN$5(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function validate5(point5) {
  var x = point5.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};
function Point$1(curve2, x, z) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$5(x, 16);
    this.z = new BN$5(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$2(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint2(bytes, enc) {
  return this.point(utils$i.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point3(x, z) {
  return new Point$1(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON2(obj) {
  return Point$1.fromJSON(this, obj);
};
Point$1.prototype.precompute = function precompute2() {
};
Point$1.prototype._encode = function _encode2() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function fromJSON2(curve2, obj) {
  return new Point$1(curve2, obj[0], obj[1] || curve2.one);
};
Point$1.prototype.inspect = function inspect4() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity3() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function dbl3() {
  var a2 = this.x.redAdd(this.z);
  var aa = a2.redSqr();
  var b = this.x.redSub(this.z);
  var bb = b.redSqr();
  var c2 = aa.redSub(bb);
  var nx = aa.redMul(bb);
  var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
  return this.curve.point(nx, nz);
};
Point$1.prototype.add = function add4() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function diffAdd(p2, diff) {
  var a2 = this.x.redAdd(this.z);
  var b = this.x.redSub(this.z);
  var c2 = p2.x.redAdd(p2.z);
  var d2 = p2.x.redSub(p2.z);
  var da = d2.redMul(a2);
  var cb = c2.redMul(b);
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$1.prototype.mul = function mul3(k) {
  var t2 = k.clone();
  var a2 = this;
  var b = this.curve.point(null, null);
  var c2 = this;
  for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
    bits.push(t2.andln(1));
  for (var i2 = bits.length - 1; i2 >= 0; i2--) {
    if (bits[i2] === 0) {
      a2 = a2.diffAdd(b, c2);
      b = b.dbl();
    } else {
      b = a2.diffAdd(b, c2);
      a2 = a2.dbl();
    }
  }
  return b;
};
Point$1.prototype.mulAdd = function mulAdd2() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function eq4(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$1.prototype.getX = function getX2() {
  this.normalize();
  return this.x.fromRed();
};
var utils$h = utils$m;
var BN$4 = bnExports;
var inherits$1 = inherits_browserExports;
var Base = base;
var assert$c = utils$h.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, "edwards", conf);
  this.a = new BN$4(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$4(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$4(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint2(x, y, z, t2) {
  return this.point(x, y, z, t2);
};
EdwardsCurve.prototype.pointFromX = function pointFromX2(x, odd) {
  x = new BN$4(x, 16);
  if (!x.red)
    x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN$4(y, 16);
  if (!y.red)
    y = y.toRed(this.red);
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y);
  }
  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate6(point5) {
  if (point5.isInfinity())
    return true;
  point5.normalize();
  var x2 = point5.x.redSqr();
  var y2 = point5.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve2, x, y, z, t2) {
  Base.BasePoint.call(this, curve2, "projective");
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$4(x, 16);
    this.y = new BN$4(y, 16);
    this.z = z ? new BN$4(z, 16) : this.curve.one;
    this.t = t2 && new BN$4(t2, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$1(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON3(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point4(x, y, z, t2) {
  return new Point(this, x, y, z, t2);
};
Point.fromJSON = function fromJSON3(curve2, obj) {
  return new Point(curve2, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect5() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity4() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  var a2 = this.x.redSqr();
  var b = this.y.redSqr();
  var c2 = this.z.redSqr();
  c2 = c2.redIAdd(c2);
  var d2 = this.curve._mulA(a2);
  var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b);
  var g = d2.redAdd(b);
  var f2 = g.redSub(c2);
  var h = d2.redSub(b);
  var nx = e2.redMul(f2);
  var ny = g.redMul(h);
  var nt = e2.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
  var b = this.x.redAdd(this.y).redSqr();
  var c2 = this.x.redSqr();
  var d2 = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e2;
  var h;
  var j;
  if (this.curve.twisted) {
    e2 = this.curve._mulA(c2);
    var f2 = e2.redAdd(d2);
    if (this.zOne) {
      nx = b.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
      ny = f2.redMul(e2.redSub(d2));
      nz = f2.redSqr().redSub(f2).redSub(f2);
    } else {
      h = this.z.redSqr();
      j = f2.redSub(h).redISub(h);
      nx = b.redSub(c2).redISub(d2).redMul(j);
      ny = f2.redMul(e2.redSub(d2));
      nz = f2.redMul(j);
    }
  } else {
    e2 = c2.redAdd(d2);
    h = this.curve._mulC(this.z).redSqr();
    j = e2.redSub(h).redSub(h);
    nx = this.curve._mulC(b.redISub(e2)).redMul(j);
    ny = this.curve._mulC(e2).redMul(c2.redISub(d2));
    nz = e2.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p2) {
  var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
  var b = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
  var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
  var d2 = this.z.redMul(p2.z.redAdd(p2.z));
  var e2 = b.redSub(a2);
  var f2 = d2.redSub(c2);
  var g = d2.redAdd(c2);
  var h = b.redAdd(a2);
  var nx = e2.redMul(f2);
  var ny = g.redMul(h);
  var nt = e2.redMul(h);
  var nz = f2.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p2) {
  var a2 = this.z.redMul(p2.z);
  var b = a2.redSqr();
  var c2 = this.x.redMul(p2.x);
  var d2 = this.y.redMul(p2.y);
  var e2 = this.curve.d.redMul(c2).redMul(d2);
  var f2 = b.redSub(e2);
  var g = b.redAdd(e2);
  var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d2);
  var nx = a2.redMul(f2).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a2.redMul(g).redMul(d2.redSub(this.curve._mulA(c2)));
    nz = f2.redMul(g);
  } else {
    ny = a2.redMul(g).redMul(d2.redSub(c2));
    nz = this.curve._mulC(f2).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add5(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p2);
  else
    return this._projAdd(p2);
};
Point.prototype.mul = function mul4(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd3(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd2(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
};
Point.prototype.normalize = function normalize2() {
  if (this.zOne)
    return this;
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg3() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY2() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq5(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP2(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x.clone();
  var t2 = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(exports) {
  var curve2 = exports;
  curve2.base = base;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve);
var curves$2 = {};
var hash$2 = {};
var utils$g = {};
var assert$b = minimalisticAssert;
var inherits = inherits_browserExports;
utils$g.inherits = inherits;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray2(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$g.toArray = toArray2;
function toHex(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$g.toHex = toHex;
function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
  return res >>> 0;
}
utils$g.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w = msg[i2];
    if (endian === "little")
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$g.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$g.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$g.zero8 = zero8;
function join32(msg, start2, end, endian) {
  var len = end - start2;
  assert$b(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i2 = 0, k = start2; i2 < res.length; i2++, k += 4) {
    var w;
    if (endian === "big")
      w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
    else
      w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i2] = w >>> 0;
  }
  return res;
}
utils$g.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k] = m2 >>> 24;
      res[k + 1] = m2 >>> 16 & 255;
      res[k + 2] = m2 >>> 8 & 255;
      res[k + 3] = m2 & 255;
    } else {
      res[k + 3] = m2 >>> 24;
      res[k + 2] = m2 >>> 16 & 255;
      res[k + 1] = m2 >>> 8 & 255;
      res[k] = m2 & 255;
    }
  }
  return res;
}
utils$g.split32 = split32;
function rotr32$1(w, b) {
  return w >>> b | w << 32 - b;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(w, b) {
  return w << b | w >>> 32 - b;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(a2, b) {
  return a2 + b >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(a2, b, c2) {
  return a2 + b + c2 >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b, c2, d2) {
  return a2 + b + c2 + d2 >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b, c2, d2, e2) {
  return a2 + b + c2 + d2 + e2 >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$f = utils$g;
var assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$f.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$f.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest2(enc) {
  this.update(this._pad());
  assert$a(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k; i2++)
    res[i2] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len & 255;
  } else {
    res[i2++] = len & 255;
    res[i2++] = len >>> 8 & 255;
    res[i2++] = len >>> 16 & 255;
    res[i2++] = len >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$e = utils$g;
var rotr32 = utils$e.rotr32;
function ft_1$1(s2, x, y, z) {
  if (s2 === 0)
    return ch32$1(x, y, z);
  if (s2 === 1 || s2 === 3)
    return p32(x, y, z);
  if (s2 === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y, z) {
  return x & y ^ ~x & z;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
common$4.maj32 = maj32$1;
function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$d = utils$g;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$d.rotl32;
var sum32$2 = utils$d.sum32;
var sum32_5$1 = utils$d.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start2) {
  var W = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W[i2] = msg[start2 + i2];
  for (; i2 < W.length; i2++)
    W[i2] = rotl32$1(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
  var a2 = this.h[0];
  var b = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b, c2, d2), e2, W[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b, 30);
    b = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$d.toHex32(this.h, "big");
  else
    return utils$d.split32(this.h, "big");
};
var utils$c = utils$g;
var common$2 = common$5;
var shaCommon = common$4;
var assert$9 = minimalisticAssert;
var sum32$1 = utils$c.sum32;
var sum32_4$1 = utils$c.sum32_4;
var sum32_5 = utils$c.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start2) {
  var W = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W[i2] = msg[start2 + i2];
  for (; i2 < W.length; i2++)
    W[i2] = sum32_4$1(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
  var a2 = this.h[0];
  var b = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert$9(this.k.length === W.length);
  for (i2 = 0; i2 < W.length; i2++) {
    var T1 = sum32_5(h, s1_256(e2), ch32(e2, f2, g), this.k[i2], W[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b, c2));
    h = g;
    g = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b;
    b = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};
SHA256$1.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$c.toHex32(this.h, "big");
  else
    return utils$c.split32(this.h, "big");
};
var utils$b = utils$g;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$b.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g;
var common$1 = common$5;
var assert$8 = minimalisticAssert;
var rotr64_hi = utils$a.rotr64_hi;
var rotr64_lo = utils$a.rotr64_lo;
var shr64_hi = utils$a.shr64_hi;
var shr64_lo = utils$a.shr64_lo;
var sum64 = utils$a.sum64;
var sum64_hi = utils$a.sum64_hi;
var sum64_lo = utils$a.sum64_lo;
var sum64_4_hi = utils$a.sum64_4_hi;
var sum64_4_lo = utils$a.sum64_4_lo;
var sum64_5_hi = utils$a.sum64_5_hi;
var sum64_5_lo = utils$a.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start2) {
  var W = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W[i2] = msg[start2 + i2];
  for (; i2 < W.length; i2 += 2) {
    var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]);
    var c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]);
    var c1_hi = W[i2 - 14];
    var c1_lo = W[i2 - 13];
    var c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]);
    var c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]);
    var c3_hi = W[i2 - 32];
    var c3_lo = W[i2 - 31];
    W[i2] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W[i2 + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start2) {
  this._prepareBlock(msg, start2);
  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert$8(this.k.length === W.length);
  for (var i2 = 0; i2 < W.length; i2 += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W[i2];
    var c4_lo = W[i2 + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512$1.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$a.toHex32(this.h, "big");
  else
    return utils$a.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ ~xh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r2 = xl & yl ^ ~xl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r2 = xh & yh ^ xh & zh ^ yh & zh;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r2 = xl & yl ^ xl & zl ^ yl & zl;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$9 = utils$g;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$9.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$9.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$8 = utils$g;
var common = common$5;
var rotl32 = utils$8.rotl32;
var sum32 = utils$8.sum32;
var sum32_3 = utils$8.sum32_3;
var sum32_4 = utils$8.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$8.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start2) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start2], K(j)),
        s[j]
      ),
      E
    );
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start2], Kh(j)),
        sh[j]
      ),
      Eh
    );
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest8(enc) {
  if (enc === "hex")
    return utils$8.toHex32(this.h, "little");
  else
    return utils$8.split32(this.h, "little");
};
function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return x & y | ~x & z;
  else if (j <= 47)
    return (x | ~y) ^ z;
  else if (j <= 63)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
function K(j) {
  if (j <= 15)
    return 0;
  else if (j <= 31)
    return 1518500249;
  else if (j <= 47)
    return 1859775393;
  else if (j <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j) {
  if (j <= 15)
    return 1352829926;
  else if (j <= 31)
    return 1548603684;
  else if (j <= 47)
    return 1836072691;
  else if (j <= 63)
    return 2053994217;
  else
    return 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$7 = utils$g;
var assert$7 = minimalisticAssert;
function Hmac(hash3, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash3, key2, enc);
  this.Hash = hash3;
  this.blockSize = hash3.blockSize / 8;
  this.outSize = hash3.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$7.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$7(key2.length <= this.blockSize);
  for (var i2 = key2.length; i2 < this.blockSize; i2++)
    key2.push(0);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest9(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports) {
  var hash3 = exports;
  hash3.utils = utils$g;
  hash3.common = common$5;
  hash3.sha = sha;
  hash3.ripemd = ripemd;
  hash3.hmac = hmac;
  hash3.sha1 = hash3.sha.sha1;
  hash3.sha256 = hash3.sha.sha256;
  hash3.sha224 = hash3.sha.sha224;
  hash3.sha384 = hash3.sha.sha384;
  hash3.sha512 = hash3.sha.sha512;
  hash3.ripemd160 = hash3.ripemd.ripemd160;
})(hash$2);
var secp256k1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1;
  hasRequiredSecp256k1 = 1;
  secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1;
}
(function(exports) {
  var curves2 = exports;
  var hash3 = hash$2;
  var curve$1 = curve;
  var utils2 = utils$m;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve$1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = requireSecp256k1();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
})(curves$2);
var hash$1 = hash$2;
var utils$6 = utils$l;
var assert$6 = minimalisticAssert;
function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$6.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$6.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$6.toArray(options.pers, options.persEnc || "hex");
  assert$6(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function init2(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function hmac2() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add6, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add6;
    add6 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$6.toArray(entropy, entropyEnc);
  add6 = utils$6.toArray(add6, addEnc);
  assert$6(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add6 || []));
  this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function generate2(len, enc, add6, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add6;
    add6 = enc;
    enc = null;
  }
  if (add6) {
    add6 = utils$6.toArray(add6, addEnc || "hex");
    this._update(add6);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add6);
  this._reseed++;
  return utils$6.encode(res, enc);
};
var BN$3 = bnExports;
var utils$5 = utils$m;
var assert$5 = utils$5.assert;
function KeyPair$3(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;
KeyPair$3.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$3)
    return pub2;
  return new KeyPair$3(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$3.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$3)
    return priv2;
  return new KeyPair$3(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$3.prototype.validate = function validate7() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$3.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$3(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$5(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$5(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$3.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$5(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$3.prototype.verify = function verify(msg, signature2, options) {
  return this.ec.verify(msg, signature2, this, void 0, options);
};
KeyPair$3.prototype.inspect = function inspect6() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$2 = bnExports;
var utils$4 = utils$m;
var assert$4 = utils$4.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new BN$2(options.r, 16);
  this.s = new BN$2(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  if (buf[p2.place] === 0) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature$3.prototype._importDER = function _importDER(data, enc) {
  data = utils$4.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len = getLength(data, p2);
  if (len === false) {
    return false;
  }
  if (len + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data, p2);
  if (rlen === false) {
    return false;
  }
  if ((data[p2.place] & 128) !== 0) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  if ((data[p2.place] & 128) !== 0) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$2(r2);
  this.s = new BN$2(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature$3.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr = [2];
  constructLength(arr, r2.length);
  arr = arr.concat(r2);
  arr.push(2);
  constructLength(arr, s2.length);
  var backHalf = arr.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$4.encode(res, enc);
};
var BN$1 = bnExports;
var HmacDRBG = hmacDrbg;
var utils$3 = utils$m;
var curves$1 = curves$2;
var rand2 = brorandExports;
var assert$3 = utils$3.assert;
var KeyPair$2 = key$1;
var Signature$2 = signature$1;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$3(
      Object.prototype.hasOwnProperty.call(curves$1, options),
      "Unknown curve " + options
    );
    options = curves$1[options];
  }
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair$2(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
  return KeyPair$2.fromPrivate(this, priv2, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub2, enc) {
  return KeyPair$2.fromPublic(this, pub2, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand2(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN$1(2));
  for (; ; ) {
    var priv2 = new BN$1(drbg.generate(bytes));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
  var byteLength;
  if (BN$1.isBN(msg) || typeof msg === "number") {
    msg = new BN$1(msg, 16);
    byteLength = msg.byteLength();
  } else if (typeof msg === "object") {
    byteLength = msg.length;
    msg = new BN$1(msg, 16);
  } else {
    var str = msg.toString();
    byteLength = str.length + 1 >>> 1;
    msg = new BN$1(str, 16);
  }
  if (typeof bitLength !== "number") {
    bitLength = byteLength * 8;
  }
  var delta = bitLength - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign2(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  if (typeof msg !== "string" && typeof msg !== "number" && !BN$1.isBN(msg)) {
    assert$3(
      typeof msg === "object" && msg && typeof msg.length === "number",
      "Expected message to be an array-like, a hex string, or a BN instance"
    );
    assert$3(msg.length >>> 0 === msg.length);
    for (var i2 = 0; i2 < msg.length; i2++) assert$3((msg[i2] & 255) === msg[i2]);
  }
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(msg, false, options.msgBitLength);
  assert$3(!msg.isNeg(), "Can not sign a negative message");
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  assert$3(new BN$1(nonce).eq(msg), "Can not sign message");
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$1(1));
  for (var iter = 0; ; iter++) {
    var k = options.k ? options.k(iter) : new BN$1(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new Signature$2({ r: r2, s: s2, recoveryParam });
  }
};
EC.prototype.verify = function verify2(msg, signature2, key2, enc, options) {
  if (!options)
    options = {};
  msg = this._truncateToN(msg, false, options.msgBitLength);
  key2 = this.keyFromPublic(key2, enc);
  signature2 = new Signature$2(signature2, "hex");
  var r2 = signature2.r;
  var s2 = signature2.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC.prototype.recoverPubKey = function(msg, signature2, j, enc) {
  assert$3((3 & j) === j, "The recovery param is more than two bits");
  signature2 = new Signature$2(signature2, enc);
  var n2 = this.n;
  var e2 = new BN$1(msg);
  var r2 = signature2.r;
  var s2 = signature2.s;
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature2.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC.prototype.getKeyRecoveryParam = function(e2, signature2, Q, enc) {
  signature2 = new Signature$2(signature2, enc);
  if (signature2.recoveryParam !== null)
    return signature2.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature2, i2);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$2 = utils$m;
var assert$2 = utils$2.assert;
var parseBytes$2 = utils$2.parseBytes;
var cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$2(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}
KeyPair$1.fromPublic = function fromPublic2(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$1)
    return pub2;
  return new KeyPair$1(eddsa2, { pub: pub2 });
};
KeyPair$1.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$1)
    return secret2;
  return new KeyPair$1(eddsa2, { secret: secret2 });
};
KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a2 = hash3.slice(0, eddsa2.encodingLength);
  a2[0] &= 248;
  a2[lastIx] &= 127;
  a2[lastIx] |= 64;
  return a2;
});
cachedProperty$1(KeyPair$1, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function sign3(message2) {
  assert$2(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message2, this);
};
KeyPair$1.prototype.verify = function verify3(message2, sig) {
  return this.eddsa.verify(message2, sig, this);
};
KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$2(this._secret, "KeyPair is public only");
  return utils$2.encode(this.secret(), enc);
};
KeyPair$1.prototype.getPublic = function getPublic2(enc) {
  return utils$2.encode(this.pubBytes(), enc);
};
var key = KeyPair$1;
var BN = bnExports;
var utils$1 = utils$m;
var assert$1 = utils$1.assert;
var cachedProperty = utils$1.cachedProperty;
var parseBytes$1 = utils$1.parseBytes;
function Signature$1(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$1(sig);
  if (Array.isArray(sig)) {
    assert$1(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$1(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$1, "S", function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function toHex2() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1;
var hash2 = hash$2;
var curves = curves$2;
var utils = utils$m;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = key;
var Signature = signature;
function EDDSA(curve2) {
  assert(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash2.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign4(message2, secret2) {
  message2 = parseBytes(message2);
  var key2 = this.keyFromSecret(secret2);
  var r2 = this.hashInt(key2.messagePrefix(), message2);
  var R2 = this.g.mul(r2);
  var Rencoded2 = this.encodePoint(R2);
  var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message2).mul(key2.priv());
  var S2 = r2.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R2, S: S2, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify4(message2, sig, pub2) {
  message2 = parseBytes(message2);
  sig = this.makeSignature(sig);
  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
    return false;
  }
  var key2 = this.keyFromPublic(pub2);
  var h = this.hashInt(sig.Rencoded(), key2.pubBytes(), message2);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key2.pub().mul(h));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i2 = 0; i2 < arguments.length; i2++)
    hash3.update(arguments[i2]);
  return utils.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic2(pub2) {
  return KeyPair.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point5) {
  var enc = point5.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point5.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint3(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
  var xIsOdd = (bytes[lastIx] & 128) !== 0;
  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
(function(exports) {
  var elliptic2 = exports;
  elliptic2.version = require$$0.version;
  elliptic2.utils = utils$m;
  elliptic2.rand = brorandExports;
  elliptic2.curve = curve;
  elliptic2.curves = curves$2;
  elliptic2.ec = ec;
  elliptic2.eddsa = eddsa;
})(elliptic);
var sha3 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.9.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2023
 * @license MIT
 */
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = globalThis;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } : Array.isArray;
    var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
      return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    } : ArrayBuffer.isView;
    var formatMessage = function(message2) {
      var type = typeof message2;
      if (type === "string") {
        return [message2, true];
      }
      if (type !== "object" || message2 === null) {
        throw new Error(INPUT_ERROR);
      }
      if (ARRAY_BUFFER && message2.constructor === ArrayBuffer) {
        return [new Uint8Array(message2), false];
      }
      if (!isArray(message2) && !isView(message2)) {
        throw new Error(INPUT_ERROR);
      }
      return [message2, false];
    };
    var empty = function(message2) {
      return formatMessage(message2)[0].length === 0;
    };
    var cloneArray = function(array) {
      var newArray = [];
      for (var i22 = 0; i22 < array.length; ++i22) {
        newArray[i22] = array[i22];
      }
      return newArray;
    };
    var createOutputMethod = function(bits2, padding, outputType) {
      return function(message2) {
        return new Keccak(bits2, padding, bits2).update(message2)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding, outputType) {
      return function(message2, outputBits) {
        return new Keccak(bits2, padding, outputBits).update(message2)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding, outputType) {
      return function(message2, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message2, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding, outputType) {
      return function(key2, message2, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message2, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding) {
      for (var i22 = 0; i22 < OUTPUT_TYPES.length; ++i22) {
        var type = OUTPUT_TYPES[i22];
        method[type] = createMethod2(bits2, padding, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding) {
      var method = createOutputMethod(bits2, padding, "hex");
      method.create = function() {
        return new Keccak(bits2, padding, bits2);
      };
      method.update = function(message2) {
        return method.create().update(message2);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding);
    };
    var createShakeMethod = function(bits2, padding) {
      var method = createShakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding, outputBits);
      };
      method.update = function(message2, outputBits) {
        return method.create(outputBits).update(message2);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
    };
    var createCshakeMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits, n2, s2) {
        if (empty(n2) && empty(s2)) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding, outputBits).bytepad([n2, s2], w);
        }
      };
      method.update = function(message2, outputBits, n2, s2) {
        return method.create(outputBits, n2, s2).update(message2);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
    };
    var createKmacMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding, "hex");
      method.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w).bytepad([key2], w);
      };
      method.update = function(key2, message2, outputBits, s2) {
        return method.create(key2, outputBits, s2).update(message2);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm = algorithms[i2];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i22 = 0; i22 < 50; ++i22) {
        this.s[i22] = 0;
      }
    }
    Keccak.prototype.update = function(message2) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var result = formatMessage(message2);
      message2 = result[0];
      var isString = result[1];
      var blocks = this.blocks, byteCount = this.byteCount, length3 = message2.length, blockCount = this.blockCount, index = 0, s2 = this.s, i22, code2;
      while (index < length3) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i22 = 1; i22 < blockCount + 1; ++i22) {
            blocks[i22] = 0;
          }
        }
        if (isString) {
          for (i22 = this.start; index < length3 && i22 < byteCount; ++index) {
            code2 = message2.charCodeAt(index);
            if (code2 < 128) {
              blocks[i22 >> 2] |= code2 << SHIFT[i22++ & 3];
            } else if (code2 < 2048) {
              blocks[i22 >> 2] |= (192 | code2 >> 6) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 & 63) << SHIFT[i22++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks[i22 >> 2] |= (224 | code2 >> 12) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 & 63) << SHIFT[i22++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message2.charCodeAt(++index) & 1023);
              blocks[i22 >> 2] |= (240 | code2 >> 18) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i22++ & 3];
              blocks[i22 >> 2] |= (128 | code2 & 63) << SHIFT[i22++ & 3];
            }
          }
        } else {
          for (i22 = this.start; index < length3 && i22 < byteCount; ++index) {
            blocks[i22 >> 2] |= message2[index] << SHIFT[i22++ & 3];
          }
        }
        this.lastByteIndex = i22;
        if (i22 >= byteCount) {
          this.start = i22 - byteCount;
          this.block = blocks[blockCount];
          for (i22 = 0; i22 < blockCount; ++i22) {
            s2[i22] ^= blocks[i22];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i22;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x, right) {
      var o2 = x & 255, n2 = 1;
      var bytes = [o2];
      x = x >> 8;
      o2 = x & 255;
      while (o2 > 0) {
        bytes.unshift(o2);
        x = x >> 8;
        o2 = x & 255;
        ++n2;
      }
      if (right) {
        bytes.push(n2);
      } else {
        bytes.unshift(n2);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var result = formatMessage(str);
      str = result[0];
      var isString = result[1];
      var bytes = 0, length3 = str.length;
      if (isString) {
        for (var i22 = 0; i22 < str.length; ++i22) {
          var code2 = str.charCodeAt(i22);
          if (code2 < 128) {
            bytes += 1;
          } else if (code2 < 2048) {
            bytes += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i22) & 1023);
            bytes += 4;
          }
        }
      } else {
        bytes = length3;
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
      var bytes = this.encode(w);
      for (var i22 = 0; i22 < strs.length; ++i22) {
        bytes += this.encodeString(strs[i22]);
      }
      var paddingBytes = (w - bytes % w) % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i22 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks[i22 >> 2] |= this.padding[i22 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i22 = 1; i22 < blockCount + 1; ++i22) {
          blocks[i22] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i22 = 0; i22 < blockCount; ++i22) {
        s2[i22] ^= blocks[i22];
      }
      f2(s2);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j2 = 0;
      var hex = "", block;
      while (j2 < outputBlocks) {
        for (i22 = 0; i22 < blockCount && j2 < outputBlocks; ++i22, ++j2) {
          block = s2[i22];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          s2 = cloneArray(s2);
          f2(s2);
          i22 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i22];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j2 = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j2 < outputBlocks) {
        for (i22 = 0; i22 < blockCount && j2 < outputBlocks; ++i22, ++j2) {
          array[j2] = s2[i22];
        }
        if (j2 % blockCount === 0) {
          s2 = cloneArray(s2);
          f2(s2);
        }
      }
      if (extraBytes) {
        array[j2] = s2[i22];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j2 = 0;
      var array = [], offset, block;
      while (j2 < outputBlocks) {
        for (i22 = 0; i22 < blockCount && j2 < outputBlocks; ++i22, ++j2) {
          offset = j2 << 2;
          block = s2[i22];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          s2 = cloneArray(s2);
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j2 << 2;
        block = s2[i22];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding, outputBits) {
      Keccak.call(this, bits2, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h;
        s2[1] ^= l2;
        s2[10] ^= h;
        s2[11] ^= l2;
        s2[20] ^= h;
        s2[21] ^= l2;
        s2[30] ^= h;
        s2[31] ^= l2;
        s2[40] ^= h;
        s2[41] ^= l2;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h;
        s2[3] ^= l2;
        s2[12] ^= h;
        s2[13] ^= l2;
        s2[22] ^= h;
        s2[23] ^= l2;
        s2[32] ^= h;
        s2[33] ^= l2;
        s2[42] ^= h;
        s2[43] ^= l2;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h;
        s2[5] ^= l2;
        s2[14] ^= h;
        s2[15] ^= l2;
        s2[24] ^= h;
        s2[25] ^= l2;
        s2[34] ^= h;
        s2[35] ^= l2;
        s2[44] ^= h;
        s2[45] ^= l2;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h;
        s2[7] ^= l2;
        s2[16] ^= h;
        s2[17] ^= l2;
        s2[26] ^= h;
        s2[27] ^= l2;
        s2[36] ^= h;
        s2[37] ^= l2;
        s2[46] ^= h;
        s2[47] ^= l2;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h;
        s2[9] ^= l2;
        s2[18] ^= h;
        s2[19] ^= l2;
        s2[28] ^= h;
        s2[29] ^= l2;
        s2[38] ^= h;
        s2[39] ^= l2;
        s2[48] ^= h;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3);
var sha3Exports = sha3.exports;
var __defProp$8 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name$8 = (target, value2) => __defProp$8(target, "name", { value: value2, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp$8(target, name2, { get: all2[name2], enumerable: true });
};
var kaspa_exports = {};
__export(kaspa_exports, {
  Abortable: () => Abortable,
  Aborted: () => Aborted,
  AccountKind: () => AccountKind,
  AccountsDiscoveryKind: () => AccountsDiscoveryKind,
  Address: () => Address,
  AddressVersion: () => AddressVersion,
  AgentConstructorOptions: () => AgentConstructorOptions,
  AppendFileOptions: () => AppendFileOptions,
  AssertionErrorOptions: () => AssertionErrorOptions,
  Balance: () => Balance,
  BalanceStrings: () => BalanceStrings,
  CommitRevealAddressKind: () => CommitRevealAddressKind,
  ConnectStrategy: () => ConnectStrategy,
  ConsoleConstructorOptions: () => ConsoleConstructorOptions,
  CreateHookCallbacks: () => CreateHookCallbacks,
  CreateReadStreamOptions: () => CreateReadStreamOptions,
  CreateWriteStreamOptions: () => CreateWriteStreamOptions,
  CryptoBox: () => CryptoBox,
  CryptoBoxPrivateKey: () => CryptoBoxPrivateKey,
  CryptoBoxPublicKey: () => CryptoBoxPublicKey,
  DerivationPath: () => DerivationPath,
  Encoding: () => Encoding,
  FeeSource: () => FeeSource,
  FormatInputPathObject: () => FormatInputPathObject,
  Generator: () => Generator,
  GeneratorSummary: () => GeneratorSummary,
  GetNameOptions: () => GetNameOptions,
  Hash: () => Hash,
  Header: () => Header,
  Keypair: () => Keypair,
  Language: () => Language,
  MkdtempSyncOptions: () => MkdtempSyncOptions,
  Mnemonic: () => Mnemonic$1,
  NetServerOptions: () => NetServerOptions,
  NetworkId: () => NetworkId,
  NetworkType: () => NetworkType,
  NewAddressKind: () => NewAddressKind,
  NodeDescriptor: () => NodeDescriptor,
  Opcodes: () => Opcodes,
  PSKB: () => PSKB,
  PSKT: () => PSKT,
  PaymentOutput: () => PaymentOutput,
  PaymentOutputs: () => PaymentOutputs,
  PendingTransaction: () => PendingTransaction,
  PipeOptions: () => PipeOptions,
  PoW: () => PoW,
  PrivateKey: () => PrivateKey,
  PrivateKeyGenerator: () => PrivateKeyGenerator,
  ProcessSendOptions: () => ProcessSendOptions,
  PrvKeyDataInfo: () => PrvKeyDataInfo,
  PublicKey: () => PublicKey,
  PublicKeyGenerator: () => PublicKeyGenerator,
  ReadStream: () => ReadStream,
  Resolver: () => Resolver,
  RpcClient: () => RpcClient,
  ScriptBuilder: () => ScriptBuilder,
  ScriptPublicKey: () => ScriptPublicKey,
  SetAadOptions: () => SetAadOptions,
  SigHashType: () => SigHashType,
  SighashType: () => SighashType,
  Storage: () => Storage,
  StreamTransformOptions: () => StreamTransformOptions,
  Transaction: () => Transaction,
  TransactionInput: () => TransactionInput,
  TransactionOutpoint: () => TransactionOutpoint,
  TransactionOutput: () => TransactionOutput,
  TransactionRecord: () => TransactionRecord,
  TransactionRecordNotification: () => TransactionRecordNotification,
  TransactionSigningHash: () => TransactionSigningHash,
  TransactionSigningHashECDSA: () => TransactionSigningHashECDSA,
  TransactionUtxoEntry: () => TransactionUtxoEntry,
  UserInfoOptions: () => UserInfoOptions,
  UtxoContext: () => UtxoContext,
  UtxoEntries: () => UtxoEntries,
  UtxoEntry: () => UtxoEntry,
  UtxoEntryReference: () => UtxoEntryReference,
  UtxoProcessor: () => UtxoProcessor,
  Wallet: () => Wallet$1,
  WalletDescriptor: () => WalletDescriptor,
  WasiOptions: () => WasiOptions,
  WriteFileSyncOptions: () => WriteFileSyncOptions,
  WriteStream: () => WriteStream,
  XOnlyPublicKey: () => XOnlyPublicKey,
  XPrv: () => XPrv,
  XPub: () => XPub,
  addressFromScriptPublicKey: () => addressFromScriptPublicKey,
  argon2sha256ivFromBinary: () => argon2sha256ivFromBinary,
  argon2sha256ivFromText: () => argon2sha256ivFromText,
  calculateStorageMass: () => calculateStorageMass,
  calculateTarget: () => calculateTarget,
  calculateTransactionFee: () => calculateTransactionFee,
  calculateTransactionMass: () => calculateTransactionMass,
  createAddress: () => createAddress,
  createInputSignature: () => createInputSignature,
  createMultisigAddress: () => createMultisigAddress,
  createTransaction: () => createTransaction,
  createTransactions: () => createTransactions,
  decryptXChaCha20Poly1305: () => decryptXChaCha20Poly1305,
  default: () => kaspa_default,
  defer: () => defer,
  encryptXChaCha20Poly1305: () => encryptXChaCha20Poly1305,
  estimateTransactions: () => estimateTransactions,
  getNetworkParams: () => getNetworkParams,
  getTransactionMaturityProgress: () => getTransactionMaturityProgress,
  initBrowserPanicHook: () => initBrowserPanicHook,
  initConsolePanicHook: () => initConsolePanicHook,
  initSync: () => initSync,
  initWASM32Bindings: () => initWASM32Bindings,
  isScriptPayToPubkey: () => isScriptPayToPubkey,
  isScriptPayToPubkeyECDSA: () => isScriptPayToPubkeyECDSA,
  isScriptPayToScriptHash: () => isScriptPayToScriptHash,
  kaspaToSompi: () => kaspaToSompi,
  maximumStandardTransactionMass: () => maximumStandardTransactionMass,
  payToAddressScript: () => payToAddressScript,
  payToScriptHashScript: () => payToScriptHashScript,
  payToScriptHashSignatureScript: () => payToScriptHashSignatureScript,
  presentPanicHookLogs: () => presentPanicHookLogs,
  setDefaultStorageFolder: () => setDefaultStorageFolder,
  setDefaultWalletFile: () => setDefaultWalletFile,
  setLogLevel: () => setLogLevel,
  sha256FromBinary: () => sha256FromBinary,
  sha256FromText: () => sha256FromText,
  sha256dFromBinary: () => sha256dFromBinary,
  sha256dFromText: () => sha256dFromText,
  signMessage: () => signMessage,
  signScriptHash: () => signScriptHash,
  signTransaction: () => signTransaction,
  sompiToKaspaString: () => sompiToKaspaString,
  sompiToKaspaStringWithSuffix: () => sompiToKaspaStringWithSuffix,
  updateTransactionMass: () => updateTransactionMass,
  verifyMessage: () => verifyMessage,
  version: () => version
});
function getObject(idx) {
  return heap[idx];
}
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function handleError(f2, args) {
  try {
    return f2.apply(this, args);
  } catch (e2) {
    wasm.__wbindgen_export_0(addHeapObject(e2));
  }
}
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127) break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function makeMutClosure(arg0, arg1, dtor, f2) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name$8((...args) => {
    state.cnt++;
    const a2 = state.a;
    state.a = 0;
    try {
      return f2(a2, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_4.get(state.dtor)(a2, state.b);
        CLOSURE_DTORS.unregister(state);
      } else {
        state.a = a2;
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
function makeClosure(arg0, arg1, dtor, f2) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name$8((...args) => {
    state.cnt++;
    try {
      return f2(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
        state.a = 0;
        CLOSURE_DTORS.unregister(state);
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name2 = val.name;
    if (typeof name2 == "string" && name2.length > 0) {
      return `Function(${name2})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length3 = val.length;
    let debug = "[";
    if (length3 > 0) {
      debug += debugString(val[0]);
    }
    for (let i2 = 1; i2 < length3; i2++) {
      debug += ", " + debugString(val[i2]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
}
function addBorrowedObject(obj) {
  if (stack_pointer == 1) throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
function isScriptPayToScriptHash(script) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.isScriptPayToScriptHash(retptr, addHeapObject(script));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function isScriptPayToPubkeyECDSA(script) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.isScriptPayToPubkeyECDSA(retptr, addHeapObject(script));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function isScriptPayToPubkey(script) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.isScriptPayToPubkey(retptr, addHeapObject(script));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function addressFromScriptPublicKey(script_public_key, network) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.addressFromScriptPublicKey(retptr, addBorrowedObject(script_public_key), addBorrowedObject(network));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
    heap[stack_pointer++] = void 0;
  }
}
function payToScriptHashSignatureScript(redeem_script, signature2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.payToScriptHashSignatureScript(retptr, addHeapObject(redeem_script), addHeapObject(signature2));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function payToScriptHashScript(redeem_script) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.payToScriptHashScript(retptr, addHeapObject(redeem_script));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return ScriptPublicKey.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function payToAddressScript(address) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.payToAddressScript(retptr, addBorrowedObject(address));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return ScriptPublicKey.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function calculateTarget(difficulty) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.calculateTarget(retptr, difficulty);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function argon2sha256ivFromText(text, byteLength) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.argon2sha256ivFromText(retptr, ptr0, len0, byteLength);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function argon2sha256ivFromBinary(data, hashLength) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.argon2sha256ivFromBinary(retptr, addHeapObject(data), hashLength);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256dFromText(text) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.sha256dFromText(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256dFromBinary(data) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.sha256dFromBinary(retptr, addHeapObject(data));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256FromText(text) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.sha256FromText(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256FromBinary(data) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.sha256FromBinary(retptr, addHeapObject(data));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function decryptXChaCha20Poly1305(base64string, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(base64string, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(password, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    wasm.decryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
function encryptXChaCha20Poly1305(plainText, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(plainText, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(password, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    wasm.encryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
function calculateStorageMass(network_id, input_values, output_values) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-32);
    wasm.calculateStorageMass(retptr, addHeapObject(network_id), addBorrowedObject(input_values), addBorrowedObject(output_values));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);
    var r4 = getDataViewMemory0().getInt32(retptr + 4 * 4, true);
    var r5 = getDataViewMemory0().getInt32(retptr + 4 * 5, true);
    if (r5) {
      throw takeObject(r4);
    }
    return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(32);
    heap[stack_pointer++] = void 0;
    heap[stack_pointer++] = void 0;
  }
}
function calculateTransactionFee(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-32);
    wasm.calculateTransactionFee(retptr, addHeapObject(network_id), addBorrowedObject(tx), isLikeNone(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);
    var r4 = getDataViewMemory0().getInt32(retptr + 4 * 4, true);
    var r5 = getDataViewMemory0().getInt32(retptr + 4 * 5, true);
    if (r5) {
      throw takeObject(r4);
    }
    return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(32);
    heap[stack_pointer++] = void 0;
  }
}
function updateTransactionMass(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(tx, Transaction);
    wasm.updateTransactionMass(retptr, addHeapObject(network_id), tx.__wbg_ptr, isLikeNone(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function calculateTransactionMass(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.calculateTransactionMass(retptr, addHeapObject(network_id), addBorrowedObject(tx), isLikeNone(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject(r2);
    }
    return BigInt.asUintN(64, r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function maximumStandardTransactionMass() {
  const ret = wasm.maximumStandardTransactionMass();
  return BigInt.asUintN(64, ret);
}
function signScriptHash(script_hash, privkey) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(privkey, PrivateKey);
    wasm.signScriptHash(retptr, addHeapObject(script_hash), privkey.__wbg_ptr);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function createInputSignature(tx, input_index, private_key, sighash_type) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(tx, Transaction);
    _assertClass(private_key, PrivateKey);
    wasm.createInputSignature(retptr, tx.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone(sighash_type) ? 6 : sighash_type);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function signTransaction(tx, signer, verify_sig) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    _assertClass(tx, Transaction);
    wasm.signTransaction(retptr, tx.__wbg_ptr, addBorrowedObject(signer), verify_sig);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Transaction.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function createAddress(key2, network, ecdsa2, account_kind) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    let ptr0 = 0;
    if (!isLikeNone(account_kind)) {
      _assertClass(account_kind, AccountKind);
      ptr0 = account_kind.__destroy_into_raw();
    }
    wasm.createAddress(retptr, addBorrowedObject(key2), addBorrowedObject(network), isLikeNone(ecdsa2) ? 16777215 : ecdsa2 ? 1 : 0, ptr0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Address.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
    heap[stack_pointer++] = void 0;
  }
}
function createMultisigAddress(minimum_signatures, keys, network_type, ecdsa2, account_kind) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    let ptr0 = 0;
    if (!isLikeNone(account_kind)) {
      _assertClass(account_kind, AccountKind);
      ptr0 = account_kind.__destroy_into_raw();
    }
    wasm.createMultisigAddress(retptr, minimum_signatures, addBorrowedObject(keys), network_type, isLikeNone(ecdsa2) ? 16777215 : ecdsa2 ? 1 : 0, ptr0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Address.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function getTransactionMaturityProgress(blockDaaScore, currentDaaScore, networkId, isCoinbase) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.getTransactionMaturityProgress(retptr, addHeapObject(blockDaaScore), addHeapObject(currentDaaScore), addHeapObject(networkId), isCoinbase);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function getNetworkParams(networkId) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.getNetworkParams(retptr, addHeapObject(networkId));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function sompiToKaspaStringWithSuffix(sompi, network) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.sompiToKaspaStringWithSuffix(retptr, addHeapObject(sompi), addBorrowedObject(network));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
    wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function sompiToKaspaString(sompi) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.sompiToKaspaString(retptr, addHeapObject(sompi));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function kaspaToSompi(kaspa) {
  const ptr0 = passStringToWasm0(kaspa, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.kaspaToSompi(ptr0, len0);
  return takeObject(ret);
}
function estimateTransactions(settings) {
  const ret = wasm.estimateTransactions(addHeapObject(settings));
  return takeObject(ret);
}
function createTransactions(settings) {
  const ret = wasm.createTransactions(addHeapObject(settings));
  return takeObject(ret);
}
function createTransaction(utxo_entry_source, outputs, priority_fee, payload, sig_op_count) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.createTransaction(retptr, addHeapObject(utxo_entry_source), addHeapObject(outputs), addHeapObject(priority_fee), isLikeNone(payload) ? 0 : addHeapObject(payload), isLikeNone(sig_op_count) ? 16777215 : sig_op_count);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Transaction.__wrap(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function setDefaultStorageFolder(folder) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(folder, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.setDefaultStorageFolder(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject(r0);
    }
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function setDefaultWalletFile(folder) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(folder, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm.setDefaultWalletFile(retptr, ptr0, len0);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject(r0);
    }
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function verifyMessage(value2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.verifyMessage(retptr, addHeapObject(value2));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function signMessage(value2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.signMessage(retptr, addHeapObject(value2));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function version() {
  let deferred1_0;
  let deferred1_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.version(retptr);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    deferred1_0 = r0;
    deferred1_1 = r1;
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
  }
}
function passArrayJsValueToWasm0(array, malloc) {
  const ptr = malloc(array.length * 4, 4) >>> 0;
  const mem = getDataViewMemory0();
  for (let i2 = 0; i2 < array.length; i2++) {
    mem.setUint32(ptr + 4 * i2, addHeapObject(array[i2]), true);
  }
  WASM_VECTOR_LEN = array.length;
  return ptr;
}
function getArrayJsValueFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getDataViewMemory0();
  const result = [];
  for (let i2 = ptr; i2 < ptr + 4 * len; i2 += 4) {
    result.push(takeObject(mem.getUint32(i2, true)));
  }
  return result;
}
function setLogLevel(level) {
  wasm.setLogLevel(addHeapObject(level));
}
function initWASM32Bindings(config) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.initWASM32Bindings(retptr, addHeapObject(config));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject(r0);
    }
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function initConsolePanicHook() {
  wasm.initConsolePanicHook();
}
function initBrowserPanicHook() {
  wasm.initBrowserPanicHook();
}
function presentPanicHookLogs() {
  wasm.presentPanicHookLogs();
}
function defer() {
  const ret = wasm.defer();
  return takeObject(ret);
}
function __wbg_adapter_66(arg0, arg1) {
  wasm.__wbindgen_export_5(arg0, arg1);
}
function __wbg_adapter_69(arg0, arg1, arg2) {
  wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2));
}
function __wbg_adapter_72(arg0, arg1) {
  wasm.__wbindgen_export_7(arg0, arg1);
}
function __wbg_adapter_75(arg0, arg1, arg2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.__wbindgen_export_8(retptr, arg0, arg1, addHeapObject(arg2));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject(r0);
    }
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function __wbg_adapter_78(arg0, arg1, arg2) {
  wasm.__wbindgen_export_9(arg0, arg1, addHeapObject(arg2));
}
function __wbg_adapter_81(arg0, arg1, arg2, arg3) {
  const ret = wasm.__wbindgen_export_10(arg0, arg1, addHeapObject(arg2), arg3);
  return takeObject(ret);
}
function __wbg_adapter_84(arg0, arg1, arg2) {
  wasm.__wbindgen_export_11(arg0, arg1, addHeapObject(arg2));
}
function __wbg_adapter_87(arg0, arg1, arg2) {
  wasm.__wbindgen_export_11(arg0, arg1, arg2);
}
function __wbg_adapter_90(arg0, arg1, arg2) {
  wasm.__wbindgen_export_12(arg0, arg1, addHeapObject(arg2));
}
function __wbg_adapter_199(arg0, arg1, arg2, arg3) {
  wasm.__wbindgen_export_13(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_BigInt_470dd987b8190f8e = function(arg0) {
    const ret = BigInt(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_BigInt_ddea6d2f55558acb = function() {
    return handleError(function(arg0) {
      const ret = BigInt(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_Window_b0044ac7db258535 = function(arg0) {
    const ret = getObject(arg0).Window;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_WorkerGlobalScope_b74cefefc62a37da = function(arg0) {
    const ret = getObject(arg0).WorkerGlobalScope;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {
    getObject(arg0).abort();
  };
  imports.wbg.__wbg_aborted_new = function(arg0) {
    const ret = Aborted.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_accountkind_new = function(arg0) {
    const ret = AccountKind.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_addListener_d78339dd4535b756 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).addListener(getStringFromWasm0(arg1, arg2), getObject(arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_address_new = function(arg0) {
    const ret = Address.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_advance_b3ccc91b80962d79 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).advance(arg1 >>> 0);
    }, arguments);
  };
  imports.wbg.__wbg_appendChild_8204974b7328bf98 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).appendChild(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_body_942ea927546a04ba = function(arg0) {
    const ret = getObject(arg0).body;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_cancelAnimationFrame_032049cb190240a7 = function(arg0) {
    cancelAnimationFrame(takeObject(arg0));
  };
  imports.wbg.__wbg_clearInterval_d472232e2fb5e5e4 = function() {
    return handleError(function(arg0) {
      clearInterval(getObject(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_clearTimeout_c5ac0f4b6a07b59e = function() {
    return handleError(function(arg0) {
      clearTimeout(getObject(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_close_0880036443561527 = function() {
    return handleError(function(arg0) {
      getObject(arg0).close();
    }, arguments);
  };
  imports.wbg.__wbg_continue_c46c11d3dbe1b030 = function() {
    return handleError(function(arg0) {
      getObject(arg0).continue();
    }, arguments);
  };
  imports.wbg.__wbg_count_613cb921d67a4f26 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).count();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createElement_8c9931a732ee2fea = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createIndex_873ac48adc772309 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject(arg0).createIndex(getStringFromWasm0(arg1, arg2), getObject(arg3), getObject(arg4));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectStore_e566459f7161f82f = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_6e98d2f9c7bd9764 = function() {
    return handleError(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject(arg1));
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_data_432d9c3df2630942 = function(arg0) {
    const ret = getObject(arg0).data;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_delete_200677093b4cf756 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).delete(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_delete_36c8630e530a2a1a = function(arg0, arg1) {
    const ret = getObject(arg0).delete(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_document_d249400bd7bd996d = function(arg0) {
    const ret = getObject(arg0).document;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_entries_3265d4158b33e5dc = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_entries_c8a90a7ed73e84ce = function(arg0) {
    const ret = getObject(arg0).entries();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_error_5edc95999c70d386 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_error_b5d62a6100a65a3b = function(arg0, arg1) {
    console.error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_error_ff4ddaabdfc5dbb3 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).error;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_existsSync_6b2031627aea3e5a = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).existsSync(getStringFromWasm0(arg1, arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_7bb58c5ed3c31810 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fromCodePoint_f37c25c172f2e8b5 = function() {
    return handleError(function(arg0) {
      const ret = String.fromCodePoint(arg0 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_from_2a5d3e218e67aa85 = function(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_from_d608a04300bfd9ac = function(arg0) {
    const ret = Buffer.from(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_generatorsummary_new = function(arg0) {
    const ret = GeneratorSummary.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getItem_17f98dee3b43fa7e = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg1).getItem(getStringFromWasm0(arg2, arg3));
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_get_13495dac72693ecc = function(arg0, arg1) {
    const ret = getObject(arg0).get(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_8da03f81f6a1111e = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).get(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_a8e28596722a45ff = function() {
    return handleError(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.get(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      } finally {
        wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_f1f75752f252b231 = function() {
    return handleError(function() {
      const ret = chrome.storage.local.get();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
    const ret = getObject(arg0)[getObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_global_b6f5c73312f62313 = function(arg0) {
    const ret = getObject(arg0).global;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_has_a5ea9117f258a0ec = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.has(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_hash_new = function(arg0) {
    const ret = Hash.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_index_e00ca5fff206ee3e = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).index(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_601ec26c63e333de = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_b1f49280282046f8 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_f6b47b0dc333fd2f = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_innerHTML_e1553352fe93921a = function(arg0, arg1) {
    const ret = getObject(arg1).innerHTML;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Map_f3469ce2244d2430 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Object_7f2dcef8f78644a4 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Object;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Response;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Window;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_is_c7481c65e7e5df9e = function(arg0, arg1) {
    const ret = Object.is(getObject(arg0), getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_key_c5e0a01cf450dca2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg1).key(arg2 >>> 0);
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_keys_5c77a08ddc2fb8a6 = function(arg0) {
    const ret = Object.keys(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_ed4a84b02b798bda = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_localStorage_1406c99c39728187 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).localStorage;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_location_350d99456c2f3693 = function(arg0) {
    const ret = getObject(arg0).location;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_log_6c164928aa7b57f4 = function(arg0, arg1) {
    console.log(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_mkdirSync_29d1fd92bf140bd0 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      getObject(arg0).mkdirSync(getStringFromWasm0(arg1, arg2), takeObject(arg3));
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_navigator_1577371c070c8947 = function(arg0) {
    const ret = getObject(arg0).navigator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_networkid_new = function(arg0) {
    const ret = NetworkId.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    const ret = /* @__PURE__ */ new Date();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() {
    return handleError(function() {
      const ret = new Headers();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_0b790fd655ff1a97 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new WebSocket(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = /* @__PURE__ */ __name$8((arg02, arg12) => {
        const a2 = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_199(a2, state0.b, arg02, arg12);
        } finally {
          state0.a = a2;
        }
      }, "cb0");
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_new_405e22f390576ce2 = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_5e0be73521bc8c17 = function() {
    const ret = /* @__PURE__ */ new Map();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_757fd34d47ff40d2 = function(arg0) {
    const ret = new ArrayBuffer(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_78feb108b6472713 = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b1a33e5095abf678 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Worker(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_e25e5aab09ff45db = function() {
    return handleError(function() {
      const ret = new AbortController();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_f5f8a7325e1cb479 = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithnodejsconfigimpl_b0a2d4e5b0763676 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      const ret = new WebSocket(getStringFromWasm0(arg0, arg1), takeObject(arg2), takeObject(arg3), takeObject(arg4), takeObject(arg5), takeObject(arg6));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrsequenceandoptions_aaff55b467c81b63 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Blob(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_6574e1a8a62d1055 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_nodedescriptor_new = function(arg0) {
    const ret = NodeDescriptor.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_now_807e54c39636c349 = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_now_d18023d54d4e5500 = function(arg0) {
    const ret = getObject(arg0).now();
    return ret;
  };
  imports.wbg.__wbg_objectStore_21878d46d25b64b6 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_oldVersion_e8337811e52861c6 = function(arg0) {
    const ret = getObject(arg0).oldVersion;
    return ret;
  };
  imports.wbg.__wbg_on_9ef8de87725b93b5 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).on(getStringFromWasm0(arg1, arg2), getObject(arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_once_8901720a31f56808 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).once(getStringFromWasm0(arg1, arg2), getObject(arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_openCursor_d8ea5d621ec422f8 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).openCursor(getObject(arg1), __wbindgen_enum_IdbCursorDirection[arg2]);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_open_e0c0b2993eb596e1 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2), arg3 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_pendingtransaction_new = function(arg0) {
    const ret = PendingTransaction.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_postMessage_6edafa8f7b9c2f52 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).postMessage(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_prependListener_dc1e8b094d0f731e = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).prependListener(getStringFromWasm0(arg1, arg2), getObject(arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_prependOnceListener_93873dc17dd2fcad = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).prependOnceListener(getStringFromWasm0(arg1, arg2), getObject(arg3));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_protocol_faa0494a9b2554cb = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg1).protocol;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_publickey_new = function(arg0) {
    const ret = PublicKey.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_put_066faa31a6a88f5b = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {
    queueMicrotask(getObject(arg0));
  };
  imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_readFileSync_42b340d959241f2b = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).readFileSync(getStringFromWasm0(arg1, arg2), takeObject(arg3));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readdir_319d9b13a44c9af9 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).readdir(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readyState_4013cfdf4f22afb0 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return (__wbindgen_enum_IdbRequestReadyState.indexOf(ret) + 1 || 3) - 1;
  };
  imports.wbg.__wbg_readyState_6c28968f3e6c1e47 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return ret;
  };
  imports.wbg.__wbg_removeAttribute_e419cd6726b4c62f = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).removeAttribute(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_removeItem_9d2669ee3bba6f7d = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).removeItem(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_remove_cb9af65ab98197c5 = function() {
    return handleError(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.remove(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      } finally {
        wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_renameSync_86e78b84a05e4a0b = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).renameSync(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_requestAnimationFrame_63a812187303a02c = function(arg0) {
    const ret = requestAnimationFrame(takeObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_05f2f70e92254dbb = function(arg0, arg1) {
    const ret = __require(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_11fc9008c54f5b90 = function(arg0, arg1) {
    const ret = __require(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_result_f29afabdf2c05826 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).result;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_rpcclient_new = function(arg0) {
    const ret = RpcClient.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_send_17f8c8c8e084cc5e = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).send(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_9a57107cc0d7eafa = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).send(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_afb0c27f2d9698e3 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).send(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setAttribute_2704501201f15687 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_setInterval_160c4baec24e25f6 = function() {
    return handleError(function(arg0, arg1) {
      const ret = setInterval(getObject(arg0), arg1 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_setItem_212ecc915942ab0a = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setItem(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_setTime_8afa2faa26e7eb59 = function(arg0, arg1) {
    const ret = getObject(arg0).setTime(arg1);
    return ret;
  };
  imports.wbg.__wbg_setTimeout_430dd4984e76f6c3 = function() {
    return handleError(function(arg0, arg1) {
      const ret = setTimeout(getObject(arg0), arg1 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_005c36bbcfafb768 = function() {
    return handleError(function(arg0) {
      const ret = chrome.storage.local.set(takeObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_set_8fc6bf8a5b1071d1 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_setbinaryType_9981a6ba2bd58b94 = function(arg0, arg1) {
    getObject(arg0).binaryType = __wbindgen_enum_BinaryType[arg1];
  };
  imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {
    getObject(arg0).body = getObject(arg1);
  };
  imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {
    getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];
  };
  imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {
    getObject(arg0).headers = getObject(arg1);
  };
  imports.wbg.__wbg_setinnerHTML_31bde41f835786f7 = function(arg0, arg1, arg2) {
    getObject(arg0).innerHTML = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {
    getObject(arg0).method = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {
    getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];
  };
  imports.wbg.__wbg_setonabort_3bf4db6614fa98e9 = function(arg0, arg1) {
    getObject(arg0).onabort = getObject(arg1);
  };
  imports.wbg.__wbg_setonblocked_aebf64bd39f1eca8 = function(arg0, arg1) {
    getObject(arg0).onblocked = getObject(arg1);
  };
  imports.wbg.__wbg_setonclose_b15bdabd419b6357 = function(arg0, arg1) {
    getObject(arg0).onclose = getObject(arg1);
  };
  imports.wbg.__wbg_setoncomplete_4d19df0dadb7c4d4 = function(arg0, arg1) {
    getObject(arg0).oncomplete = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_b0d9d723b8fddbbb = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_d7e3056cc6e56085 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_e2c5c0fa6fbf6d99 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonmessage_007594843a0b97e8 = function(arg0, arg1) {
    getObject(arg0).onmessage = getObject(arg1);
  };
  imports.wbg.__wbg_setonmessage_5a885b16bdc6dca6 = function(arg0, arg1) {
    getObject(arg0).onmessage = getObject(arg1);
  };
  imports.wbg.__wbg_setonopen_c42cfdbb28b087c4 = function(arg0, arg1) {
    getObject(arg0).onopen = getObject(arg1);
  };
  imports.wbg.__wbg_setonsuccess_afa464ee777a396d = function(arg0, arg1) {
    getObject(arg0).onsuccess = getObject(arg1);
  };
  imports.wbg.__wbg_setonupgradeneeded_fcf7ce4f2eb0cb5f = function(arg0, arg1) {
    getObject(arg0).onupgradeneeded = getObject(arg1);
  };
  imports.wbg.__wbg_setonversionchange_6ee07fa49ee1e3a5 = function(arg0, arg1) {
    getObject(arg0).onversionchange = getObject(arg1);
  };
  imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {
    getObject(arg0).signal = getObject(arg1);
  };
  imports.wbg.__wbg_settype_39ed370d3edd403c = function(arg0, arg1, arg2) {
    getObject(arg0).type = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setunique_dd24c422aa05df89 = function(arg0, arg1) {
    getObject(arg0).unique = arg1 !== 0;
  };
  imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_c99a96ed42647c4c = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_statSync_9a429acc496bafda = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).statSync(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_target_0a62d9d79a2a1ede = function(arg0) {
    const ret = getObject(arg0).target;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_text_7805bea50de2af49 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).text();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_toString_2f76f493957b63da = function(arg0, arg1, arg2) {
    const ret = getObject(arg1).toString(arg2);
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_toString_b5d4438bc26b267c = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).toString(arg1);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_babc423936946a37 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), __wbindgen_enum_IdbTransactionMode[arg3]);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_new = function(arg0) {
    const ret = Transaction.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactioninput_new = function(arg0) {
    const ret = TransactionInput.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactionoutput_new = function(arg0) {
    const ret = TransactionOutput.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactionrecordnotification_new = function(arg0) {
    const ret = TransactionRecordNotification.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_unlinkSync_656392e8d747415f = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).unlinkSync(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_update_acd72607f506872a = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).update(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_userAgent_12e9d8e62297563f = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg1).userAgent;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_utxoentryreference_new = function(arg0) {
    const ret = UtxoEntryReference.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_value_68c4e9a54bb7fd5e = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_walletdescriptor_new = function(arg0) {
    const ret = WalletDescriptor.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_warn_28319e260c89a4f8 = function(arg0, arg1) {
    console.warn(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_writeFileSync_6325b339950ab342 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).writeFileSync(getStringFromWasm0(arg1, arg2), takeObject(arg3), takeObject(arg4));
    }, arguments);
  };
  imports.wbg.__wbindgen_array_new = function() {
    const ret = [];
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_array_push = function(arg0, arg1) {
    getObject(arg0).push(takeObject(arg1));
  };
  imports.wbg.__wbindgen_as_number = function(arg0) {
    const ret = +getObject(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbindgen_closure_wrapper16385 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6406, __wbg_adapter_78);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17150 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_81);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17152 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_84);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17154 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_87);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17515 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6560, __wbg_adapter_90);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17516 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6560, __wbg_adapter_90);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper4216 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1320, __wbg_adapter_75);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper826 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 182, __wbg_adapter_66);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 237, __wbg_adapter_69);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper949 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 237, __wbg_adapter_72);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject(arg0) in getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_is_array = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_is_falsy = function(arg0) {
    const ret = !getObject(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_lt = function(arg0, arg1) {
    const ret = getObject(arg0) < getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_neg = function(arg0) {
    const ret = -getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_try_into_number = function(arg0) {
    let result;
    try {
      result = +getObject(arg0);
    } catch (e2) {
      result = e2;
    }
    const ret = result;
    return addHeapObject(ret);
  };
  return imports;
}
function __wbg_init_memory(imports, memory) {
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  return wasm;
}
function initSync(module2) {
  if (wasm !== void 0) return wasm;
  if (typeof module2 !== "undefined") {
    if (Object.getPrototypeOf(module2) === Object.prototype) {
      ({ module: module2 } = module2);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports = __wbg_get_imports();
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init(instance, module2);
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("kaspa_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module2);
}
var wasm, heap, heap_next, WASM_VECTOR_LEN, cachedUint8ArrayMemory0, cachedTextEncoder, encodeString, cachedDataViewMemory0, cachedTextDecoder, CLOSURE_DTORS, stack_pointer, AccountsDiscoveryKind, AddressVersion, CommitRevealAddressKind, ConnectStrategy, Encoding, FeeSource, Language, NetworkType, NewAddressKind, Opcodes, SighashType, __wbindgen_enum_BinaryType, __wbindgen_enum_IdbCursorDirection, __wbindgen_enum_IdbRequestReadyState, __wbindgen_enum_IdbTransactionMode, __wbindgen_enum_RequestCredentials, __wbindgen_enum_RequestMode, AbortableFinalization, Abortable, AbortedFinalization, Aborted, AccountKindFinalization, AccountKind, AddressFinalization, Address, AgentConstructorOptionsFinalization, AgentConstructorOptions, AppendFileOptionsFinalization, AppendFileOptions, AssertionErrorOptionsFinalization, AssertionErrorOptions, BalanceFinalization, Balance, BalanceStringsFinalization, BalanceStrings, ConsoleConstructorOptionsFinalization, ConsoleConstructorOptions, CreateHookCallbacksFinalization, CreateHookCallbacks, CreateReadStreamOptionsFinalization, CreateReadStreamOptions, CreateWriteStreamOptionsFinalization, CreateWriteStreamOptions, CryptoBoxFinalization, CryptoBox, CryptoBoxPrivateKeyFinalization, CryptoBoxPrivateKey, CryptoBoxPublicKeyFinalization, CryptoBoxPublicKey, DerivationPathFinalization, DerivationPath, FormatInputPathObjectFinalization, FormatInputPathObject, GeneratorFinalization, Generator, GeneratorSummaryFinalization, GeneratorSummary, GetNameOptionsFinalization, GetNameOptions, HashFinalization, Hash, HeaderFinalization, Header, KeypairFinalization, Keypair, MkdtempSyncOptionsFinalization, MkdtempSyncOptions, MnemonicFinalization, Mnemonic$1, NetServerOptionsFinalization, NetServerOptions, NetworkIdFinalization, NetworkId, NodeDescriptorFinalization, NodeDescriptor, PSKBFinalization, PSKB, PSKTFinalization, PSKT, PaymentOutputFinalization, PaymentOutput, PaymentOutputsFinalization, PaymentOutputs, PendingTransactionFinalization, PendingTransaction, PipeOptionsFinalization, PipeOptions, PoWFinalization, PoW, PrivateKeyFinalization, PrivateKey, PrivateKeyGeneratorFinalization, PrivateKeyGenerator, ProcessSendOptionsFinalization, ProcessSendOptions, PrvKeyDataInfoFinalization, PrvKeyDataInfo, PublicKeyFinalization, PublicKey, PublicKeyGeneratorFinalization, PublicKeyGenerator, ReadStreamFinalization, ReadStream, ResolverFinalization, Resolver, RpcClientFinalization, RpcClient, ScriptBuilderFinalization, ScriptBuilder, ScriptPublicKeyFinalization, ScriptPublicKey, SetAadOptionsFinalization, SetAadOptions, SigHashTypeFinalization, SigHashType, StorageFinalization, Storage, StreamTransformOptionsFinalization, StreamTransformOptions, TransactionFinalization, Transaction, TransactionInputFinalization, TransactionInput, TransactionOutpointFinalization, TransactionOutpoint, TransactionOutputFinalization, TransactionOutput, TransactionRecordFinalization, TransactionRecord, TransactionRecordNotificationFinalization, TransactionRecordNotification, TransactionSigningHashFinalization, TransactionSigningHash, TransactionSigningHashECDSAFinalization, TransactionSigningHashECDSA, TransactionUtxoEntryFinalization, TransactionUtxoEntry, UserInfoOptionsFinalization, UserInfoOptions, UtxoContextFinalization, UtxoContext, UtxoEntriesFinalization, UtxoEntries, UtxoEntryFinalization, UtxoEntry, UtxoEntryReferenceFinalization, UtxoEntryReference, UtxoProcessorFinalization, UtxoProcessor, WalletFinalization, Wallet$1, WalletDescriptorFinalization, WalletDescriptor, WasiOptionsFinalization, WasiOptions, WriteFileSyncOptionsFinalization, WriteFileSyncOptions, WriteStreamFinalization, WriteStream, XOnlyPublicKeyFinalization, XOnlyPublicKey, XPrvFinalization, XPrv, XPubFinalization, XPub, kaspa_default;
var init_kaspa = __esm({
  "web/kaspa.js"() {
    heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    __name$8(getObject, "getObject");
    heap_next = heap.length;
    __name$8(addHeapObject, "addHeapObject");
    __name$8(handleError, "handleError");
    WASM_VECTOR_LEN = 0;
    cachedUint8ArrayMemory0 = null;
    __name$8(getUint8ArrayMemory0, "getUint8ArrayMemory0");
    cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: /* @__PURE__ */ __name$8(() => {
      throw Error("TextEncoder not available");
    }, "encode") };
    encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    __name$8(passStringToWasm0, "passStringToWasm0");
    cachedDataViewMemory0 = null;
    __name$8(getDataViewMemory0, "getDataViewMemory0");
    cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: /* @__PURE__ */ __name$8(() => {
      throw Error("TextDecoder not available");
    }, "decode") };
    if (typeof TextDecoder !== "undefined") {
      cachedTextDecoder.decode();
    }
    __name$8(getStringFromWasm0, "getStringFromWasm0");
    __name$8(isLikeNone, "isLikeNone");
    __name$8(dropObject, "dropObject");
    __name$8(takeObject, "takeObject");
    __name$8(getArrayU8FromWasm0, "getArrayU8FromWasm0");
    CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((state) => {
      wasm.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
    });
    __name$8(makeMutClosure, "makeMutClosure");
    __name$8(makeClosure, "makeClosure");
    __name$8(debugString, "debugString");
    __name$8(_assertClass, "_assertClass");
    stack_pointer = 128;
    __name$8(addBorrowedObject, "addBorrowedObject");
    __name$8(isScriptPayToScriptHash, "isScriptPayToScriptHash");
    __name$8(isScriptPayToPubkeyECDSA, "isScriptPayToPubkeyECDSA");
    __name$8(isScriptPayToPubkey, "isScriptPayToPubkey");
    __name$8(addressFromScriptPublicKey, "addressFromScriptPublicKey");
    __name$8(payToScriptHashSignatureScript, "payToScriptHashSignatureScript");
    __name$8(payToScriptHashScript, "payToScriptHashScript");
    __name$8(payToAddressScript, "payToAddressScript");
    __name$8(calculateTarget, "calculateTarget");
    __name$8(argon2sha256ivFromText, "argon2sha256ivFromText");
    __name$8(argon2sha256ivFromBinary, "argon2sha256ivFromBinary");
    __name$8(sha256dFromText, "sha256dFromText");
    __name$8(sha256dFromBinary, "sha256dFromBinary");
    __name$8(sha256FromText, "sha256FromText");
    __name$8(sha256FromBinary, "sha256FromBinary");
    __name$8(decryptXChaCha20Poly1305, "decryptXChaCha20Poly1305");
    __name$8(encryptXChaCha20Poly1305, "encryptXChaCha20Poly1305");
    __name$8(calculateStorageMass, "calculateStorageMass");
    __name$8(calculateTransactionFee, "calculateTransactionFee");
    __name$8(updateTransactionMass, "updateTransactionMass");
    __name$8(calculateTransactionMass, "calculateTransactionMass");
    __name$8(maximumStandardTransactionMass, "maximumStandardTransactionMass");
    __name$8(signScriptHash, "signScriptHash");
    __name$8(createInputSignature, "createInputSignature");
    __name$8(signTransaction, "signTransaction");
    __name$8(createAddress, "createAddress");
    __name$8(createMultisigAddress, "createMultisigAddress");
    __name$8(getTransactionMaturityProgress, "getTransactionMaturityProgress");
    __name$8(getNetworkParams, "getNetworkParams");
    __name$8(sompiToKaspaStringWithSuffix, "sompiToKaspaStringWithSuffix");
    __name$8(sompiToKaspaString, "sompiToKaspaString");
    __name$8(kaspaToSompi, "kaspaToSompi");
    __name$8(estimateTransactions, "estimateTransactions");
    __name$8(createTransactions, "createTransactions");
    __name$8(createTransaction, "createTransaction");
    __name$8(setDefaultStorageFolder, "setDefaultStorageFolder");
    __name$8(setDefaultWalletFile, "setDefaultWalletFile");
    __name$8(verifyMessage, "verifyMessage");
    __name$8(signMessage, "signMessage");
    __name$8(version, "version");
    __name$8(passArrayJsValueToWasm0, "passArrayJsValueToWasm0");
    __name$8(getArrayJsValueFromWasm0, "getArrayJsValueFromWasm0");
    __name$8(setLogLevel, "setLogLevel");
    __name$8(initWASM32Bindings, "initWASM32Bindings");
    __name$8(initConsolePanicHook, "initConsolePanicHook");
    __name$8(initBrowserPanicHook, "initBrowserPanicHook");
    __name$8(presentPanicHookLogs, "presentPanicHookLogs");
    __name$8(defer, "defer");
    __name$8(__wbg_adapter_66, "__wbg_adapter_66");
    __name$8(__wbg_adapter_69, "__wbg_adapter_69");
    __name$8(__wbg_adapter_72, "__wbg_adapter_72");
    __name$8(__wbg_adapter_75, "__wbg_adapter_75");
    __name$8(__wbg_adapter_78, "__wbg_adapter_78");
    __name$8(__wbg_adapter_81, "__wbg_adapter_81");
    __name$8(__wbg_adapter_84, "__wbg_adapter_84");
    __name$8(__wbg_adapter_87, "__wbg_adapter_87");
    __name$8(__wbg_adapter_90, "__wbg_adapter_90");
    __name$8(__wbg_adapter_199, "__wbg_adapter_199");
    AccountsDiscoveryKind = Object.freeze({
      Bip44: 0,
      "0": "Bip44"
    });
    AddressVersion = Object.freeze({
      /**
       * PubKey addresses always have the version byte set to 0
       */
      PubKey: 0,
      "0": "PubKey",
      /**
       * PubKey ECDSA addresses always have the version byte set to 1
       */
      PubKeyECDSA: 1,
      "1": "PubKeyECDSA",
      /**
       * ScriptHash addresses always have the version byte set to 8
       */
      ScriptHash: 8,
      "8": "ScriptHash"
    });
    CommitRevealAddressKind = Object.freeze({
      Receive: 0,
      "0": "Receive",
      Change: 1,
      "1": "Change"
    });
    ConnectStrategy = Object.freeze({
      /**
       * Continuously attempt to connect to the server. This behavior will
       * block `connect()` function until the connection is established.
       */
      Retry: 0,
      "0": "Retry",
      /**
       * Causes `connect()` to return immediately if the first-time connection
       * has failed.
       */
      Fallback: 1,
      "1": "Fallback"
    });
    Encoding = Object.freeze({
      Borsh: 0,
      "0": "Borsh",
      SerdeJson: 1,
      "1": "SerdeJson"
    });
    FeeSource = Object.freeze({
      SenderPays: 0,
      "0": "SenderPays",
      ReceiverPays: 1,
      "1": "ReceiverPays"
    });
    Language = Object.freeze({
      /**
       * English is presently the only supported language
       */
      English: 0,
      "0": "English"
    });
    NetworkType = Object.freeze({
      Mainnet: 0,
      "0": "Mainnet",
      Testnet: 1,
      "1": "Testnet",
      Devnet: 2,
      "2": "Devnet",
      Simnet: 3,
      "3": "Simnet"
    });
    NewAddressKind = Object.freeze({
      Receive: 0,
      "0": "Receive",
      Change: 1,
      "1": "Change"
    });
    Opcodes = Object.freeze({
      OpFalse: 0,
      "0": "OpFalse",
      OpData1: 1,
      "1": "OpData1",
      OpData2: 2,
      "2": "OpData2",
      OpData3: 3,
      "3": "OpData3",
      OpData4: 4,
      "4": "OpData4",
      OpData5: 5,
      "5": "OpData5",
      OpData6: 6,
      "6": "OpData6",
      OpData7: 7,
      "7": "OpData7",
      OpData8: 8,
      "8": "OpData8",
      OpData9: 9,
      "9": "OpData9",
      OpData10: 10,
      "10": "OpData10",
      OpData11: 11,
      "11": "OpData11",
      OpData12: 12,
      "12": "OpData12",
      OpData13: 13,
      "13": "OpData13",
      OpData14: 14,
      "14": "OpData14",
      OpData15: 15,
      "15": "OpData15",
      OpData16: 16,
      "16": "OpData16",
      OpData17: 17,
      "17": "OpData17",
      OpData18: 18,
      "18": "OpData18",
      OpData19: 19,
      "19": "OpData19",
      OpData20: 20,
      "20": "OpData20",
      OpData21: 21,
      "21": "OpData21",
      OpData22: 22,
      "22": "OpData22",
      OpData23: 23,
      "23": "OpData23",
      OpData24: 24,
      "24": "OpData24",
      OpData25: 25,
      "25": "OpData25",
      OpData26: 26,
      "26": "OpData26",
      OpData27: 27,
      "27": "OpData27",
      OpData28: 28,
      "28": "OpData28",
      OpData29: 29,
      "29": "OpData29",
      OpData30: 30,
      "30": "OpData30",
      OpData31: 31,
      "31": "OpData31",
      OpData32: 32,
      "32": "OpData32",
      OpData33: 33,
      "33": "OpData33",
      OpData34: 34,
      "34": "OpData34",
      OpData35: 35,
      "35": "OpData35",
      OpData36: 36,
      "36": "OpData36",
      OpData37: 37,
      "37": "OpData37",
      OpData38: 38,
      "38": "OpData38",
      OpData39: 39,
      "39": "OpData39",
      OpData40: 40,
      "40": "OpData40",
      OpData41: 41,
      "41": "OpData41",
      OpData42: 42,
      "42": "OpData42",
      OpData43: 43,
      "43": "OpData43",
      OpData44: 44,
      "44": "OpData44",
      OpData45: 45,
      "45": "OpData45",
      OpData46: 46,
      "46": "OpData46",
      OpData47: 47,
      "47": "OpData47",
      OpData48: 48,
      "48": "OpData48",
      OpData49: 49,
      "49": "OpData49",
      OpData50: 50,
      "50": "OpData50",
      OpData51: 51,
      "51": "OpData51",
      OpData52: 52,
      "52": "OpData52",
      OpData53: 53,
      "53": "OpData53",
      OpData54: 54,
      "54": "OpData54",
      OpData55: 55,
      "55": "OpData55",
      OpData56: 56,
      "56": "OpData56",
      OpData57: 57,
      "57": "OpData57",
      OpData58: 58,
      "58": "OpData58",
      OpData59: 59,
      "59": "OpData59",
      OpData60: 60,
      "60": "OpData60",
      OpData61: 61,
      "61": "OpData61",
      OpData62: 62,
      "62": "OpData62",
      OpData63: 63,
      "63": "OpData63",
      OpData64: 64,
      "64": "OpData64",
      OpData65: 65,
      "65": "OpData65",
      OpData66: 66,
      "66": "OpData66",
      OpData67: 67,
      "67": "OpData67",
      OpData68: 68,
      "68": "OpData68",
      OpData69: 69,
      "69": "OpData69",
      OpData70: 70,
      "70": "OpData70",
      OpData71: 71,
      "71": "OpData71",
      OpData72: 72,
      "72": "OpData72",
      OpData73: 73,
      "73": "OpData73",
      OpData74: 74,
      "74": "OpData74",
      OpData75: 75,
      "75": "OpData75",
      OpPushData1: 76,
      "76": "OpPushData1",
      OpPushData2: 77,
      "77": "OpPushData2",
      OpPushData4: 78,
      "78": "OpPushData4",
      Op1Negate: 79,
      "79": "Op1Negate",
      OpReserved: 80,
      "80": "OpReserved",
      OpTrue: 81,
      "81": "OpTrue",
      Op2: 82,
      "82": "Op2",
      Op3: 83,
      "83": "Op3",
      Op4: 84,
      "84": "Op4",
      Op5: 85,
      "85": "Op5",
      Op6: 86,
      "86": "Op6",
      Op7: 87,
      "87": "Op7",
      Op8: 88,
      "88": "Op8",
      Op9: 89,
      "89": "Op9",
      Op10: 90,
      "90": "Op10",
      Op11: 91,
      "91": "Op11",
      Op12: 92,
      "92": "Op12",
      Op13: 93,
      "93": "Op13",
      Op14: 94,
      "94": "Op14",
      Op15: 95,
      "95": "Op15",
      Op16: 96,
      "96": "Op16",
      OpNop: 97,
      "97": "OpNop",
      OpVer: 98,
      "98": "OpVer",
      OpIf: 99,
      "99": "OpIf",
      OpNotIf: 100,
      "100": "OpNotIf",
      OpVerIf: 101,
      "101": "OpVerIf",
      OpVerNotIf: 102,
      "102": "OpVerNotIf",
      OpElse: 103,
      "103": "OpElse",
      OpEndIf: 104,
      "104": "OpEndIf",
      OpVerify: 105,
      "105": "OpVerify",
      OpReturn: 106,
      "106": "OpReturn",
      OpToAltStack: 107,
      "107": "OpToAltStack",
      OpFromAltStack: 108,
      "108": "OpFromAltStack",
      Op2Drop: 109,
      "109": "Op2Drop",
      Op2Dup: 110,
      "110": "Op2Dup",
      Op3Dup: 111,
      "111": "Op3Dup",
      Op2Over: 112,
      "112": "Op2Over",
      Op2Rot: 113,
      "113": "Op2Rot",
      Op2Swap: 114,
      "114": "Op2Swap",
      OpIfDup: 115,
      "115": "OpIfDup",
      OpDepth: 116,
      "116": "OpDepth",
      OpDrop: 117,
      "117": "OpDrop",
      OpDup: 118,
      "118": "OpDup",
      OpNip: 119,
      "119": "OpNip",
      OpOver: 120,
      "120": "OpOver",
      OpPick: 121,
      "121": "OpPick",
      OpRoll: 122,
      "122": "OpRoll",
      OpRot: 123,
      "123": "OpRot",
      OpSwap: 124,
      "124": "OpSwap",
      OpTuck: 125,
      "125": "OpTuck",
      /**
       * Splice opcodes.
       */
      OpCat: 126,
      "126": "OpCat",
      OpSubStr: 127,
      "127": "OpSubStr",
      OpLeft: 128,
      "128": "OpLeft",
      OpRight: 129,
      "129": "OpRight",
      OpSize: 130,
      "130": "OpSize",
      /**
       * Bitwise logic opcodes.
       */
      OpInvert: 131,
      "131": "OpInvert",
      OpAnd: 132,
      "132": "OpAnd",
      OpOr: 133,
      "133": "OpOr",
      OpXor: 134,
      "134": "OpXor",
      OpEqual: 135,
      "135": "OpEqual",
      OpEqualVerify: 136,
      "136": "OpEqualVerify",
      OpReserved1: 137,
      "137": "OpReserved1",
      OpReserved2: 138,
      "138": "OpReserved2",
      /**
       * Numeric related opcodes.
       */
      Op1Add: 139,
      "139": "Op1Add",
      Op1Sub: 140,
      "140": "Op1Sub",
      Op2Mul: 141,
      "141": "Op2Mul",
      Op2Div: 142,
      "142": "Op2Div",
      OpNegate: 143,
      "143": "OpNegate",
      OpAbs: 144,
      "144": "OpAbs",
      OpNot: 145,
      "145": "OpNot",
      Op0NotEqual: 146,
      "146": "Op0NotEqual",
      OpAdd: 147,
      "147": "OpAdd",
      OpSub: 148,
      "148": "OpSub",
      OpMul: 149,
      "149": "OpMul",
      OpDiv: 150,
      "150": "OpDiv",
      OpMod: 151,
      "151": "OpMod",
      OpLShift: 152,
      "152": "OpLShift",
      OpRShift: 153,
      "153": "OpRShift",
      OpBoolAnd: 154,
      "154": "OpBoolAnd",
      OpBoolOr: 155,
      "155": "OpBoolOr",
      OpNumEqual: 156,
      "156": "OpNumEqual",
      OpNumEqualVerify: 157,
      "157": "OpNumEqualVerify",
      OpNumNotEqual: 158,
      "158": "OpNumNotEqual",
      OpLessThan: 159,
      "159": "OpLessThan",
      OpGreaterThan: 160,
      "160": "OpGreaterThan",
      OpLessThanOrEqual: 161,
      "161": "OpLessThanOrEqual",
      OpGreaterThanOrEqual: 162,
      "162": "OpGreaterThanOrEqual",
      OpMin: 163,
      "163": "OpMin",
      OpMax: 164,
      "164": "OpMax",
      OpWithin: 165,
      "165": "OpWithin",
      /**
       * Undefined opcodes.
       */
      OpUnknown166: 166,
      "166": "OpUnknown166",
      OpUnknown167: 167,
      "167": "OpUnknown167",
      /**
       * Crypto opcodes.
       */
      OpSHA256: 168,
      "168": "OpSHA256",
      OpCheckMultiSigECDSA: 169,
      "169": "OpCheckMultiSigECDSA",
      OpBlake2b: 170,
      "170": "OpBlake2b",
      OpCheckSigECDSA: 171,
      "171": "OpCheckSigECDSA",
      OpCheckSig: 172,
      "172": "OpCheckSig",
      OpCheckSigVerify: 173,
      "173": "OpCheckSigVerify",
      OpCheckMultiSig: 174,
      "174": "OpCheckMultiSig",
      OpCheckMultiSigVerify: 175,
      "175": "OpCheckMultiSigVerify",
      OpCheckLockTimeVerify: 176,
      "176": "OpCheckLockTimeVerify",
      OpCheckSequenceVerify: 177,
      "177": "OpCheckSequenceVerify",
      /**
       * Undefined opcodes.
       */
      OpUnknown178: 178,
      "178": "OpUnknown178",
      OpUnknown179: 179,
      "179": "OpUnknown179",
      OpUnknown180: 180,
      "180": "OpUnknown180",
      OpUnknown181: 181,
      "181": "OpUnknown181",
      OpUnknown182: 182,
      "182": "OpUnknown182",
      OpUnknown183: 183,
      "183": "OpUnknown183",
      OpUnknown184: 184,
      "184": "OpUnknown184",
      OpUnknown185: 185,
      "185": "OpUnknown185",
      OpUnknown186: 186,
      "186": "OpUnknown186",
      OpUnknown187: 187,
      "187": "OpUnknown187",
      OpUnknown188: 188,
      "188": "OpUnknown188",
      OpUnknown189: 189,
      "189": "OpUnknown189",
      OpUnknown190: 190,
      "190": "OpUnknown190",
      OpUnknown191: 191,
      "191": "OpUnknown191",
      OpUnknown192: 192,
      "192": "OpUnknown192",
      OpUnknown193: 193,
      "193": "OpUnknown193",
      OpUnknown194: 194,
      "194": "OpUnknown194",
      OpUnknown195: 195,
      "195": "OpUnknown195",
      OpUnknown196: 196,
      "196": "OpUnknown196",
      OpUnknown197: 197,
      "197": "OpUnknown197",
      OpUnknown198: 198,
      "198": "OpUnknown198",
      OpUnknown199: 199,
      "199": "OpUnknown199",
      OpUnknown200: 200,
      "200": "OpUnknown200",
      OpUnknown201: 201,
      "201": "OpUnknown201",
      OpUnknown202: 202,
      "202": "OpUnknown202",
      OpUnknown203: 203,
      "203": "OpUnknown203",
      OpUnknown204: 204,
      "204": "OpUnknown204",
      OpUnknown205: 205,
      "205": "OpUnknown205",
      OpUnknown206: 206,
      "206": "OpUnknown206",
      OpUnknown207: 207,
      "207": "OpUnknown207",
      OpUnknown208: 208,
      "208": "OpUnknown208",
      OpUnknown209: 209,
      "209": "OpUnknown209",
      OpUnknown210: 210,
      "210": "OpUnknown210",
      OpUnknown211: 211,
      "211": "OpUnknown211",
      OpUnknown212: 212,
      "212": "OpUnknown212",
      OpUnknown213: 213,
      "213": "OpUnknown213",
      OpUnknown214: 214,
      "214": "OpUnknown214",
      OpUnknown215: 215,
      "215": "OpUnknown215",
      OpUnknown216: 216,
      "216": "OpUnknown216",
      OpUnknown217: 217,
      "217": "OpUnknown217",
      OpUnknown218: 218,
      "218": "OpUnknown218",
      OpUnknown219: 219,
      "219": "OpUnknown219",
      OpUnknown220: 220,
      "220": "OpUnknown220",
      OpUnknown221: 221,
      "221": "OpUnknown221",
      OpUnknown222: 222,
      "222": "OpUnknown222",
      OpUnknown223: 223,
      "223": "OpUnknown223",
      OpUnknown224: 224,
      "224": "OpUnknown224",
      OpUnknown225: 225,
      "225": "OpUnknown225",
      OpUnknown226: 226,
      "226": "OpUnknown226",
      OpUnknown227: 227,
      "227": "OpUnknown227",
      OpUnknown228: 228,
      "228": "OpUnknown228",
      OpUnknown229: 229,
      "229": "OpUnknown229",
      OpUnknown230: 230,
      "230": "OpUnknown230",
      OpUnknown231: 231,
      "231": "OpUnknown231",
      OpUnknown232: 232,
      "232": "OpUnknown232",
      OpUnknown233: 233,
      "233": "OpUnknown233",
      OpUnknown234: 234,
      "234": "OpUnknown234",
      OpUnknown235: 235,
      "235": "OpUnknown235",
      OpUnknown236: 236,
      "236": "OpUnknown236",
      OpUnknown237: 237,
      "237": "OpUnknown237",
      OpUnknown238: 238,
      "238": "OpUnknown238",
      OpUnknown239: 239,
      "239": "OpUnknown239",
      OpUnknown240: 240,
      "240": "OpUnknown240",
      OpUnknown241: 241,
      "241": "OpUnknown241",
      OpUnknown242: 242,
      "242": "OpUnknown242",
      OpUnknown243: 243,
      "243": "OpUnknown243",
      OpUnknown244: 244,
      "244": "OpUnknown244",
      OpUnknown245: 245,
      "245": "OpUnknown245",
      OpUnknown246: 246,
      "246": "OpUnknown246",
      OpUnknown247: 247,
      "247": "OpUnknown247",
      OpUnknown248: 248,
      "248": "OpUnknown248",
      OpUnknown249: 249,
      "249": "OpUnknown249",
      OpSmallInteger: 250,
      "250": "OpSmallInteger",
      OpPubKeys: 251,
      "251": "OpPubKeys",
      OpUnknown252: 252,
      "252": "OpUnknown252",
      OpPubKeyHash: 253,
      "253": "OpPubKeyHash",
      OpPubKey: 254,
      "254": "OpPubKey",
      OpInvalidOpCode: 255,
      "255": "OpInvalidOpCode"
    });
    SighashType = Object.freeze({
      All: 0,
      "0": "All",
      None: 1,
      "1": "None",
      Single: 2,
      "2": "Single",
      AllAnyOneCanPay: 3,
      "3": "AllAnyOneCanPay",
      NoneAnyOneCanPay: 4,
      "4": "NoneAnyOneCanPay",
      SingleAnyOneCanPay: 5,
      "5": "SingleAnyOneCanPay"
    });
    __wbindgen_enum_BinaryType = ["blob", "arraybuffer"];
    __wbindgen_enum_IdbCursorDirection = ["next", "nextunique", "prev", "prevunique"];
    __wbindgen_enum_IdbRequestReadyState = ["pending", "done"];
    __wbindgen_enum_IdbTransactionMode = ["readonly", "readwrite", "versionchange", "readwriteflush", "cleanup"];
    __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];
    __wbindgen_enum_RequestMode = ["same-origin", "no-cors", "cors", "navigate"];
    AbortableFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_abortable_free(ptr >>> 0, 1));
    Abortable = class {
      static {
        __name$8(this, "Abortable");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AbortableFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_abortable_free(ptr, 0);
      }
      constructor() {
        const ret = wasm.abortable_new();
        this.__wbg_ptr = ret >>> 0;
        AbortableFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean}
       */
      isAborted() {
        const ret = wasm.abortable_isAborted(this.__wbg_ptr);
        return ret !== 0;
      }
      abort() {
        wasm.abortable_abort(this.__wbg_ptr);
      }
      check() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.abortable_check(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      reset() {
        wasm.abortable_reset(this.__wbg_ptr);
      }
    };
    AbortedFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_aborted_free(ptr >>> 0, 1));
    Aborted = class _Aborted {
      static {
        __name$8(this, "Aborted");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Aborted.prototype);
        obj.__wbg_ptr = ptr;
        AbortedFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AbortedFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_aborted_free(ptr, 0);
      }
    };
    AccountKindFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_accountkind_free(ptr >>> 0, 1));
    AccountKind = class _AccountKind {
      static {
        __name$8(this, "AccountKind");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_AccountKind.prototype);
        obj.__wbg_ptr = ptr;
        AccountKindFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AccountKindFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_accountkind_free(ptr, 0);
      }
      /**
       * @param {string} kind
       */
      constructor(kind) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(kind, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.accountkind_ctor(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          AccountKindFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.accountkind_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    AddressFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_address_free(ptr >>> 0, 1));
    Address = class _Address {
      static {
        __name$8(this, "Address");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Address.prototype);
        obj.__wbg_ptr = ptr;
        AddressFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          version: this.version,
          prefix: this.prefix,
          payload: this.payload
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddressFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_address_free(ptr, 0);
      }
      /**
       * @param {string} address
       */
      constructor(address) {
        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_constructor(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        AddressFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {string} address
       * @returns {boolean}
       */
      static validate(address) {
        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.address_validate(ptr0, len0);
        return ret !== 0;
      }
      /**
       * Convert an address to a string.
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.address_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get version() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.address_version(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get prefix() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.address_prefix(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} prefix
       */
      set setPrefix(prefix) {
        const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.address_set_setPrefix(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string}
       */
      get payload() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.address_payload(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {number} n
       * @returns {string}
       */
      short(n2) {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.address_short(retptr, this.__wbg_ptr, n2);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    AgentConstructorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_agentconstructoroptions_free(ptr >>> 0, 1));
    AgentConstructorOptions = class {
      static {
        __name$8(this, "AgentConstructorOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AgentConstructorOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_agentconstructoroptions_free(ptr, 0);
      }
      /**
       * @returns {number}
       */
      get keep_alive_msecs() {
        const ret = wasm.agentconstructoroptions_keep_alive_msecs(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set keep_alive_msecs(value2) {
        wasm.agentconstructoroptions_set_keep_alive_msecs(this.__wbg_ptr, value2);
      }
      /**
       * @returns {boolean}
       */
      get keep_alive() {
        const ret = wasm.agentconstructoroptions_keep_alive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} value
       */
      set keep_alive(value2) {
        wasm.agentconstructoroptions_set_keep_alive(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get max_free_sockets() {
        const ret = wasm.agentconstructoroptions_max_free_sockets(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set max_free_sockets(value2) {
        wasm.agentconstructoroptions_set_max_free_sockets(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get max_sockets() {
        const ret = wasm.agentconstructoroptions_max_sockets(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set max_sockets(value2) {
        wasm.agentconstructoroptions_set_max_sockets(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get timeout() {
        const ret = wasm.agentconstructoroptions_timeout(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set timeout(value2) {
        wasm.agentconstructoroptions_set_timeout(this.__wbg_ptr, value2);
      }
    };
    AppendFileOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_appendfileoptions_free(ptr >>> 0, 1));
    AppendFileOptions = class _AppendFileOptions {
      static {
        __name$8(this, "AppendFileOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_AppendFileOptions.prototype);
        obj.__wbg_ptr = ptr;
        AppendFileOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AppendFileOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_appendfileoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       * @param {number | null} [mode]
       * @param {string | null} [flag]
       */
      constructor(encoding, mode, flag) {
        const ret = wasm.appendfileoptions_new_with_values(isLikeNone(encoding) ? 0 : addHeapObject(encoding), isLikeNone(mode) ? 4294967297 : mode >>> 0, isLikeNone(flag) ? 0 : addHeapObject(flag));
        this.__wbg_ptr = ret >>> 0;
        AppendFileOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {AppendFileOptions}
       */
      static new() {
        const ret = wasm.appendfileoptions_new();
        return _AppendFileOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.appendfileoptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.appendfileoptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm.appendfileoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm.appendfileoptions_set_mode(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flag() {
        const ret = wasm.appendfileoptions_flag(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flag(value2) {
        wasm.appendfileoptions_set_flag(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
    };
    AssertionErrorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_assertionerroroptions_free(ptr >>> 0, 1));
    AssertionErrorOptions = class {
      static {
        __name$8(this, "AssertionErrorOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AssertionErrorOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_assertionerroroptions_free(ptr, 0);
      }
      /**
       * @param {string | null | undefined} message
       * @param {any} actual
       * @param {any} expected
       * @param {string} operator
       */
      constructor(message2, actual, expected, operator) {
        const ret = wasm.assertionerroroptions_new(isLikeNone(message2) ? 0 : addHeapObject(message2), addHeapObject(actual), addHeapObject(expected), addHeapObject(operator));
        this.__wbg_ptr = ret >>> 0;
        AssertionErrorOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * If provided, the error message is set to this value.
       * @returns {string | undefined}
       */
      get message() {
        const ret = wasm.assertionerroroptions_message(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set message(value2) {
        wasm.assertionerroroptions_set_message(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * The actual property on the error instance.
       * @returns {any}
       */
      get actual() {
        const ret = wasm.assertionerroroptions_actual(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} value
       */
      set actual(value2) {
        wasm.assertionerroroptions_set_actual(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * The expected property on the error instance.
       * @returns {any}
       */
      get expected() {
        const ret = wasm.assertionerroroptions_expected(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} value
       */
      set expected(value2) {
        wasm.assertionerroroptions_set_expected(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * The operator property on the error instance.
       * @returns {string}
       */
      get operator() {
        const ret = wasm.assertionerroroptions_operator(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string} value
       */
      set operator(value2) {
        wasm.assertionerroroptions_set_operator(this.__wbg_ptr, addHeapObject(value2));
      }
    };
    BalanceFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_balance_free(ptr >>> 0, 1));
    Balance = class _Balance {
      static {
        __name$8(this, "Balance");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Balance.prototype);
        obj.__wbg_ptr = ptr;
        BalanceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BalanceFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_balance_free(ptr, 0);
      }
      /**
       * Confirmed amount of funds available for spending.
       * @returns {bigint}
       */
      get mature() {
        const ret = wasm.balance_mature(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Amount of funds that are being received and are not yet confirmed.
       * @returns {bigint}
       */
      get pending() {
        const ret = wasm.balance_pending(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Amount of funds that are being send and are not yet accepted by the network.
       * @returns {bigint}
       */
      get outgoing() {
        const ret = wasm.balance_outgoing(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {NetworkType | NetworkId | string} network_type
       * @returns {BalanceStrings}
       */
      toBalanceStrings(network_type) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.balance_toBalanceStrings(retptr, this.__wbg_ptr, addBorrowedObject(network_type));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return BalanceStrings.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
    };
    BalanceStringsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_balancestrings_free(ptr >>> 0, 1));
    BalanceStrings = class _BalanceStrings {
      static {
        __name$8(this, "BalanceStrings");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_BalanceStrings.prototype);
        obj.__wbg_ptr = ptr;
        BalanceStringsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BalanceStringsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_balancestrings_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get mature() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.balancestrings_mature(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string | undefined}
       */
      get pending() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.balancestrings_pending(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ConsoleConstructorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_consoleconstructoroptions_free(ptr >>> 0, 1));
    ConsoleConstructorOptions = class _ConsoleConstructorOptions {
      static {
        __name$8(this, "ConsoleConstructorOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ConsoleConstructorOptions.prototype);
        obj.__wbg_ptr = ptr;
        ConsoleConstructorOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConsoleConstructorOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_consoleconstructoroptions_free(ptr, 0);
      }
      /**
       * @param {any} stdout
       * @param {any} stderr
       * @param {boolean | null | undefined} ignore_errors
       * @param {any} color_mod
       * @param {object | null} [inspect_options]
       */
      constructor(stdout, stderr, ignore_errors, color_mod, inspect_options) {
        const ret = wasm.consoleconstructoroptions_new_with_values(addHeapObject(stdout), addHeapObject(stderr), isLikeNone(ignore_errors) ? 16777215 : ignore_errors ? 1 : 0, addHeapObject(color_mod), isLikeNone(inspect_options) ? 0 : addHeapObject(inspect_options));
        this.__wbg_ptr = ret >>> 0;
        ConsoleConstructorOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {any} stdout
       * @param {any} stderr
       * @returns {ConsoleConstructorOptions}
       */
      static new(stdout, stderr) {
        const ret = wasm.consoleconstructoroptions_new(addHeapObject(stdout), addHeapObject(stderr));
        return _ConsoleConstructorOptions.__wrap(ret);
      }
      /**
       * @returns {any}
       */
      get stdout() {
        const ret = wasm.consoleconstructoroptions_stdout(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} value
       */
      set stdout(value2) {
        wasm.consoleconstructoroptions_set_stdout(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {any}
       */
      get stderr() {
        const ret = wasm.consoleconstructoroptions_stderr(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} value
       */
      set stderr(value2) {
        wasm.consoleconstructoroptions_set_stderr(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {boolean | undefined}
       */
      get ignore_errors() {
        const ret = wasm.consoleconstructoroptions_ignore_errors(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set ignore_errors(value2) {
        wasm.consoleconstructoroptions_set_ignore_errors(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {any}
       */
      get color_mod() {
        const ret = wasm.consoleconstructoroptions_color_mod(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} value
       */
      set color_mod(value2) {
        wasm.consoleconstructoroptions_set_color_mod(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {object | undefined}
       */
      get inspect_options() {
        const ret = wasm.consoleconstructoroptions_inspect_options(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {object | null} [value]
       */
      set inspect_options(value2) {
        wasm.consoleconstructoroptions_set_inspect_options(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
    };
    CreateHookCallbacksFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_createhookcallbacks_free(ptr >>> 0, 1));
    CreateHookCallbacks = class {
      static {
        __name$8(this, "CreateHookCallbacks");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateHookCallbacksFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_createhookcallbacks_free(ptr, 0);
      }
      /**
       * @param {Function} init
       * @param {Function} before
       * @param {Function} after
       * @param {Function} destroy
       * @param {Function} promise_resolve
       */
      constructor(init3, before, after, destroy, promise_resolve) {
        try {
          const ret = wasm.createhookcallbacks_new(addBorrowedObject(init3), addBorrowedObject(before), addBorrowedObject(after), addBorrowedObject(destroy), addBorrowedObject(promise_resolve));
          this.__wbg_ptr = ret >>> 0;
          CreateHookCallbacksFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {Function}
       */
      get init() {
        const ret = wasm.createhookcallbacks_init(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set init(value2) {
        wasm.createhookcallbacks_set_init(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {Function}
       */
      get before() {
        const ret = wasm.createhookcallbacks_before(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set before(value2) {
        wasm.createhookcallbacks_set_before(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {Function}
       */
      get after() {
        const ret = wasm.createhookcallbacks_after(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set after(value2) {
        wasm.createhookcallbacks_set_after(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {Function}
       */
      get destroy() {
        const ret = wasm.createhookcallbacks_destroy(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set destroy(value2) {
        wasm.createhookcallbacks_set_destroy(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {Function}
       */
      get promise_resolve() {
        const ret = wasm.createhookcallbacks_promise_resolve(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set promise_resolve(value2) {
        wasm.createhookcallbacks_set_promise_resolve(this.__wbg_ptr, addHeapObject(value2));
      }
    };
    CreateReadStreamOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_createreadstreamoptions_free(ptr >>> 0, 1));
    CreateReadStreamOptions = class {
      static {
        __name$8(this, "CreateReadStreamOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateReadStreamOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_createreadstreamoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [auto_close]
       * @param {boolean | null} [emit_close]
       * @param {string | null} [encoding]
       * @param {number | null} [end]
       * @param {number | null} [fd]
       * @param {string | null} [flags]
       * @param {number | null} [high_water_mark]
       * @param {number | null} [mode]
       * @param {number | null} [start]
       */
      constructor(auto_close, emit_close, encoding, end, fd, flags, high_water_mark, mode, start2) {
        const ret = wasm.createreadstreamoptions_new_with_values(isLikeNone(auto_close) ? 16777215 : auto_close ? 1 : 0, isLikeNone(emit_close) ? 16777215 : emit_close ? 1 : 0, isLikeNone(encoding) ? 0 : addHeapObject(encoding), !isLikeNone(end), isLikeNone(end) ? 0 : end, isLikeNone(fd) ? 4294967297 : fd >>> 0, isLikeNone(flags) ? 0 : addHeapObject(flags), !isLikeNone(high_water_mark), isLikeNone(high_water_mark) ? 0 : high_water_mark, isLikeNone(mode) ? 4294967297 : mode >>> 0, !isLikeNone(start2), isLikeNone(start2) ? 0 : start2);
        this.__wbg_ptr = ret >>> 0;
        CreateReadStreamOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get auto_close() {
        const ret = wasm.createreadstreamoptions_auto_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set auto_close(value2) {
        wasm.createreadstreamoptions_set_auto_close(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get emit_close() {
        const ret = wasm.createreadstreamoptions_emit_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set emit_close(value2) {
        wasm.createreadstreamoptions_set_emit_close(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.createreadstreamoptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.createreadstreamoptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get end() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.createreadstreamoptions_end(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set end(value2) {
        wasm.createreadstreamoptions_set_end(this.__wbg_ptr, !isLikeNone(value2), isLikeNone(value2) ? 0 : value2);
      }
      /**
       * @returns {number | undefined}
       */
      get fd() {
        const ret = wasm.createreadstreamoptions_fd(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set fd(value2) {
        wasm.createreadstreamoptions_set_fd(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flags() {
        const ret = wasm.createreadstreamoptions_flags(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flags(value2) {
        wasm.createreadstreamoptions_set_flags(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get high_water_mark() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.createreadstreamoptions_high_water_mark(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set high_water_mark(value2) {
        wasm.createreadstreamoptions_set_high_water_mark(this.__wbg_ptr, !isLikeNone(value2), isLikeNone(value2) ? 0 : value2);
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm.createreadstreamoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm.createreadstreamoptions_set_mode(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {number | undefined}
       */
      get start() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.createreadstreamoptions_start(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set start(value2) {
        wasm.createreadstreamoptions_set_start(this.__wbg_ptr, !isLikeNone(value2), isLikeNone(value2) ? 0 : value2);
      }
    };
    CreateWriteStreamOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_createwritestreamoptions_free(ptr >>> 0, 1));
    CreateWriteStreamOptions = class {
      static {
        __name$8(this, "CreateWriteStreamOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateWriteStreamOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_createwritestreamoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [auto_close]
       * @param {boolean | null} [emit_close]
       * @param {string | null} [encoding]
       * @param {number | null} [fd]
       * @param {string | null} [flags]
       * @param {number | null} [mode]
       * @param {number | null} [start]
       */
      constructor(auto_close, emit_close, encoding, fd, flags, mode, start2) {
        const ret = wasm.createwritestreamoptions_new_with_values(isLikeNone(auto_close) ? 16777215 : auto_close ? 1 : 0, isLikeNone(emit_close) ? 16777215 : emit_close ? 1 : 0, isLikeNone(encoding) ? 0 : addHeapObject(encoding), isLikeNone(fd) ? 4294967297 : fd >>> 0, isLikeNone(flags) ? 0 : addHeapObject(flags), isLikeNone(mode) ? 4294967297 : mode >>> 0, !isLikeNone(start2), isLikeNone(start2) ? 0 : start2);
        this.__wbg_ptr = ret >>> 0;
        CreateWriteStreamOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get auto_close() {
        const ret = wasm.createwritestreamoptions_auto_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set auto_close(value2) {
        wasm.createwritestreamoptions_set_auto_close(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get emit_close() {
        const ret = wasm.createwritestreamoptions_emit_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set emit_close(value2) {
        wasm.createwritestreamoptions_set_emit_close(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.createwritestreamoptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.createwritestreamoptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get fd() {
        const ret = wasm.createwritestreamoptions_fd(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set fd(value2) {
        wasm.createwritestreamoptions_set_fd(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flags() {
        const ret = wasm.createwritestreamoptions_flags(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flags(value2) {
        wasm.createwritestreamoptions_set_flags(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm.createwritestreamoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm.createwritestreamoptions_set_mode(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {number | undefined}
       */
      get start() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.createwritestreamoptions_start(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set start(value2) {
        wasm.createwritestreamoptions_set_start(this.__wbg_ptr, !isLikeNone(value2), isLikeNone(value2) ? 0 : value2);
      }
    };
    CryptoBoxFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_cryptobox_free(ptr >>> 0, 1));
    CryptoBox = class {
      static {
        __name$8(this, "CryptoBox");
      }
      toJSON() {
        return {
          publicKey: this.publicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cryptobox_free(ptr, 0);
      }
      /**
       * @param {CryptoBoxPrivateKey | HexString | Uint8Array} secretKey
       * @param {CryptoBoxPublicKey | HexString | Uint8Array} peerPublicKey
       */
      constructor(secretKey, peerPublicKey) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.cryptobox_ctor(retptr, addBorrowedObject(secretKey), addBorrowedObject(peerPublicKey));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {string}
       */
      get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.cryptobox_publicKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} plaintext
       * @returns {string}
       */
      encrypt(plaintext) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.cryptobox_encrypt(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @param {string} base64string
       * @returns {string}
       */
      decrypt(base64string) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(base64string, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.cryptobox_decrypt(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
    };
    CryptoBoxPrivateKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_cryptoboxprivatekey_free(ptr >>> 0, 1));
    CryptoBoxPrivateKey = class {
      static {
        __name$8(this, "CryptoBoxPrivateKey");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxPrivateKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cryptoboxprivatekey_free(ptr, 0);
      }
      /**
       * @param {HexString | Uint8Array} secretKey
       */
      constructor(secretKey) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.cryptoboxprivatekey_ctor(retptr, addHeapObject(secretKey));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxPrivateKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {CryptoBoxPublicKey}
       */
      to_public_key() {
        const ret = wasm.cryptoboxprivatekey_to_public_key(this.__wbg_ptr);
        return CryptoBoxPublicKey.__wrap(ret);
      }
    };
    CryptoBoxPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_cryptoboxpublickey_free(ptr >>> 0, 1));
    CryptoBoxPublicKey = class _CryptoBoxPublicKey {
      static {
        __name$8(this, "CryptoBoxPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_CryptoBoxPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        CryptoBoxPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxPublicKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cryptoboxpublickey_free(ptr, 0);
      }
      /**
       * @param {HexString | Uint8Array} publicKey
       */
      constructor(publicKey) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.cryptoboxpublickey_ctor(retptr, addHeapObject(publicKey));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxPublicKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.cryptoboxpublickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    DerivationPathFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_derivationpath_free(ptr >>> 0, 1));
    DerivationPath = class _DerivationPath {
      static {
        __name$8(this, "DerivationPath");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_DerivationPath.prototype);
        obj.__wbg_ptr = ptr;
        DerivationPathFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DerivationPathFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_derivationpath_free(ptr, 0);
      }
      /**
       * @param {string} path
       */
      constructor(path) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(path, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.derivationpath_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          DerivationPathFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Is this derivation path empty? (i.e. the root)
       * @returns {boolean}
       */
      isEmpty() {
        const ret = wasm.derivationpath_isEmpty(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Get the count of [`ChildNumber`] values in this derivation path.
       * @returns {number}
       */
      length() {
        const ret = wasm.derivationpath_length(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * Get the parent [`DerivationPath`] for the current one.
       *
       * Returns `Undefined` if this is already the root path.
       * @returns {DerivationPath | undefined}
       */
      parent() {
        const ret = wasm.derivationpath_parent(this.__wbg_ptr);
        return ret === 0 ? void 0 : _DerivationPath.__wrap(ret);
      }
      /**
       * Push a [`ChildNumber`] onto an existing derivation path.
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       */
      push(child_number, hardened) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.derivationpath_push(retptr, this.__wbg_ptr, child_number, isLikeNone(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.derivationpath_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    FormatInputPathObjectFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_formatinputpathobject_free(ptr >>> 0, 1));
    FormatInputPathObject = class _FormatInputPathObject {
      static {
        __name$8(this, "FormatInputPathObject");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_FormatInputPathObject.prototype);
        obj.__wbg_ptr = ptr;
        FormatInputPathObjectFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FormatInputPathObjectFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_formatinputpathobject_free(ptr, 0);
      }
      /**
       * @param {string | null} [base]
       * @param {string | null} [dir]
       * @param {string | null} [ext]
       * @param {string | null} [name]
       * @param {string | null} [root]
       */
      constructor(base3, dir, ext, name2, root) {
        const ret = wasm.formatinputpathobject_new_with_values(isLikeNone(base3) ? 0 : addHeapObject(base3), isLikeNone(dir) ? 0 : addHeapObject(dir), isLikeNone(ext) ? 0 : addHeapObject(ext), isLikeNone(name2) ? 0 : addHeapObject(name2), isLikeNone(root) ? 0 : addHeapObject(root));
        this.__wbg_ptr = ret >>> 0;
        FormatInputPathObjectFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {FormatInputPathObject}
       */
      static new() {
        const ret = wasm.formatinputpathobject_new();
        return _FormatInputPathObject.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get base() {
        const ret = wasm.formatinputpathobject_base(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set base(value2) {
        wasm.formatinputpathobject_set_base(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get dir() {
        const ret = wasm.formatinputpathobject_dir(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set dir(value2) {
        wasm.formatinputpathobject_set_dir(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get ext() {
        const ret = wasm.formatinputpathobject_ext(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set ext(value2) {
        wasm.formatinputpathobject_set_ext(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get name() {
        const ret = wasm.formatinputpathobject_name(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set name(value2) {
        wasm.formatinputpathobject_set_name(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get root() {
        const ret = wasm.formatinputpathobject_root(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set root(value2) {
        wasm.formatinputpathobject_set_root(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
    };
    GeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_generator_free(ptr >>> 0, 1));
    Generator = class {
      static {
        __name$8(this, "Generator");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GeneratorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_generator_free(ptr, 0);
      }
      /**
       * @param {IGeneratorSettingsObject} args
       */
      constructor(args) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.generator_ctor(retptr, addHeapObject(args));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          GeneratorFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate next transaction
       * @returns {Promise<any>}
       */
      next() {
        const ret = wasm.generator_next(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<GeneratorSummary>}
       */
      estimate() {
        const ret = wasm.generator_estimate(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {GeneratorSummary}
       */
      summary() {
        const ret = wasm.generator_summary(this.__wbg_ptr);
        return GeneratorSummary.__wrap(ret);
      }
    };
    GeneratorSummaryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_generatorsummary_free(ptr >>> 0, 1));
    GeneratorSummary = class _GeneratorSummary {
      static {
        __name$8(this, "GeneratorSummary");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_GeneratorSummary.prototype);
        obj.__wbg_ptr = ptr;
        GeneratorSummaryFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          networkType: this.networkType,
          utxos: this.utxos,
          fees: this.fees,
          mass: this.mass,
          transactions: this.transactions,
          finalAmount: this.finalAmount,
          finalTransactionId: this.finalTransactionId
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GeneratorSummaryFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_generatorsummary_free(ptr, 0);
      }
      /**
       * @returns {NetworkType}
       */
      get networkType() {
        const ret = wasm.generatorsummary_networkType(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {number}
       */
      get utxos() {
        const ret = wasm.generatorsummary_utxos(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {bigint}
       */
      get fees() {
        const ret = wasm.generatorsummary_fees(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm.generatorsummary_mass(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {number}
       */
      get transactions() {
        const ret = wasm.generatorsummary_transactions(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {bigint | undefined}
       */
      get finalAmount() {
        const ret = wasm.generatorsummary_finalAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get finalTransactionId() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.generatorsummary_finalTransactionId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    GetNameOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_getnameoptions_free(ptr >>> 0, 1));
    GetNameOptions = class _GetNameOptions {
      static {
        __name$8(this, "GetNameOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_GetNameOptions.prototype);
        obj.__wbg_ptr = ptr;
        GetNameOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetNameOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_getnameoptions_free(ptr, 0);
      }
      /**
       * @param {number | null | undefined} family
       * @param {string} host
       * @param {string} local_address
       * @param {number} port
       * @returns {GetNameOptions}
       */
      static new(family, host, local_address, port) {
        const ret = wasm.getnameoptions_new(isLikeNone(family) ? 16777215 : family, addHeapObject(host), addHeapObject(local_address), port);
        return _GetNameOptions.__wrap(ret);
      }
      /**
       * @returns {number | undefined}
       */
      get family() {
        const ret = wasm.getnameoptions_family(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set family(value2) {
        wasm.getnameoptions_set_family(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2);
      }
      /**
       * @returns {string}
       */
      get host() {
        const ret = wasm.getnameoptions_host(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string} value
       */
      set host(value2) {
        wasm.getnameoptions_set_host(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {string}
       */
      get local_address() {
        const ret = wasm.getnameoptions_local_address(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string} value
       */
      set local_address(value2) {
        wasm.getnameoptions_set_local_address(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {number}
       */
      get port() {
        const ret = wasm.getnameoptions_port(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} value
       */
      set port(value2) {
        wasm.getnameoptions_set_port(this.__wbg_ptr, value2);
      }
    };
    HashFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_hash_free(ptr >>> 0, 1));
    Hash = class _Hash {
      static {
        __name$8(this, "Hash");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Hash.prototype);
        obj.__wbg_ptr = ptr;
        HashFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HashFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_hash_free(ptr, 0);
      }
      /**
       * @param {string} hex_str
       */
      constructor(hex_str) {
        const ptr0 = passStringToWasm0(hex_str, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.hash_constructor(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        HashFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.hash_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    HeaderFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_header_free(ptr >>> 0, 1));
    Header = class {
      static {
        __name$8(this, "Header");
      }
      toJSON() {
        return {
          version: this.version,
          timestamp: this.timestamp,
          bits: this.bits,
          nonce: this.nonce,
          daaScore: this.daaScore,
          blueScore: this.blueScore,
          hash: this.hash,
          hashMerkleRoot: this.hashMerkleRoot,
          acceptedIdMerkleRoot: this.acceptedIdMerkleRoot,
          utxoCommitment: this.utxoCommitment,
          pruningPoint: this.pruningPoint,
          parentsByLevel: this.parentsByLevel,
          blueWork: this.blueWork
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HeaderFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_header_free(ptr, 0);
      }
      /**
       * @param {Header | IHeader | IRawHeader} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_constructor(retptr, addHeapObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          HeaderFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Finalizes the header and recomputes (updates) the header hash
       * @return { String } header hash
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Obtain `JSON` representation of the header. JSON representation
       * should be obtained using WASM, to ensure proper serialization of
       * big integers.
       * @returns {string}
       */
      asJSON() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_asJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm.header_get_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} version
       */
      set version(version3) {
        wasm.header_set_version(this.__wbg_ptr, version3);
      }
      /**
       * @returns {bigint}
       */
      get timestamp() {
        const ret = wasm.header_get_timestamp(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} timestamp
       */
      set timestamp(timestamp) {
        wasm.header_set_timestamp(this.__wbg_ptr, timestamp);
      }
      /**
       * @returns {number}
       */
      get bits() {
        const ret = wasm.header_bits(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} bits
       */
      set bits(bits) {
        wasm.header_set_bits(this.__wbg_ptr, bits);
      }
      /**
       * @returns {bigint}
       */
      get nonce() {
        const ret = wasm.header_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} nonce
       */
      set nonce(nonce) {
        wasm.header_set_nonce(this.__wbg_ptr, nonce);
      }
      /**
       * @returns {bigint}
       */
      get daaScore() {
        const ret = wasm.header_daa_score(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} daa_score
       */
      set daaScore(daa_score) {
        wasm.header_set_daa_score(this.__wbg_ptr, daa_score);
      }
      /**
       * @returns {bigint}
       */
      get blueScore() {
        const ret = wasm.header_blue_score(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} blue_score
       */
      set blueScore(blue_score) {
        wasm.header_set_blue_score(this.__wbg_ptr, blue_score);
      }
      /**
       * @returns {string}
       */
      get hash() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_get_hash_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get hashMerkleRoot() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_get_hash_merkle_root_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set hashMerkleRoot(js_value) {
        wasm.header_set_hash_merkle_root_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {string}
       */
      get acceptedIdMerkleRoot() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_get_accepted_id_merkle_root_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set acceptedIdMerkleRoot(js_value) {
        wasm.header_set_accepted_id_merkle_root_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {string}
       */
      get utxoCommitment() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_get_utxo_commitment_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set utxoCommitment(js_value) {
        wasm.header_set_utxo_commitment_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {string}
       */
      get pruningPoint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_get_pruning_point_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set pruningPoint(js_value) {
        wasm.header_set_pruning_point_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {any}
       */
      get parentsByLevel() {
        const ret = wasm.header_get_parents_by_level_as_js_value(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} js_value
       */
      set parentsByLevel(js_value) {
        wasm.header_set_parents_by_level_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {bigint}
       */
      get blueWork() {
        const ret = wasm.header_blue_work(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {string}
       */
      getBlueWorkAsHex() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.header_getBlueWorkAsHex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set blueWork(js_value) {
        wasm.header_set_blue_work_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
    };
    KeypairFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_keypair_free(ptr >>> 0, 1));
    Keypair = class _Keypair {
      static {
        __name$8(this, "Keypair");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Keypair.prototype);
        obj.__wbg_ptr = ptr;
        KeypairFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          publicKey: this.publicKey,
          privateKey: this.privateKey,
          xOnlyPublicKey: this.xOnlyPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeypairFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keypair_free(ptr, 0);
      }
      /**
       * Get the [`PublicKey`] of this [`Keypair`].
       * @returns {string}
       */
      get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.keypair_get_public_key(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`PrivateKey`] of this [`Keypair`].
       * @returns {string}
       */
      get privateKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.keypair_get_private_key(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the `XOnlyPublicKey` of this [`Keypair`].
       * @returns {any}
       */
      get xOnlyPublicKey() {
        const ret = wasm.keypair_get_xonly_public_key(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Get the [`Address`] of this Keypair's [`PublicKey`].
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.keypair_toAddress(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this Keypair's [`PublicKey`].
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.keypair_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Create a new random [`Keypair`].
       * JavaScript: `let keypair = Keypair::random();`.
       * @returns {Keypair}
       */
      static random() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.keypair_random(retptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Keypair.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Create a new [`Keypair`] from a [`PrivateKey`].
       * JavaScript: `let privkey = new PrivateKey(hexString); let keypair = privkey.toKeypair();`.
       * @param {PrivateKey} secret_key
       * @returns {Keypair}
       */
      static fromPrivateKey(secret_key) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(secret_key, PrivateKey);
          wasm.keypair_fromPrivateKey(retptr, secret_key.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Keypair.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    MkdtempSyncOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_mkdtempsyncoptions_free(ptr >>> 0, 1));
    MkdtempSyncOptions = class _MkdtempSyncOptions {
      static {
        __name$8(this, "MkdtempSyncOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_MkdtempSyncOptions.prototype);
        obj.__wbg_ptr = ptr;
        MkdtempSyncOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MkdtempSyncOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mkdtempsyncoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       */
      constructor(encoding) {
        const ret = wasm.mkdtempsyncoptions_new_with_values(isLikeNone(encoding) ? 0 : addHeapObject(encoding));
        this.__wbg_ptr = ret >>> 0;
        MkdtempSyncOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {MkdtempSyncOptions}
       */
      static new() {
        const ret = wasm.mkdtempsyncoptions_new();
        return _MkdtempSyncOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.mkdtempsyncoptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.mkdtempsyncoptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
    };
    MnemonicFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_mnemonic_free(ptr >>> 0, 1));
    Mnemonic$1 = class _Mnemonic {
      static {
        __name$8(this, "Mnemonic");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Mnemonic.prototype);
        obj.__wbg_ptr = ptr;
        MnemonicFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          entropy: this.entropy,
          phrase: this.phrase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MnemonicFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mnemonic_free(ptr, 0);
      }
      /**
       * @param {string} phrase
       * @param {Language | null} [language]
       */
      constructor(phrase, language) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(phrase, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.mnemonic_constructor(retptr, ptr0, len0, isLikeNone(language) ? 1 : language);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          MnemonicFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Validate mnemonic phrase. Returns `true` if the phrase is valid, `false` otherwise.
       * @param {string} phrase
       * @param {Language | null} [language]
       * @returns {boolean}
       */
      static validate(phrase, language) {
        const ptr0 = passStringToWasm0(phrase, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.mnemonic_validate(ptr0, len0, isLikeNone(language) ? 1 : language);
        return ret !== 0;
      }
      /**
       * @returns {string}
       */
      get entropy() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.mnemonic_entropy(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} entropy
       */
      set entropy(entropy) {
        const ptr0 = passStringToWasm0(entropy, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.mnemonic_set_entropy(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {number | null} [word_count]
       * @returns {Mnemonic}
       */
      static random(word_count) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.mnemonic_random(retptr, isLikeNone(word_count) ? 4294967297 : word_count >>> 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Mnemonic.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get phrase() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.mnemonic_phrase(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} phrase
       */
      set phrase(phrase) {
        const ptr0 = passStringToWasm0(phrase, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.mnemonic_set_phrase(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {string | null} [password]
       * @returns {string}
       */
      toSeed(password) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          var ptr0 = isLikeNone(password) ? 0 : passStringToWasm0(password, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          var len0 = WASM_VECTOR_LEN;
          wasm.mnemonic_toSeed(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred2_0 = r0;
          deferred2_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    NetServerOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_netserveroptions_free(ptr >>> 0, 1));
    NetServerOptions = class {
      static {
        __name$8(this, "NetServerOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetServerOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_netserveroptions_free(ptr, 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get allow_half_open() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.netserveroptions_allow_half_open(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set allow_half_open(value2) {
        const ptr = this.__destroy_into_raw();
        wasm.netserveroptions_set_allow_half_open(ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get pause_on_connect() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.netserveroptions_pause_on_connect(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set pause_on_connect(value2) {
        const ptr = this.__destroy_into_raw();
        wasm.netserveroptions_set_allow_half_open(ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    NetworkIdFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_networkid_free(ptr >>> 0, 1));
    NetworkId = class _NetworkId {
      static {
        __name$8(this, "NetworkId");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_NetworkId.prototype);
        obj.__wbg_ptr = ptr;
        NetworkIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          type: this.type,
          suffix: this.suffix,
          id: this.id
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetworkIdFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_networkid_free(ptr, 0);
      }
      /**
       * @returns {NetworkType}
       */
      get type() {
        const ret = wasm.__wbg_get_networkid_type(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {NetworkType} arg0
       */
      set type(arg0) {
        wasm.__wbg_set_networkid_type(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {number | undefined}
       */
      get suffix() {
        const ret = wasm.__wbg_get_networkid_suffix(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [arg0]
       */
      set suffix(arg0) {
        wasm.__wbg_set_networkid_suffix(this.__wbg_ptr, isLikeNone(arg0) ? 4294967297 : arg0 >>> 0);
      }
      /**
       * @param {any} value
       */
      constructor(value2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.networkid_ctor(retptr, addBorrowedObject(value2));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          NetworkIdFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.networkid_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.networkid_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      addressPrefix() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.networkid_addressPrefix(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    NodeDescriptorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_nodedescriptor_free(ptr >>> 0, 1));
    NodeDescriptor = class _NodeDescriptor {
      static {
        __name$8(this, "NodeDescriptor");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_NodeDescriptor.prototype);
        obj.__wbg_ptr = ptr;
        NodeDescriptorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          uid: this.uid,
          url: this.url
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NodeDescriptorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nodedescriptor_free(ptr, 0);
      }
      /**
       * The unique identifier of the node.
       * @returns {string}
       */
      get uid() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_nodedescriptor_uid(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * The unique identifier of the node.
       * @param {string} arg0
       */
      set uid(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_nodedescriptor_uid(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * The URL of the node WebSocket (wRPC URL).
       * @returns {string}
       */
      get url() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_nodedescriptor_url(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * The URL of the node WebSocket (wRPC URL).
       * @param {string} arg0
       */
      set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_nodedescriptor_url(this.__wbg_ptr, ptr0, len0);
      }
    };
    PSKBFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pskb_free(ptr >>> 0, 1));
    PSKB = class _PSKB {
      static {
        __name$8(this, "PSKB");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PSKB.prototype);
        obj.__wbg_ptr = ptr;
        PSKBFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSKBFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pskb_free(ptr, 0);
      }
      constructor() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskb_new(retptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PSKBFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      serialize() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskb_serialize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       * @returns {string}
       */
      displayFormat(network_id) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskb_displayFormat(retptr, this.__wbg_ptr, addBorrowedObject(network_id));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @param {string} hex_data
       * @returns {PSKB}
       */
      static deserialize(hex_data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(hex_data, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.pskb_deserialize(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKB.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {number}
       */
      get length() {
        const ret = wasm.pskb_length(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {PSKT} pskt
       */
      add(pskt) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(pskt, PSKT);
          wasm.pskb_add(retptr, this.__wbg_ptr, pskt.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {PSKB} other
       */
      merge(other) {
        _assertClass(other, _PSKB);
        wasm.pskb_merge(this.__wbg_ptr, other.__wbg_ptr);
      }
    };
    PSKTFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pskt_free(ptr >>> 0, 1));
    PSKT = class _PSKT {
      static {
        __name$8(this, "PSKT");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PSKT.prototype);
        obj.__wbg_ptr = ptr;
        PSKTFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          role: this.role,
          payload: this.payload
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSKTFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pskt_free(ptr, 0);
      }
      /**
       * @param {PSKT | Transaction | string | undefined} payload
       */
      constructor(payload) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_new(retptr, addHeapObject(payload));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PSKTFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get role() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_role(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {any}
       */
      get payload() {
        const ret = wasm.pskt_payload(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {string}
       */
      serialize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_serialize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Change role to `CREATOR`
       * #[wasm_bindgen(js_name = toCreator)]
       * @returns {PSKT}
       */
      creator() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_creator(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `CONSTRUCTOR`
       * @returns {PSKT}
       */
      toConstructor() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toConstructor(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `UPDATER`
       * @returns {PSKT}
       */
      toUpdater() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toUpdater(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `SIGNER`
       * @returns {PSKT}
       */
      toSigner() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toSigner(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `COMBINER`
       * @returns {PSKT}
       */
      toCombiner() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toCombiner(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `FINALIZER`
       * @returns {PSKT}
       */
      toFinalizer() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toFinalizer(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `EXTRACTOR`
       * @returns {PSKT}
       */
      toExtractor() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_toExtractor(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} lock_time
       * @returns {PSKT}
       */
      fallbackLockTime(lock_time) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_fallbackLockTime(retptr, this.__wbg_ptr, lock_time);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      inputsModifiable() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_inputsModifiable(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      outputsModifiable() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_outputsModifiable(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      noMoreInputs() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_noMoreInputs(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      noMoreOutputs() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_noMoreOutputs(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {ITransactionInput | TransactionInput} input
       * @param {any} data
       * @returns {PSKT}
       */
      inputAndRedeemScript(input, data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_inputAndRedeemScript(retptr, this.__wbg_ptr, addBorrowedObject(input), addBorrowedObject(data));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {ITransactionInput | TransactionInput} input
       * @returns {PSKT}
       */
      input(input) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_input(retptr, this.__wbg_ptr, addBorrowedObject(input));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {ITransactionOutput | TransactionOutput} output
       * @returns {PSKT}
       */
      output(output) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_output(retptr, this.__wbg_ptr, addBorrowedObject(output));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {bigint} n
       * @param {number} input_index
       * @returns {PSKT}
       */
      setSequence(n2, input_index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_setSequence(retptr, this.__wbg_ptr, n2, input_index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {Hash}
       */
      calculateId() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_calculateId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Hash.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} data
       * @returns {bigint}
       */
      calculateMass(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pskt_calculateMass(retptr, this.__wbg_ptr, addBorrowedObject(data));
          var r0 = getDataViewMemory0().getBigInt64(retptr + 8 * 0, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          if (r3) {
            throw takeObject(r2);
          }
          return BigInt.asUintN(64, r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
    };
    PaymentOutputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_paymentoutput_free(ptr >>> 0, 1));
    PaymentOutput = class {
      static {
        __name$8(this, "PaymentOutput");
      }
      toJSON() {
        return {
          address: this.address,
          amount: this.amount
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PaymentOutputFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paymentoutput_free(ptr, 0);
      }
      /**
       * @returns {Address}
       */
      get address() {
        const ret = wasm.__wbg_get_paymentoutput_address(this.__wbg_ptr);
        return Address.__wrap(ret);
      }
      /**
       * @param {Address} arg0
       */
      set address(arg0) {
        _assertClass(arg0, Address);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_paymentoutput_address(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm.__wbg_get_paymentoutput_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm.__wbg_set_paymentoutput_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @param {Address} address
       * @param {bigint} amount
       */
      constructor(address, amount) {
        _assertClass(address, Address);
        var ptr0 = address.__destroy_into_raw();
        const ret = wasm.paymentoutput_new(ptr0, amount);
        this.__wbg_ptr = ret >>> 0;
        PaymentOutputFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
    };
    PaymentOutputsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_paymentoutputs_free(ptr >>> 0, 1));
    PaymentOutputs = class {
      static {
        __name$8(this, "PaymentOutputs");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PaymentOutputsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paymentoutputs_free(ptr, 0);
      }
      /**
       * @param {IPaymentOutput[]} output_array
       */
      constructor(output_array) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.paymentoutputs_constructor(retptr, addHeapObject(output_array));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PaymentOutputsFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PendingTransactionFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pendingtransaction_free(ptr >>> 0, 1));
    PendingTransaction = class _PendingTransaction {
      static {
        __name$8(this, "PendingTransaction");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PendingTransaction.prototype);
        obj.__wbg_ptr = ptr;
        PendingTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          paymentAmount: this.paymentAmount,
          changeAmount: this.changeAmount,
          feeAmount: this.feeAmount,
          mass: this.mass,
          minimumSignatures: this.minimumSignatures,
          aggregateInputAmount: this.aggregateInputAmount,
          aggregateOutputAmount: this.aggregateOutputAmount,
          type: this.type,
          transaction: this.transaction
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PendingTransactionFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pendingtransaction_free(ptr, 0);
      }
      /**
       * Transaction Id
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Total amount transferred to the destination (aggregate output - change).
       * @returns {any}
       */
      get paymentAmount() {
        const ret = wasm.pendingtransaction_paymentAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Change amount (if any).
       * @returns {bigint}
       */
      get changeAmount() {
        const ret = wasm.pendingtransaction_changeAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Total transaction fees (network fees + priority fees).
       * @returns {bigint}
       */
      get feeAmount() {
        const ret = wasm.pendingtransaction_feeAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Calculated transaction mass.
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm.pendingtransaction_mass(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Minimum number of signatures required by the transaction.
       * (as specified during the transaction creation).
       * @returns {number}
       */
      get minimumSignatures() {
        const ret = wasm.pendingtransaction_minimumSignatures(this.__wbg_ptr);
        return ret;
      }
      /**
       * Total aggregate input amount.
       * @returns {bigint}
       */
      get aggregateInputAmount() {
        const ret = wasm.pendingtransaction_aggregateInputAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Total aggregate output amount.
       * @returns {bigint}
       */
      get aggregateOutputAmount() {
        const ret = wasm.pendingtransaction_aggregateOutputAmount(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Transaction type ("batch" or "final").
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * List of unique addresses used by transaction inputs.
       * This method can be used to determine addresses used by transaction inputs
       * in order to select private keys needed for transaction signing.
       * @returns {Array<any>}
       */
      addresses() {
        const ret = wasm.pendingtransaction_addresses(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Provides a list of UTXO entries used by the transaction.
       * @returns {Array<any>}
       */
      getUtxoEntries() {
        const ret = wasm.pendingtransaction_getUtxoEntries(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Creates and returns a signature for the input at the specified index.
       * @param {number} input_index
       * @param {PrivateKey} private_key
       * @param {SighashType | null} [sighash_type]
       * @returns {HexString}
       */
      createInputSignature(input_index, private_key, sighash_type) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(private_key, PrivateKey);
          wasm.pendingtransaction_createInputSignature(retptr, this.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone(sighash_type) ? 6 : sighash_type);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Sets a signature to the input at the specified index.
       * @param {number} input_index
       * @param {HexString | Uint8Array} signature_script
       */
      fillInput(input_index, signature_script) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_fillInput(retptr, this.__wbg_ptr, input_index, addHeapObject(signature_script));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Signs the input at the specified index with the supplied private key
       * and an optional SighashType.
       * @param {number} input_index
       * @param {PrivateKey} private_key
       * @param {SighashType | null} [sighash_type]
       */
      signInput(input_index, private_key, sighash_type) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(private_key, PrivateKey);
          wasm.pendingtransaction_signInput(retptr, this.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone(sighash_type) ? 6 : sighash_type);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Signs transaction with supplied [`Array`] or [`PrivateKey`] or an array of
       * raw private key bytes (encoded as `Uint8Array` or as hex strings)
       * @param {(PrivateKey | HexString | Uint8Array)[]} js_value
       * @param {boolean | null} [check_fully_signed]
       */
      sign(js_value, check_fully_signed) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_sign(retptr, this.__wbg_ptr, addHeapObject(js_value), isLikeNone(check_fully_signed) ? 16777215 : check_fully_signed ? 1 : 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Submit transaction to the supplied [`RpcClient`]
       * **IMPORTANT:** This method will remove UTXOs from the associated
       * {@link UtxoContext} if one was used to create the transaction
       * and will return UTXOs back to {@link UtxoContext} in case of
       * a failed submission.
       *
       * # Important
       *
       * Make sure to consume the returned `txid` value. Always invoke this method
       * as follows `let txid = await pendingTransaction.submit(rpc);`. If you do not
       * consume the returned value and the rpc object is temporary, the GC will
       * collect the `rpc` object passed to submit() potentially causing a panic.
       *
       * @see {@link RpcClient.submitTransaction}
       * @param {RpcClient} wasm_rpc_client
       * @returns {Promise<string>}
       */
      submit(wasm_rpc_client) {
        _assertClass(wasm_rpc_client, RpcClient);
        const ret = wasm.pendingtransaction_submit(this.__wbg_ptr, wasm_rpc_client.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Returns encapsulated network [`Transaction`]
       * @returns {Transaction}
       */
      get transaction() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_transaction(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Transaction.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a pure JavaScript Object.
       * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
       * @see {@link ISerializableTransaction}
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {ITransaction | Transaction}
       */
      serializeToObject() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_serializeToObject(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a JSON string.
       * The schema of the JSON is defined by {@link ISerializableTransaction}.
       * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromJSON}.
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {string}
       */
      serializeToJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_serializeToJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
       * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromSafeJSON}.
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {string}
       */
      serializeToSafeJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pendingtransaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    PipeOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pipeoptions_free(ptr >>> 0, 1));
    PipeOptions = class {
      static {
        __name$8(this, "PipeOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PipeOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pipeoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [end]
       */
      constructor(end) {
        const ret = wasm.pipeoptions_new(isLikeNone(end) ? 16777215 : end ? 1 : 0);
        this.__wbg_ptr = ret >>> 0;
        PipeOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get end() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.pipeoptions_end(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set end(value2) {
        const ptr = this.__destroy_into_raw();
        wasm.pipeoptions_set_end(ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    PoWFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pow_free(ptr >>> 0, 1));
    PoW = class _PoW {
      static {
        __name$8(this, "PoW");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PoW.prototype);
        obj.__wbg_ptr = ptr;
        PoWFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          target: this.target,
          prePoWHash: this.prePoWHash
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoWFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_pow_free(ptr, 0);
      }
      /**
       * @param {Header | IHeader | IRawHeader} header
       * @param {bigint | null} [timestamp]
       */
      constructor(header, timestamp) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pow_new(retptr, addBorrowedObject(header), !isLikeNone(timestamp), isLikeNone(timestamp) ? BigInt(0) : timestamp);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PoWFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * The target based on the provided bits.
       * @returns {bigint}
       */
      get target() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pow_target(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Checks if the computed target meets or exceeds the difficulty specified in the template.
       * @returns A boolean indicating if it reached the target and a bigint representing the reached target.
       * @param {bigint} nonce
       * @returns {[boolean, bigint]}
       */
      checkWork(nonce) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pow_checkWork(retptr, this.__wbg_ptr, nonce);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Hash of the header without timestamp and nonce.
       * @returns {string}
       */
      get prePoWHash() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.pow_get_pre_pow_hash(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Can be used for parsing Stratum templates.
       * @param {string} pre_pow_hash
       * @param {bigint} timestamp
       * @param {number | null} [target_bits]
       * @returns {PoW}
       */
      static fromRaw(pre_pow_hash, timestamp, target_bits) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(pre_pow_hash, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.pow_fromRaw(retptr, ptr0, len0, timestamp, isLikeNone(target_bits) ? 4294967297 : target_bits >>> 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PoW.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PrivateKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_privatekey_free(ptr >>> 0, 1));
    PrivateKey = class _PrivateKey {
      static {
        __name$8(this, "PrivateKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PrivateKey.prototype);
        obj.__wbg_ptr = ptr;
        PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privatekey_free(ptr, 0);
      }
      /**
       * Create a new [`PrivateKey`] from a hex-encoded string.
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(key2, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.privatekey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PrivateKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Returns the [`PrivateKey`] key encoded as a hex string.
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Generate a [`Keypair`] from this [`PrivateKey`].
       * @returns {Keypair}
       */
      toKeypair() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekey_toKeypair(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Keypair.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PublicKey}
       */
      toPublicKey() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekey_toPublicKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PublicKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Get the [`Address`] of the PublicKey generated from this PrivateKey.
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of the PublicKey generated from this PrivateKey.
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
    };
    PrivateKeyGeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_privatekeygenerator_free(ptr >>> 0, 1));
    PrivateKeyGenerator = class {
      static {
        __name$8(this, "PrivateKeyGenerator");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyGeneratorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privatekeygenerator_free(ptr, 0);
      }
      /**
       * @param {XPrv | string} xprv
       * @param {boolean} is_multisig
       * @param {bigint} account_index
       * @param {number | null} [cosigner_index]
       */
      constructor(xprv, is_multisig, account_index, cosigner_index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekeygenerator_new(retptr, addBorrowedObject(xprv), is_multisig, account_index, isLikeNone(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PrivateKeyGeneratorFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {number} index
       * @returns {PrivateKey}
       */
      receiveKey(index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekeygenerator_receiveKey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PrivateKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} index
       * @returns {PrivateKey}
       */
      changeKey(index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.privatekeygenerator_changeKey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PrivateKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ProcessSendOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_processsendoptions_free(ptr >>> 0, 1));
    ProcessSendOptions = class {
      static {
        __name$8(this, "ProcessSendOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProcessSendOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_processsendoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [swallow_errors]
       */
      constructor(swallow_errors) {
        const ret = wasm.processsendoptions_new(isLikeNone(swallow_errors) ? 16777215 : swallow_errors ? 1 : 0);
        this.__wbg_ptr = ret >>> 0;
        ProcessSendOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get swallow_errors() {
        const ret = wasm.processsendoptions_swallow_errors(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set swallow_errors(value2) {
        wasm.processsendoptions_set_swallow_errors(this.__wbg_ptr, isLikeNone(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    PrvKeyDataInfoFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_prvkeydatainfo_free(ptr >>> 0, 1));
    PrvKeyDataInfo = class {
      static {
        __name$8(this, "PrvKeyDataInfo");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrvKeyDataInfoFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_prvkeydatainfo_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.prvkeydatainfo_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {any}
       */
      get name() {
        const ret = wasm.prvkeydatainfo_name(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {any}
       */
      get isEncrypted() {
        const ret = wasm.prvkeydatainfo_isEncrypted(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string} _name
       */
      setName(_name) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(_name, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.prvkeydatainfo_setName(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_publickey_free(ptr >>> 0, 1));
    PublicKey = class _PublicKey {
      static {
        __name$8(this, "PublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr, 0);
      }
      /**
       * Create a new [`PublicKey`] from a hex-encoded string.
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(key2, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.publickey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PublicKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`Address`] of this PublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this PublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {XOnlyPublicKey}
       */
      toXOnlyPublicKey() {
        const ret = wasm.publickey_toXOnlyPublicKey(this.__wbg_ptr);
        return XOnlyPublicKey.__wrap(ret);
      }
      /**
       * Compute a 4-byte key fingerprint for this public key as a hex string.
       * Default implementation uses `RIPEMD160(SHA256(public_key))`.
       * @returns {HexString | undefined}
       */
      fingerprint() {
        const ret = wasm.publickey_fingerprint(this.__wbg_ptr);
        return takeObject(ret);
      }
    };
    PublicKeyGeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_publickeygenerator_free(ptr >>> 0, 1));
    PublicKeyGenerator = class _PublicKeyGenerator {
      static {
        __name$8(this, "PublicKeyGenerator");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PublicKeyGenerator.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyGeneratorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyGeneratorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickeygenerator_free(ptr, 0);
      }
      /**
       * @param {XPub | string} kpub
       * @param {number | null} [cosigner_index]
       * @returns {PublicKeyGenerator}
       */
      static fromXPub(kpub, cosigner_index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_fromXPub(retptr, addBorrowedObject(kpub), isLikeNone(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PublicKeyGenerator.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {XPrv | string} xprv
       * @param {boolean} is_multisig
       * @param {bigint} account_index
       * @param {number | null} [cosigner_index]
       * @returns {PublicKeyGenerator}
       */
      static fromMasterXPrv(xprv, is_multisig, account_index, cosigner_index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_fromMasterXPrv(retptr, addBorrowedObject(xprv), is_multisig, account_index, isLikeNone(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _PublicKeyGenerator.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate Receive Public Key derivations for a given range.
       * @param {number} start
       * @param {number} end
       * @returns {(PublicKey | string)[]}
       */
      receivePubkeys(start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receivePubkeys(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Receive Public Key derivation at a given index.
       * @param {number} index
       * @returns {PublicKey}
       */
      receivePubkey(index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receivePubkey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PublicKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a range of Receive Public Key derivations and return them as strings.
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      receivePubkeysAsStrings(start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receivePubkeysAsStrings(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Receive Public Key derivation at a given index and return it as a string.
       * @param {number} index
       * @returns {string}
       */
      receivePubkeyAsString(index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receivePubkeyAsString(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Receive Address derivations for a given range.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Address[]}
       */
      receiveAddresses(networkType, start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receiveAddresses(retptr, this.__wbg_ptr, addBorrowedObject(networkType), start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a single Receive Address derivation at a given index.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {Address}
       */
      receiveAddress(networkType, index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receiveAddress(retptr, this.__wbg_ptr, addBorrowedObject(networkType), index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a range of Receive Address derivations and return them as strings.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      receiveAddressAsStrings(networkType, start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receiveAddressAsStrings(retptr, this.__wbg_ptr, addBorrowedObject(networkType), start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a single Receive Address derivation at a given index and return it as a string.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {string}
       */
      receiveAddressAsString(networkType, index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_receiveAddressAsString(retptr, this.__wbg_ptr, addBorrowedObject(networkType), index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Change Public Key derivations for a given range.
       * @param {number} start
       * @param {number} end
       * @returns {(PublicKey | string)[]}
       */
      changePubkeys(start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changePubkeys(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Change Public Key derivation at a given index.
       * @param {number} index
       * @returns {PublicKey}
       */
      changePubkey(index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changePubkey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PublicKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a range of Change Public Key derivations and return them as strings.
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      changePubkeysAsStrings(start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changePubkeysAsStrings(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Change Public Key derivation at a given index and return it as a string.
       * @param {number} index
       * @returns {string}
       */
      changePubkeyAsString(index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changePubkeyAsString(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Change Address derivations for a given range.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Address[]}
       */
      changeAddresses(networkType, start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changeAddresses(retptr, this.__wbg_ptr, addBorrowedObject(networkType), start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a single Change Address derivation at a given index.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {Address}
       */
      changeAddress(networkType, index) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changeAddress(retptr, this.__wbg_ptr, addBorrowedObject(networkType), index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a range of Change Address derivations and return them as strings.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      changeAddressAsStrings(networkType, start2, end) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changeAddressAsStrings(retptr, this.__wbg_ptr, addBorrowedObject(networkType), start2, end);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Generate a single Change Address derivation at a given index and return it as a string.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {string}
       */
      changeAddressAsString(networkType, index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_changeAddressAsString(retptr, this.__wbg_ptr, addBorrowedObject(networkType), index);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.publickeygenerator_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    ReadStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_readstream_free(ptr >>> 0, 1));
    ReadStream = class {
      static {
        __name$8(this, "ReadStream");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ReadStreamFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_readstream_free(ptr, 0);
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_open(listener) {
        try {
          const ret = wasm.readstream_add_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_close(listener) {
        try {
          const ret = wasm.readstream_add_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_open(listener) {
        try {
          const ret = wasm.readstream_on_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_close(listener) {
        try {
          const ret = wasm.readstream_on_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_open(listener) {
        try {
          const ret = wasm.readstream_once_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_close(listener) {
        try {
          const ret = wasm.readstream_once_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_open(listener) {
        try {
          const ret = wasm.readstream_prepend_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_close(listener) {
        try {
          const ret = wasm.readstream_prepend_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_open(listener) {
        try {
          const ret = wasm.readstream_prepend_once_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_close(listener) {
        try {
          const ret = wasm.readstream_prepend_once_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
    };
    ResolverFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_resolver_free(ptr >>> 0, 1));
    Resolver = class _Resolver {
      static {
        __name$8(this, "Resolver");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Resolver.prototype);
        obj.__wbg_ptr = ptr;
        ResolverFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          urls: this.urls
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResolverFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_resolver_free(ptr, 0);
      }
      /**
       * List of public Kaspa Resolver URLs.
       * @returns {string[] | undefined}
       */
      get urls() {
        const ret = wasm.resolver_urls(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Fetches a public Kaspa wRPC endpoint for the given encoding and network identifier.
       * @see {@link Encoding}, {@link NetworkId}, {@link Node}
       * @param {Encoding} encoding
       * @param {NetworkId | string} network_id
       * @returns {Promise<NodeDescriptor>}
       */
      getNode(encoding, network_id) {
        const ret = wasm.resolver_getNode(this.__wbg_ptr, encoding, addHeapObject(network_id));
        return takeObject(ret);
      }
      /**
       * Fetches a public Kaspa wRPC endpoint URL for the given encoding and network identifier.
       * @see {@link Encoding}, {@link NetworkId}
       * @param {Encoding} encoding
       * @param {NetworkId | string} network_id
       * @returns {Promise<string>}
       */
      getUrl(encoding, network_id) {
        const ret = wasm.resolver_getUrl(this.__wbg_ptr, encoding, addHeapObject(network_id));
        return takeObject(ret);
      }
      /**
       * Connect to a public Kaspa wRPC endpoint for the given encoding and network identifier
       * supplied via {@link IResolverConnect} interface.
       * @see {@link IResolverConnect}, {@link RpcClient}
       * @param {IResolverConnect | NetworkId | string} options
       * @returns {Promise<RpcClient>}
       */
      connect(options) {
        const ret = wasm.resolver_connect(this.__wbg_ptr, addHeapObject(options));
        return takeObject(ret);
      }
      /**
       * Creates a new Resolver client with the given
       * configuration supplied as {@link IResolverConfig}
       * interface. If not supplied, the default configuration
       * containing a list of community-operated resolvers
       * will be used.
       * @param {IResolverConfig | string[] | null} [args]
       */
      constructor(args) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.resolver_ctor(retptr, isLikeNone(args) ? 0 : addHeapObject(args));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          ResolverFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    RpcClientFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_rpcclient_free(ptr >>> 0, 1));
    RpcClient = class _RpcClient {
      static {
        __name$8(this, "RpcClient");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_RpcClient.prototype);
        obj.__wbg_ptr = ptr;
        RpcClientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          url: this.url,
          resolver: this.resolver,
          isConnected: this.isConnected,
          encoding: this.encoding,
          nodeId: this.nodeId
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RpcClientFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rpcclient_free(ptr, 0);
      }
      /**
       * Retrieves the current number of blocks in the Kaspa BlockDAG.
       * This is not a block count, not a "block height" and can not be
       * used for transaction validation.
       * Returned information: Current block count.
       * @see {@link IGetBlockCountRequest}, {@link IGetBlockCountResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetBlockCountRequest | null} [request]
       * @returns {Promise<IGetBlockCountResponse>}
       */
      getBlockCount(request) {
        const ret = wasm.rpcclient_getBlockCount(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Provides information about the Directed Acyclic Graph (DAG)
       * structure of the Kaspa BlockDAG.
       * Returned information: Number of blocks in the DAG,
       * number of tips in the DAG, hash of the selected parent block,
       * difficulty of the selected parent block, selected parent block
       * blue score, selected parent block time.
       * @see {@link IGetBlockDagInfoRequest}, {@link IGetBlockDagInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetBlockDagInfoRequest | null} [request]
       * @returns {Promise<IGetBlockDagInfoResponse>}
       */
      getBlockDagInfo(request) {
        const ret = wasm.rpcclient_getBlockDagInfo(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Returns the total current coin supply of Kaspa network.
       * Returned information: Total coin supply.
       * @see {@link IGetCoinSupplyRequest}, {@link IGetCoinSupplyResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetCoinSupplyRequest | null} [request]
       * @returns {Promise<IGetCoinSupplyResponse>}
       */
      getCoinSupply(request) {
        const ret = wasm.rpcclient_getCoinSupply(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves information about the peers connected to the Kaspa node.
       * Returned information: Peer ID, IP address and port, connection
       * status, protocol version.
       * @see {@link IGetConnectedPeerInfoRequest}, {@link IGetConnectedPeerInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetConnectedPeerInfoRequest | null} [request]
       * @returns {Promise<IGetConnectedPeerInfoResponse>}
       */
      getConnectedPeerInfo(request) {
        const ret = wasm.rpcclient_getConnectedPeerInfo(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves general information about the Kaspa node.
       * Returned information: Version of the Kaspa node, protocol
       * version, network identifier.
       * This call is primarily used by gRPC clients.
       * For wRPC clients, use {@link RpcClient.getServerInfo}.
       * @see {@link IGetInfoRequest}, {@link IGetInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetInfoRequest | null} [request]
       * @returns {Promise<IGetInfoResponse>}
       */
      getInfo(request) {
        const ret = wasm.rpcclient_getInfo(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Provides a list of addresses of known peers in the Kaspa
       * network that the node can potentially connect to.
       * Returned information: List of peer addresses.
       * @see {@link IGetPeerAddressesRequest}, {@link IGetPeerAddressesResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetPeerAddressesRequest | null} [request]
       * @returns {Promise<IGetPeerAddressesResponse>}
       */
      getPeerAddresses(request) {
        const ret = wasm.rpcclient_getPeerAddresses(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves various metrics and statistics related to the
       * performance and status of the Kaspa node.
       * Returned information: Memory usage, CPU usage, network activity.
       * @see {@link IGetMetricsRequest}, {@link IGetMetricsResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetMetricsRequest | null} [request]
       * @returns {Promise<IGetMetricsResponse>}
       */
      getMetrics(request) {
        const ret = wasm.rpcclient_getMetrics(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves current number of network connections
       * @see {@link IGetConnectionsRequest}, {@link IGetConnectionsResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetConnectionsRequest | null} [request]
       * @returns {Promise<IGetConnectionsResponse>}
       */
      getConnections(request) {
        const ret = wasm.rpcclient_getConnections(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves the current sink block, which is the block with
       * the highest cumulative difficulty in the Kaspa BlockDAG.
       * Returned information: Sink block hash, sink block height.
       * @see {@link IGetSinkRequest}, {@link IGetSinkResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSinkRequest | null} [request]
       * @returns {Promise<IGetSinkResponse>}
       */
      getSink(request) {
        const ret = wasm.rpcclient_getSink(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Returns the blue score of the current sink block, indicating
       * the total amount of work that has been done on the main chain
       * leading up to that block.
       * Returned information: Blue score of the sink block.
       * @see {@link IGetSinkBlueScoreRequest}, {@link IGetSinkBlueScoreResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSinkBlueScoreRequest | null} [request]
       * @returns {Promise<IGetSinkBlueScoreResponse>}
       */
      getSinkBlueScore(request) {
        const ret = wasm.rpcclient_getSinkBlueScore(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Tests the connection and responsiveness of a Kaspa node.
       * Returned information: None.
       * @see {@link IPingRequest}, {@link IPingResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IPingRequest | null} [request]
       * @returns {Promise<IPingResponse>}
       */
      ping(request) {
        const ret = wasm.rpcclient_ping(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Gracefully shuts down the Kaspa node.
       * Returned information: None.
       * @see {@link IShutdownRequest}, {@link IShutdownResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IShutdownRequest | null} [request]
       * @returns {Promise<IShutdownResponse>}
       */
      shutdown(request) {
        const ret = wasm.rpcclient_shutdown(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves information about the Kaspa server.
       * Returned information: Version of the Kaspa server, protocol
       * version, network identifier.
       * @see {@link IGetServerInfoRequest}, {@link IGetServerInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetServerInfoRequest | null} [request]
       * @returns {Promise<IGetServerInfoResponse>}
       */
      getServerInfo(request) {
        const ret = wasm.rpcclient_getServerInfo(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Obtains basic information about the synchronization status of the Kaspa node.
       * Returned information: Syncing status.
       * @see {@link IGetSyncStatusRequest}, {@link IGetSyncStatusResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSyncStatusRequest | null} [request]
       * @returns {Promise<IGetSyncStatusResponse>}
       */
      getSyncStatus(request) {
        const ret = wasm.rpcclient_getSyncStatus(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Feerate estimates
       * @see {@link IGetFeeEstimateRequest}, {@link IGetFeeEstimateResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetFeeEstimateRequest | null} [request]
       * @returns {Promise<IGetFeeEstimateResponse>}
       */
      getFeeEstimate(request) {
        const ret = wasm.rpcclient_getFeeEstimate(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves the current network configuration.
       * Returned information: Current network configuration.
       * @see {@link IGetCurrentNetworkRequest}, {@link IGetCurrentNetworkResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetCurrentNetworkRequest | null} [request]
       * @returns {Promise<IGetCurrentNetworkResponse>}
       */
      getCurrentNetwork(request) {
        const ret = wasm.rpcclient_getCurrentNetwork(this.__wbg_ptr, isLikeNone(request) ? 0 : addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Adds a peer to the Kaspa node's list of known peers.
       * Returned information: None.
       * @see {@link IAddPeerRequest}, {@link IAddPeerResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IAddPeerRequest} request
       * @returns {Promise<IAddPeerResponse>}
       */
      addPeer(request) {
        const ret = wasm.rpcclient_addPeer(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Bans a peer from connecting to the Kaspa node for a specified duration.
       * Returned information: None.
       * @see {@link IBanRequest}, {@link IBanResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IBanRequest} request
       * @returns {Promise<IBanResponse>}
       */
      ban(request) {
        const ret = wasm.rpcclient_ban(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Estimates the network's current hash rate in hashes per second.
       * Returned information: Estimated network hashes per second.
       * @see {@link IEstimateNetworkHashesPerSecondRequest}, {@link IEstimateNetworkHashesPerSecondResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IEstimateNetworkHashesPerSecondRequest} request
       * @returns {Promise<IEstimateNetworkHashesPerSecondResponse>}
       */
      estimateNetworkHashesPerSecond(request) {
        const ret = wasm.rpcclient_estimateNetworkHashesPerSecond(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves the balance of a specific address in the Kaspa BlockDAG.
       * Returned information: Balance of the address.
       * @see {@link IGetBalanceByAddressRequest}, {@link IGetBalanceByAddressResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBalanceByAddressRequest} request
       * @returns {Promise<IGetBalanceByAddressResponse>}
       */
      getBalanceByAddress(request) {
        const ret = wasm.rpcclient_getBalanceByAddress(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves balances for multiple addresses in the Kaspa BlockDAG.
       * Returned information: Balances of the addresses.
       * @see {@link IGetBalancesByAddressesRequest}, {@link IGetBalancesByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBalancesByAddressesRequest | Address[] | string[]} request
       * @returns {Promise<IGetBalancesByAddressesResponse>}
       */
      getBalancesByAddresses(request) {
        const ret = wasm.rpcclient_getBalancesByAddresses(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves a specific block from the Kaspa BlockDAG.
       * Returned information: Block information.
       * @see {@link IGetBlockRequest}, {@link IGetBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlockRequest} request
       * @returns {Promise<IGetBlockResponse>}
       */
      getBlock(request) {
        const ret = wasm.rpcclient_getBlock(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves multiple blocks from the Kaspa BlockDAG.
       * Returned information: List of block information.
       * @see {@link IGetBlocksRequest}, {@link IGetBlocksResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlocksRequest} request
       * @returns {Promise<IGetBlocksResponse>}
       */
      getBlocks(request) {
        const ret = wasm.rpcclient_getBlocks(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Generates a new block template for mining.
       * Returned information: Block template information.
       * @see {@link IGetBlockTemplateRequest}, {@link IGetBlockTemplateResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlockTemplateRequest} request
       * @returns {Promise<IGetBlockTemplateResponse>}
       */
      getBlockTemplate(request) {
        const ret = wasm.rpcclient_getBlockTemplate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Checks if block is blue or not.
       * Returned information: Block blueness.
       * @see {@link IGetCurrentBlockColorRequest}, {@link IGetCurrentBlockColorResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetCurrentBlockColorRequest} request
       * @returns {Promise<IGetCurrentBlockColorResponse>}
       */
      getCurrentBlockColor(request) {
        const ret = wasm.rpcclient_getCurrentBlockColor(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves the estimated DAA (Difficulty Adjustment Algorithm)
       * score timestamp estimate.
       * Returned information: DAA score timestamp estimate.
       * @see {@link IGetDaaScoreTimestampEstimateRequest}, {@link IGetDaaScoreTimestampEstimateResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetDaaScoreTimestampEstimateRequest} request
       * @returns {Promise<IGetDaaScoreTimestampEstimateResponse>}
       */
      getDaaScoreTimestampEstimate(request) {
        const ret = wasm.rpcclient_getDaaScoreTimestampEstimate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Feerate estimates (experimental)
       * @see {@link IGetFeeEstimateExperimentalRequest}, {@link IGetFeeEstimateExperimentalResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetFeeEstimateExperimentalRequest} request
       * @returns {Promise<IGetFeeEstimateExperimentalResponse>}
       */
      getFeeEstimateExperimental(request) {
        const ret = wasm.rpcclient_getFeeEstimateExperimental(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves block headers from the Kaspa BlockDAG.
       * Returned information: List of block headers.
       * @see {@link IGetHeadersRequest}, {@link IGetHeadersResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetHeadersRequest} request
       * @returns {Promise<IGetHeadersResponse>}
       */
      getHeaders(request) {
        const ret = wasm.rpcclient_getHeaders(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves mempool entries from the Kaspa node's mempool.
       * Returned information: List of mempool entries.
       * @see {@link IGetMempoolEntriesRequest}, {@link IGetMempoolEntriesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntriesRequest} request
       * @returns {Promise<IGetMempoolEntriesResponse>}
       */
      getMempoolEntries(request) {
        const ret = wasm.rpcclient_getMempoolEntries(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves mempool entries associated with specific addresses.
       * Returned information: List of mempool entries.
       * @see {@link IGetMempoolEntriesByAddressesRequest}, {@link IGetMempoolEntriesByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntriesByAddressesRequest} request
       * @returns {Promise<IGetMempoolEntriesByAddressesResponse>}
       */
      getMempoolEntriesByAddresses(request) {
        const ret = wasm.rpcclient_getMempoolEntriesByAddresses(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves a specific mempool entry by transaction ID.
       * Returned information: Mempool entry information.
       * @see {@link IGetMempoolEntryRequest}, {@link IGetMempoolEntryResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntryRequest} request
       * @returns {Promise<IGetMempoolEntryResponse>}
       */
      getMempoolEntry(request) {
        const ret = wasm.rpcclient_getMempoolEntry(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves information about a subnetwork in the Kaspa BlockDAG.
       * Returned information: Subnetwork information.
       * @see {@link IGetSubnetworkRequest}, {@link IGetSubnetworkResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetSubnetworkRequest} request
       * @returns {Promise<IGetSubnetworkResponse>}
       */
      getSubnetwork(request) {
        const ret = wasm.rpcclient_getSubnetwork(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves unspent transaction outputs (UTXOs) associated with
       * specific addresses.
       * Returned information: List of UTXOs.
       * @see {@link IGetUtxosByAddressesRequest}, {@link IGetUtxosByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetUtxosByAddressesRequest | Address[] | string[]} request
       * @returns {Promise<IGetUtxosByAddressesResponse>}
       */
      getUtxosByAddresses(request) {
        const ret = wasm.rpcclient_getUtxosByAddresses(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Retrieves the virtual chain corresponding to a specified block hash.
       * Returned information: Virtual chain information.
       * @see {@link IGetVirtualChainFromBlockRequest}, {@link IGetVirtualChainFromBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetVirtualChainFromBlockRequest} request
       * @returns {Promise<IGetVirtualChainFromBlockResponse>}
       */
      getVirtualChainFromBlock(request) {
        const ret = wasm.rpcclient_getVirtualChainFromBlock(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Resolves a finality conflict in the Kaspa BlockDAG.
       * Returned information: None.
       * @see {@link IResolveFinalityConflictRequest}, {@link IResolveFinalityConflictResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IResolveFinalityConflictRequest} request
       * @returns {Promise<IResolveFinalityConflictResponse>}
       */
      resolveFinalityConflict(request) {
        const ret = wasm.rpcclient_resolveFinalityConflict(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Submits a block to the Kaspa network.
       * Returned information: None.
       * @see {@link ISubmitBlockRequest}, {@link ISubmitBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitBlockRequest} request
       * @returns {Promise<ISubmitBlockResponse>}
       */
      submitBlock(request) {
        const ret = wasm.rpcclient_submitBlock(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Submits a transaction to the Kaspa network.
       * Returned information: Submitted Transaction Id.
       * @see {@link ISubmitTransactionRequest}, {@link ISubmitTransactionResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitTransactionRequest} request
       * @returns {Promise<ISubmitTransactionResponse>}
       */
      submitTransaction(request) {
        const ret = wasm.rpcclient_submitTransaction(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Submits an RBF transaction to the Kaspa network.
       * Returned information: Submitted Transaction Id, Transaction that was replaced.
       * @see {@link ISubmitTransactionReplacementRequest}, {@link ISubmitTransactionReplacementResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitTransactionReplacementRequest} request
       * @returns {Promise<ISubmitTransactionReplacementResponse>}
       */
      submitTransactionReplacement(request) {
        const ret = wasm.rpcclient_submitTransactionReplacement(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Unbans a previously banned peer, allowing it to connect
       * to the Kaspa node again.
       * Returned information: None.
       * @see {@link IUnbanRequest}, {@link IUnbanResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IUnbanRequest} request
       * @returns {Promise<IUnbanResponse>}
       */
      unban(request) {
        const ret = wasm.rpcclient_unban(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * Manage subscription for a block added notification event.
       * Block added notification event is produced when a new
       * block is added to the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeBlockAdded() {
        const ret = wasm.rpcclient_subscribeBlockAdded(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeBlockAdded() {
        const ret = wasm.rpcclient_unsubscribeBlockAdded(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a finality conflict notification event.
       * Finality conflict notification event is produced when a finality
       * conflict occurs in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeFinalityConflict() {
        const ret = wasm.rpcclient_subscribeFinalityConflict(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeFinalityConflict() {
        const ret = wasm.rpcclient_unsubscribeFinalityConflict(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a finality conflict resolved notification event.
       * Finality conflict resolved notification event is produced when a finality
       * conflict in the Kaspa BlockDAG is resolved.
       * @returns {Promise<void>}
       */
      subscribeFinalityConflictResolved() {
        const ret = wasm.rpcclient_subscribeFinalityConflictResolved(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeFinalityConflictResolved() {
        const ret = wasm.rpcclient_unsubscribeFinalityConflictResolved(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a sink blue score changed notification event.
       * Sink blue score changed notification event is produced when the blue
       * score of the sink block changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeSinkBlueScoreChanged() {
        const ret = wasm.rpcclient_subscribeSinkBlueScoreChanged(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeSinkBlueScoreChanged() {
        const ret = wasm.rpcclient_unsubscribeSinkBlueScoreChanged(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a pruning point UTXO set override notification event.
       * Pruning point UTXO set override notification event is produced when the
       * UTXO set override for the pruning point changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribePruningPointUtxoSetOverride() {
        const ret = wasm.rpcclient_subscribePruningPointUtxoSetOverride(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribePruningPointUtxoSetOverride() {
        const ret = wasm.rpcclient_unsubscribePruningPointUtxoSetOverride(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a new block template notification event.
       * New block template notification event is produced when a new block
       * template is generated for mining in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeNewBlockTemplate() {
        const ret = wasm.rpcclient_subscribeNewBlockTemplate(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeNewBlockTemplate() {
        const ret = wasm.rpcclient_unsubscribeNewBlockTemplate(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a virtual DAA score changed notification event.
       * Virtual DAA score changed notification event is produced when the virtual
       * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeVirtualDaaScoreChanged() {
        const ret = wasm.rpcclient_subscribeVirtualDaaScoreChanged(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a virtual DAA score changed notification event.
       * Virtual DAA score changed notification event is produced when the virtual
       * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      unsubscribeVirtualDaaScoreChanged() {
        const ret = wasm.rpcclient_unsubscribeVirtualDaaScoreChanged(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Subscribe for a UTXOs changed notification event.
       * UTXOs changed notification event is produced when the set
       * of unspent transaction outputs (UTXOs) changes in the
       * Kaspa BlockDAG. The event notification will be scoped to the
       * provided list of addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      subscribeUtxosChanged(addresses) {
        const ret = wasm.rpcclient_subscribeUtxosChanged(this.__wbg_ptr, addHeapObject(addresses));
        return takeObject(ret);
      }
      /**
       * Unsubscribe from UTXOs changed notification event
       * for a specific set of addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      unsubscribeUtxosChanged(addresses) {
        const ret = wasm.rpcclient_unsubscribeUtxosChanged(this.__wbg_ptr, addHeapObject(addresses));
        return takeObject(ret);
      }
      /**
       * Manage subscription for a virtual chain changed notification event.
       * Virtual chain changed notification event is produced when the virtual
       * chain changes in the Kaspa BlockDAG.
       * @param {boolean} include_accepted_transaction_ids
       * @returns {Promise<void>}
       */
      subscribeVirtualChainChanged(include_accepted_transaction_ids) {
        const ret = wasm.rpcclient_subscribeVirtualChainChanged(this.__wbg_ptr, include_accepted_transaction_ids);
        return takeObject(ret);
      }
      /**
       * Manage subscription for a virtual chain changed notification event.
       * Virtual chain changed notification event is produced when the virtual
       * chain changes in the Kaspa BlockDAG.
       * @param {boolean} include_accepted_transaction_ids
       * @returns {Promise<void>}
       */
      unsubscribeVirtualChainChanged(include_accepted_transaction_ids) {
        const ret = wasm.rpcclient_unsubscribeVirtualChainChanged(this.__wbg_ptr, include_accepted_transaction_ids);
        return takeObject(ret);
      }
      /**
       * @param {Encoding} encoding
       * @param {NetworkType | NetworkId | string} network
       * @returns {number}
       */
      static defaultPort(encoding, network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_defaultPort(retptr, encoding, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return r0;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Constructs an WebSocket RPC URL given the partial URL or an IP, RPC encoding
       * and a network type.
       *
       * # Arguments
       *
       * * `url` - Partial URL or an IP address
       * * `encoding` - RPC encoding
       * * `network_type` - Network type
       * @param {string} url
       * @param {Encoding} encoding
       * @param {NetworkId} network
       * @returns {string}
       */
      static parseUrl(url, encoding, network) {
        let deferred4_0;
        let deferred4_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          _assertClass(network, NetworkId);
          var ptr1 = network.__destroy_into_raw();
          wasm.rpcclient_parseUrl(retptr, ptr0, len0, encoding, ptr1);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr3 = r0;
          var len3 = r1;
          if (r3) {
            ptr3 = 0;
            len3 = 0;
            throw takeObject(r2);
          }
          deferred4_0 = ptr3;
          deferred4_1 = len3;
          return getStringFromWasm0(ptr3, len3);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
        }
      }
      /**
       *
       * Create a new RPC client with optional {@link Encoding} and a `url`.
       *
       * @see {@link IRpcConfig} interface for more details.
       * @param {IRpcConfig | null} [config]
       */
      constructor(config) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_ctor(retptr, isLikeNone(config) ? 0 : addHeapObject(config));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          RpcClientFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * The current URL of the RPC client.
       * @returns {string | undefined}
       */
      get url() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_url(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Current rpc resolver
       * @returns {Resolver | undefined}
       */
      get resolver() {
        const ret = wasm.rpcclient_resolver(this.__wbg_ptr);
        return ret === 0 ? void 0 : Resolver.__wrap(ret);
      }
      /**
       * Set the resolver for the RPC client.
       * This setting will take effect on the next connection.
       * @param {Resolver} resolver
       */
      setResolver(resolver) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(resolver, Resolver);
          var ptr0 = resolver.__destroy_into_raw();
          wasm.rpcclient_setResolver(retptr, this.__wbg_ptr, ptr0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Set the network id for the RPC client.
       * This setting will take effect on the next connection.
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_setNetworkId(retptr, this.__wbg_ptr, addBorrowedObject(network_id));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * The current connection status of the RPC client.
       * @returns {boolean}
       */
      get isConnected() {
        const ret = wasm.rpcclient_isConnected(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * The current protocol encoding.
       * @returns {string}
       */
      get encoding() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_encoding(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Optional: Resolver node id.
       * @returns {string | undefined}
       */
      get nodeId() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_nodeId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Connect to the Kaspa RPC server. This function starts a background
       * task that connects and reconnects to the server if the connection
       * is terminated.  Use [`disconnect()`](Self::disconnect()) to
       * terminate the connection.
       * @see {@link IConnectOptions} interface for more details.
       * @param {IConnectOptions | undefined | null} [args]
       * @returns {Promise<void>}
       */
      connect(args) {
        const ret = wasm.rpcclient_connect(this.__wbg_ptr, isLikeNone(args) ? 0 : addHeapObject(args));
        return takeObject(ret);
      }
      /**
       * Disconnect from the Kaspa RPC server.
       * @returns {Promise<void>}
       */
      disconnect() {
        const ret = wasm.rpcclient_disconnect(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Start background RPC services (automatically started when invoking {@link RpcClient.connect}).
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm.rpcclient_start(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Stop background RPC services (automatically stopped when invoking {@link RpcClient.disconnect}).
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm.rpcclient_stop(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Triggers a disconnection on the underlying WebSocket
       * if the WebSocket is in connected state.
       * This is intended for debug purposes only.
       * Can be used to test application reconnection logic.
       */
      triggerAbort() {
        wasm.rpcclient_triggerAbort(this.__wbg_ptr);
      }
      /**
       *
       * Register an event listener callback.
       *
       * Registers a callback function to be executed when a specific event occurs.
       * The callback function will receive an {@link RpcEvent} object with the event `type` and `data`.
       *
       * **RPC Subscriptions vs Event Listeners**
       *
       * Subscriptions are used to receive notifications from the RPC client.
       * Event listeners are client-side application registrations that are
       * triggered when notifications are received.
       *
       * If node is disconnected, upon reconnection you do not need to re-register event listeners,
       * however, you have to re-subscribe for Kaspa node notifications. As such, it is recommended
       * to register event listeners when the RPC `open` event is received.
       *
       * ```javascript
       * rpc.addEventListener("connect", async (event) => {
       *     console.log("Connected to", rpc.url);
       *     await rpc.subscribeDaaScore();
       *     // ... perform wallet address subscriptions
       * });
       * ```
       *
       * **Multiple events and listeners**
       *
       * `addEventListener` can be used to register multiple event listeners for the same event
       * as well as the same event listener for multiple events.
       *
       * ```javascript
       * // Registering a single event listener for multiple events:
       * rpc.addEventListener(["connect", "disconnect"], (event) => {
       *     console.log(event);
       * });
       *
       * // Registering event listener for all events:
       * // (by omitting the event type)
       * rpc.addEventListener((event) => {
       *     console.log(event);
       * });
       *
       * // Registering multiple event listeners for the same event:
       * rpc.addEventListener("connect", (event) => { // first listener
       *     console.log(event);
       * });
       * rpc.addEventListener("connect", (event) => { // second listener
       *     console.log(event);
       * });
       * ```
       *
       * **Use of context objects**
       *
       * You can also register an event with a `context` object. When the event is triggered,
       * the `handleEvent` method of the `context` object will be called while `this` value
       * will be set to the `context` object.
       * ```javascript
       * // Registering events with a context object:
       *
       * const context = {
       *     someProperty: "someValue",
       *     handleEvent: (event) => {
       *         // the following will log "someValue"
       *         console.log(this.someProperty);
       *         console.log(event);
       *     }
       * };
       * rpc.addEventListener(["connect","disconnect"], context);
       *
       * ```
       *
       * **General use examples**
       *
       * In TypeScript you can use {@link RpcEventType} enum (such as `RpcEventType.Connect`)
       * or `string` (such as "connect") to register event listeners.
       * In JavaScript you can only use `string`.
       *
       * ```typescript
       * // Example usage (TypeScript):
       *
       * rpc.addEventListener(RpcEventType.Connect, (event) => {
       *     console.log("Connected to", rpc.url);
       * });
       *
       * rpc.addEventListener(RpcEventType.VirtualDaaScoreChanged, (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeDaaScore();
       *
       * rpc.addEventListener(RpcEventType.BlockAdded, (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeBlockAdded();
       *
       * // Example usage (JavaScript):
       *
       * rpc.addEventListener("virtual-daa-score-changed", (event) => {
       *     console.log(event.type,event.data);
       * });
       *
       * await rpc.subscribeDaaScore();
       * rpc.addEventListener("block-added", (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeBlockAdded();
       * ```
       *
       * @see {@link RpcEventType} for a list of supported events.
       * @see {@link RpcEventData} for the event data interface specification.
       * @see {@link RpcClient.removeEventListener}, {@link RpcClient.removeAllEventListeners}
       * @param {RpcEventType | string | RpcEventCallback} event
       * @param {RpcEventCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_addEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister an event listener.
       * This function will remove the callback for the specified event.
       * If the `callback` is not supplied, all callbacks will be
       * removed for the specified event.
       *
       * @see {@link RpcClient.addEventListener}
       * @param {RpcEventType | string} event
       * @param {RpcEventCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_removeEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister a single event listener callback from all events.
       *
       *
       * @param {RpcEventCallback} callback
       */
      clearEventListener(callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_clearEventListener(retptr, this.__wbg_ptr, addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister all notification callbacks for all events.
       */
      removeAllEventListeners() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rpcclient_removeAllEventListeners(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ScriptBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_scriptbuilder_free(ptr >>> 0, 1));
    ScriptBuilder = class _ScriptBuilder {
      static {
        __name$8(this, "ScriptBuilder");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ScriptBuilder.prototype);
        obj.__wbg_ptr = ptr;
        ScriptBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {};
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptBuilderFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptbuilder_free(ptr, 0);
      }
      constructor() {
        const ret = wasm.scriptbuilder_new();
        this.__wbg_ptr = ret >>> 0;
        ScriptBuilderFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * Creates a new ScriptBuilder over an existing script.
       * Supplied script can be represented as an `Uint8Array` or a `HexString`.
       * @param {HexString | Uint8Array} script
       * @returns {ScriptBuilder}
       */
      static fromScript(script) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_fromScript(retptr, addHeapObject(script));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Pushes the passed opcode to the end of the script. The script will not
       * be modified if pushing the opcode would cause the script to exceed the
       * maximum allowed script engine size.
       * @param {number} op
       * @returns {ScriptBuilder}
       */
      addOp(op) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addOp(retptr, this.__wbg_ptr, op);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Adds the passed opcodes to the end of the script.
       * Supplied opcodes can be represented as an `Uint8Array` or a `HexString`.
       * @param {HexString | Uint8Array} opcodes
       * @returns {ScriptBuilder}
       */
      addOps(opcodes) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addOps(retptr, this.__wbg_ptr, addHeapObject(opcodes));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * AddData pushes the passed data to the end of the script. It automatically
       * chooses canonical opcodes depending on the length of the data.
       *
       * A zero length buffer will lead to a push of empty data onto the stack (Op0 = OpFalse)
       * and any push of data greater than [`MAX_SCRIPT_ELEMENT_SIZE`](kaspa_txscript::MAX_SCRIPT_ELEMENT_SIZE) will not modify
       * the script since that is not allowed by the script engine.
       *
       * Also, the script will not be modified if pushing the data would cause the script to
       * exceed the maximum allowed script engine size [`MAX_SCRIPTS_SIZE`](kaspa_txscript::MAX_SCRIPTS_SIZE).
       * @param {HexString | Uint8Array} data
       * @returns {ScriptBuilder}
       */
      addData(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addData(retptr, this.__wbg_ptr, addHeapObject(data));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} value
       * @returns {ScriptBuilder}
       */
      addI64(value2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addI64(retptr, this.__wbg_ptr, value2);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} lock_time
       * @returns {ScriptBuilder}
       */
      addLockTime(lock_time) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addLockTime(retptr, this.__wbg_ptr, lock_time);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} sequence
       * @returns {ScriptBuilder}
       */
      addSequence(sequence) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_addLockTime(retptr, this.__wbg_ptr, sequence);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {HexString | Uint8Array} data
       * @returns {number}
       */
      static canonicalDataSize(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_canonicalDataSize(retptr, addHeapObject(data));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return r0 >>> 0;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Get script bytes represented by a hex string.
       * @returns {HexString}
       */
      toString() {
        const ret = wasm.scriptbuilder_toString(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Drains (empties) the script builder, returning the
       * script bytes represented by a hex string.
       * @returns {HexString}
       */
      drain() {
        const ret = wasm.scriptbuilder_drain(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Creates an equivalent pay-to-script-hash script.
       * Can be used to create an P2SH address.
       * @see {@link addressFromScriptPublicKey}
       * @returns {ScriptPublicKey}
       */
      createPayToScriptHashScript() {
        const ret = wasm.scriptbuilder_createPayToScriptHashScript(this.__wbg_ptr);
        return ScriptPublicKey.__wrap(ret);
      }
      /**
       * Generates a signature script that fits a pay-to-script-hash script.
       * @param {HexString | Uint8Array} signature
       * @returns {HexString}
       */
      encodePayToScriptHashSignatureScript(signature2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_encodePayToScriptHashSignatureScript(retptr, this.__wbg_ptr, addHeapObject(signature2));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {IHexViewConfig | null} [args]
       * @returns {string}
       */
      hexView(args) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptbuilder_hexView(retptr, this.__wbg_ptr, isLikeNone(args) ? 0 : addHeapObject(args));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    ScriptPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_scriptpublickey_free(ptr >>> 0, 1));
    ScriptPublicKey = class _ScriptPublicKey {
      static {
        __name$8(this, "ScriptPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ScriptPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        ScriptPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          version: this.version,
          script: this.script
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptPublicKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scriptpublickey_free(ptr, 0);
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm.__wbg_get_scriptpublickey_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} arg0
       */
      set version(arg0) {
        wasm.__wbg_set_scriptpublickey_version(this.__wbg_ptr, arg0);
      }
      /**
       * @param {number} version
       * @param {any} script
       */
      constructor(version3, script) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptpublickey_constructor(retptr, version3, addHeapObject(script));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          ScriptPublicKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get script() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.scriptpublickey_script_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    SetAadOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_setaadoptions_free(ptr >>> 0, 1));
    SetAadOptions = class {
      static {
        __name$8(this, "SetAadOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SetAadOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_setaadoptions_free(ptr, 0);
      }
      /**
       * @param {Function} flush
       * @param {number} plaintext_length
       * @param {Function} transform
       */
      constructor(flush, plaintext_length, transform) {
        const ret = wasm.setaadoptions_new(addHeapObject(flush), plaintext_length, addHeapObject(transform));
        this.__wbg_ptr = ret >>> 0;
        SetAadOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {Function}
       */
      get flush() {
        const ret = wasm.setaadoptions_flush(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set flush(value2) {
        wasm.setaadoptions_set_flush(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {number}
       */
      get plaintextLength() {
        const ret = wasm.setaadoptions_plaintextLength(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set plaintext_length(value2) {
        wasm.setaadoptions_set_plaintext_length(this.__wbg_ptr, value2);
      }
      /**
       * @returns {Function}
       */
      get transform() {
        const ret = wasm.setaadoptions_transform(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set transform(value2) {
        wasm.setaadoptions_set_transform(this.__wbg_ptr, addHeapObject(value2));
      }
    };
    SigHashTypeFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_sighashtype_free(ptr >>> 0, 1));
    SigHashType = class {
      static {
        __name$8(this, "SigHashType");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SigHashTypeFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_sighashtype_free(ptr, 0);
      }
    };
    StorageFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_storage_free(ptr >>> 0, 1));
    Storage = class {
      static {
        __name$8(this, "Storage");
      }
      toJSON() {
        return {
          filename: this.filename
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StorageFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_storage_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get filename() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.storage_filename(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    StreamTransformOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_streamtransformoptions_free(ptr >>> 0, 1));
    StreamTransformOptions = class {
      static {
        __name$8(this, "StreamTransformOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StreamTransformOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_streamtransformoptions_free(ptr, 0);
      }
      /**
       * @param {Function} flush
       * @param {Function} transform
       */
      constructor(flush, transform) {
        const ret = wasm.streamtransformoptions_new(addHeapObject(flush), addHeapObject(transform));
        this.__wbg_ptr = ret >>> 0;
        StreamTransformOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {Function}
       */
      get flush() {
        const ret = wasm.streamtransformoptions_flush(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set flush(value2) {
        wasm.streamtransformoptions_set_flush(this.__wbg_ptr, addHeapObject(value2));
      }
      /**
       * @returns {Function}
       */
      get transform() {
        const ret = wasm.streamtransformoptions_transform(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {Function} value
       */
      set transform(value2) {
        wasm.streamtransformoptions_set_transform(this.__wbg_ptr, addHeapObject(value2));
      }
    };
    TransactionFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transaction_free(ptr >>> 0, 1));
    Transaction = class _Transaction {
      static {
        __name$8(this, "Transaction");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Transaction.prototype);
        obj.__wbg_ptr = ptr;
        TransactionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          inputs: this.inputs,
          outputs: this.outputs,
          version: this.version,
          lockTime: this.lockTime,
          gas: this.gas,
          subnetworkId: this.subnetworkId,
          payload: this.payload,
          mass: this.mass
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transaction_free(ptr, 0);
      }
      /**
       * Determines whether or not a transaction is a coinbase transaction. A coinbase
       * transaction is a special transaction created by miners that distributes fees and block subsidy
       * to the previous blocks' miners, and specifies the script_pub_key that will be used to pay the current
       * miner in future blocks.
       * @returns {boolean}
       */
      is_coinbase() {
        const ret = wasm.transaction_is_coinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Recompute and finalize the tx id based on updated tx fields
       * @returns {Hash}
       */
      finalize() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Hash.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Returns the transaction ID
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {ITransaction | Transaction} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_constructor(retptr, addBorrowedObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          TransactionFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {TransactionInput[]}
       */
      get inputs() {
        const ret = wasm.transaction_get_inputs_as_js_array(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Returns a list of unique addresses used by transaction inputs.
       * This method can be used to determine addresses used by transaction inputs
       * in order to select private keys needed for transaction signing.
       * @param {NetworkType | NetworkId | string} network_type
       * @returns {Address[]}
       */
      addresses(network_type) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_addresses(retptr, this.__wbg_ptr, addBorrowedObject(network_type));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {(ITransactionInput | TransactionInput)[]} js_value
       */
      set inputs(js_value) {
        try {
          wasm.transaction_set_inputs_from_js_array(this.__wbg_ptr, addBorrowedObject(js_value));
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {TransactionOutput[]}
       */
      get outputs() {
        const ret = wasm.transaction_get_outputs_as_js_array(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {(ITransactionOutput | TransactionOutput)[]} js_value
       */
      set outputs(js_value) {
        try {
          wasm.transaction_set_outputs_from_js_array(this.__wbg_ptr, addBorrowedObject(js_value));
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm.transaction_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} v
       */
      set version(v) {
        wasm.transaction_set_version(this.__wbg_ptr, v);
      }
      /**
       * @returns {bigint}
       */
      get lockTime() {
        const ret = wasm.transaction_lockTime(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set lockTime(v) {
        wasm.transaction_set_lockTime(this.__wbg_ptr, v);
      }
      /**
       * @returns {bigint}
       */
      get gas() {
        const ret = wasm.transaction_gas(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set gas(v) {
        wasm.transaction_set_gas(this.__wbg_ptr, v);
      }
      /**
       * @returns {string}
       */
      get subnetworkId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_get_subnetwork_id_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set subnetworkId(js_value) {
        wasm.transaction_set_subnetwork_id_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {string}
       */
      get payload() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_get_payload_as_hex_string(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set payload(js_value) {
        wasm.transaction_set_payload_from_js_value(this.__wbg_ptr, addHeapObject(js_value));
      }
      /**
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm.transaction_get_mass(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set mass(v) {
        wasm.transaction_set_mass(this.__wbg_ptr, v);
      }
      /**
       * Serializes the transaction to a pure JavaScript Object.
       * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
       * @see {@link ISerializableTransaction}
       * @returns {ISerializableTransaction}
       */
      serializeToObject() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_serializeToObject(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a JSON string.
       * The schema of the JSON is defined by {@link ISerializableTransaction}.
       * @returns {string}
       */
      serializeToJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_serializeToJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
       * @returns {string}
       */
      serializeToSafeJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a pure JavaScript Object.
       * @param {any} js_value
       * @returns {Transaction}
       */
      static deserializeFromObject(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transaction_deserializeFromObject(retptr, addBorrowedObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a JSON string.
       * @param {string} json
       * @returns {Transaction}
       */
      static deserializeFromJSON(json) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.transaction_deserializeFromJSON(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a "Safe" JSON schema where all `bigint` values are represented as `string`.
       * @param {string} json
       * @returns {Transaction}
       */
      static deserializeFromSafeJSON(json) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.transaction_deserializeFromSafeJSON(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    TransactionInputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactioninput_free(ptr >>> 0, 1));
    TransactionInput = class _TransactionInput {
      static {
        __name$8(this, "TransactionInput");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionInput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionInputFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          previousOutpoint: this.previousOutpoint,
          signatureScript: this.signatureScript,
          sequence: this.sequence,
          sigOpCount: this.sigOpCount,
          utxo: this.utxo
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionInputFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactioninput_free(ptr, 0);
      }
      /**
       * @param {ITransactionInput | TransactionInput} value
       */
      constructor(value2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactioninput_constructor(retptr, addBorrowedObject(value2));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          TransactionInputFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get previousOutpoint() {
        const ret = wasm.transactioninput_get_previous_outpoint(this.__wbg_ptr);
        return TransactionOutpoint.__wrap(ret);
      }
      /**
       * @param {any} js_value
       */
      set previousOutpoint(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactioninput_set_previous_outpoint(retptr, this.__wbg_ptr, addBorrowedObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {string | undefined}
       */
      get signatureScript() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactioninput_get_signature_script_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} js_value
       */
      set signatureScript(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactioninput_set_signature_script_from_js_value(retptr, this.__wbg_ptr, addHeapObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {bigint}
       */
      get sequence() {
        const ret = wasm.transactioninput_get_sequence(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} sequence
       */
      set sequence(sequence) {
        wasm.transactioninput_set_sequence(this.__wbg_ptr, sequence);
      }
      /**
       * @returns {number}
       */
      get sigOpCount() {
        const ret = wasm.transactioninput_get_sig_op_count(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} sig_op_count
       */
      set sigOpCount(sig_op_count) {
        wasm.transactioninput_set_sig_op_count(this.__wbg_ptr, sig_op_count);
      }
      /**
       * @returns {UtxoEntryReference | undefined}
       */
      get utxo() {
        const ret = wasm.transactioninput_get_utxo(this.__wbg_ptr);
        return ret === 0 ? void 0 : UtxoEntryReference.__wrap(ret);
      }
    };
    TransactionOutpointFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionoutpoint_free(ptr >>> 0, 1));
    TransactionOutpoint = class _TransactionOutpoint {
      static {
        __name$8(this, "TransactionOutpoint");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionOutpoint.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutpointFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          transactionId: this.transactionId,
          index: this.index
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutpointFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutpoint_free(ptr, 0);
      }
      /**
       * @param {Hash} transaction_id
       * @param {number} index
       */
      constructor(transaction_id, index) {
        _assertClass(transaction_id, Hash);
        var ptr0 = transaction_id.__destroy_into_raw();
        const ret = wasm.transactionoutpoint_ctor(ptr0, index);
        this.__wbg_ptr = ret >>> 0;
        TransactionOutpointFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string}
       */
      getId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionoutpoint_getId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get transactionId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionoutpoint_transactionId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get index() {
        const ret = wasm.transactionoutpoint_index(this.__wbg_ptr);
        return ret >>> 0;
      }
    };
    TransactionOutputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionoutput_free(ptr >>> 0, 1));
    TransactionOutput = class _TransactionOutput {
      static {
        __name$8(this, "TransactionOutput");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionOutput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          value: this.value,
          scriptPublicKey: this.scriptPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionoutput_free(ptr, 0);
      }
      /**
       * TransactionOutput constructor
       * @param {bigint} value
       * @param {ScriptPublicKey} script_public_key
       */
      constructor(value2, script_public_key) {
        _assertClass(script_public_key, ScriptPublicKey);
        const ret = wasm.transactionoutput_ctor(value2, script_public_key.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        TransactionOutputFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {bigint}
       */
      get value() {
        const ret = wasm.transactionoutput_value(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set value(v) {
        wasm.transactionoutput_set_value(this.__wbg_ptr, v);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm.transactionoutput_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} v
       */
      set scriptPublicKey(v) {
        _assertClass(v, ScriptPublicKey);
        wasm.transactionoutput_set_scriptPublicKey(this.__wbg_ptr, v.__wbg_ptr);
      }
    };
    TransactionRecordFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionrecord_free(ptr >>> 0, 1));
    TransactionRecord = class _TransactionRecord {
      static {
        __name$8(this, "TransactionRecord");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionRecord.prototype);
        obj.__wbg_ptr = ptr;
        TransactionRecordFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          unixtimeMsec: this.unixtimeMsec,
          network: this.network,
          note: this.note,
          metadata: this.metadata,
          value: this.value,
          blockDaaScore: this.blockDaaScore,
          binding: this.binding,
          data: this.data,
          type: this.type
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionRecordFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionrecord_free(ptr, 0);
      }
      /**
       * @returns {Hash}
       */
      get id() {
        const ret = wasm.__wbg_get_transactionrecord_id(this.__wbg_ptr);
        return Hash.__wrap(ret);
      }
      /**
       * @param {Hash} arg0
       */
      set id(arg0) {
        _assertClass(arg0, Hash);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_transactionrecord_id(this.__wbg_ptr, ptr0);
      }
      /**
       * Unix time in milliseconds
       * @returns {bigint | undefined}
       */
      get unixtimeMsec() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_transactionrecord_unixtimeMsec(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Unix time in milliseconds
       * @param {bigint | null} [arg0]
       */
      set unixtimeMsec(arg0) {
        wasm.__wbg_set_transactionrecord_unixtimeMsec(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
      }
      /**
       * @returns {NetworkId}
       */
      get network() {
        const ret = wasm.__wbg_get_transactionrecord_network(this.__wbg_ptr);
        return NetworkId.__wrap(ret);
      }
      /**
       * @param {NetworkId} arg0
       */
      set network(arg0) {
        _assertClass(arg0, NetworkId);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_transactionrecord_network(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {string | undefined}
       */
      get note() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_transactionrecord_note(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set note(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_transactionrecord_note(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string | undefined}
       */
      get metadata() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_transactionrecord_metadata(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set metadata(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_transactionrecord_metadata(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {bigint} currentDaaScore
       * @returns {string}
       */
      maturityProgress(currentDaaScore) {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionrecord_maturityProgress(retptr, this.__wbg_ptr, addHeapObject(currentDaaScore));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {bigint}
       */
      get value() {
        const ret = wasm.transactionrecord_value(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm.transactionrecord_blockDaaScore(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {IBinding}
       */
      get binding() {
        const ret = wasm.transactionrecord_binding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {ITransactionData}
       */
      get data() {
        const ret = wasm.transactionrecord_data(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionrecord_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Check if the transaction record has the given address within the associated UTXO set.
       * @param {Address} address
       * @returns {boolean}
       */
      hasAddress(address) {
        _assertClass(address, Address);
        const ret = wasm.transactionrecord_hasAddress(this.__wbg_ptr, address.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Serialize the transaction record to a JavaScript object.
       * @returns {any}
       */
      serialize() {
        const ret = wasm.transactionrecord_serialize(this.__wbg_ptr);
        return takeObject(ret);
      }
    };
    TransactionRecordNotificationFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionrecordnotification_free(ptr >>> 0, 1));
    TransactionRecordNotification = class _TransactionRecordNotification {
      static {
        __name$8(this, "TransactionRecordNotification");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionRecordNotification.prototype);
        obj.__wbg_ptr = ptr;
        TransactionRecordNotificationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          type: this.type,
          data: this.data
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionRecordNotificationFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionrecordnotification_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_transactionrecordnotification_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} arg0
       */
      set type(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_transactionrecordnotification_type(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {TransactionRecord}
       */
      get data() {
        const ret = wasm.__wbg_get_transactionrecordnotification_data(this.__wbg_ptr);
        return TransactionRecord.__wrap(ret);
      }
      /**
       * @param {TransactionRecord} arg0
       */
      set data(arg0) {
        _assertClass(arg0, TransactionRecord);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_transactionrecordnotification_data(this.__wbg_ptr, ptr0);
      }
    };
    TransactionSigningHashFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionsigninghash_free(ptr >>> 0, 1));
    TransactionSigningHash = class {
      static {
        __name$8(this, "TransactionSigningHash");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionSigningHashFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionsigninghash_free(ptr, 0);
      }
      constructor() {
        const ret = wasm.transactionsigninghash_new();
        this.__wbg_ptr = ret >>> 0;
        TransactionSigningHashFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {HexString | Uint8Array} data
       */
      update(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionsigninghash_update(retptr, this.__wbg_ptr, addHeapObject(data));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionsigninghash_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    TransactionSigningHashECDSAFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionsigninghashecdsa_free(ptr >>> 0, 1));
    TransactionSigningHashECDSA = class {
      static {
        __name$8(this, "TransactionSigningHashECDSA");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionSigningHashECDSAFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionsigninghashecdsa_free(ptr, 0);
      }
      constructor() {
        const ret = wasm.transactionsigninghashecdsa_new();
        this.__wbg_ptr = ret >>> 0;
        TransactionSigningHashECDSAFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {HexString | Uint8Array} data
       */
      update(data) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionsigninghashecdsa_update(retptr, this.__wbg_ptr, addHeapObject(data));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.transactionsigninghashecdsa_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    TransactionUtxoEntryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_transactionutxoentry_free(ptr >>> 0, 1));
    TransactionUtxoEntry = class {
      static {
        __name$8(this, "TransactionUtxoEntry");
      }
      toJSON() {
        return {
          amount: this.amount,
          scriptPublicKey: this.scriptPublicKey,
          blockDaaScore: this.blockDaaScore,
          isCoinbase: this.isCoinbase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionUtxoEntryFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_transactionutxoentry_free(ptr, 0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm.__wbg_get_transactionutxoentry_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm.__wbg_set_transactionutxoentry_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm.__wbg_get_transactionutxoentry_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} arg0
       */
      set scriptPublicKey(arg0) {
        _assertClass(arg0, ScriptPublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_transactionutxoentry_scriptPublicKey(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm.__wbg_get_transactionutxoentry_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set blockDaaScore(arg0) {
        wasm.__wbg_set_transactionutxoentry_blockDaaScore(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm.__wbg_get_transactionutxoentry_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      set isCoinbase(arg0) {
        wasm.__wbg_set_transactionutxoentry_isCoinbase(this.__wbg_ptr, arg0);
      }
    };
    UserInfoOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_userinfooptions_free(ptr >>> 0, 1));
    UserInfoOptions = class _UserInfoOptions {
      static {
        __name$8(this, "UserInfoOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UserInfoOptions.prototype);
        obj.__wbg_ptr = ptr;
        UserInfoOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UserInfoOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_userinfooptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       */
      constructor(encoding) {
        const ret = wasm.userinfooptions_new_with_values(isLikeNone(encoding) ? 0 : addHeapObject(encoding));
        this.__wbg_ptr = ret >>> 0;
        UserInfoOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {UserInfoOptions}
       */
      static new() {
        const ret = wasm.userinfooptions_new();
        return _UserInfoOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.userinfooptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.userinfooptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
    };
    UtxoContextFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_utxocontext_free(ptr >>> 0, 1));
    UtxoContext = class {
      static {
        __name$8(this, "UtxoContext");
      }
      toJSON() {
        return {
          isActive: this.isActive,
          matureLength: this.matureLength,
          balance: this.balance,
          balanceStrings: this.balanceStrings
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoContextFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_utxocontext_free(ptr, 0);
      }
      /**
       * @param {IUtxoContextArgs} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxocontext_ctor(retptr, addHeapObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoContextFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Performs a scan of the given addresses and registers them in the context for event notifications.
       * @param {(Address | string)[]} addresses
       * @param {bigint | null} [optional_current_daa_score]
       * @returns {Promise<void>}
       */
      trackAddresses(addresses, optional_current_daa_score) {
        const ret = wasm.utxocontext_trackAddresses(this.__wbg_ptr, addHeapObject(addresses), isLikeNone(optional_current_daa_score) ? 0 : addHeapObject(optional_current_daa_score));
        return takeObject(ret);
      }
      /**
       * Unregister a list of addresses from the context. This will stop tracking of these addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      unregisterAddresses(addresses) {
        const ret = wasm.utxocontext_unregisterAddresses(this.__wbg_ptr, addHeapObject(addresses));
        return takeObject(ret);
      }
      /**
       * Clear the UtxoContext.  Unregister all addresses and clear all UTXO entries.
       * IMPORTANT: This function must be manually called when disconnecting or re-connecting to the node
       * (followed by address re-registration).
       * @returns {Promise<void>}
       */
      clear() {
        const ret = wasm.utxocontext_clear(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {boolean}
       */
      get isActive() {
        const ret = wasm.utxocontext_isActive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       *
       * Returns a range of mature UTXO entries that are currently
       * managed by the UtxoContext and are available for spending.
       *
       * NOTE: This function is provided for informational purposes only.
       * **You should not manage UTXO entries manually if they are owned by UtxoContext.**
       *
       * The resulting range may be less than requested if UTXO entries
       * have been spent asynchronously by UtxoContext or by other means
       * (i.e. UtxoContext has received notification from the network that
       * UtxoEntries have been spent externally).
       *
       * UtxoEntries are kept in in the ascending sorted order by their amount.
       * @param {number} from
       * @param {number} to
       * @returns {UtxoEntryReference[]}
       */
      getMatureRange(from2, to) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxocontext_getMatureRange(retptr, this.__wbg_ptr, from2, to);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Obtain the length of the mature UTXO entries that are currently
       * managed by the UtxoContext.
       * @returns {number}
       */
      get matureLength() {
        const ret = wasm.utxocontext_matureLength(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * Returns pending UTXO entries that are currently managed by the UtxoContext.
       * @returns {UtxoEntryReference[]}
       */
      getPending() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxocontext_getPending(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Current {@link Balance} of the UtxoContext.
       * @returns {Balance | undefined}
       */
      get balance() {
        const ret = wasm.utxocontext_balance(this.__wbg_ptr);
        return ret === 0 ? void 0 : Balance.__wrap(ret);
      }
      /**
       * Current {@link BalanceStrings} of the UtxoContext.
       * @returns {BalanceStrings | undefined}
       */
      get balanceStrings() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxocontext_balanceStrings(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return r0 === 0 ? void 0 : BalanceStrings.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    UtxoEntriesFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_utxoentries_free(ptr >>> 0, 1));
    UtxoEntries = class {
      static {
        __name$8(this, "UtxoEntries");
      }
      toJSON() {
        return {
          items: this.items
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntriesFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_utxoentries_free(ptr, 0);
      }
      /**
       * Create a new `UtxoEntries` struct with a set of entries.
       * @param {any} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoentries_js_ctor(retptr, addHeapObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoEntriesFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {any}
       */
      get items() {
        const ret = wasm.utxoentries_get_items_as_js_array(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {any} js_value
       */
      set items(js_value) {
        try {
          wasm.utxoentries_set_items_from_js_array(this.__wbg_ptr, addBorrowedObject(js_value));
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Sort the contained entries by amount. Please note that
       * this function is not intended for use with large UTXO sets
       * as it duplicates the whole contained UTXO set while sorting.
       */
      sort() {
        wasm.utxoentries_sort(this.__wbg_ptr);
      }
      /**
       * @returns {bigint}
       */
      amount() {
        const ret = wasm.utxoentries_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
    };
    UtxoEntryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_utxoentry_free(ptr >>> 0, 1));
    UtxoEntry = class _UtxoEntry {
      static {
        __name$8(this, "UtxoEntry");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UtxoEntry.prototype);
        obj.__wbg_ptr = ptr;
        UtxoEntryFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          address: this.address,
          outpoint: this.outpoint,
          amount: this.amount,
          scriptPublicKey: this.scriptPublicKey,
          blockDaaScore: this.blockDaaScore,
          isCoinbase: this.isCoinbase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntryFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_utxoentry_free(ptr, 0);
      }
      /**
       * @returns {Address | undefined}
       */
      get address() {
        const ret = wasm.__wbg_get_utxoentry_address(this.__wbg_ptr);
        return ret === 0 ? void 0 : Address.__wrap(ret);
      }
      /**
       * @param {Address | null} [arg0]
       */
      set address(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
          _assertClass(arg0, Address);
          ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_utxoentry_address(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get outpoint() {
        const ret = wasm.__wbg_get_utxoentry_outpoint(this.__wbg_ptr);
        return TransactionOutpoint.__wrap(ret);
      }
      /**
       * @param {TransactionOutpoint} arg0
       */
      set outpoint(arg0) {
        _assertClass(arg0, TransactionOutpoint);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_utxoentry_outpoint(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm.__wbg_get_utxoentry_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm.__wbg_set_utxoentry_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm.__wbg_get_utxoentry_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} arg0
       */
      set scriptPublicKey(arg0) {
        _assertClass(arg0, ScriptPublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_utxoentry_scriptPublicKey(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm.__wbg_get_utxoentry_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set blockDaaScore(arg0) {
        wasm.__wbg_set_utxoentry_blockDaaScore(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm.__wbg_get_utxoentry_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      set isCoinbase(arg0) {
        wasm.__wbg_set_utxoentry_isCoinbase(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {string}
       */
      toString() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoentry_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    UtxoEntryReferenceFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_utxoentryreference_free(ptr >>> 0, 1));
    UtxoEntryReference = class _UtxoEntryReference {
      static {
        __name$8(this, "UtxoEntryReference");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UtxoEntryReference.prototype);
        obj.__wbg_ptr = ptr;
        UtxoEntryReferenceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          entry: this.entry,
          outpoint: this.outpoint,
          address: this.address,
          amount: this.amount,
          isCoinbase: this.isCoinbase,
          blockDaaScore: this.blockDaaScore,
          scriptPublicKey: this.scriptPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntryReferenceFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_utxoentryreference_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      toString() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoentryreference_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {UtxoEntry}
       */
      get entry() {
        const ret = wasm.utxoentryreference_entry(this.__wbg_ptr);
        return UtxoEntry.__wrap(ret);
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get outpoint() {
        const ret = wasm.utxoentryreference_outpoint(this.__wbg_ptr);
        return TransactionOutpoint.__wrap(ret);
      }
      /**
       * @returns {Address | undefined}
       */
      get address() {
        const ret = wasm.utxoentryreference_address(this.__wbg_ptr);
        return ret === 0 ? void 0 : Address.__wrap(ret);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm.utxoentryreference_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm.utxoentryreference_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm.utxoentryreference_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm.utxoentryreference_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey.__wrap(ret);
      }
    };
    UtxoProcessorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_utxoprocessor_free(ptr >>> 0, 1));
    UtxoProcessor = class {
      static {
        __name$8(this, "UtxoProcessor");
      }
      toJSON() {
        return {
          rpc: this.rpc,
          networkId: this.networkId,
          isActive: this.isActive
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoProcessorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_utxoprocessor_free(ptr, 0);
      }
      /**
       * @param {string | UtxoProcessorNotificationCallback} event
       * @param {UtxoProcessorNotificationCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_addEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {UtxoProcessorEventType | UtxoProcessorEventType[] | string | string[]} event
       * @param {UtxoProcessorNotificationCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_removeEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * UtxoProcessor constructor.
       *
       *
       *
       * @see {@link IUtxoProcessorArgs}
       * @param {IUtxoProcessorArgs} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_ctor(retptr, addHeapObject(js_value));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoProcessorFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Starts the UtxoProcessor and begins processing UTXO and other notifications.
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm.utxoprocessor_start(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * Stops the UtxoProcessor and ends processing UTXO and other notifications.
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm.utxoprocessor_stop(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {RpcClient}
       */
      get rpc() {
        const ret = wasm.utxoprocessor_rpc(this.__wbg_ptr);
        return RpcClient.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get networkId() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_networkId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_setNetworkId(retptr, this.__wbg_ptr, addBorrowedObject(network_id));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @returns {boolean}
       */
      get isActive() {
        const ret = wasm.utxoprocessor_isActive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       *
       * Set the coinbase transaction maturity period DAA score for a given network.
       * This controls the DAA period after which the user transactions are considered mature
       * and the wallet subsystem emits the transaction maturity event.
       *
       * @see {@link TransactionRecord}
       * @see {@link IUtxoProcessorEvent}
       *
       * @category Wallet SDK
       * @param {NetworkId | string} network_id
       * @param {bigint} value
       */
      static setCoinbaseTransactionMaturityDAA(network_id, value2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_setCoinbaseTransactionMaturityDAA(retptr, addBorrowedObject(network_id), value2);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       *
       * Set the user transaction maturity period DAA score for a given network.
       * This controls the DAA period after which the user transactions are considered mature
       * and the wallet subsystem emits the transaction maturity event.
       *
       * @see {@link TransactionRecord}
       * @see {@link IUtxoProcessorEvent}
       *
       * @category Wallet SDK
       * @param {NetworkId | string} network_id
       * @param {bigint} value
       */
      static setUserTransactionMaturityDAA(network_id, value2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.utxoprocessor_setUserTransactionMaturityDAA(retptr, addBorrowedObject(network_id), value2);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
    };
    WalletFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_wallet_free(ptr >>> 0, 1));
    Wallet$1 = class {
      static {
        __name$8(this, "Wallet");
      }
      toJSON() {
        return {
          rpc: this.rpc,
          isOpen: this.isOpen,
          isSynced: this.isSynced,
          descriptor: this.descriptor
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wallet_free(ptr, 0);
      }
      /**
       * @param {IWalletConfig} config
       */
      constructor(config) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.wallet_constructor(retptr, addHeapObject(config));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          WalletFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {RpcClient}
       */
      get rpc() {
        const ret = wasm.wallet_rpc(this.__wbg_ptr);
        return RpcClient.__wrap(ret);
      }
      /**
       * @remarks This is a local property indicating
       * if the wallet is currently open.
       * @returns {boolean}
       */
      get isOpen() {
        const ret = wasm.wallet_isOpen(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @remarks This is a local property indicating
       * if the node is currently synced.
       * @returns {boolean}
       */
      get isSynced() {
        const ret = wasm.wallet_isSynced(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @returns {WalletDescriptor | undefined}
       */
      get descriptor() {
        const ret = wasm.wallet_descriptor(this.__wbg_ptr);
        return ret === 0 ? void 0 : WalletDescriptor.__wrap(ret);
      }
      /**
       * Check if a wallet with a given name exists.
       * @param {string | null} [name]
       * @returns {Promise<boolean>}
       */
      exists(name2) {
        var ptr0 = isLikeNone(name2) ? 0 : passStringToWasm0(name2, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.wallet_exists(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm.wallet_start(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm.wallet_stop(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {IConnectOptions | undefined | null} [args]
       * @returns {Promise<void>}
       */
      connect(args) {
        const ret = wasm.wallet_connect(this.__wbg_ptr, isLikeNone(args) ? 0 : addHeapObject(args));
        return takeObject(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      disconnect() {
        const ret = wasm.wallet_disconnect(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | WalletNotificationCallback} event
       * @param {WalletNotificationCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.wallet_addEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {WalletEventType | WalletEventType[] | string | string[]} event
       * @param {WalletNotificationCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.wallet_removeEventListener(retptr, this.__wbg_ptr, addHeapObject(event), isLikeNone(callback) ? 0 : addHeapObject(callback));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.wallet_setNetworkId(retptr, this.__wbg_ptr, addHeapObject(network_id));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Ping backend
       * @see {@link IBatchRequest} {@link IBatchResponse}
       * @throws `string` in case of an error.
       * @param {IBatchRequest} request
       * @returns {Promise<IBatchResponse>}
       */
      batch(request) {
        const ret = wasm.wallet_batch(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IFlushRequest} {@link IFlushResponse}
       * @throws `string` in case of an error.
       * @param {IFlushRequest} request
       * @returns {Promise<IFlushResponse>}
       */
      flush(request) {
        const ret = wasm.wallet_flush(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IRetainContextRequest} {@link IRetainContextResponse}
       * @throws `string` in case of an error.
       * @param {IRetainContextRequest} request
       * @returns {Promise<IRetainContextResponse>}
       */
      retainContext(request) {
        const ret = wasm.wallet_retainContext(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IGetStatusRequest} {@link IGetStatusResponse}
       * @throws `string` in case of an error.
       * @param {IGetStatusRequest} request
       * @returns {Promise<IGetStatusResponse>}
       */
      getStatus(request) {
        const ret = wasm.wallet_getStatus(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletEnumerateRequest} {@link IWalletEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IWalletEnumerateRequest} request
       * @returns {Promise<IWalletEnumerateResponse>}
       */
      walletEnumerate(request) {
        const ret = wasm.wallet_walletEnumerate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletCreateRequest} {@link IWalletCreateResponse}
       * @throws `string` in case of an error.
       * @param {IWalletCreateRequest} request
       * @returns {Promise<IWalletCreateResponse>}
       */
      walletCreate(request) {
        const ret = wasm.wallet_walletCreate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletOpenRequest} {@link IWalletOpenResponse}
       * @throws `string` in case of an error.
       * @param {IWalletOpenRequest} request
       * @returns {Promise<IWalletOpenResponse>}
       */
      walletOpen(request) {
        const ret = wasm.wallet_walletOpen(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletReloadRequest} {@link IWalletReloadResponse}
       * @throws `string` in case of an error.
       * @param {IWalletReloadRequest} request
       * @returns {Promise<IWalletReloadResponse>}
       */
      walletReload(request) {
        const ret = wasm.wallet_walletReload(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletCloseRequest} {@link IWalletCloseResponse}
       * @throws `string` in case of an error.
       * @param {IWalletCloseRequest} request
       * @returns {Promise<IWalletCloseResponse>}
       */
      walletClose(request) {
        const ret = wasm.wallet_walletClose(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletChangeSecretRequest} {@link IWalletChangeSecretResponse}
       * @throws `string` in case of an error.
       * @param {IWalletChangeSecretRequest} request
       * @returns {Promise<IWalletChangeSecretResponse>}
       */
      walletChangeSecret(request) {
        const ret = wasm.wallet_walletChangeSecret(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletExportRequest} {@link IWalletExportResponse}
       * @throws `string` in case of an error.
       * @param {IWalletExportRequest} request
       * @returns {Promise<IWalletExportResponse>}
       */
      walletExport(request) {
        const ret = wasm.wallet_walletExport(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IWalletImportRequest} {@link IWalletImportResponse}
       * @throws `string` in case of an error.
       * @param {IWalletImportRequest} request
       * @returns {Promise<IWalletImportResponse>}
       */
      walletImport(request) {
        const ret = wasm.wallet_walletImport(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IPrvKeyDataEnumerateRequest} {@link IPrvKeyDataEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataEnumerateRequest} request
       * @returns {Promise<IPrvKeyDataEnumerateResponse>}
       */
      prvKeyDataEnumerate(request) {
        const ret = wasm.wallet_prvKeyDataEnumerate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IPrvKeyDataCreateRequest} {@link IPrvKeyDataCreateResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataCreateRequest} request
       * @returns {Promise<IPrvKeyDataCreateResponse>}
       */
      prvKeyDataCreate(request) {
        const ret = wasm.wallet_prvKeyDataCreate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IPrvKeyDataRemoveRequest} {@link IPrvKeyDataRemoveResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataRemoveRequest} request
       * @returns {Promise<IPrvKeyDataRemoveResponse>}
       */
      prvKeyDataRemove(request) {
        const ret = wasm.wallet_prvKeyDataRemove(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IPrvKeyDataGetRequest} {@link IPrvKeyDataGetResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataGetRequest} request
       * @returns {Promise<IPrvKeyDataGetResponse>}
       */
      prvKeyDataGet(request) {
        const ret = wasm.wallet_prvKeyDataGet(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsEnumerateRequest} {@link IAccountsEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEnumerateRequest} request
       * @returns {Promise<IAccountsEnumerateResponse>}
       */
      accountsEnumerate(request) {
        const ret = wasm.wallet_accountsEnumerate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsRenameRequest} {@link IAccountsRenameResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsRenameRequest} request
       * @returns {Promise<IAccountsRenameResponse>}
       */
      accountsRename(request) {
        const ret = wasm.wallet_accountsRename(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsDiscoveryRequest} {@link IAccountsDiscoveryResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsDiscoveryRequest} request
       * @returns {Promise<IAccountsDiscoveryResponse>}
       */
      accountsDiscovery(request) {
        const ret = wasm.wallet_accountsDiscovery(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsCreateRequest} {@link IAccountsCreateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCreateRequest} request
       * @returns {Promise<IAccountsCreateResponse>}
       */
      accountsCreate(request) {
        const ret = wasm.wallet_accountsCreate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsEnsureDefaultRequest} {@link IAccountsEnsureDefaultResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEnsureDefaultRequest} request
       * @returns {Promise<IAccountsEnsureDefaultResponse>}
       */
      accountsEnsureDefault(request) {
        const ret = wasm.wallet_accountsEnsureDefault(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsImportRequest} {@link IAccountsImportResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsImportRequest} request
       * @returns {Promise<IAccountsImportResponse>}
       */
      accountsImport(request) {
        const ret = wasm.wallet_accountsImport(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsActivateRequest} {@link IAccountsActivateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsActivateRequest} request
       * @returns {Promise<IAccountsActivateResponse>}
       */
      accountsActivate(request) {
        const ret = wasm.wallet_accountsActivate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsDeactivateRequest} {@link IAccountsDeactivateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsDeactivateRequest} request
       * @returns {Promise<IAccountsDeactivateResponse>}
       */
      accountsDeactivate(request) {
        const ret = wasm.wallet_accountsDeactivate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsGetRequest} {@link IAccountsGetResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsGetRequest} request
       * @returns {Promise<IAccountsGetResponse>}
       */
      accountsGet(request) {
        const ret = wasm.wallet_accountsGet(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsCreateNewAddressRequest} {@link IAccountsCreateNewAddressResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCreateNewAddressRequest} request
       * @returns {Promise<IAccountsCreateNewAddressResponse>}
       */
      accountsCreateNewAddress(request) {
        const ret = wasm.wallet_accountsCreateNewAddress(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsSendRequest} {@link IAccountsSendResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsSendRequest} request
       * @returns {Promise<IAccountsSendResponse>}
       */
      accountsSend(request) {
        const ret = wasm.wallet_accountsSend(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsPskbSignRequest} {@link IAccountsPskbSignResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbSignRequest} request
       * @returns {Promise<IAccountsPskbSignResponse>}
       */
      accountsPskbSign(request) {
        const ret = wasm.wallet_accountsPskbSign(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsPskbBroadcastRequest} {@link IAccountsPskbBroadcastResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbBroadcastRequest} request
       * @returns {Promise<IAccountsPskbBroadcastResponse>}
       */
      accountsPskbBroadcast(request) {
        const ret = wasm.wallet_accountsPskbBroadcast(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsPskbSendRequest} {@link IAccountsPskbSendResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbSendRequest} request
       * @returns {Promise<IAccountsPskbSendResponse>}
       */
      accountsPskbSend(request) {
        const ret = wasm.wallet_accountsPskbSend(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsGetUtxosRequest} {@link IAccountsGetUtxosResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsGetUtxosRequest} request
       * @returns {Promise<IAccountsGetUtxosResponse>}
       */
      accountsGetUtxos(request) {
        const ret = wasm.wallet_accountsGetUtxos(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsTransferRequest} {@link IAccountsTransferResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsTransferRequest} request
       * @returns {Promise<IAccountsTransferResponse>}
       */
      accountsTransfer(request) {
        const ret = wasm.wallet_accountsTransfer(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsEstimateRequest} {@link IAccountsEstimateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEstimateRequest} request
       * @returns {Promise<IAccountsEstimateResponse>}
       */
      accountsEstimate(request) {
        const ret = wasm.wallet_accountsEstimate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link ITransactionsDataGetRequest} {@link ITransactionsDataGetResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsDataGetRequest} request
       * @returns {Promise<ITransactionsDataGetResponse>}
       */
      transactionsDataGet(request) {
        const ret = wasm.wallet_transactionsDataGet(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link ITransactionsReplaceNoteRequest} {@link ITransactionsReplaceNoteResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsReplaceNoteRequest} request
       * @returns {Promise<ITransactionsReplaceNoteResponse>}
       */
      transactionsReplaceNote(request) {
        const ret = wasm.wallet_transactionsReplaceNote(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link ITransactionsReplaceMetadataRequest} {@link ITransactionsReplaceMetadataResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsReplaceMetadataRequest} request
       * @returns {Promise<ITransactionsReplaceMetadataResponse>}
       */
      transactionsReplaceMetadata(request) {
        const ret = wasm.wallet_transactionsReplaceMetadata(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAddressBookEnumerateRequest} {@link IAddressBookEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IAddressBookEnumerateRequest} request
       * @returns {Promise<IAddressBookEnumerateResponse>}
       */
      addressBookEnumerate(request) {
        const ret = wasm.wallet_addressBookEnumerate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IFeeRateEstimateRequest} {@link IFeeRateEstimateResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRateEstimateRequest} request
       * @returns {Promise<IFeeRateEstimateResponse>}
       */
      feeRateEstimate(request) {
        const ret = wasm.wallet_feeRateEstimate(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IFeeRatePollerEnableRequest} {@link IFeeRatePollerEnableResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRatePollerEnableRequest} request
       * @returns {Promise<IFeeRatePollerEnableResponse>}
       */
      feeRatePollerEnable(request) {
        const ret = wasm.wallet_feeRatePollerEnable(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IFeeRatePollerDisableRequest} {@link IFeeRatePollerDisableResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRatePollerDisableRequest} request
       * @returns {Promise<IFeeRatePollerDisableResponse>}
       */
      feeRatePollerDisable(request) {
        const ret = wasm.wallet_feeRatePollerDisable(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsCommitRevealRequest} {@link IAccountsCommitRevealResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCommitRevealRequest} request
       * @returns {Promise<IAccountsCommitRevealResponse>}
       */
      accountsCommitReveal(request) {
        const ret = wasm.wallet_accountsCommitReveal(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
      /**
       * @see {@link IAccountsCommitRevealManualRequest} {@link IAccountsCommitRevealManualResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCommitRevealManualRequest} request
       * @returns {Promise<IAccountsCommitRevealManualResponse>}
       */
      accountsCommitRevealManual(request) {
        const ret = wasm.wallet_accountsCommitRevealManual(this.__wbg_ptr, addHeapObject(request));
        return takeObject(ret);
      }
    };
    WalletDescriptorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_walletdescriptor_free(ptr >>> 0, 1));
    WalletDescriptor = class _WalletDescriptor {
      static {
        __name$8(this, "WalletDescriptor");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_WalletDescriptor.prototype);
        obj.__wbg_ptr = ptr;
        WalletDescriptorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          title: this.title,
          filename: this.filename
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletDescriptorFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_walletdescriptor_free(ptr, 0);
      }
      /**
       * @returns {string | undefined}
       */
      get title() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_walletdescriptor_title(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set title(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_walletdescriptor_title(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string}
       */
      get filename() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.__wbg_get_walletdescriptor_filename(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} arg0
       */
      set filename(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_walletdescriptor_filename(this.__wbg_ptr, ptr0, len0);
      }
    };
    WasiOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_wasioptions_free(ptr >>> 0, 1));
    WasiOptions = class _WasiOptions {
      static {
        __name$8(this, "WasiOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_WasiOptions.prototype);
        obj.__wbg_ptr = ptr;
        WasiOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasiOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasioptions_free(ptr, 0);
      }
      /**
       * @param {any[] | null | undefined} args
       * @param {object | null | undefined} env
       * @param {object} preopens
       */
      constructor(args, env, preopens) {
        var ptr0 = isLikeNone(args) ? 0 : passArrayJsValueToWasm0(args, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasioptions_new_with_values(ptr0, len0, isLikeNone(env) ? 0 : addHeapObject(env), addHeapObject(preopens));
        this.__wbg_ptr = ret >>> 0;
        WasiOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {object} preopens
       * @returns {WasiOptions}
       */
      static new(preopens) {
        const ret = wasm.wasioptions_new(addHeapObject(preopens));
        return _WasiOptions.__wrap(ret);
      }
      /**
       * @returns {any[] | undefined}
       */
      get args() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.wasioptions_args(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 4, 4);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any[] | null} [value]
       */
      set args(value2) {
        var ptr0 = isLikeNone(value2) ? 0 : passArrayJsValueToWasm0(value2, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.wasioptions_set_args(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {object | undefined}
       */
      get env() {
        const ret = wasm.wasioptions_env(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {object | null} [value]
       */
      set env(value2) {
        wasm.wasioptions_set_env(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {object}
       */
      get preopens() {
        const ret = wasm.wasioptions_preopens(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {object} value
       */
      set preopens(value2) {
        wasm.wasioptions_set_preopens(this.__wbg_ptr, addHeapObject(value2));
      }
    };
    WriteFileSyncOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_writefilesyncoptions_free(ptr >>> 0, 1));
    WriteFileSyncOptions = class {
      static {
        __name$8(this, "WriteFileSyncOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WriteFileSyncOptionsFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_writefilesyncoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       * @param {string | null} [flag]
       * @param {number | null} [mode]
       */
      constructor(encoding, flag, mode) {
        const ret = wasm.writefilesyncoptions_new(isLikeNone(encoding) ? 0 : addHeapObject(encoding), isLikeNone(flag) ? 0 : addHeapObject(flag), isLikeNone(mode) ? 4294967297 : mode >>> 0);
        this.__wbg_ptr = ret >>> 0;
        WriteFileSyncOptionsFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm.writefilesyncoptions_encoding(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm.writefilesyncoptions_set_encoding(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get flag() {
        const ret = wasm.writefilesyncoptions_flag(this.__wbg_ptr);
        return takeObject(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flag(value2) {
        wasm.writefilesyncoptions_set_flag(this.__wbg_ptr, isLikeNone(value2) ? 0 : addHeapObject(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm.writefilesyncoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm.writefilesyncoptions_set_mode(this.__wbg_ptr, isLikeNone(value2) ? 4294967297 : value2 >>> 0);
      }
    };
    WriteStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_writestream_free(ptr >>> 0, 1));
    WriteStream = class {
      static {
        __name$8(this, "WriteStream");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WriteStreamFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_writestream_free(ptr, 0);
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_open(listener) {
        try {
          const ret = wasm.writestream_add_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_close(listener) {
        try {
          const ret = wasm.writestream_add_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_open(listener) {
        try {
          const ret = wasm.writestream_on_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_close(listener) {
        try {
          const ret = wasm.writestream_on_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_open(listener) {
        try {
          const ret = wasm.writestream_once_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_close(listener) {
        try {
          const ret = wasm.writestream_once_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_open(listener) {
        try {
          const ret = wasm.writestream_prepend_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_close(listener) {
        try {
          const ret = wasm.writestream_prepend_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_open(listener) {
        try {
          const ret = wasm.writestream_prepend_once_listener_with_open(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_close(listener) {
        try {
          const ret = wasm.writestream_prepend_once_listener_with_close(this.__wbg_ptr, addBorrowedObject(listener));
          return takeObject(ret);
        } finally {
          heap[stack_pointer++] = void 0;
        }
      }
    };
    XOnlyPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_xonlypublickey_free(ptr >>> 0, 1));
    XOnlyPublicKey = class _XOnlyPublicKey {
      static {
        __name$8(this, "XOnlyPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XOnlyPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        XOnlyPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XOnlyPublicKeyFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_xonlypublickey_free(ptr, 0);
      }
      /**
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(key2, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.xonlypublickey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XOnlyPublicKeyFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xonlypublickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`Address`] of this XOnlyPublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xonlypublickey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this XOnlyPublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xonlypublickey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject(network));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return Address.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {Address} address
       * @returns {XOnlyPublicKey}
       */
      static fromAddress(address) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          _assertClass(address, Address);
          wasm.xonlypublickey_fromAddress(retptr, address.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XOnlyPublicKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    XPrvFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_xprv_free(ptr >>> 0, 1));
    XPrv = class _XPrv {
      static {
        __name$8(this, "XPrv");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XPrv.prototype);
        obj.__wbg_ptr = ptr;
        XPrvFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          xprv: this.xprv,
          privateKey: this.privateKey,
          depth: this.depth,
          parentFingerprint: this.parentFingerprint,
          childNumber: this.childNumber,
          chainCode: this.chainCode
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XPrvFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_xprv_free(ptr, 0);
      }
      /**
       * @param {HexString} seed
       */
      constructor(seed) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_try_new(retptr, addHeapObject(seed));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XPrvFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Create {@link XPrv} from `xprvxxxx..` string
       * @param {string} xprv
       * @returns {XPrv}
       */
      static fromXPrv(xprv) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(xprv, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.xprv_fromXPrv(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       * @returns {XPrv}
       */
      deriveChild(child_number, hardened) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_deriveChild(retptr, this.__wbg_ptr, child_number, isLikeNone(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} path
       * @returns {XPrv}
       */
      derivePath(path) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_derivePath(retptr, this.__wbg_ptr, addBorrowedObject(path));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {string} prefix
       * @returns {string}
       */
      intoString(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.xprv_intoString(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {XPub}
       */
      toXPub() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_toXPub(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return XPub.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PrivateKey}
       */
      toPrivateKey() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_toPrivateKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return PrivateKey.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get xprv() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get privateKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_privateKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get depth() {
        const ret = wasm.xprv_depth(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {string}
       */
      get parentFingerprint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_parentFingerprint(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get childNumber() {
        const ret = wasm.xprv_childNumber(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {string}
       */
      get chainCode() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xprv_chainCode(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    XPubFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_xpub_free(ptr >>> 0, 1));
    XPub = class _XPub {
      static {
        __name$8(this, "XPub");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XPub.prototype);
        obj.__wbg_ptr = ptr;
        XPubFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          xpub: this.xpub,
          depth: this.depth,
          parentFingerprint: this.parentFingerprint,
          childNumber: this.childNumber,
          chainCode: this.chainCode
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XPubFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_xpub_free(ptr, 0);
      }
      /**
       * @param {string} xpub
       */
      constructor(xpub) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(xpub, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.xpub_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XPubFinalization.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       * @returns {XPub}
       */
      deriveChild(child_number, hardened) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xpub_deriveChild(retptr, this.__wbg_ptr, child_number, isLikeNone(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XPub.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} path
       * @returns {XPub}
       */
      derivePath(path) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xpub_derivePath(retptr, this.__wbg_ptr, addBorrowedObject(path));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return _XPub.__wrap(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
      /**
       * @param {string} prefix
       * @returns {string}
       */
      intoString(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(prefix, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.xpub_intoString(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm0(ptr2, len2);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @returns {PublicKey}
       */
      toPublicKey() {
        const ret = wasm.xpub_toPublicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
      }
      /**
       * @returns {string}
       */
      get xpub() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xpub_xpub(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm0(ptr1, len1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get depth() {
        const ret = wasm.xpub_depth(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {string}
       */
      get parentFingerprint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xpub_parentFingerprint(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get childNumber() {
        const ret = wasm.xpub_childNumber(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {string}
       */
      get chainCode() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.xpub_chainCode(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm0(r0, r1);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    __name$8(__wbg_load, "__wbg_load");
    __name$8(__wbg_get_imports, "__wbg_get_imports");
    __name$8(__wbg_init_memory, "__wbg_init_memory");
    __name$8(__wbg_finalize_init, "__wbg_finalize_init");
    __name$8(initSync, "initSync");
    __name$8(__wbg_init, "__wbg_init");
    kaspa_default = __wbg_init;
  }
});
var kaspa_exports2 = {};
__export(kaspa_exports2, {
  Abortable: () => Abortable2,
  Aborted: () => Aborted2,
  AccountKind: () => AccountKind2,
  AccountsDiscoveryKind: () => AccountsDiscoveryKind2,
  Address: () => Address2,
  AddressVersion: () => AddressVersion2,
  AgentConstructorOptions: () => AgentConstructorOptions2,
  AppendFileOptions: () => AppendFileOptions2,
  AssertionErrorOptions: () => AssertionErrorOptions2,
  Balance: () => Balance2,
  BalanceStrings: () => BalanceStrings2,
  CommitRevealAddressKind: () => CommitRevealAddressKind2,
  ConnectStrategy: () => ConnectStrategy2,
  ConsoleConstructorOptions: () => ConsoleConstructorOptions2,
  CreateHookCallbacks: () => CreateHookCallbacks2,
  CreateReadStreamOptions: () => CreateReadStreamOptions2,
  CreateWriteStreamOptions: () => CreateWriteStreamOptions2,
  CryptoBox: () => CryptoBox2,
  CryptoBoxPrivateKey: () => CryptoBoxPrivateKey2,
  CryptoBoxPublicKey: () => CryptoBoxPublicKey2,
  DerivationPath: () => DerivationPath2,
  Encoding: () => Encoding2,
  FeeSource: () => FeeSource2,
  FormatInputPathObject: () => FormatInputPathObject2,
  Generator: () => Generator2,
  GeneratorSummary: () => GeneratorSummary2,
  GetNameOptions: () => GetNameOptions2,
  Hash: () => Hash2,
  Header: () => Header2,
  Keypair: () => Keypair2,
  Language: () => Language2,
  MkdtempSyncOptions: () => MkdtempSyncOptions2,
  Mnemonic: () => Mnemonic2,
  NetServerOptions: () => NetServerOptions2,
  NetworkId: () => NetworkId2,
  NetworkType: () => NetworkType2,
  NewAddressKind: () => NewAddressKind2,
  NodeDescriptor: () => NodeDescriptor2,
  Opcodes: () => Opcodes2,
  PSKB: () => PSKB2,
  PSKT: () => PSKT2,
  PaymentOutput: () => PaymentOutput2,
  PaymentOutputs: () => PaymentOutputs2,
  PendingTransaction: () => PendingTransaction2,
  PipeOptions: () => PipeOptions2,
  PoW: () => PoW2,
  PrivateKey: () => PrivateKey2,
  PrivateKeyGenerator: () => PrivateKeyGenerator2,
  ProcessSendOptions: () => ProcessSendOptions2,
  PrvKeyDataInfo: () => PrvKeyDataInfo2,
  PublicKey: () => PublicKey2,
  PublicKeyGenerator: () => PublicKeyGenerator2,
  ReadStream: () => ReadStream2,
  Resolver: () => Resolver2,
  RpcClient: () => RpcClient2,
  ScriptBuilder: () => ScriptBuilder2,
  ScriptPublicKey: () => ScriptPublicKey2,
  SetAadOptions: () => SetAadOptions2,
  SigHashType: () => SigHashType2,
  SighashType: () => SighashType2,
  Storage: () => Storage2,
  StreamTransformOptions: () => StreamTransformOptions2,
  Transaction: () => Transaction2,
  TransactionInput: () => TransactionInput2,
  TransactionOutpoint: () => TransactionOutpoint2,
  TransactionOutput: () => TransactionOutput2,
  TransactionRecord: () => TransactionRecord2,
  TransactionRecordNotification: () => TransactionRecordNotification2,
  TransactionSigningHash: () => TransactionSigningHash2,
  TransactionSigningHashECDSA: () => TransactionSigningHashECDSA2,
  TransactionUtxoEntry: () => TransactionUtxoEntry2,
  UserInfoOptions: () => UserInfoOptions2,
  UtxoContext: () => UtxoContext2,
  UtxoEntries: () => UtxoEntries2,
  UtxoEntry: () => UtxoEntry2,
  UtxoEntryReference: () => UtxoEntryReference2,
  UtxoProcessor: () => UtxoProcessor2,
  Wallet: () => Wallet2,
  WalletDescriptor: () => WalletDescriptor2,
  WasiOptions: () => WasiOptions2,
  WriteFileSyncOptions: () => WriteFileSyncOptions2,
  WriteStream: () => WriteStream2,
  XOnlyPublicKey: () => XOnlyPublicKey2,
  XPrv: () => XPrv2,
  XPub: () => XPub2,
  addressFromScriptPublicKey: () => addressFromScriptPublicKey2,
  argon2sha256ivFromBinary: () => argon2sha256ivFromBinary2,
  argon2sha256ivFromText: () => argon2sha256ivFromText2,
  calculateStorageMass: () => calculateStorageMass2,
  calculateTarget: () => calculateTarget2,
  calculateTransactionFee: () => calculateTransactionFee2,
  calculateTransactionMass: () => calculateTransactionMass2,
  createAddress: () => createAddress2,
  createInputSignature: () => createInputSignature2,
  createMultisigAddress: () => createMultisigAddress2,
  createTransaction: () => createTransaction2,
  createTransactions: () => createTransactions2,
  decryptXChaCha20Poly1305: () => decryptXChaCha20Poly13052,
  default: () => kaspa_default2,
  defer: () => defer2,
  encryptXChaCha20Poly1305: () => encryptXChaCha20Poly13052,
  estimateTransactions: () => estimateTransactions2,
  getNetworkParams: () => getNetworkParams2,
  getTransactionMaturityProgress: () => getTransactionMaturityProgress2,
  initBrowserPanicHook: () => initBrowserPanicHook2,
  initConsolePanicHook: () => initConsolePanicHook2,
  initSync: () => initSync2,
  initWASM32Bindings: () => initWASM32Bindings2,
  isScriptPayToPubkey: () => isScriptPayToPubkey2,
  isScriptPayToPubkeyECDSA: () => isScriptPayToPubkeyECDSA2,
  isScriptPayToScriptHash: () => isScriptPayToScriptHash2,
  kaspaToSompi: () => kaspaToSompi2,
  maximumStandardTransactionMass: () => maximumStandardTransactionMass2,
  payToAddressScript: () => payToAddressScript2,
  payToScriptHashScript: () => payToScriptHashScript2,
  payToScriptHashSignatureScript: () => payToScriptHashSignatureScript2,
  presentPanicHookLogs: () => presentPanicHookLogs2,
  setDefaultStorageFolder: () => setDefaultStorageFolder2,
  setDefaultWalletFile: () => setDefaultWalletFile2,
  setLogLevel: () => setLogLevel2,
  sha256FromBinary: () => sha256FromBinary2,
  sha256FromText: () => sha256FromText2,
  sha256dFromBinary: () => sha256dFromBinary2,
  sha256dFromText: () => sha256dFromText2,
  signMessage: () => signMessage2,
  signScriptHash: () => signScriptHash2,
  signTransaction: () => signTransaction2,
  sompiToKaspaString: () => sompiToKaspaString2,
  sompiToKaspaStringWithSuffix: () => sompiToKaspaStringWithSuffix2,
  updateTransactionMass: () => updateTransactionMass2,
  verifyMessage: () => verifyMessage2,
  version: () => version2
});
function getObject2(idx) {
  return heap2[idx];
}
function addHeapObject2(obj) {
  if (heap_next2 === heap2.length) heap2.push(heap2.length + 1);
  const idx = heap_next2;
  heap_next2 = heap2[idx];
  heap2[idx] = obj;
  return idx;
}
function handleError2(f2, args) {
  try {
    return f2.apply(this, args);
  } catch (e2) {
    wasm2.__wbindgen_export_0(addHeapObject2(e2));
  }
}
function getUint8ArrayMemory02() {
  if (cachedUint8ArrayMemory02 === null || cachedUint8ArrayMemory02.byteLength === 0) {
    cachedUint8ArrayMemory02 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8ArrayMemory02;
}
function passStringToWasm02(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder2.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory02().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN2 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory02();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127) break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory02().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN2 = offset;
  return ptr;
}
function getDataViewMemory02() {
  if (cachedDataViewMemory02 === null || cachedDataViewMemory02.buffer.detached === true || cachedDataViewMemory02.buffer.detached === void 0 && cachedDataViewMemory02.buffer !== wasm2.memory.buffer) {
    cachedDataViewMemory02 = new DataView(wasm2.memory.buffer);
  }
  return cachedDataViewMemory02;
}
function getStringFromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder2.decode(getUint8ArrayMemory02().subarray(ptr, ptr + len));
}
function isLikeNone2(x) {
  return x === void 0 || x === null;
}
function dropObject2(idx) {
  if (idx < 132) return;
  heap2[idx] = heap_next2;
  heap_next2 = idx;
}
function takeObject2(idx) {
  const ret = getObject2(idx);
  dropObject2(idx);
  return ret;
}
function getArrayU8FromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory02().subarray(ptr / 1, ptr / 1 + len);
}
function makeMutClosure2(arg0, arg1, dtor, f2) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name$8((...args) => {
    state.cnt++;
    const a2 = state.a;
    state.a = 0;
    try {
      return f2(a2, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_4.get(state.dtor)(a2, state.b);
        CLOSURE_DTORS2.unregister(state);
      } else {
        state.a = a2;
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS2.register(real, state, state);
  return real;
}
function makeClosure2(arg0, arg1, dtor, f2) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name$8((...args) => {
    state.cnt++;
    try {
      return f2(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
        state.a = 0;
        CLOSURE_DTORS2.unregister(state);
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS2.register(real, state, state);
  return real;
}
function debugString2(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name2 = val.name;
    if (typeof name2 == "string" && name2.length > 0) {
      return `Function(${name2})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length3 = val.length;
    let debug = "[";
    if (length3 > 0) {
      debug += debugString2(val[0]);
    }
    for (let i2 = 1; i2 < length3; i2++) {
      debug += ", " + debugString2(val[i2]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function _assertClass2(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
}
function addBorrowedObject2(obj) {
  if (stack_pointer2 == 1) throw new Error("out of js stack");
  heap2[--stack_pointer2] = obj;
  return stack_pointer2;
}
function isScriptPayToScriptHash2(script) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.isScriptPayToScriptHash(retptr, addHeapObject2(script));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return r0 !== 0;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function isScriptPayToPubkeyECDSA2(script) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.isScriptPayToPubkeyECDSA(retptr, addHeapObject2(script));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return r0 !== 0;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function isScriptPayToPubkey2(script) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.isScriptPayToPubkey(retptr, addHeapObject2(script));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return r0 !== 0;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function addressFromScriptPublicKey2(script_public_key, network) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.addressFromScriptPublicKey(retptr, addBorrowedObject2(script_public_key), addBorrowedObject2(network));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
    heap2[stack_pointer2++] = void 0;
  }
}
function payToScriptHashSignatureScript2(redeem_script, signature2) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.payToScriptHashSignatureScript(retptr, addHeapObject2(redeem_script), addHeapObject2(signature2));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function payToScriptHashScript2(redeem_script) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.payToScriptHashScript(retptr, addHeapObject2(redeem_script));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return ScriptPublicKey2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function payToAddressScript2(address) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.payToAddressScript(retptr, addBorrowedObject2(address));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return ScriptPublicKey2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
  }
}
function calculateTarget2(difficulty) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.calculateTarget(retptr, difficulty);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function argon2sha256ivFromText2(text, byteLength) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.argon2sha256ivFromText(retptr, ptr0, len0, byteLength);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function argon2sha256ivFromBinary2(data, hashLength) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.argon2sha256ivFromBinary(retptr, addHeapObject2(data), hashLength);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256dFromText2(text) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.sha256dFromText(retptr, ptr0, len0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256dFromBinary2(data) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.sha256dFromBinary(retptr, addHeapObject2(data));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256FromText2(text) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.sha256FromText(retptr, ptr0, len0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function sha256FromBinary2(data) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.sha256FromBinary(retptr, addHeapObject2(data));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function decryptXChaCha20Poly13052(base64string, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(base64string, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    const ptr1 = passStringToWasm02(password, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    wasm2.decryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject2(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm02(ptr3, len3);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
function encryptXChaCha20Poly13052(plainText, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(plainText, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    const ptr1 = passStringToWasm02(password, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    wasm2.encryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject2(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm02(ptr3, len3);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
function calculateStorageMass2(network_id, input_values, output_values) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-32);
    wasm2.calculateStorageMass(retptr, addHeapObject2(network_id), addBorrowedObject2(input_values), addBorrowedObject2(output_values));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r2 = getDataViewMemory02().getBigInt64(retptr + 8 * 1, true);
    var r4 = getDataViewMemory02().getInt32(retptr + 4 * 4, true);
    var r5 = getDataViewMemory02().getInt32(retptr + 4 * 5, true);
    if (r5) {
      throw takeObject2(r4);
    }
    return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(32);
    heap2[stack_pointer2++] = void 0;
    heap2[stack_pointer2++] = void 0;
  }
}
function calculateTransactionFee2(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-32);
    wasm2.calculateTransactionFee(retptr, addHeapObject2(network_id), addBorrowedObject2(tx), isLikeNone2(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r2 = getDataViewMemory02().getBigInt64(retptr + 8 * 1, true);
    var r4 = getDataViewMemory02().getInt32(retptr + 4 * 4, true);
    var r5 = getDataViewMemory02().getInt32(retptr + 4 * 5, true);
    if (r5) {
      throw takeObject2(r4);
    }
    return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(32);
    heap2[stack_pointer2++] = void 0;
  }
}
function updateTransactionMass2(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    _assertClass2(tx, Transaction2);
    wasm2.updateTransactionMass(retptr, addHeapObject2(network_id), tx.__wbg_ptr, isLikeNone2(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return r0 !== 0;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function calculateTransactionMass2(network_id, tx, minimum_signatures) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.calculateTransactionMass(retptr, addHeapObject2(network_id), addBorrowedObject2(tx), isLikeNone2(minimum_signatures) ? 16777215 : minimum_signatures);
    var r0 = getDataViewMemory02().getBigInt64(retptr + 8 * 0, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    if (r3) {
      throw takeObject2(r2);
    }
    return BigInt.asUintN(64, r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
  }
}
function maximumStandardTransactionMass2() {
  const ret = wasm2.maximumStandardTransactionMass();
  return BigInt.asUintN(64, ret);
}
function signScriptHash2(script_hash, privkey) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    _assertClass2(privkey, PrivateKey2);
    wasm2.signScriptHash(retptr, addHeapObject2(script_hash), privkey.__wbg_ptr);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject2(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm02(ptr1, len1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function createInputSignature2(tx, input_index, private_key, sighash_type) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    _assertClass2(tx, Transaction2);
    _assertClass2(private_key, PrivateKey2);
    wasm2.createInputSignature(retptr, tx.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone2(sighash_type) ? 6 : sighash_type);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function signTransaction2(tx, signer, verify_sig) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    _assertClass2(tx, Transaction2);
    wasm2.signTransaction(retptr, tx.__wbg_ptr, addBorrowedObject2(signer), verify_sig);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return Transaction2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
  }
}
function createAddress2(key2, network, ecdsa2, account_kind) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    let ptr0 = 0;
    if (!isLikeNone2(account_kind)) {
      _assertClass2(account_kind, AccountKind2);
      ptr0 = account_kind.__destroy_into_raw();
    }
    wasm2.createAddress(retptr, addBorrowedObject2(key2), addBorrowedObject2(network), isLikeNone2(ecdsa2) ? 16777215 : ecdsa2 ? 1 : 0, ptr0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return Address2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
    heap2[stack_pointer2++] = void 0;
  }
}
function createMultisigAddress2(minimum_signatures, keys, network_type, ecdsa2, account_kind) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    let ptr0 = 0;
    if (!isLikeNone2(account_kind)) {
      _assertClass2(account_kind, AccountKind2);
      ptr0 = account_kind.__destroy_into_raw();
    }
    wasm2.createMultisigAddress(retptr, minimum_signatures, addBorrowedObject2(keys), network_type, isLikeNone2(ecdsa2) ? 16777215 : ecdsa2 ? 1 : 0, ptr0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return Address2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
  }
}
function getTransactionMaturityProgress2(blockDaaScore, currentDaaScore, networkId, isCoinbase) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.getTransactionMaturityProgress(retptr, addHeapObject2(blockDaaScore), addHeapObject2(currentDaaScore), addHeapObject2(networkId), isCoinbase);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject2(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm02(ptr1, len1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function getNetworkParams2(networkId) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.getNetworkParams(retptr, addHeapObject2(networkId));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function sompiToKaspaStringWithSuffix2(sompi, network) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.sompiToKaspaStringWithSuffix(retptr, addHeapObject2(sompi), addBorrowedObject2(network));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject2(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm02(ptr1, len1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    heap2[stack_pointer2++] = void 0;
    wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function sompiToKaspaString2(sompi) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.sompiToKaspaString(retptr, addHeapObject2(sompi));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject2(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm02(ptr1, len1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
function kaspaToSompi2(kaspa) {
  const ptr0 = passStringToWasm02(kaspa, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
  const len0 = WASM_VECTOR_LEN2;
  const ret = wasm2.kaspaToSompi(ptr0, len0);
  return takeObject2(ret);
}
function estimateTransactions2(settings) {
  const ret = wasm2.estimateTransactions(addHeapObject2(settings));
  return takeObject2(ret);
}
function createTransactions2(settings) {
  const ret = wasm2.createTransactions(addHeapObject2(settings));
  return takeObject2(ret);
}
function createTransaction2(utxo_entry_source, outputs, priority_fee, payload, sig_op_count) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.createTransaction(retptr, addHeapObject2(utxo_entry_source), addHeapObject2(outputs), addHeapObject2(priority_fee), isLikeNone2(payload) ? 0 : addHeapObject2(payload), isLikeNone2(sig_op_count) ? 16777215 : sig_op_count);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return Transaction2.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function setDefaultStorageFolder2(folder) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(folder, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.setDefaultStorageFolder(retptr, ptr0, len0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject2(r0);
    }
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function setDefaultWalletFile2(folder) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm02(folder, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN2;
    wasm2.setDefaultWalletFile(retptr, ptr0, len0);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject2(r0);
    }
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function verifyMessage2(value2) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.verifyMessage(retptr, addHeapObject2(value2));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return r0 !== 0;
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function signMessage2(value2) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.signMessage(retptr, addHeapObject2(value2));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject2(r1);
    }
    return takeObject2(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function version2() {
  let deferred1_0;
  let deferred1_1;
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.version(retptr);
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    deferred1_0 = r0;
    deferred1_1 = r1;
    return getStringFromWasm02(r0, r1);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
    wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
  }
}
function passArrayJsValueToWasm02(array, malloc) {
  const ptr = malloc(array.length * 4, 4) >>> 0;
  const mem = getDataViewMemory02();
  for (let i2 = 0; i2 < array.length; i2++) {
    mem.setUint32(ptr + 4 * i2, addHeapObject2(array[i2]), true);
  }
  WASM_VECTOR_LEN2 = array.length;
  return ptr;
}
function getArrayJsValueFromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getDataViewMemory02();
  const result = [];
  for (let i2 = ptr; i2 < ptr + 4 * len; i2 += 4) {
    result.push(takeObject2(mem.getUint32(i2, true)));
  }
  return result;
}
function setLogLevel2(level) {
  wasm2.setLogLevel(addHeapObject2(level));
}
function initWASM32Bindings2(config) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.initWASM32Bindings(retptr, addHeapObject2(config));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject2(r0);
    }
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function initConsolePanicHook2() {
  wasm2.initConsolePanicHook();
}
function initBrowserPanicHook2() {
  wasm2.initBrowserPanicHook();
}
function presentPanicHookLogs2() {
  wasm2.presentPanicHookLogs();
}
function defer2() {
  const ret = wasm2.defer();
  return takeObject2(ret);
}
function __wbg_adapter_662(arg0, arg1) {
  wasm2.__wbindgen_export_5(arg0, arg1);
}
function __wbg_adapter_692(arg0, arg1, arg2) {
  wasm2.__wbindgen_export_6(arg0, arg1, addHeapObject2(arg2));
}
function __wbg_adapter_722(arg0, arg1) {
  wasm2.__wbindgen_export_7(arg0, arg1);
}
function __wbg_adapter_752(arg0, arg1, arg2) {
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    wasm2.__wbindgen_export_8(retptr, arg0, arg1, addHeapObject2(arg2));
    var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject2(r0);
    }
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function __wbg_adapter_782(arg0, arg1, arg2) {
  wasm2.__wbindgen_export_9(arg0, arg1, addHeapObject2(arg2));
}
function __wbg_adapter_812(arg0, arg1, arg2, arg3) {
  const ret = wasm2.__wbindgen_export_10(arg0, arg1, addHeapObject2(arg2), arg3);
  return takeObject2(ret);
}
function __wbg_adapter_842(arg0, arg1, arg2) {
  wasm2.__wbindgen_export_11(arg0, arg1, addHeapObject2(arg2));
}
function __wbg_adapter_872(arg0, arg1, arg2) {
  wasm2.__wbindgen_export_11(arg0, arg1, arg2);
}
function __wbg_adapter_902(arg0, arg1, arg2) {
  wasm2.__wbindgen_export_12(arg0, arg1, addHeapObject2(arg2));
}
function __wbg_adapter_1992(arg0, arg1, arg2, arg3) {
  wasm2.__wbindgen_export_13(arg0, arg1, addHeapObject2(arg2), addHeapObject2(arg3));
}
async function __wbg_load2(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports2() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_BigInt_470dd987b8190f8e = function(arg0) {
    const ret = BigInt(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_BigInt_ddea6d2f55558acb = function() {
    return handleError2(function(arg0) {
      const ret = BigInt(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
    const ret = String(getObject2(arg1));
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_Window_b0044ac7db258535 = function(arg0) {
    const ret = getObject2(arg0).Window;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_WorkerGlobalScope_b74cefefc62a37da = function(arg0) {
    const ret = getObject2(arg0).WorkerGlobalScope;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {
    getObject2(arg0).abort();
  };
  imports.wbg.__wbg_aborted_new = function(arg0) {
    const ret = Aborted2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_accountkind_new = function(arg0) {
    const ret = AccountKind2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_addListener_d78339dd4535b756 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg0).addListener(getStringFromWasm02(arg1, arg2), getObject2(arg3));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_address_new = function(arg0) {
    const ret = Address2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_advance_b3ccc91b80962d79 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).advance(arg1 >>> 0);
    }, arguments);
  };
  imports.wbg.__wbg_appendChild_8204974b7328bf98 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).appendChild(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).append(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_body_942ea927546a04ba = function(arg0) {
    const ret = getObject2(arg0).body;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = getObject2(arg0).buffer;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).call(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).call(getObject2(arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_cancelAnimationFrame_032049cb190240a7 = function(arg0) {
    cancelAnimationFrame(takeObject2(arg0));
  };
  imports.wbg.__wbg_clearInterval_d472232e2fb5e5e4 = function() {
    return handleError2(function(arg0) {
      clearInterval(getObject2(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_clearTimeout_c5ac0f4b6a07b59e = function() {
    return handleError2(function(arg0) {
      clearTimeout(getObject2(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_close_0880036443561527 = function() {
    return handleError2(function(arg0) {
      getObject2(arg0).close();
    }, arguments);
  };
  imports.wbg.__wbg_continue_c46c11d3dbe1b030 = function() {
    return handleError2(function(arg0) {
      getObject2(arg0).continue();
    }, arguments);
  };
  imports.wbg.__wbg_count_613cb921d67a4f26 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).count();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createElement_8c9931a732ee2fea = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).createElement(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createIndex_873ac48adc772309 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject2(arg0).createIndex(getStringFromWasm02(arg1, arg2), getObject2(arg3), getObject2(arg4));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectStore_e566459f7161f82f = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).createObjectStore(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_6e98d2f9c7bd9764 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject2(arg1));
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN2;
      getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
    const ret = getObject2(arg0).crypto;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_data_432d9c3df2630942 = function(arg0) {
    const ret = getObject2(arg0).data;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_delete_200677093b4cf756 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).delete(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_delete_36c8630e530a2a1a = function(arg0, arg1) {
    const ret = getObject2(arg0).delete(getObject2(arg1));
    return ret;
  };
  imports.wbg.__wbg_document_d249400bd7bd996d = function(arg0) {
    const ret = getObject2(arg0).document;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {
    const ret = getObject2(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_entries_3265d4158b33e5dc = function(arg0) {
    const ret = Object.entries(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_entries_c8a90a7ed73e84ce = function(arg0) {
    const ret = getObject2(arg0).entries();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_error_5edc95999c70d386 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm02(arg0, arg1));
    } finally {
      wasm2.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_error_b5d62a6100a65a3b = function(arg0, arg1) {
    console.error(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbg_error_ff4ddaabdfc5dbb3 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).error;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_existsSync_6b2031627aea3e5a = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).existsSync(getStringFromWasm02(arg1, arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {
    const ret = getObject2(arg0).fetch(getObject2(arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_fetch_7bb58c5ed3c31810 = function(arg0) {
    const ret = fetch(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_fromCodePoint_f37c25c172f2e8b5 = function() {
    return handleError2(function(arg0) {
      const ret = String.fromCodePoint(arg0 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_from_2a5d3e218e67aa85 = function(arg0) {
    const ret = Array.from(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_from_d608a04300bfd9ac = function(arg0) {
    const ret = Buffer.from(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_generatorsummary_new = function(arg0) {
    const ret = GeneratorSummary2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_getItem_17f98dee3b43fa7e = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg1).getItem(getStringFromWasm02(arg2, arg3));
      var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      var len1 = WASM_VECTOR_LEN2;
      getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).getRandomValues(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_get_13495dac72693ecc = function(arg0, arg1) {
    const ret = getObject2(arg0).get(getObject2(arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.get(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_8da03f81f6a1111e = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).get(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_a8e28596722a45ff = function() {
    return handleError2(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.get(getStringFromWasm02(arg0, arg1));
        return addHeapObject2(ret);
      } finally {
        wasm2.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {
    const ret = getObject2(arg0)[arg1 >>> 0];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_get_f1f75752f252b231 = function() {
    return handleError2(function() {
      const ret = chrome.storage.local.get();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
    const ret = getObject2(arg0)[getObject2(arg1)];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_global_b6f5c73312f62313 = function(arg0) {
    const ret = getObject2(arg0).global;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_has_a5ea9117f258a0ec = function() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.has(getObject2(arg0), getObject2(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_hash_new = function(arg0) {
    const ret = Hash2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {
    const ret = getObject2(arg0).headers;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_index_e00ca5fff206ee3e = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).index(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_601ec26c63e333de = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).indexedDB;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_b1f49280282046f8 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).indexedDB;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_f6b47b0dc333fd2f = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).indexedDB;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_innerHTML_e1553352fe93921a = function(arg0, arg1) {
    const ret = getObject2(arg1).innerHTML;
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Map_f3469ce2244d2430 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Object_7f2dcef8f78644a4 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Object;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Response;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Window;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {
    const ret = Array.isArray(getObject2(arg0));
    return ret;
  };
  imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(arg0) {
    const ret = Number.isSafeInteger(getObject2(arg0));
    return ret;
  };
  imports.wbg.__wbg_is_c7481c65e7e5df9e = function(arg0, arg1) {
    const ret = Object.is(getObject2(arg0), getObject2(arg1));
    return ret;
  };
  imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
    const ret = Symbol.iterator;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_key_c5e0a01cf450dca2 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg1).key(arg2 >>> 0);
      var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      var len1 = WASM_VECTOR_LEN2;
      getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_keys_5c77a08ddc2fb8a6 = function(arg0) {
    const ret = Object.keys(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_ed4a84b02b798bda = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).length;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_localStorage_1406c99c39728187 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).localStorage;
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_location_350d99456c2f3693 = function(arg0) {
    const ret = getObject2(arg0).location;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_log_6c164928aa7b57f4 = function(arg0, arg1) {
    console.log(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbg_mkdirSync_29d1fd92bf140bd0 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      getObject2(arg0).mkdirSync(getStringFromWasm02(arg1, arg2), takeObject2(arg3));
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
    const ret = getObject2(arg0).msCrypto;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_navigator_1577371c070c8947 = function(arg0) {
    const ret = getObject2(arg0).navigator;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_networkid_new = function(arg0) {
    const ret = NetworkId2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    const ret = /* @__PURE__ */ new Date();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() {
    return handleError2(function() {
      const ret = new Headers();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_0b790fd655ff1a97 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new WebSocket(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = /* @__PURE__ */ __name$8((arg02, arg12) => {
        const a2 = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_1992(a2, state0.b, arg02, arg12);
        } finally {
          state0.a = a2;
        }
      }, "cb0");
      const ret = new Promise(cb0);
      return addHeapObject2(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_new_405e22f390576ce2 = function() {
    const ret = new Object();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_5e0be73521bc8c17 = function() {
    const ret = /* @__PURE__ */ new Map();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_757fd34d47ff40d2 = function(arg0) {
    const ret = new ArrayBuffer(arg0 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_78feb108b6472713 = function() {
    const ret = new Array();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_b1a33e5095abf678 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Worker(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_e25e5aab09ff45db = function() {
    return handleError2(function() {
      const ret = new AbortController();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_f5f8a7325e1cb479 = function() {
    const ret = new Error();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject2(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_newwithnodejsconfigimpl_b0a2d4e5b0763676 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      const ret = new WebSocket(getStringFromWasm02(arg0, arg1), takeObject2(arg2), takeObject2(arg3), takeObject2(arg4), takeObject2(arg5), takeObject2(arg6));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm02(arg0, arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrsequenceandoptions_aaff55b467c81b63 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Blob(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {
    const ret = getObject2(arg0).next;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_next_6574e1a8a62d1055 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).next();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
    const ret = getObject2(arg0).node;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_nodedescriptor_new = function(arg0) {
    const ret = NodeDescriptor2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_now_807e54c39636c349 = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_now_d18023d54d4e5500 = function(arg0) {
    const ret = getObject2(arg0).now();
    return ret;
  };
  imports.wbg.__wbg_objectStore_21878d46d25b64b6 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).objectStore(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_oldVersion_e8337811e52861c6 = function(arg0) {
    const ret = getObject2(arg0).oldVersion;
    return ret;
  };
  imports.wbg.__wbg_on_9ef8de87725b93b5 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg0).on(getStringFromWasm02(arg1, arg2), getObject2(arg3));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_once_8901720a31f56808 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg0).once(getStringFromWasm02(arg1, arg2), getObject2(arg3));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_openCursor_d8ea5d621ec422f8 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).openCursor(getObject2(arg1), __wbindgen_enum_IdbCursorDirection2[arg2]);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_open_e0c0b2993eb596e1 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg0).open(getStringFromWasm02(arg1, arg2), arg3 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_pendingtransaction_new = function(arg0) {
    const ret = PendingTransaction2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_postMessage_6edafa8f7b9c2f52 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).postMessage(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_prependListener_dc1e8b094d0f731e = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg0).prependListener(getStringFromWasm02(arg1, arg2), getObject2(arg3));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_prependOnceListener_93873dc17dd2fcad = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg0).prependOnceListener(getStringFromWasm02(arg1, arg2), getObject2(arg3));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
    const ret = getObject2(arg0).process;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_protocol_faa0494a9b2554cb = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg1).protocol;
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN2;
      getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_publickey_new = function(arg0) {
    const ret = PublicKey2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
    const ret = getObject2(arg0).push(getObject2(arg1));
    return ret;
  };
  imports.wbg.__wbg_put_066faa31a6a88f5b = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).put(getObject2(arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {
    queueMicrotask(getObject2(arg0));
  };
  imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {
    const ret = getObject2(arg0).queueMicrotask;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).randomFillSync(takeObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_readFileSync_42b340d959241f2b = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg0).readFileSync(getStringFromWasm02(arg1, arg2), takeObject2(arg3));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readdir_319d9b13a44c9af9 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).readdir(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readyState_4013cfdf4f22afb0 = function(arg0) {
    const ret = getObject2(arg0).readyState;
    return (__wbindgen_enum_IdbRequestReadyState2.indexOf(ret) + 1 || 3) - 1;
  };
  imports.wbg.__wbg_readyState_6c28968f3e6c1e47 = function(arg0) {
    const ret = getObject2(arg0).readyState;
    return ret;
  };
  imports.wbg.__wbg_removeAttribute_e419cd6726b4c62f = function() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject2(arg0).removeAttribute(getStringFromWasm02(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_removeItem_9d2669ee3bba6f7d = function() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject2(arg0).removeItem(getStringFromWasm02(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_remove_cb9af65ab98197c5 = function() {
    return handleError2(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.remove(getStringFromWasm02(arg0, arg1));
        return addHeapObject2(ret);
      } finally {
        wasm2.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_renameSync_86e78b84a05e4a0b = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).renameSync(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_requestAnimationFrame_63a812187303a02c = function(arg0) {
    const ret = requestAnimationFrame(takeObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_require_05f2f70e92254dbb = function(arg0, arg1) {
    const ret = __require(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_require_11fc9008c54f5b90 = function(arg0, arg1) {
    const ret = __require(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return handleError2(function() {
      const ret = module.require;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {
    const ret = Promise.resolve(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_result_f29afabdf2c05826 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).result;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_rpcclient_new = function(arg0) {
    const ret = RpcClient2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_send_17f8c8c8e084cc5e = function() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject2(arg0).send(getArrayU8FromWasm02(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_9a57107cc0d7eafa = function() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject2(arg0).send(getStringFromWasm02(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_afb0c27f2d9698e3 = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).send(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setAttribute_2704501201f15687 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).setAttribute(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_setInterval_160c4baec24e25f6 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = setInterval(getObject2(arg0), arg1 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_setItem_212ecc915942ab0a = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).setItem(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_setTime_8afa2faa26e7eb59 = function(arg0, arg1) {
    const ret = getObject2(arg0).setTime(arg1);
    return ret;
  };
  imports.wbg.__wbg_setTimeout_430dd4984e76f6c3 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = setTimeout(getObject2(arg0), arg1 >>> 0);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_005c36bbcfafb768 = function() {
    return handleError2(function(arg0) {
      const ret = chrome.storage.local.set(takeObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {
    getObject2(arg0)[arg1 >>> 0] = takeObject2(arg2);
  };
  imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    getObject2(arg0)[takeObject2(arg1)] = takeObject2(arg2);
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    getObject2(arg0).set(getObject2(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_set_8fc6bf8a5b1071d1 = function(arg0, arg1, arg2) {
    const ret = getObject2(arg0).set(getObject2(arg1), getObject2(arg2));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject2(arg0), getObject2(arg1), getObject2(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_setbinaryType_9981a6ba2bd58b94 = function(arg0, arg1) {
    getObject2(arg0).binaryType = __wbindgen_enum_BinaryType2[arg1];
  };
  imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {
    getObject2(arg0).body = getObject2(arg1);
  };
  imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {
    getObject2(arg0).credentials = __wbindgen_enum_RequestCredentials2[arg1];
  };
  imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {
    getObject2(arg0).headers = getObject2(arg1);
  };
  imports.wbg.__wbg_setinnerHTML_31bde41f835786f7 = function(arg0, arg1, arg2) {
    getObject2(arg0).innerHTML = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {
    getObject2(arg0).method = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {
    getObject2(arg0).mode = __wbindgen_enum_RequestMode2[arg1];
  };
  imports.wbg.__wbg_setonabort_3bf4db6614fa98e9 = function(arg0, arg1) {
    getObject2(arg0).onabort = getObject2(arg1);
  };
  imports.wbg.__wbg_setonblocked_aebf64bd39f1eca8 = function(arg0, arg1) {
    getObject2(arg0).onblocked = getObject2(arg1);
  };
  imports.wbg.__wbg_setonclose_b15bdabd419b6357 = function(arg0, arg1) {
    getObject2(arg0).onclose = getObject2(arg1);
  };
  imports.wbg.__wbg_setoncomplete_4d19df0dadb7c4d4 = function(arg0, arg1) {
    getObject2(arg0).oncomplete = getObject2(arg1);
  };
  imports.wbg.__wbg_setonerror_b0d9d723b8fddbbb = function(arg0, arg1) {
    getObject2(arg0).onerror = getObject2(arg1);
  };
  imports.wbg.__wbg_setonerror_d7e3056cc6e56085 = function(arg0, arg1) {
    getObject2(arg0).onerror = getObject2(arg1);
  };
  imports.wbg.__wbg_setonerror_e2c5c0fa6fbf6d99 = function(arg0, arg1) {
    getObject2(arg0).onerror = getObject2(arg1);
  };
  imports.wbg.__wbg_setonmessage_007594843a0b97e8 = function(arg0, arg1) {
    getObject2(arg0).onmessage = getObject2(arg1);
  };
  imports.wbg.__wbg_setonmessage_5a885b16bdc6dca6 = function(arg0, arg1) {
    getObject2(arg0).onmessage = getObject2(arg1);
  };
  imports.wbg.__wbg_setonopen_c42cfdbb28b087c4 = function(arg0, arg1) {
    getObject2(arg0).onopen = getObject2(arg1);
  };
  imports.wbg.__wbg_setonsuccess_afa464ee777a396d = function(arg0, arg1) {
    getObject2(arg0).onsuccess = getObject2(arg1);
  };
  imports.wbg.__wbg_setonupgradeneeded_fcf7ce4f2eb0cb5f = function(arg0, arg1) {
    getObject2(arg0).onupgradeneeded = getObject2(arg1);
  };
  imports.wbg.__wbg_setonversionchange_6ee07fa49ee1e3a5 = function(arg0, arg1) {
    getObject2(arg0).onversionchange = getObject2(arg1);
  };
  imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {
    getObject2(arg0).signal = getObject2(arg1);
  };
  imports.wbg.__wbg_settype_39ed370d3edd403c = function(arg0, arg1, arg2) {
    getObject2(arg0).type = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setunique_dd24c422aa05df89 = function(arg0, arg1) {
    getObject2(arg0).unique = arg1 !== 0;
  };
  imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {
    const ret = getObject2(arg0).signal;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_stack_c99a96ed42647c4c = function(arg0, arg1) {
    const ret = getObject2(arg1).stack;
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_statSync_9a429acc496bafda = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).statSync(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {
    const ret = getObject2(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() {
    return handleError2(function(arg0) {
      const ret = JSON.stringify(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = getObject2(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_target_0a62d9d79a2a1ede = function(arg0) {
    const ret = getObject2(arg0).target;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_text_7805bea50de2af49 = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).text();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {
    const ret = getObject2(arg0).then(getObject2(arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {
    const ret = getObject2(arg0).then(getObject2(arg1), getObject2(arg2));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_toString_2f76f493957b63da = function(arg0, arg1, arg2) {
    const ret = getObject2(arg1).toString(arg2);
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_toString_b5d4438bc26b267c = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).toString(arg1);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_babc423936946a37 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg0).transaction(getStringFromWasm02(arg1, arg2), __wbindgen_enum_IdbTransactionMode2[arg3]);
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_new = function(arg0) {
    const ret = Transaction2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_transactioninput_new = function(arg0) {
    const ret = TransactionInput2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_transactionoutput_new = function(arg0) {
    const ret = TransactionOutput2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_transactionrecordnotification_new = function(arg0) {
    const ret = TransactionRecordNotification2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_unlinkSync_656392e8d747415f = function() {
    return handleError2(function(arg0, arg1, arg2) {
      getObject2(arg0).unlinkSync(getStringFromWasm02(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_update_acd72607f506872a = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).update(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {
    const ret = getObject2(arg1).url;
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_userAgent_12e9d8e62297563f = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg1).userAgent;
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN2;
      getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_utxoentryreference_new = function(arg0) {
    const ret = UtxoEntryReference2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_value_68c4e9a54bb7fd5e = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).value;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {
    const ret = getObject2(arg0).value;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
    const ret = getObject2(arg0).versions;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_walletdescriptor_new = function(arg0) {
    const ret = WalletDescriptor2.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_warn_28319e260c89a4f8 = function(arg0, arg1) {
    console.warn(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbg_writeFileSync_6325b339950ab342 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).writeFileSync(getStringFromWasm02(arg1, arg2), takeObject2(arg3), takeObject2(arg4));
    }, arguments);
  };
  imports.wbg.__wbindgen_array_new = function() {
    const ret = [];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_array_push = function(arg0, arg1) {
    getObject2(arg0).push(takeObject2(arg1));
  };
  imports.wbg.__wbindgen_as_number = function(arg0) {
    const ret = +getObject2(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject2(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getDataViewMemory02().setBigInt64(arg0 + 8 * 1, isLikeNone2(ret) ? BigInt(0) : ret, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, !isLikeNone2(ret), true);
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject2(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject2(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbindgen_closure_wrapper16385 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6406, __wbg_adapter_782);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17150 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6436, __wbg_adapter_812);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17152 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6436, __wbg_adapter_842);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17154 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6436, __wbg_adapter_872);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17515 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6560, __wbg_adapter_902);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17516 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 6560, __wbg_adapter_902);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper4216 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 1320, __wbg_adapter_752);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper826 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 182, __wbg_adapter_662);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {
    const ret = makeClosure2(arg0, arg1, 237, __wbg_adapter_692);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper949 = function(arg0, arg1, arg2) {
    const ret = makeClosure2(arg0, arg1, 237, __wbg_adapter_722);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString2(getObject2(arg1));
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject2(arg0) in getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_is_array = function(arg0) {
    const ret = Array.isArray(getObject2(arg0));
    return ret;
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject2(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_is_falsy = function(arg0) {
    const ret = !getObject2(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject2(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    const ret = getObject2(arg0) === null;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject2(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject2(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject2(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject2(arg0) === getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject2(arg0) == getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_lt = function(arg0, arg1) {
    const ret = getObject2(arg0) < getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm2.memory;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_neg = function(arg0) {
    const ret = -getObject2(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getDataViewMemory02().setFloat64(arg0 + 8 * 1, isLikeNone2(ret) ? 0 : ret, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, !isLikeNone2(ret), true);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject2(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject2(arg0);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    var len1 = WASM_VECTOR_LEN2;
    getDataViewMemory02().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory02().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm02(arg0, arg1);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbindgen_try_into_number = function(arg0) {
    let result;
    try {
      result = +getObject2(arg0);
    } catch (e2) {
      result = e2;
    }
    const ret = result;
    return addHeapObject2(ret);
  };
  return imports;
}
function __wbg_init_memory2(imports, memory) {
}
function __wbg_finalize_init2(instance, module2) {
  wasm2 = instance.exports;
  __wbg_init2.__wbindgen_wasm_module = module2;
  cachedDataViewMemory02 = null;
  cachedUint8ArrayMemory02 = null;
  return wasm2;
}
function initSync2(module2) {
  if (wasm2 !== void 0) return wasm2;
  if (typeof module2 !== "undefined") {
    if (Object.getPrototypeOf(module2) === Object.prototype) {
      ({ module: module2 } = module2);
    } else {
      console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
    }
  }
  const imports = __wbg_get_imports2();
  if (!(module2 instanceof WebAssembly.Module)) {
    module2 = new WebAssembly.Module(module2);
  }
  const instance = new WebAssembly.Instance(module2, imports);
  return __wbg_finalize_init2(instance, module2);
}
async function __wbg_init2(module_or_path) {
  if (wasm2 !== void 0) return wasm2;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("kaspa_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports2();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  const { instance, module: module2 } = await __wbg_load2(await module_or_path, imports);
  return __wbg_finalize_init2(instance, module2);
}
var wasm2, heap2, heap_next2, WASM_VECTOR_LEN2, cachedUint8ArrayMemory02, cachedTextEncoder2, encodeString2, cachedDataViewMemory02, cachedTextDecoder2, CLOSURE_DTORS2, stack_pointer2, AccountsDiscoveryKind2, AddressVersion2, CommitRevealAddressKind2, ConnectStrategy2, Encoding2, FeeSource2, Language2, NetworkType2, NewAddressKind2, Opcodes2, SighashType2, __wbindgen_enum_BinaryType2, __wbindgen_enum_IdbCursorDirection2, __wbindgen_enum_IdbRequestReadyState2, __wbindgen_enum_IdbTransactionMode2, __wbindgen_enum_RequestCredentials2, __wbindgen_enum_RequestMode2, AbortableFinalization2, Abortable2, AbortedFinalization2, Aborted2, AccountKindFinalization2, AccountKind2, AddressFinalization2, Address2, AgentConstructorOptionsFinalization2, AgentConstructorOptions2, AppendFileOptionsFinalization2, AppendFileOptions2, AssertionErrorOptionsFinalization2, AssertionErrorOptions2, BalanceFinalization2, Balance2, BalanceStringsFinalization2, BalanceStrings2, ConsoleConstructorOptionsFinalization2, ConsoleConstructorOptions2, CreateHookCallbacksFinalization2, CreateHookCallbacks2, CreateReadStreamOptionsFinalization2, CreateReadStreamOptions2, CreateWriteStreamOptionsFinalization2, CreateWriteStreamOptions2, CryptoBoxFinalization2, CryptoBox2, CryptoBoxPrivateKeyFinalization2, CryptoBoxPrivateKey2, CryptoBoxPublicKeyFinalization2, CryptoBoxPublicKey2, DerivationPathFinalization2, DerivationPath2, FormatInputPathObjectFinalization2, FormatInputPathObject2, GeneratorFinalization2, Generator2, GeneratorSummaryFinalization2, GeneratorSummary2, GetNameOptionsFinalization2, GetNameOptions2, HashFinalization2, Hash2, HeaderFinalization2, Header2, KeypairFinalization2, Keypair2, MkdtempSyncOptionsFinalization2, MkdtempSyncOptions2, MnemonicFinalization2, Mnemonic2, NetServerOptionsFinalization2, NetServerOptions2, NetworkIdFinalization2, NetworkId2, NodeDescriptorFinalization2, NodeDescriptor2, PSKBFinalization2, PSKB2, PSKTFinalization2, PSKT2, PaymentOutputFinalization2, PaymentOutput2, PaymentOutputsFinalization2, PaymentOutputs2, PendingTransactionFinalization2, PendingTransaction2, PipeOptionsFinalization2, PipeOptions2, PoWFinalization2, PoW2, PrivateKeyFinalization2, PrivateKey2, PrivateKeyGeneratorFinalization2, PrivateKeyGenerator2, ProcessSendOptionsFinalization2, ProcessSendOptions2, PrvKeyDataInfoFinalization2, PrvKeyDataInfo2, PublicKeyFinalization2, PublicKey2, PublicKeyGeneratorFinalization2, PublicKeyGenerator2, ReadStreamFinalization2, ReadStream2, ResolverFinalization2, Resolver2, RpcClientFinalization2, RpcClient2, ScriptBuilderFinalization2, ScriptBuilder2, ScriptPublicKeyFinalization2, ScriptPublicKey2, SetAadOptionsFinalization2, SetAadOptions2, SigHashTypeFinalization2, SigHashType2, StorageFinalization2, Storage2, StreamTransformOptionsFinalization2, StreamTransformOptions2, TransactionFinalization2, Transaction2, TransactionInputFinalization2, TransactionInput2, TransactionOutpointFinalization2, TransactionOutpoint2, TransactionOutputFinalization2, TransactionOutput2, TransactionRecordFinalization2, TransactionRecord2, TransactionRecordNotificationFinalization2, TransactionRecordNotification2, TransactionSigningHashFinalization2, TransactionSigningHash2, TransactionSigningHashECDSAFinalization2, TransactionSigningHashECDSA2, TransactionUtxoEntryFinalization2, TransactionUtxoEntry2, UserInfoOptionsFinalization2, UserInfoOptions2, UtxoContextFinalization2, UtxoContext2, UtxoEntriesFinalization2, UtxoEntries2, UtxoEntryFinalization2, UtxoEntry2, UtxoEntryReferenceFinalization2, UtxoEntryReference2, UtxoProcessorFinalization2, UtxoProcessor2, WalletFinalization2, Wallet2, WalletDescriptorFinalization2, WalletDescriptor2, WasiOptionsFinalization2, WasiOptions2, WriteFileSyncOptionsFinalization2, WriteFileSyncOptions2, WriteStreamFinalization2, WriteStream2, XOnlyPublicKeyFinalization2, XOnlyPublicKey2, XPrvFinalization2, XPrv2, XPubFinalization2, XPub2, kaspa_default2;
var init_kaspa2 = __esm({
  "nodejs/kaspa.js"() {
    heap2 = new Array(128).fill(void 0);
    heap2.push(void 0, null, true, false);
    __name$8(getObject2, "getObject");
    heap_next2 = heap2.length;
    __name$8(addHeapObject2, "addHeapObject");
    __name$8(handleError2, "handleError");
    WASM_VECTOR_LEN2 = 0;
    cachedUint8ArrayMemory02 = null;
    __name$8(getUint8ArrayMemory02, "getUint8ArrayMemory0");
    cachedTextEncoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: /* @__PURE__ */ __name$8(() => {
      throw Error("TextEncoder not available");
    }, "encode") };
    encodeString2 = typeof cachedTextEncoder2.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder2.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder2.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    __name$8(passStringToWasm02, "passStringToWasm0");
    cachedDataViewMemory02 = null;
    __name$8(getDataViewMemory02, "getDataViewMemory0");
    cachedTextDecoder2 = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: /* @__PURE__ */ __name$8(() => {
      throw Error("TextDecoder not available");
    }, "decode") };
    if (typeof TextDecoder !== "undefined") {
      cachedTextDecoder2.decode();
    }
    __name$8(getStringFromWasm02, "getStringFromWasm0");
    __name$8(isLikeNone2, "isLikeNone");
    __name$8(dropObject2, "dropObject");
    __name$8(takeObject2, "takeObject");
    __name$8(getArrayU8FromWasm02, "getArrayU8FromWasm0");
    CLOSURE_DTORS2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((state) => {
      wasm2.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
    });
    __name$8(makeMutClosure2, "makeMutClosure");
    __name$8(makeClosure2, "makeClosure");
    __name$8(debugString2, "debugString");
    __name$8(_assertClass2, "_assertClass");
    stack_pointer2 = 128;
    __name$8(addBorrowedObject2, "addBorrowedObject");
    __name$8(isScriptPayToScriptHash2, "isScriptPayToScriptHash");
    __name$8(isScriptPayToPubkeyECDSA2, "isScriptPayToPubkeyECDSA");
    __name$8(isScriptPayToPubkey2, "isScriptPayToPubkey");
    __name$8(addressFromScriptPublicKey2, "addressFromScriptPublicKey");
    __name$8(payToScriptHashSignatureScript2, "payToScriptHashSignatureScript");
    __name$8(payToScriptHashScript2, "payToScriptHashScript");
    __name$8(payToAddressScript2, "payToAddressScript");
    __name$8(calculateTarget2, "calculateTarget");
    __name$8(argon2sha256ivFromText2, "argon2sha256ivFromText");
    __name$8(argon2sha256ivFromBinary2, "argon2sha256ivFromBinary");
    __name$8(sha256dFromText2, "sha256dFromText");
    __name$8(sha256dFromBinary2, "sha256dFromBinary");
    __name$8(sha256FromText2, "sha256FromText");
    __name$8(sha256FromBinary2, "sha256FromBinary");
    __name$8(decryptXChaCha20Poly13052, "decryptXChaCha20Poly1305");
    __name$8(encryptXChaCha20Poly13052, "encryptXChaCha20Poly1305");
    __name$8(calculateStorageMass2, "calculateStorageMass");
    __name$8(calculateTransactionFee2, "calculateTransactionFee");
    __name$8(updateTransactionMass2, "updateTransactionMass");
    __name$8(calculateTransactionMass2, "calculateTransactionMass");
    __name$8(maximumStandardTransactionMass2, "maximumStandardTransactionMass");
    __name$8(signScriptHash2, "signScriptHash");
    __name$8(createInputSignature2, "createInputSignature");
    __name$8(signTransaction2, "signTransaction");
    __name$8(createAddress2, "createAddress");
    __name$8(createMultisigAddress2, "createMultisigAddress");
    __name$8(getTransactionMaturityProgress2, "getTransactionMaturityProgress");
    __name$8(getNetworkParams2, "getNetworkParams");
    __name$8(sompiToKaspaStringWithSuffix2, "sompiToKaspaStringWithSuffix");
    __name$8(sompiToKaspaString2, "sompiToKaspaString");
    __name$8(kaspaToSompi2, "kaspaToSompi");
    __name$8(estimateTransactions2, "estimateTransactions");
    __name$8(createTransactions2, "createTransactions");
    __name$8(createTransaction2, "createTransaction");
    __name$8(setDefaultStorageFolder2, "setDefaultStorageFolder");
    __name$8(setDefaultWalletFile2, "setDefaultWalletFile");
    __name$8(verifyMessage2, "verifyMessage");
    __name$8(signMessage2, "signMessage");
    __name$8(version2, "version");
    __name$8(passArrayJsValueToWasm02, "passArrayJsValueToWasm0");
    __name$8(getArrayJsValueFromWasm02, "getArrayJsValueFromWasm0");
    __name$8(setLogLevel2, "setLogLevel");
    __name$8(initWASM32Bindings2, "initWASM32Bindings");
    __name$8(initConsolePanicHook2, "initConsolePanicHook");
    __name$8(initBrowserPanicHook2, "initBrowserPanicHook");
    __name$8(presentPanicHookLogs2, "presentPanicHookLogs");
    __name$8(defer2, "defer");
    __name$8(__wbg_adapter_662, "__wbg_adapter_66");
    __name$8(__wbg_adapter_692, "__wbg_adapter_69");
    __name$8(__wbg_adapter_722, "__wbg_adapter_72");
    __name$8(__wbg_adapter_752, "__wbg_adapter_75");
    __name$8(__wbg_adapter_782, "__wbg_adapter_78");
    __name$8(__wbg_adapter_812, "__wbg_adapter_81");
    __name$8(__wbg_adapter_842, "__wbg_adapter_84");
    __name$8(__wbg_adapter_872, "__wbg_adapter_87");
    __name$8(__wbg_adapter_902, "__wbg_adapter_90");
    __name$8(__wbg_adapter_1992, "__wbg_adapter_199");
    AccountsDiscoveryKind2 = Object.freeze({
      Bip44: 0,
      "0": "Bip44"
    });
    AddressVersion2 = Object.freeze({
      /**
       * PubKey addresses always have the version byte set to 0
       */
      PubKey: 0,
      "0": "PubKey",
      /**
       * PubKey ECDSA addresses always have the version byte set to 1
       */
      PubKeyECDSA: 1,
      "1": "PubKeyECDSA",
      /**
       * ScriptHash addresses always have the version byte set to 8
       */
      ScriptHash: 8,
      "8": "ScriptHash"
    });
    CommitRevealAddressKind2 = Object.freeze({
      Receive: 0,
      "0": "Receive",
      Change: 1,
      "1": "Change"
    });
    ConnectStrategy2 = Object.freeze({
      /**
       * Continuously attempt to connect to the server. This behavior will
       * block `connect()` function until the connection is established.
       */
      Retry: 0,
      "0": "Retry",
      /**
       * Causes `connect()` to return immediately if the first-time connection
       * has failed.
       */
      Fallback: 1,
      "1": "Fallback"
    });
    Encoding2 = Object.freeze({
      Borsh: 0,
      "0": "Borsh",
      SerdeJson: 1,
      "1": "SerdeJson"
    });
    FeeSource2 = Object.freeze({
      SenderPays: 0,
      "0": "SenderPays",
      ReceiverPays: 1,
      "1": "ReceiverPays"
    });
    Language2 = Object.freeze({
      /**
       * English is presently the only supported language
       */
      English: 0,
      "0": "English"
    });
    NetworkType2 = Object.freeze({
      Mainnet: 0,
      "0": "Mainnet",
      Testnet: 1,
      "1": "Testnet",
      Devnet: 2,
      "2": "Devnet",
      Simnet: 3,
      "3": "Simnet"
    });
    NewAddressKind2 = Object.freeze({
      Receive: 0,
      "0": "Receive",
      Change: 1,
      "1": "Change"
    });
    Opcodes2 = Object.freeze({
      OpFalse: 0,
      "0": "OpFalse",
      OpData1: 1,
      "1": "OpData1",
      OpData2: 2,
      "2": "OpData2",
      OpData3: 3,
      "3": "OpData3",
      OpData4: 4,
      "4": "OpData4",
      OpData5: 5,
      "5": "OpData5",
      OpData6: 6,
      "6": "OpData6",
      OpData7: 7,
      "7": "OpData7",
      OpData8: 8,
      "8": "OpData8",
      OpData9: 9,
      "9": "OpData9",
      OpData10: 10,
      "10": "OpData10",
      OpData11: 11,
      "11": "OpData11",
      OpData12: 12,
      "12": "OpData12",
      OpData13: 13,
      "13": "OpData13",
      OpData14: 14,
      "14": "OpData14",
      OpData15: 15,
      "15": "OpData15",
      OpData16: 16,
      "16": "OpData16",
      OpData17: 17,
      "17": "OpData17",
      OpData18: 18,
      "18": "OpData18",
      OpData19: 19,
      "19": "OpData19",
      OpData20: 20,
      "20": "OpData20",
      OpData21: 21,
      "21": "OpData21",
      OpData22: 22,
      "22": "OpData22",
      OpData23: 23,
      "23": "OpData23",
      OpData24: 24,
      "24": "OpData24",
      OpData25: 25,
      "25": "OpData25",
      OpData26: 26,
      "26": "OpData26",
      OpData27: 27,
      "27": "OpData27",
      OpData28: 28,
      "28": "OpData28",
      OpData29: 29,
      "29": "OpData29",
      OpData30: 30,
      "30": "OpData30",
      OpData31: 31,
      "31": "OpData31",
      OpData32: 32,
      "32": "OpData32",
      OpData33: 33,
      "33": "OpData33",
      OpData34: 34,
      "34": "OpData34",
      OpData35: 35,
      "35": "OpData35",
      OpData36: 36,
      "36": "OpData36",
      OpData37: 37,
      "37": "OpData37",
      OpData38: 38,
      "38": "OpData38",
      OpData39: 39,
      "39": "OpData39",
      OpData40: 40,
      "40": "OpData40",
      OpData41: 41,
      "41": "OpData41",
      OpData42: 42,
      "42": "OpData42",
      OpData43: 43,
      "43": "OpData43",
      OpData44: 44,
      "44": "OpData44",
      OpData45: 45,
      "45": "OpData45",
      OpData46: 46,
      "46": "OpData46",
      OpData47: 47,
      "47": "OpData47",
      OpData48: 48,
      "48": "OpData48",
      OpData49: 49,
      "49": "OpData49",
      OpData50: 50,
      "50": "OpData50",
      OpData51: 51,
      "51": "OpData51",
      OpData52: 52,
      "52": "OpData52",
      OpData53: 53,
      "53": "OpData53",
      OpData54: 54,
      "54": "OpData54",
      OpData55: 55,
      "55": "OpData55",
      OpData56: 56,
      "56": "OpData56",
      OpData57: 57,
      "57": "OpData57",
      OpData58: 58,
      "58": "OpData58",
      OpData59: 59,
      "59": "OpData59",
      OpData60: 60,
      "60": "OpData60",
      OpData61: 61,
      "61": "OpData61",
      OpData62: 62,
      "62": "OpData62",
      OpData63: 63,
      "63": "OpData63",
      OpData64: 64,
      "64": "OpData64",
      OpData65: 65,
      "65": "OpData65",
      OpData66: 66,
      "66": "OpData66",
      OpData67: 67,
      "67": "OpData67",
      OpData68: 68,
      "68": "OpData68",
      OpData69: 69,
      "69": "OpData69",
      OpData70: 70,
      "70": "OpData70",
      OpData71: 71,
      "71": "OpData71",
      OpData72: 72,
      "72": "OpData72",
      OpData73: 73,
      "73": "OpData73",
      OpData74: 74,
      "74": "OpData74",
      OpData75: 75,
      "75": "OpData75",
      OpPushData1: 76,
      "76": "OpPushData1",
      OpPushData2: 77,
      "77": "OpPushData2",
      OpPushData4: 78,
      "78": "OpPushData4",
      Op1Negate: 79,
      "79": "Op1Negate",
      OpReserved: 80,
      "80": "OpReserved",
      OpTrue: 81,
      "81": "OpTrue",
      Op2: 82,
      "82": "Op2",
      Op3: 83,
      "83": "Op3",
      Op4: 84,
      "84": "Op4",
      Op5: 85,
      "85": "Op5",
      Op6: 86,
      "86": "Op6",
      Op7: 87,
      "87": "Op7",
      Op8: 88,
      "88": "Op8",
      Op9: 89,
      "89": "Op9",
      Op10: 90,
      "90": "Op10",
      Op11: 91,
      "91": "Op11",
      Op12: 92,
      "92": "Op12",
      Op13: 93,
      "93": "Op13",
      Op14: 94,
      "94": "Op14",
      Op15: 95,
      "95": "Op15",
      Op16: 96,
      "96": "Op16",
      OpNop: 97,
      "97": "OpNop",
      OpVer: 98,
      "98": "OpVer",
      OpIf: 99,
      "99": "OpIf",
      OpNotIf: 100,
      "100": "OpNotIf",
      OpVerIf: 101,
      "101": "OpVerIf",
      OpVerNotIf: 102,
      "102": "OpVerNotIf",
      OpElse: 103,
      "103": "OpElse",
      OpEndIf: 104,
      "104": "OpEndIf",
      OpVerify: 105,
      "105": "OpVerify",
      OpReturn: 106,
      "106": "OpReturn",
      OpToAltStack: 107,
      "107": "OpToAltStack",
      OpFromAltStack: 108,
      "108": "OpFromAltStack",
      Op2Drop: 109,
      "109": "Op2Drop",
      Op2Dup: 110,
      "110": "Op2Dup",
      Op3Dup: 111,
      "111": "Op3Dup",
      Op2Over: 112,
      "112": "Op2Over",
      Op2Rot: 113,
      "113": "Op2Rot",
      Op2Swap: 114,
      "114": "Op2Swap",
      OpIfDup: 115,
      "115": "OpIfDup",
      OpDepth: 116,
      "116": "OpDepth",
      OpDrop: 117,
      "117": "OpDrop",
      OpDup: 118,
      "118": "OpDup",
      OpNip: 119,
      "119": "OpNip",
      OpOver: 120,
      "120": "OpOver",
      OpPick: 121,
      "121": "OpPick",
      OpRoll: 122,
      "122": "OpRoll",
      OpRot: 123,
      "123": "OpRot",
      OpSwap: 124,
      "124": "OpSwap",
      OpTuck: 125,
      "125": "OpTuck",
      /**
       * Splice opcodes.
       */
      OpCat: 126,
      "126": "OpCat",
      OpSubStr: 127,
      "127": "OpSubStr",
      OpLeft: 128,
      "128": "OpLeft",
      OpRight: 129,
      "129": "OpRight",
      OpSize: 130,
      "130": "OpSize",
      /**
       * Bitwise logic opcodes.
       */
      OpInvert: 131,
      "131": "OpInvert",
      OpAnd: 132,
      "132": "OpAnd",
      OpOr: 133,
      "133": "OpOr",
      OpXor: 134,
      "134": "OpXor",
      OpEqual: 135,
      "135": "OpEqual",
      OpEqualVerify: 136,
      "136": "OpEqualVerify",
      OpReserved1: 137,
      "137": "OpReserved1",
      OpReserved2: 138,
      "138": "OpReserved2",
      /**
       * Numeric related opcodes.
       */
      Op1Add: 139,
      "139": "Op1Add",
      Op1Sub: 140,
      "140": "Op1Sub",
      Op2Mul: 141,
      "141": "Op2Mul",
      Op2Div: 142,
      "142": "Op2Div",
      OpNegate: 143,
      "143": "OpNegate",
      OpAbs: 144,
      "144": "OpAbs",
      OpNot: 145,
      "145": "OpNot",
      Op0NotEqual: 146,
      "146": "Op0NotEqual",
      OpAdd: 147,
      "147": "OpAdd",
      OpSub: 148,
      "148": "OpSub",
      OpMul: 149,
      "149": "OpMul",
      OpDiv: 150,
      "150": "OpDiv",
      OpMod: 151,
      "151": "OpMod",
      OpLShift: 152,
      "152": "OpLShift",
      OpRShift: 153,
      "153": "OpRShift",
      OpBoolAnd: 154,
      "154": "OpBoolAnd",
      OpBoolOr: 155,
      "155": "OpBoolOr",
      OpNumEqual: 156,
      "156": "OpNumEqual",
      OpNumEqualVerify: 157,
      "157": "OpNumEqualVerify",
      OpNumNotEqual: 158,
      "158": "OpNumNotEqual",
      OpLessThan: 159,
      "159": "OpLessThan",
      OpGreaterThan: 160,
      "160": "OpGreaterThan",
      OpLessThanOrEqual: 161,
      "161": "OpLessThanOrEqual",
      OpGreaterThanOrEqual: 162,
      "162": "OpGreaterThanOrEqual",
      OpMin: 163,
      "163": "OpMin",
      OpMax: 164,
      "164": "OpMax",
      OpWithin: 165,
      "165": "OpWithin",
      /**
       * Undefined opcodes.
       */
      OpUnknown166: 166,
      "166": "OpUnknown166",
      OpUnknown167: 167,
      "167": "OpUnknown167",
      /**
       * Crypto opcodes.
       */
      OpSHA256: 168,
      "168": "OpSHA256",
      OpCheckMultiSigECDSA: 169,
      "169": "OpCheckMultiSigECDSA",
      OpBlake2b: 170,
      "170": "OpBlake2b",
      OpCheckSigECDSA: 171,
      "171": "OpCheckSigECDSA",
      OpCheckSig: 172,
      "172": "OpCheckSig",
      OpCheckSigVerify: 173,
      "173": "OpCheckSigVerify",
      OpCheckMultiSig: 174,
      "174": "OpCheckMultiSig",
      OpCheckMultiSigVerify: 175,
      "175": "OpCheckMultiSigVerify",
      OpCheckLockTimeVerify: 176,
      "176": "OpCheckLockTimeVerify",
      OpCheckSequenceVerify: 177,
      "177": "OpCheckSequenceVerify",
      /**
       * Undefined opcodes.
       */
      OpUnknown178: 178,
      "178": "OpUnknown178",
      OpUnknown179: 179,
      "179": "OpUnknown179",
      OpUnknown180: 180,
      "180": "OpUnknown180",
      OpUnknown181: 181,
      "181": "OpUnknown181",
      OpUnknown182: 182,
      "182": "OpUnknown182",
      OpUnknown183: 183,
      "183": "OpUnknown183",
      OpUnknown184: 184,
      "184": "OpUnknown184",
      OpUnknown185: 185,
      "185": "OpUnknown185",
      OpUnknown186: 186,
      "186": "OpUnknown186",
      OpUnknown187: 187,
      "187": "OpUnknown187",
      OpUnknown188: 188,
      "188": "OpUnknown188",
      OpUnknown189: 189,
      "189": "OpUnknown189",
      OpUnknown190: 190,
      "190": "OpUnknown190",
      OpUnknown191: 191,
      "191": "OpUnknown191",
      OpUnknown192: 192,
      "192": "OpUnknown192",
      OpUnknown193: 193,
      "193": "OpUnknown193",
      OpUnknown194: 194,
      "194": "OpUnknown194",
      OpUnknown195: 195,
      "195": "OpUnknown195",
      OpUnknown196: 196,
      "196": "OpUnknown196",
      OpUnknown197: 197,
      "197": "OpUnknown197",
      OpUnknown198: 198,
      "198": "OpUnknown198",
      OpUnknown199: 199,
      "199": "OpUnknown199",
      OpUnknown200: 200,
      "200": "OpUnknown200",
      OpUnknown201: 201,
      "201": "OpUnknown201",
      OpUnknown202: 202,
      "202": "OpUnknown202",
      OpUnknown203: 203,
      "203": "OpUnknown203",
      OpUnknown204: 204,
      "204": "OpUnknown204",
      OpUnknown205: 205,
      "205": "OpUnknown205",
      OpUnknown206: 206,
      "206": "OpUnknown206",
      OpUnknown207: 207,
      "207": "OpUnknown207",
      OpUnknown208: 208,
      "208": "OpUnknown208",
      OpUnknown209: 209,
      "209": "OpUnknown209",
      OpUnknown210: 210,
      "210": "OpUnknown210",
      OpUnknown211: 211,
      "211": "OpUnknown211",
      OpUnknown212: 212,
      "212": "OpUnknown212",
      OpUnknown213: 213,
      "213": "OpUnknown213",
      OpUnknown214: 214,
      "214": "OpUnknown214",
      OpUnknown215: 215,
      "215": "OpUnknown215",
      OpUnknown216: 216,
      "216": "OpUnknown216",
      OpUnknown217: 217,
      "217": "OpUnknown217",
      OpUnknown218: 218,
      "218": "OpUnknown218",
      OpUnknown219: 219,
      "219": "OpUnknown219",
      OpUnknown220: 220,
      "220": "OpUnknown220",
      OpUnknown221: 221,
      "221": "OpUnknown221",
      OpUnknown222: 222,
      "222": "OpUnknown222",
      OpUnknown223: 223,
      "223": "OpUnknown223",
      OpUnknown224: 224,
      "224": "OpUnknown224",
      OpUnknown225: 225,
      "225": "OpUnknown225",
      OpUnknown226: 226,
      "226": "OpUnknown226",
      OpUnknown227: 227,
      "227": "OpUnknown227",
      OpUnknown228: 228,
      "228": "OpUnknown228",
      OpUnknown229: 229,
      "229": "OpUnknown229",
      OpUnknown230: 230,
      "230": "OpUnknown230",
      OpUnknown231: 231,
      "231": "OpUnknown231",
      OpUnknown232: 232,
      "232": "OpUnknown232",
      OpUnknown233: 233,
      "233": "OpUnknown233",
      OpUnknown234: 234,
      "234": "OpUnknown234",
      OpUnknown235: 235,
      "235": "OpUnknown235",
      OpUnknown236: 236,
      "236": "OpUnknown236",
      OpUnknown237: 237,
      "237": "OpUnknown237",
      OpUnknown238: 238,
      "238": "OpUnknown238",
      OpUnknown239: 239,
      "239": "OpUnknown239",
      OpUnknown240: 240,
      "240": "OpUnknown240",
      OpUnknown241: 241,
      "241": "OpUnknown241",
      OpUnknown242: 242,
      "242": "OpUnknown242",
      OpUnknown243: 243,
      "243": "OpUnknown243",
      OpUnknown244: 244,
      "244": "OpUnknown244",
      OpUnknown245: 245,
      "245": "OpUnknown245",
      OpUnknown246: 246,
      "246": "OpUnknown246",
      OpUnknown247: 247,
      "247": "OpUnknown247",
      OpUnknown248: 248,
      "248": "OpUnknown248",
      OpUnknown249: 249,
      "249": "OpUnknown249",
      OpSmallInteger: 250,
      "250": "OpSmallInteger",
      OpPubKeys: 251,
      "251": "OpPubKeys",
      OpUnknown252: 252,
      "252": "OpUnknown252",
      OpPubKeyHash: 253,
      "253": "OpPubKeyHash",
      OpPubKey: 254,
      "254": "OpPubKey",
      OpInvalidOpCode: 255,
      "255": "OpInvalidOpCode"
    });
    SighashType2 = Object.freeze({
      All: 0,
      "0": "All",
      None: 1,
      "1": "None",
      Single: 2,
      "2": "Single",
      AllAnyOneCanPay: 3,
      "3": "AllAnyOneCanPay",
      NoneAnyOneCanPay: 4,
      "4": "NoneAnyOneCanPay",
      SingleAnyOneCanPay: 5,
      "5": "SingleAnyOneCanPay"
    });
    __wbindgen_enum_BinaryType2 = ["blob", "arraybuffer"];
    __wbindgen_enum_IdbCursorDirection2 = ["next", "nextunique", "prev", "prevunique"];
    __wbindgen_enum_IdbRequestReadyState2 = ["pending", "done"];
    __wbindgen_enum_IdbTransactionMode2 = ["readonly", "readwrite", "versionchange", "readwriteflush", "cleanup"];
    __wbindgen_enum_RequestCredentials2 = ["omit", "same-origin", "include"];
    __wbindgen_enum_RequestMode2 = ["same-origin", "no-cors", "cors", "navigate"];
    AbortableFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_abortable_free(ptr >>> 0, 1));
    Abortable2 = class {
      static {
        __name$8(this, "Abortable");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AbortableFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_abortable_free(ptr, 0);
      }
      constructor() {
        const ret = wasm2.abortable_new();
        this.__wbg_ptr = ret >>> 0;
        AbortableFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean}
       */
      isAborted() {
        const ret = wasm2.abortable_isAborted(this.__wbg_ptr);
        return ret !== 0;
      }
      abort() {
        wasm2.abortable_abort(this.__wbg_ptr);
      }
      check() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.abortable_check(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      reset() {
        wasm2.abortable_reset(this.__wbg_ptr);
      }
    };
    AbortedFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_aborted_free(ptr >>> 0, 1));
    Aborted2 = class _Aborted {
      static {
        __name$8(this, "Aborted");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Aborted.prototype);
        obj.__wbg_ptr = ptr;
        AbortedFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AbortedFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_aborted_free(ptr, 0);
      }
    };
    AccountKindFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_accountkind_free(ptr >>> 0, 1));
    AccountKind2 = class _AccountKind {
      static {
        __name$8(this, "AccountKind");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_AccountKind.prototype);
        obj.__wbg_ptr = ptr;
        AccountKindFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AccountKindFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_accountkind_free(ptr, 0);
      }
      /**
       * @param {string} kind
       */
      constructor(kind) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(kind, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.accountkind_ctor(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          AccountKindFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.accountkind_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    AddressFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_address_free(ptr >>> 0, 1));
    Address2 = class _Address {
      static {
        __name$8(this, "Address");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Address.prototype);
        obj.__wbg_ptr = ptr;
        AddressFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          version: this.version,
          prefix: this.prefix,
          payload: this.payload
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AddressFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_address_free(ptr, 0);
      }
      /**
       * @param {string} address
       */
      constructor(address) {
        const ptr0 = passStringToWasm02(address, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.address_constructor(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        AddressFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {string} address
       * @returns {boolean}
       */
      static validate(address) {
        const ptr0 = passStringToWasm02(address, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.address_validate(ptr0, len0);
        return ret !== 0;
      }
      /**
       * Convert an address to a string.
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.address_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get version() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.address_version(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get prefix() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.address_prefix(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} prefix
       */
      set setPrefix(prefix) {
        const ptr0 = passStringToWasm02(prefix, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.address_set_setPrefix(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string}
       */
      get payload() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.address_payload(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {number} n
       * @returns {string}
       */
      short(n2) {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.address_short(retptr, this.__wbg_ptr, n2);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    AgentConstructorOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_agentconstructoroptions_free(ptr >>> 0, 1));
    AgentConstructorOptions2 = class {
      static {
        __name$8(this, "AgentConstructorOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AgentConstructorOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_agentconstructoroptions_free(ptr, 0);
      }
      /**
       * @returns {number}
       */
      get keep_alive_msecs() {
        const ret = wasm2.agentconstructoroptions_keep_alive_msecs(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set keep_alive_msecs(value2) {
        wasm2.agentconstructoroptions_set_keep_alive_msecs(this.__wbg_ptr, value2);
      }
      /**
       * @returns {boolean}
       */
      get keep_alive() {
        const ret = wasm2.agentconstructoroptions_keep_alive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} value
       */
      set keep_alive(value2) {
        wasm2.agentconstructoroptions_set_keep_alive(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get max_free_sockets() {
        const ret = wasm2.agentconstructoroptions_max_free_sockets(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set max_free_sockets(value2) {
        wasm2.agentconstructoroptions_set_max_free_sockets(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get max_sockets() {
        const ret = wasm2.agentconstructoroptions_max_sockets(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set max_sockets(value2) {
        wasm2.agentconstructoroptions_set_max_sockets(this.__wbg_ptr, value2);
      }
      /**
       * @returns {number}
       */
      get timeout() {
        const ret = wasm2.agentconstructoroptions_timeout(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set timeout(value2) {
        wasm2.agentconstructoroptions_set_timeout(this.__wbg_ptr, value2);
      }
    };
    AppendFileOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_appendfileoptions_free(ptr >>> 0, 1));
    AppendFileOptions2 = class _AppendFileOptions {
      static {
        __name$8(this, "AppendFileOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_AppendFileOptions.prototype);
        obj.__wbg_ptr = ptr;
        AppendFileOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AppendFileOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_appendfileoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       * @param {number | null} [mode]
       * @param {string | null} [flag]
       */
      constructor(encoding, mode, flag) {
        const ret = wasm2.appendfileoptions_new_with_values(isLikeNone2(encoding) ? 0 : addHeapObject2(encoding), isLikeNone2(mode) ? 4294967297 : mode >>> 0, isLikeNone2(flag) ? 0 : addHeapObject2(flag));
        this.__wbg_ptr = ret >>> 0;
        AppendFileOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {AppendFileOptions}
       */
      static new() {
        const ret = wasm2.appendfileoptions_new();
        return _AppendFileOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.appendfileoptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.appendfileoptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm2.appendfileoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm2.appendfileoptions_set_mode(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flag() {
        const ret = wasm2.appendfileoptions_flag(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flag(value2) {
        wasm2.appendfileoptions_set_flag(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
    };
    AssertionErrorOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_assertionerroroptions_free(ptr >>> 0, 1));
    AssertionErrorOptions2 = class {
      static {
        __name$8(this, "AssertionErrorOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AssertionErrorOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_assertionerroroptions_free(ptr, 0);
      }
      /**
       * @param {string | null | undefined} message
       * @param {any} actual
       * @param {any} expected
       * @param {string} operator
       */
      constructor(message2, actual, expected, operator) {
        const ret = wasm2.assertionerroroptions_new(isLikeNone2(message2) ? 0 : addHeapObject2(message2), addHeapObject2(actual), addHeapObject2(expected), addHeapObject2(operator));
        this.__wbg_ptr = ret >>> 0;
        AssertionErrorOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * If provided, the error message is set to this value.
       * @returns {string | undefined}
       */
      get message() {
        const ret = wasm2.assertionerroroptions_message(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set message(value2) {
        wasm2.assertionerroroptions_set_message(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * The actual property on the error instance.
       * @returns {any}
       */
      get actual() {
        const ret = wasm2.assertionerroroptions_actual(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} value
       */
      set actual(value2) {
        wasm2.assertionerroroptions_set_actual(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * The expected property on the error instance.
       * @returns {any}
       */
      get expected() {
        const ret = wasm2.assertionerroroptions_expected(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} value
       */
      set expected(value2) {
        wasm2.assertionerroroptions_set_expected(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * The operator property on the error instance.
       * @returns {string}
       */
      get operator() {
        const ret = wasm2.assertionerroroptions_operator(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string} value
       */
      set operator(value2) {
        wasm2.assertionerroroptions_set_operator(this.__wbg_ptr, addHeapObject2(value2));
      }
    };
    BalanceFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_balance_free(ptr >>> 0, 1));
    Balance2 = class _Balance {
      static {
        __name$8(this, "Balance");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Balance.prototype);
        obj.__wbg_ptr = ptr;
        BalanceFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BalanceFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_balance_free(ptr, 0);
      }
      /**
       * Confirmed amount of funds available for spending.
       * @returns {bigint}
       */
      get mature() {
        const ret = wasm2.balance_mature(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Amount of funds that are being received and are not yet confirmed.
       * @returns {bigint}
       */
      get pending() {
        const ret = wasm2.balance_pending(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Amount of funds that are being send and are not yet accepted by the network.
       * @returns {bigint}
       */
      get outgoing() {
        const ret = wasm2.balance_outgoing(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {NetworkType | NetworkId | string} network_type
       * @returns {BalanceStrings}
       */
      toBalanceStrings(network_type) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.balance_toBalanceStrings(retptr, this.__wbg_ptr, addBorrowedObject2(network_type));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return BalanceStrings2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    BalanceStringsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_balancestrings_free(ptr >>> 0, 1));
    BalanceStrings2 = class _BalanceStrings {
      static {
        __name$8(this, "BalanceStrings");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_BalanceStrings.prototype);
        obj.__wbg_ptr = ptr;
        BalanceStringsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BalanceStringsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_balancestrings_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get mature() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.balancestrings_mature(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string | undefined}
       */
      get pending() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.balancestrings_pending(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ConsoleConstructorOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_consoleconstructoroptions_free(ptr >>> 0, 1));
    ConsoleConstructorOptions2 = class _ConsoleConstructorOptions {
      static {
        __name$8(this, "ConsoleConstructorOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ConsoleConstructorOptions.prototype);
        obj.__wbg_ptr = ptr;
        ConsoleConstructorOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ConsoleConstructorOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_consoleconstructoroptions_free(ptr, 0);
      }
      /**
       * @param {any} stdout
       * @param {any} stderr
       * @param {boolean | null | undefined} ignore_errors
       * @param {any} color_mod
       * @param {object | null} [inspect_options]
       */
      constructor(stdout, stderr, ignore_errors, color_mod, inspect_options) {
        const ret = wasm2.consoleconstructoroptions_new_with_values(addHeapObject2(stdout), addHeapObject2(stderr), isLikeNone2(ignore_errors) ? 16777215 : ignore_errors ? 1 : 0, addHeapObject2(color_mod), isLikeNone2(inspect_options) ? 0 : addHeapObject2(inspect_options));
        this.__wbg_ptr = ret >>> 0;
        ConsoleConstructorOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {any} stdout
       * @param {any} stderr
       * @returns {ConsoleConstructorOptions}
       */
      static new(stdout, stderr) {
        const ret = wasm2.consoleconstructoroptions_new(addHeapObject2(stdout), addHeapObject2(stderr));
        return _ConsoleConstructorOptions.__wrap(ret);
      }
      /**
       * @returns {any}
       */
      get stdout() {
        const ret = wasm2.consoleconstructoroptions_stdout(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} value
       */
      set stdout(value2) {
        wasm2.consoleconstructoroptions_set_stdout(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {any}
       */
      get stderr() {
        const ret = wasm2.consoleconstructoroptions_stderr(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} value
       */
      set stderr(value2) {
        wasm2.consoleconstructoroptions_set_stderr(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {boolean | undefined}
       */
      get ignore_errors() {
        const ret = wasm2.consoleconstructoroptions_ignore_errors(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set ignore_errors(value2) {
        wasm2.consoleconstructoroptions_set_ignore_errors(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {any}
       */
      get color_mod() {
        const ret = wasm2.consoleconstructoroptions_color_mod(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} value
       */
      set color_mod(value2) {
        wasm2.consoleconstructoroptions_set_color_mod(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {object | undefined}
       */
      get inspect_options() {
        const ret = wasm2.consoleconstructoroptions_inspect_options(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {object | null} [value]
       */
      set inspect_options(value2) {
        wasm2.consoleconstructoroptions_set_inspect_options(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
    };
    CreateHookCallbacksFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_createhookcallbacks_free(ptr >>> 0, 1));
    CreateHookCallbacks2 = class {
      static {
        __name$8(this, "CreateHookCallbacks");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateHookCallbacksFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_createhookcallbacks_free(ptr, 0);
      }
      /**
       * @param {Function} init
       * @param {Function} before
       * @param {Function} after
       * @param {Function} destroy
       * @param {Function} promise_resolve
       */
      constructor(init3, before, after, destroy, promise_resolve) {
        try {
          const ret = wasm2.createhookcallbacks_new(addBorrowedObject2(init3), addBorrowedObject2(before), addBorrowedObject2(after), addBorrowedObject2(destroy), addBorrowedObject2(promise_resolve));
          this.__wbg_ptr = ret >>> 0;
          CreateHookCallbacksFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {Function}
       */
      get init() {
        const ret = wasm2.createhookcallbacks_init(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set init(value2) {
        wasm2.createhookcallbacks_set_init(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {Function}
       */
      get before() {
        const ret = wasm2.createhookcallbacks_before(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set before(value2) {
        wasm2.createhookcallbacks_set_before(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {Function}
       */
      get after() {
        const ret = wasm2.createhookcallbacks_after(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set after(value2) {
        wasm2.createhookcallbacks_set_after(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {Function}
       */
      get destroy() {
        const ret = wasm2.createhookcallbacks_destroy(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set destroy(value2) {
        wasm2.createhookcallbacks_set_destroy(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {Function}
       */
      get promise_resolve() {
        const ret = wasm2.createhookcallbacks_promise_resolve(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set promise_resolve(value2) {
        wasm2.createhookcallbacks_set_promise_resolve(this.__wbg_ptr, addHeapObject2(value2));
      }
    };
    CreateReadStreamOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_createreadstreamoptions_free(ptr >>> 0, 1));
    CreateReadStreamOptions2 = class {
      static {
        __name$8(this, "CreateReadStreamOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateReadStreamOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_createreadstreamoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [auto_close]
       * @param {boolean | null} [emit_close]
       * @param {string | null} [encoding]
       * @param {number | null} [end]
       * @param {number | null} [fd]
       * @param {string | null} [flags]
       * @param {number | null} [high_water_mark]
       * @param {number | null} [mode]
       * @param {number | null} [start]
       */
      constructor(auto_close, emit_close, encoding, end, fd, flags, high_water_mark, mode, start2) {
        const ret = wasm2.createreadstreamoptions_new_with_values(isLikeNone2(auto_close) ? 16777215 : auto_close ? 1 : 0, isLikeNone2(emit_close) ? 16777215 : emit_close ? 1 : 0, isLikeNone2(encoding) ? 0 : addHeapObject2(encoding), !isLikeNone2(end), isLikeNone2(end) ? 0 : end, isLikeNone2(fd) ? 4294967297 : fd >>> 0, isLikeNone2(flags) ? 0 : addHeapObject2(flags), !isLikeNone2(high_water_mark), isLikeNone2(high_water_mark) ? 0 : high_water_mark, isLikeNone2(mode) ? 4294967297 : mode >>> 0, !isLikeNone2(start2), isLikeNone2(start2) ? 0 : start2);
        this.__wbg_ptr = ret >>> 0;
        CreateReadStreamOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get auto_close() {
        const ret = wasm2.createreadstreamoptions_auto_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set auto_close(value2) {
        wasm2.createreadstreamoptions_set_auto_close(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get emit_close() {
        const ret = wasm2.createreadstreamoptions_emit_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set emit_close(value2) {
        wasm2.createreadstreamoptions_set_emit_close(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.createreadstreamoptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.createreadstreamoptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get end() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.createreadstreamoptions_end(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory02().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set end(value2) {
        wasm2.createreadstreamoptions_set_end(this.__wbg_ptr, !isLikeNone2(value2), isLikeNone2(value2) ? 0 : value2);
      }
      /**
       * @returns {number | undefined}
       */
      get fd() {
        const ret = wasm2.createreadstreamoptions_fd(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set fd(value2) {
        wasm2.createreadstreamoptions_set_fd(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flags() {
        const ret = wasm2.createreadstreamoptions_flags(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flags(value2) {
        wasm2.createreadstreamoptions_set_flags(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get high_water_mark() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.createreadstreamoptions_high_water_mark(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory02().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set high_water_mark(value2) {
        wasm2.createreadstreamoptions_set_high_water_mark(this.__wbg_ptr, !isLikeNone2(value2), isLikeNone2(value2) ? 0 : value2);
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm2.createreadstreamoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm2.createreadstreamoptions_set_mode(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {number | undefined}
       */
      get start() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.createreadstreamoptions_start(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory02().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set start(value2) {
        wasm2.createreadstreamoptions_set_start(this.__wbg_ptr, !isLikeNone2(value2), isLikeNone2(value2) ? 0 : value2);
      }
    };
    CreateWriteStreamOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_createwritestreamoptions_free(ptr >>> 0, 1));
    CreateWriteStreamOptions2 = class {
      static {
        __name$8(this, "CreateWriteStreamOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CreateWriteStreamOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_createwritestreamoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [auto_close]
       * @param {boolean | null} [emit_close]
       * @param {string | null} [encoding]
       * @param {number | null} [fd]
       * @param {string | null} [flags]
       * @param {number | null} [mode]
       * @param {number | null} [start]
       */
      constructor(auto_close, emit_close, encoding, fd, flags, mode, start2) {
        const ret = wasm2.createwritestreamoptions_new_with_values(isLikeNone2(auto_close) ? 16777215 : auto_close ? 1 : 0, isLikeNone2(emit_close) ? 16777215 : emit_close ? 1 : 0, isLikeNone2(encoding) ? 0 : addHeapObject2(encoding), isLikeNone2(fd) ? 4294967297 : fd >>> 0, isLikeNone2(flags) ? 0 : addHeapObject2(flags), isLikeNone2(mode) ? 4294967297 : mode >>> 0, !isLikeNone2(start2), isLikeNone2(start2) ? 0 : start2);
        this.__wbg_ptr = ret >>> 0;
        CreateWriteStreamOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get auto_close() {
        const ret = wasm2.createwritestreamoptions_auto_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set auto_close(value2) {
        wasm2.createwritestreamoptions_set_auto_close(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get emit_close() {
        const ret = wasm2.createwritestreamoptions_emit_close(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set emit_close(value2) {
        wasm2.createwritestreamoptions_set_emit_close(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.createwritestreamoptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.createwritestreamoptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get fd() {
        const ret = wasm2.createwritestreamoptions_fd(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set fd(value2) {
        wasm2.createwritestreamoptions_set_fd(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {string | undefined}
       */
      get flags() {
        const ret = wasm2.createwritestreamoptions_flags(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flags(value2) {
        wasm2.createwritestreamoptions_set_flags(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm2.createwritestreamoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm2.createwritestreamoptions_set_mode(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
      /**
       * @returns {number | undefined}
       */
      get start() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.createwritestreamoptions_start(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory02().getFloat64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : r2;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number | null} [value]
       */
      set start(value2) {
        wasm2.createwritestreamoptions_set_start(this.__wbg_ptr, !isLikeNone2(value2), isLikeNone2(value2) ? 0 : value2);
      }
    };
    CryptoBoxFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_cryptobox_free(ptr >>> 0, 1));
    CryptoBox2 = class {
      static {
        __name$8(this, "CryptoBox");
      }
      toJSON() {
        return {
          publicKey: this.publicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_cryptobox_free(ptr, 0);
      }
      /**
       * @param {CryptoBoxPrivateKey | HexString | Uint8Array} secretKey
       * @param {CryptoBoxPublicKey | HexString | Uint8Array} peerPublicKey
       */
      constructor(secretKey, peerPublicKey) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.cryptobox_ctor(retptr, addBorrowedObject2(secretKey), addBorrowedObject2(peerPublicKey));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {string}
       */
      get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.cryptobox_publicKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} plaintext
       * @returns {string}
       */
      encrypt(plaintext) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(plaintext, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.cryptobox_encrypt(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject2(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm02(ptr2, len2);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @param {string} base64string
       * @returns {string}
       */
      decrypt(base64string) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(base64string, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.cryptobox_decrypt(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject2(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm02(ptr2, len2);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
    };
    CryptoBoxPrivateKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_cryptoboxprivatekey_free(ptr >>> 0, 1));
    CryptoBoxPrivateKey2 = class {
      static {
        __name$8(this, "CryptoBoxPrivateKey");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxPrivateKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_cryptoboxprivatekey_free(ptr, 0);
      }
      /**
       * @param {HexString | Uint8Array} secretKey
       */
      constructor(secretKey) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.cryptoboxprivatekey_ctor(retptr, addHeapObject2(secretKey));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxPrivateKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {CryptoBoxPublicKey}
       */
      to_public_key() {
        const ret = wasm2.cryptoboxprivatekey_to_public_key(this.__wbg_ptr);
        return CryptoBoxPublicKey2.__wrap(ret);
      }
    };
    CryptoBoxPublicKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_cryptoboxpublickey_free(ptr >>> 0, 1));
    CryptoBoxPublicKey2 = class _CryptoBoxPublicKey {
      static {
        __name$8(this, "CryptoBoxPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_CryptoBoxPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        CryptoBoxPublicKeyFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CryptoBoxPublicKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_cryptoboxpublickey_free(ptr, 0);
      }
      /**
       * @param {HexString | Uint8Array} publicKey
       */
      constructor(publicKey) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.cryptoboxpublickey_ctor(retptr, addHeapObject2(publicKey));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          CryptoBoxPublicKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.cryptoboxpublickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    DerivationPathFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_derivationpath_free(ptr >>> 0, 1));
    DerivationPath2 = class _DerivationPath {
      static {
        __name$8(this, "DerivationPath");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_DerivationPath.prototype);
        obj.__wbg_ptr = ptr;
        DerivationPathFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DerivationPathFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_derivationpath_free(ptr, 0);
      }
      /**
       * @param {string} path
       */
      constructor(path) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(path, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.derivationpath_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          DerivationPathFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Is this derivation path empty? (i.e. the root)
       * @returns {boolean}
       */
      isEmpty() {
        const ret = wasm2.derivationpath_isEmpty(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Get the count of [`ChildNumber`] values in this derivation path.
       * @returns {number}
       */
      length() {
        const ret = wasm2.derivationpath_length(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * Get the parent [`DerivationPath`] for the current one.
       *
       * Returns `Undefined` if this is already the root path.
       * @returns {DerivationPath | undefined}
       */
      parent() {
        const ret = wasm2.derivationpath_parent(this.__wbg_ptr);
        return ret === 0 ? void 0 : _DerivationPath.__wrap(ret);
      }
      /**
       * Push a [`ChildNumber`] onto an existing derivation path.
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       */
      push(child_number, hardened) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.derivationpath_push(retptr, this.__wbg_ptr, child_number, isLikeNone2(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.derivationpath_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    FormatInputPathObjectFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_formatinputpathobject_free(ptr >>> 0, 1));
    FormatInputPathObject2 = class _FormatInputPathObject {
      static {
        __name$8(this, "FormatInputPathObject");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_FormatInputPathObject.prototype);
        obj.__wbg_ptr = ptr;
        FormatInputPathObjectFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FormatInputPathObjectFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_formatinputpathobject_free(ptr, 0);
      }
      /**
       * @param {string | null} [base]
       * @param {string | null} [dir]
       * @param {string | null} [ext]
       * @param {string | null} [name]
       * @param {string | null} [root]
       */
      constructor(base3, dir, ext, name2, root) {
        const ret = wasm2.formatinputpathobject_new_with_values(isLikeNone2(base3) ? 0 : addHeapObject2(base3), isLikeNone2(dir) ? 0 : addHeapObject2(dir), isLikeNone2(ext) ? 0 : addHeapObject2(ext), isLikeNone2(name2) ? 0 : addHeapObject2(name2), isLikeNone2(root) ? 0 : addHeapObject2(root));
        this.__wbg_ptr = ret >>> 0;
        FormatInputPathObjectFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {FormatInputPathObject}
       */
      static new() {
        const ret = wasm2.formatinputpathobject_new();
        return _FormatInputPathObject.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get base() {
        const ret = wasm2.formatinputpathobject_base(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set base(value2) {
        wasm2.formatinputpathobject_set_base(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get dir() {
        const ret = wasm2.formatinputpathobject_dir(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set dir(value2) {
        wasm2.formatinputpathobject_set_dir(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get ext() {
        const ret = wasm2.formatinputpathobject_ext(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set ext(value2) {
        wasm2.formatinputpathobject_set_ext(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get name() {
        const ret = wasm2.formatinputpathobject_name(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set name(value2) {
        wasm2.formatinputpathobject_set_name(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get root() {
        const ret = wasm2.formatinputpathobject_root(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set root(value2) {
        wasm2.formatinputpathobject_set_root(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
    };
    GeneratorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_generator_free(ptr >>> 0, 1));
    Generator2 = class {
      static {
        __name$8(this, "Generator");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GeneratorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_generator_free(ptr, 0);
      }
      /**
       * @param {IGeneratorSettingsObject} args
       */
      constructor(args) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.generator_ctor(retptr, addHeapObject2(args));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          GeneratorFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate next transaction
       * @returns {Promise<any>}
       */
      next() {
        const ret = wasm2.generator_next(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<GeneratorSummary>}
       */
      estimate() {
        const ret = wasm2.generator_estimate(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {GeneratorSummary}
       */
      summary() {
        const ret = wasm2.generator_summary(this.__wbg_ptr);
        return GeneratorSummary2.__wrap(ret);
      }
    };
    GeneratorSummaryFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_generatorsummary_free(ptr >>> 0, 1));
    GeneratorSummary2 = class _GeneratorSummary {
      static {
        __name$8(this, "GeneratorSummary");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_GeneratorSummary.prototype);
        obj.__wbg_ptr = ptr;
        GeneratorSummaryFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          networkType: this.networkType,
          utxos: this.utxos,
          fees: this.fees,
          mass: this.mass,
          transactions: this.transactions,
          finalAmount: this.finalAmount,
          finalTransactionId: this.finalTransactionId
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GeneratorSummaryFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_generatorsummary_free(ptr, 0);
      }
      /**
       * @returns {NetworkType}
       */
      get networkType() {
        const ret = wasm2.generatorsummary_networkType(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {number}
       */
      get utxos() {
        const ret = wasm2.generatorsummary_utxos(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {bigint}
       */
      get fees() {
        const ret = wasm2.generatorsummary_fees(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm2.generatorsummary_mass(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {number}
       */
      get transactions() {
        const ret = wasm2.generatorsummary_transactions(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {bigint | undefined}
       */
      get finalAmount() {
        const ret = wasm2.generatorsummary_finalAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get finalTransactionId() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.generatorsummary_finalTransactionId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    GetNameOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_getnameoptions_free(ptr >>> 0, 1));
    GetNameOptions2 = class _GetNameOptions {
      static {
        __name$8(this, "GetNameOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_GetNameOptions.prototype);
        obj.__wbg_ptr = ptr;
        GetNameOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetNameOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_getnameoptions_free(ptr, 0);
      }
      /**
       * @param {number | null | undefined} family
       * @param {string} host
       * @param {string} local_address
       * @param {number} port
       * @returns {GetNameOptions}
       */
      static new(family, host, local_address, port) {
        const ret = wasm2.getnameoptions_new(isLikeNone2(family) ? 16777215 : family, addHeapObject2(host), addHeapObject2(local_address), port);
        return _GetNameOptions.__wrap(ret);
      }
      /**
       * @returns {number | undefined}
       */
      get family() {
        const ret = wasm2.getnameoptions_family(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set family(value2) {
        wasm2.getnameoptions_set_family(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2);
      }
      /**
       * @returns {string}
       */
      get host() {
        const ret = wasm2.getnameoptions_host(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string} value
       */
      set host(value2) {
        wasm2.getnameoptions_set_host(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {string}
       */
      get local_address() {
        const ret = wasm2.getnameoptions_local_address(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string} value
       */
      set local_address(value2) {
        wasm2.getnameoptions_set_local_address(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {number}
       */
      get port() {
        const ret = wasm2.getnameoptions_port(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} value
       */
      set port(value2) {
        wasm2.getnameoptions_set_port(this.__wbg_ptr, value2);
      }
    };
    HashFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_hash_free(ptr >>> 0, 1));
    Hash2 = class _Hash {
      static {
        __name$8(this, "Hash");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Hash.prototype);
        obj.__wbg_ptr = ptr;
        HashFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HashFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_hash_free(ptr, 0);
      }
      /**
       * @param {string} hex_str
       */
      constructor(hex_str) {
        const ptr0 = passStringToWasm02(hex_str, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.hash_constructor(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        HashFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.hash_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    HeaderFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_header_free(ptr >>> 0, 1));
    Header2 = class {
      static {
        __name$8(this, "Header");
      }
      toJSON() {
        return {
          version: this.version,
          timestamp: this.timestamp,
          bits: this.bits,
          nonce: this.nonce,
          daaScore: this.daaScore,
          blueScore: this.blueScore,
          hash: this.hash,
          hashMerkleRoot: this.hashMerkleRoot,
          acceptedIdMerkleRoot: this.acceptedIdMerkleRoot,
          utxoCommitment: this.utxoCommitment,
          pruningPoint: this.pruningPoint,
          parentsByLevel: this.parentsByLevel,
          blueWork: this.blueWork
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HeaderFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_header_free(ptr, 0);
      }
      /**
       * @param {Header | IHeader | IRawHeader} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_constructor(retptr, addHeapObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          HeaderFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Finalizes the header and recomputes (updates) the header hash
       * @return { String } header hash
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Obtain `JSON` representation of the header. JSON representation
       * should be obtained using WASM, to ensure proper serialization of
       * big integers.
       * @returns {string}
       */
      asJSON() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_asJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm2.header_get_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} version
       */
      set version(version3) {
        wasm2.header_set_version(this.__wbg_ptr, version3);
      }
      /**
       * @returns {bigint}
       */
      get timestamp() {
        const ret = wasm2.header_get_timestamp(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} timestamp
       */
      set timestamp(timestamp) {
        wasm2.header_set_timestamp(this.__wbg_ptr, timestamp);
      }
      /**
       * @returns {number}
       */
      get bits() {
        const ret = wasm2.header_bits(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} bits
       */
      set bits(bits) {
        wasm2.header_set_bits(this.__wbg_ptr, bits);
      }
      /**
       * @returns {bigint}
       */
      get nonce() {
        const ret = wasm2.header_nonce(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} nonce
       */
      set nonce(nonce) {
        wasm2.header_set_nonce(this.__wbg_ptr, nonce);
      }
      /**
       * @returns {bigint}
       */
      get daaScore() {
        const ret = wasm2.header_daa_score(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} daa_score
       */
      set daaScore(daa_score) {
        wasm2.header_set_daa_score(this.__wbg_ptr, daa_score);
      }
      /**
       * @returns {bigint}
       */
      get blueScore() {
        const ret = wasm2.header_blue_score(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} blue_score
       */
      set blueScore(blue_score) {
        wasm2.header_set_blue_score(this.__wbg_ptr, blue_score);
      }
      /**
       * @returns {string}
       */
      get hash() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_get_hash_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get hashMerkleRoot() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_get_hash_merkle_root_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set hashMerkleRoot(js_value) {
        wasm2.header_set_hash_merkle_root_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {string}
       */
      get acceptedIdMerkleRoot() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_get_accepted_id_merkle_root_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set acceptedIdMerkleRoot(js_value) {
        wasm2.header_set_accepted_id_merkle_root_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {string}
       */
      get utxoCommitment() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_get_utxo_commitment_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set utxoCommitment(js_value) {
        wasm2.header_set_utxo_commitment_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {string}
       */
      get pruningPoint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_get_pruning_point_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set pruningPoint(js_value) {
        wasm2.header_set_pruning_point_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {any}
       */
      get parentsByLevel() {
        const ret = wasm2.header_get_parents_by_level_as_js_value(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} js_value
       */
      set parentsByLevel(js_value) {
        wasm2.header_set_parents_by_level_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {bigint}
       */
      get blueWork() {
        const ret = wasm2.header_blue_work(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {string}
       */
      getBlueWorkAsHex() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.header_getBlueWorkAsHex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set blueWork(js_value) {
        wasm2.header_set_blue_work_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
    };
    KeypairFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_keypair_free(ptr >>> 0, 1));
    Keypair2 = class _Keypair {
      static {
        __name$8(this, "Keypair");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Keypair.prototype);
        obj.__wbg_ptr = ptr;
        KeypairFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          publicKey: this.publicKey,
          privateKey: this.privateKey,
          xOnlyPublicKey: this.xOnlyPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeypairFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_keypair_free(ptr, 0);
      }
      /**
       * Get the [`PublicKey`] of this [`Keypair`].
       * @returns {string}
       */
      get publicKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.keypair_get_public_key(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`PrivateKey`] of this [`Keypair`].
       * @returns {string}
       */
      get privateKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.keypair_get_private_key(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the `XOnlyPublicKey` of this [`Keypair`].
       * @returns {any}
       */
      get xOnlyPublicKey() {
        const ret = wasm2.keypair_get_xonly_public_key(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Get the [`Address`] of this Keypair's [`PublicKey`].
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.keypair_toAddress(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this Keypair's [`PublicKey`].
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.keypair_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Create a new random [`Keypair`].
       * JavaScript: `let keypair = Keypair::random();`.
       * @returns {Keypair}
       */
      static random() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.keypair_random(retptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Keypair.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Create a new [`Keypair`] from a [`PrivateKey`].
       * JavaScript: `let privkey = new PrivateKey(hexString); let keypair = privkey.toKeypair();`.
       * @param {PrivateKey} secret_key
       * @returns {Keypair}
       */
      static fromPrivateKey(secret_key) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(secret_key, PrivateKey2);
          wasm2.keypair_fromPrivateKey(retptr, secret_key.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Keypair.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    MkdtempSyncOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_mkdtempsyncoptions_free(ptr >>> 0, 1));
    MkdtempSyncOptions2 = class _MkdtempSyncOptions {
      static {
        __name$8(this, "MkdtempSyncOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_MkdtempSyncOptions.prototype);
        obj.__wbg_ptr = ptr;
        MkdtempSyncOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MkdtempSyncOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_mkdtempsyncoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       */
      constructor(encoding) {
        const ret = wasm2.mkdtempsyncoptions_new_with_values(isLikeNone2(encoding) ? 0 : addHeapObject2(encoding));
        this.__wbg_ptr = ret >>> 0;
        MkdtempSyncOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {MkdtempSyncOptions}
       */
      static new() {
        const ret = wasm2.mkdtempsyncoptions_new();
        return _MkdtempSyncOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.mkdtempsyncoptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.mkdtempsyncoptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
    };
    MnemonicFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_mnemonic_free(ptr >>> 0, 1));
    Mnemonic2 = class _Mnemonic {
      static {
        __name$8(this, "Mnemonic");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Mnemonic.prototype);
        obj.__wbg_ptr = ptr;
        MnemonicFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          entropy: this.entropy,
          phrase: this.phrase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MnemonicFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_mnemonic_free(ptr, 0);
      }
      /**
       * @param {string} phrase
       * @param {Language | null} [language]
       */
      constructor(phrase, language) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(phrase, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.mnemonic_constructor(retptr, ptr0, len0, isLikeNone2(language) ? 1 : language);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          MnemonicFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Validate mnemonic phrase. Returns `true` if the phrase is valid, `false` otherwise.
       * @param {string} phrase
       * @param {Language | null} [language]
       * @returns {boolean}
       */
      static validate(phrase, language) {
        const ptr0 = passStringToWasm02(phrase, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.mnemonic_validate(ptr0, len0, isLikeNone2(language) ? 1 : language);
        return ret !== 0;
      }
      /**
       * @returns {string}
       */
      get entropy() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.mnemonic_entropy(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} entropy
       */
      set entropy(entropy) {
        const ptr0 = passStringToWasm02(entropy, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.mnemonic_set_entropy(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {number | null} [word_count]
       * @returns {Mnemonic}
       */
      static random(word_count) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.mnemonic_random(retptr, isLikeNone2(word_count) ? 4294967297 : word_count >>> 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Mnemonic.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get phrase() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.mnemonic_phrase(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} phrase
       */
      set phrase(phrase) {
        const ptr0 = passStringToWasm02(phrase, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.mnemonic_set_phrase(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {string | null} [password]
       * @returns {string}
       */
      toSeed(password) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          var ptr0 = isLikeNone2(password) ? 0 : passStringToWasm02(password, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          var len0 = WASM_VECTOR_LEN2;
          wasm2.mnemonic_toSeed(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred2_0 = r0;
          deferred2_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    NetServerOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_netserveroptions_free(ptr >>> 0, 1));
    NetServerOptions2 = class {
      static {
        __name$8(this, "NetServerOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetServerOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_netserveroptions_free(ptr, 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get allow_half_open() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm2.netserveroptions_allow_half_open(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set allow_half_open(value2) {
        const ptr = this.__destroy_into_raw();
        wasm2.netserveroptions_set_allow_half_open(ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
      /**
       * @returns {boolean | undefined}
       */
      get pause_on_connect() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm2.netserveroptions_pause_on_connect(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set pause_on_connect(value2) {
        const ptr = this.__destroy_into_raw();
        wasm2.netserveroptions_set_allow_half_open(ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    NetworkIdFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_networkid_free(ptr >>> 0, 1));
    NetworkId2 = class _NetworkId {
      static {
        __name$8(this, "NetworkId");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_NetworkId.prototype);
        obj.__wbg_ptr = ptr;
        NetworkIdFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          type: this.type,
          suffix: this.suffix,
          id: this.id
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetworkIdFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_networkid_free(ptr, 0);
      }
      /**
       * @returns {NetworkType}
       */
      get type() {
        const ret = wasm2.__wbg_get_networkid_type(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {NetworkType} arg0
       */
      set type(arg0) {
        wasm2.__wbg_set_networkid_type(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {number | undefined}
       */
      get suffix() {
        const ret = wasm2.__wbg_get_networkid_suffix(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [arg0]
       */
      set suffix(arg0) {
        wasm2.__wbg_set_networkid_suffix(this.__wbg_ptr, isLikeNone2(arg0) ? 4294967297 : arg0 >>> 0);
      }
      /**
       * @param {any} value
       */
      constructor(value2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.networkid_ctor(retptr, addBorrowedObject2(value2));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          NetworkIdFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.networkid_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.networkid_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      addressPrefix() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.networkid_addressPrefix(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    NodeDescriptorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_nodedescriptor_free(ptr >>> 0, 1));
    NodeDescriptor2 = class _NodeDescriptor {
      static {
        __name$8(this, "NodeDescriptor");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_NodeDescriptor.prototype);
        obj.__wbg_ptr = ptr;
        NodeDescriptorFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          uid: this.uid,
          url: this.url
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NodeDescriptorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_nodedescriptor_free(ptr, 0);
      }
      /**
       * The unique identifier of the node.
       * @returns {string}
       */
      get uid() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_nodedescriptor_uid(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * The unique identifier of the node.
       * @param {string} arg0
       */
      set uid(arg0) {
        const ptr0 = passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_nodedescriptor_uid(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * The URL of the node WebSocket (wRPC URL).
       * @returns {string}
       */
      get url() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_nodedescriptor_url(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * The URL of the node WebSocket (wRPC URL).
       * @param {string} arg0
       */
      set url(arg0) {
        const ptr0 = passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_nodedescriptor_url(this.__wbg_ptr, ptr0, len0);
      }
    };
    PSKBFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_pskb_free(ptr >>> 0, 1));
    PSKB2 = class _PSKB {
      static {
        __name$8(this, "PSKB");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PSKB.prototype);
        obj.__wbg_ptr = ptr;
        PSKBFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSKBFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pskb_free(ptr, 0);
      }
      constructor() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskb_new(retptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PSKBFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      serialize() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskb_serialize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       * @returns {string}
       */
      displayFormat(network_id) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskb_displayFormat(retptr, this.__wbg_ptr, addBorrowedObject2(network_id));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @param {string} hex_data
       * @returns {PSKB}
       */
      static deserialize(hex_data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(hex_data, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.pskb_deserialize(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKB.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {number}
       */
      get length() {
        const ret = wasm2.pskb_length(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @param {PSKT} pskt
       */
      add(pskt) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(pskt, PSKT2);
          wasm2.pskb_add(retptr, this.__wbg_ptr, pskt.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {PSKB} other
       */
      merge(other) {
        _assertClass2(other, _PSKB);
        wasm2.pskb_merge(this.__wbg_ptr, other.__wbg_ptr);
      }
    };
    PSKTFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_pskt_free(ptr >>> 0, 1));
    PSKT2 = class _PSKT {
      static {
        __name$8(this, "PSKT");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PSKT.prototype);
        obj.__wbg_ptr = ptr;
        PSKTFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          role: this.role,
          payload: this.payload
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PSKTFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pskt_free(ptr, 0);
      }
      /**
       * @param {PSKT | Transaction | string | undefined} payload
       */
      constructor(payload) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_new(retptr, addHeapObject2(payload));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PSKTFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get role() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_role(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {any}
       */
      get payload() {
        const ret = wasm2.pskt_payload(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {string}
       */
      serialize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_serialize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Change role to `CREATOR`
       * #[wasm_bindgen(js_name = toCreator)]
       * @returns {PSKT}
       */
      creator() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_creator(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `CONSTRUCTOR`
       * @returns {PSKT}
       */
      toConstructor() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toConstructor(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `UPDATER`
       * @returns {PSKT}
       */
      toUpdater() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toUpdater(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `SIGNER`
       * @returns {PSKT}
       */
      toSigner() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toSigner(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `COMBINER`
       * @returns {PSKT}
       */
      toCombiner() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toCombiner(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `FINALIZER`
       * @returns {PSKT}
       */
      toFinalizer() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toFinalizer(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Change role to `EXTRACTOR`
       * @returns {PSKT}
       */
      toExtractor() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_toExtractor(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} lock_time
       * @returns {PSKT}
       */
      fallbackLockTime(lock_time) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_fallbackLockTime(retptr, this.__wbg_ptr, lock_time);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      inputsModifiable() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_inputsModifiable(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      outputsModifiable() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_outputsModifiable(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      noMoreInputs() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_noMoreInputs(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PSKT}
       */
      noMoreOutputs() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_noMoreOutputs(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {ITransactionInput | TransactionInput} input
       * @param {any} data
       * @returns {PSKT}
       */
      inputAndRedeemScript(input, data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_inputAndRedeemScript(retptr, this.__wbg_ptr, addBorrowedObject2(input), addBorrowedObject2(data));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {ITransactionInput | TransactionInput} input
       * @returns {PSKT}
       */
      input(input) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_input(retptr, this.__wbg_ptr, addBorrowedObject2(input));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {ITransactionOutput | TransactionOutput} output
       * @returns {PSKT}
       */
      output(output) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_output(retptr, this.__wbg_ptr, addBorrowedObject2(output));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {bigint} n
       * @param {number} input_index
       * @returns {PSKT}
       */
      setSequence(n2, input_index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_setSequence(retptr, this.__wbg_ptr, n2, input_index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PSKT.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {Hash}
       */
      calculateId() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_calculateId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Hash2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} data
       * @returns {bigint}
       */
      calculateMass(data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pskt_calculateMass(retptr, this.__wbg_ptr, addBorrowedObject2(data));
          var r0 = getDataViewMemory02().getBigInt64(retptr + 8 * 0, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          if (r3) {
            throw takeObject2(r2);
          }
          return BigInt.asUintN(64, r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    PaymentOutputFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_paymentoutput_free(ptr >>> 0, 1));
    PaymentOutput2 = class {
      static {
        __name$8(this, "PaymentOutput");
      }
      toJSON() {
        return {
          address: this.address,
          amount: this.amount
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PaymentOutputFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_paymentoutput_free(ptr, 0);
      }
      /**
       * @returns {Address}
       */
      get address() {
        const ret = wasm2.__wbg_get_paymentoutput_address(this.__wbg_ptr);
        return Address2.__wrap(ret);
      }
      /**
       * @param {Address} arg0
       */
      set address(arg0) {
        _assertClass2(arg0, Address2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_paymentoutput_address(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm2.__wbg_get_paymentoutput_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm2.__wbg_set_paymentoutput_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @param {Address} address
       * @param {bigint} amount
       */
      constructor(address, amount) {
        _assertClass2(address, Address2);
        var ptr0 = address.__destroy_into_raw();
        const ret = wasm2.paymentoutput_new(ptr0, amount);
        this.__wbg_ptr = ret >>> 0;
        PaymentOutputFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
    };
    PaymentOutputsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_paymentoutputs_free(ptr >>> 0, 1));
    PaymentOutputs2 = class {
      static {
        __name$8(this, "PaymentOutputs");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PaymentOutputsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_paymentoutputs_free(ptr, 0);
      }
      /**
       * @param {IPaymentOutput[]} output_array
       */
      constructor(output_array) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.paymentoutputs_constructor(retptr, addHeapObject2(output_array));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PaymentOutputsFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PendingTransactionFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_pendingtransaction_free(ptr >>> 0, 1));
    PendingTransaction2 = class _PendingTransaction {
      static {
        __name$8(this, "PendingTransaction");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PendingTransaction.prototype);
        obj.__wbg_ptr = ptr;
        PendingTransactionFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          paymentAmount: this.paymentAmount,
          changeAmount: this.changeAmount,
          feeAmount: this.feeAmount,
          mass: this.mass,
          minimumSignatures: this.minimumSignatures,
          aggregateInputAmount: this.aggregateInputAmount,
          aggregateOutputAmount: this.aggregateOutputAmount,
          type: this.type,
          transaction: this.transaction
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PendingTransactionFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pendingtransaction_free(ptr, 0);
      }
      /**
       * Transaction Id
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Total amount transferred to the destination (aggregate output - change).
       * @returns {any}
       */
      get paymentAmount() {
        const ret = wasm2.pendingtransaction_paymentAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Change amount (if any).
       * @returns {bigint}
       */
      get changeAmount() {
        const ret = wasm2.pendingtransaction_changeAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Total transaction fees (network fees + priority fees).
       * @returns {bigint}
       */
      get feeAmount() {
        const ret = wasm2.pendingtransaction_feeAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Calculated transaction mass.
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm2.pendingtransaction_mass(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Minimum number of signatures required by the transaction.
       * (as specified during the transaction creation).
       * @returns {number}
       */
      get minimumSignatures() {
        const ret = wasm2.pendingtransaction_minimumSignatures(this.__wbg_ptr);
        return ret;
      }
      /**
       * Total aggregate input amount.
       * @returns {bigint}
       */
      get aggregateInputAmount() {
        const ret = wasm2.pendingtransaction_aggregateInputAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Total aggregate output amount.
       * @returns {bigint}
       */
      get aggregateOutputAmount() {
        const ret = wasm2.pendingtransaction_aggregateOutputAmount(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Transaction type ("batch" or "final").
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * List of unique addresses used by transaction inputs.
       * This method can be used to determine addresses used by transaction inputs
       * in order to select private keys needed for transaction signing.
       * @returns {Array<any>}
       */
      addresses() {
        const ret = wasm2.pendingtransaction_addresses(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Provides a list of UTXO entries used by the transaction.
       * @returns {Array<any>}
       */
      getUtxoEntries() {
        const ret = wasm2.pendingtransaction_getUtxoEntries(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Creates and returns a signature for the input at the specified index.
       * @param {number} input_index
       * @param {PrivateKey} private_key
       * @param {SighashType | null} [sighash_type]
       * @returns {HexString}
       */
      createInputSignature(input_index, private_key, sighash_type) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(private_key, PrivateKey2);
          wasm2.pendingtransaction_createInputSignature(retptr, this.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone2(sighash_type) ? 6 : sighash_type);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Sets a signature to the input at the specified index.
       * @param {number} input_index
       * @param {HexString | Uint8Array} signature_script
       */
      fillInput(input_index, signature_script) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_fillInput(retptr, this.__wbg_ptr, input_index, addHeapObject2(signature_script));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Signs the input at the specified index with the supplied private key
       * and an optional SighashType.
       * @param {number} input_index
       * @param {PrivateKey} private_key
       * @param {SighashType | null} [sighash_type]
       */
      signInput(input_index, private_key, sighash_type) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(private_key, PrivateKey2);
          wasm2.pendingtransaction_signInput(retptr, this.__wbg_ptr, input_index, private_key.__wbg_ptr, isLikeNone2(sighash_type) ? 6 : sighash_type);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Signs transaction with supplied [`Array`] or [`PrivateKey`] or an array of
       * raw private key bytes (encoded as `Uint8Array` or as hex strings)
       * @param {(PrivateKey | HexString | Uint8Array)[]} js_value
       * @param {boolean | null} [check_fully_signed]
       */
      sign(js_value, check_fully_signed) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_sign(retptr, this.__wbg_ptr, addHeapObject2(js_value), isLikeNone2(check_fully_signed) ? 16777215 : check_fully_signed ? 1 : 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Submit transaction to the supplied [`RpcClient`]
       * **IMPORTANT:** This method will remove UTXOs from the associated
       * {@link UtxoContext} if one was used to create the transaction
       * and will return UTXOs back to {@link UtxoContext} in case of
       * a failed submission.
       *
       * # Important
       *
       * Make sure to consume the returned `txid` value. Always invoke this method
       * as follows `let txid = await pendingTransaction.submit(rpc);`. If you do not
       * consume the returned value and the rpc object is temporary, the GC will
       * collect the `rpc` object passed to submit() potentially causing a panic.
       *
       * @see {@link RpcClient.submitTransaction}
       * @param {RpcClient} wasm_rpc_client
       * @returns {Promise<string>}
       */
      submit(wasm_rpc_client) {
        _assertClass2(wasm_rpc_client, RpcClient2);
        const ret = wasm2.pendingtransaction_submit(this.__wbg_ptr, wasm_rpc_client.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Returns encapsulated network [`Transaction`]
       * @returns {Transaction}
       */
      get transaction() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_transaction(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Transaction2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a pure JavaScript Object.
       * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
       * @see {@link ISerializableTransaction}
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {ITransaction | Transaction}
       */
      serializeToObject() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_serializeToObject(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a JSON string.
       * The schema of the JSON is defined by {@link ISerializableTransaction}.
       * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromJSON}.
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {string}
       */
      serializeToJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_serializeToJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
       * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromSafeJSON}.
       * @see {@link Transaction}, {@link ISerializableTransaction}
       * @returns {string}
       */
      serializeToSafeJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pendingtransaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    PipeOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_pipeoptions_free(ptr >>> 0, 1));
    PipeOptions2 = class {
      static {
        __name$8(this, "PipeOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PipeOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pipeoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [end]
       */
      constructor(end) {
        const ret = wasm2.pipeoptions_new(isLikeNone2(end) ? 16777215 : end ? 1 : 0);
        this.__wbg_ptr = ret >>> 0;
        PipeOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get end() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm2.pipeoptions_end(ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set end(value2) {
        const ptr = this.__destroy_into_raw();
        wasm2.pipeoptions_set_end(ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    PoWFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_pow_free(ptr >>> 0, 1));
    PoW2 = class _PoW {
      static {
        __name$8(this, "PoW");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PoW.prototype);
        obj.__wbg_ptr = ptr;
        PoWFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          target: this.target,
          prePoWHash: this.prePoWHash
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PoWFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_pow_free(ptr, 0);
      }
      /**
       * @param {Header | IHeader | IRawHeader} header
       * @param {bigint | null} [timestamp]
       */
      constructor(header, timestamp) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pow_new(retptr, addBorrowedObject2(header), !isLikeNone2(timestamp), isLikeNone2(timestamp) ? BigInt(0) : timestamp);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PoWFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * The target based on the provided bits.
       * @returns {bigint}
       */
      get target() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pow_target(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Checks if the computed target meets or exceeds the difficulty specified in the template.
       * @returns A boolean indicating if it reached the target and a bigint representing the reached target.
       * @param {bigint} nonce
       * @returns {[boolean, bigint]}
       */
      checkWork(nonce) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pow_checkWork(retptr, this.__wbg_ptr, nonce);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Hash of the header without timestamp and nonce.
       * @returns {string}
       */
      get prePoWHash() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.pow_get_pre_pow_hash(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Can be used for parsing Stratum templates.
       * @param {string} pre_pow_hash
       * @param {bigint} timestamp
       * @param {number | null} [target_bits]
       * @returns {PoW}
       */
      static fromRaw(pre_pow_hash, timestamp, target_bits) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(pre_pow_hash, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.pow_fromRaw(retptr, ptr0, len0, timestamp, isLikeNone2(target_bits) ? 4294967297 : target_bits >>> 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PoW.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PrivateKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_privatekey_free(ptr >>> 0, 1));
    PrivateKey2 = class _PrivateKey {
      static {
        __name$8(this, "PrivateKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PrivateKey.prototype);
        obj.__wbg_ptr = ptr;
        PrivateKeyFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_privatekey_free(ptr, 0);
      }
      /**
       * Create a new [`PrivateKey`] from a hex-encoded string.
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(key2, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.privatekey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PrivateKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Returns the [`PrivateKey`] key encoded as a hex string.
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Generate a [`Keypair`] from this [`PrivateKey`].
       * @returns {Keypair}
       */
      toKeypair() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekey_toKeypair(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Keypair2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PublicKey}
       */
      toPublicKey() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekey_toPublicKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PublicKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Get the [`Address`] of the PublicKey generated from this PrivateKey.
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of the PublicKey generated from this PrivateKey.
       * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
       * to determine the prefix of the address.
       * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    PrivateKeyGeneratorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_privatekeygenerator_free(ptr >>> 0, 1));
    PrivateKeyGenerator2 = class {
      static {
        __name$8(this, "PrivateKeyGenerator");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateKeyGeneratorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_privatekeygenerator_free(ptr, 0);
      }
      /**
       * @param {XPrv | string} xprv
       * @param {boolean} is_multisig
       * @param {bigint} account_index
       * @param {number | null} [cosigner_index]
       */
      constructor(xprv, is_multisig, account_index, cosigner_index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekeygenerator_new(retptr, addBorrowedObject2(xprv), is_multisig, account_index, isLikeNone2(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PrivateKeyGeneratorFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {number} index
       * @returns {PrivateKey}
       */
      receiveKey(index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekeygenerator_receiveKey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PrivateKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} index
       * @returns {PrivateKey}
       */
      changeKey(index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.privatekeygenerator_changeKey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PrivateKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ProcessSendOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_processsendoptions_free(ptr >>> 0, 1));
    ProcessSendOptions2 = class {
      static {
        __name$8(this, "ProcessSendOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProcessSendOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_processsendoptions_free(ptr, 0);
      }
      /**
       * @param {boolean | null} [swallow_errors]
       */
      constructor(swallow_errors) {
        const ret = wasm2.processsendoptions_new(isLikeNone2(swallow_errors) ? 16777215 : swallow_errors ? 1 : 0);
        this.__wbg_ptr = ret >>> 0;
        ProcessSendOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {boolean | undefined}
       */
      get swallow_errors() {
        const ret = wasm2.processsendoptions_swallow_errors(this.__wbg_ptr);
        return ret === 16777215 ? void 0 : ret !== 0;
      }
      /**
       * @param {boolean | null} [value]
       */
      set swallow_errors(value2) {
        wasm2.processsendoptions_set_swallow_errors(this.__wbg_ptr, isLikeNone2(value2) ? 16777215 : value2 ? 1 : 0);
      }
    };
    PrvKeyDataInfoFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_prvkeydatainfo_free(ptr >>> 0, 1));
    PrvKeyDataInfo2 = class {
      static {
        __name$8(this, "PrvKeyDataInfo");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrvKeyDataInfoFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_prvkeydatainfo_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.prvkeydatainfo_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {any}
       */
      get name() {
        const ret = wasm2.prvkeydatainfo_name(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {any}
       */
      get isEncrypted() {
        const ret = wasm2.prvkeydatainfo_isEncrypted(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string} _name
       */
      setName(_name) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(_name, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.prvkeydatainfo_setName(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    PublicKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_publickey_free(ptr >>> 0, 1));
    PublicKey2 = class _PublicKey {
      static {
        __name$8(this, "PublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_publickey_free(ptr, 0);
      }
      /**
       * Create a new [`PublicKey`] from a hex-encoded string.
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(key2, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.publickey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          PublicKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`Address`] of this PublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this PublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {XOnlyPublicKey}
       */
      toXOnlyPublicKey() {
        const ret = wasm2.publickey_toXOnlyPublicKey(this.__wbg_ptr);
        return XOnlyPublicKey2.__wrap(ret);
      }
      /**
       * Compute a 4-byte key fingerprint for this public key as a hex string.
       * Default implementation uses `RIPEMD160(SHA256(public_key))`.
       * @returns {HexString | undefined}
       */
      fingerprint() {
        const ret = wasm2.publickey_fingerprint(this.__wbg_ptr);
        return takeObject2(ret);
      }
    };
    PublicKeyGeneratorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_publickeygenerator_free(ptr >>> 0, 1));
    PublicKeyGenerator2 = class _PublicKeyGenerator {
      static {
        __name$8(this, "PublicKeyGenerator");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_PublicKeyGenerator.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyGeneratorFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyGeneratorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_publickeygenerator_free(ptr, 0);
      }
      /**
       * @param {XPub | string} kpub
       * @param {number | null} [cosigner_index]
       * @returns {PublicKeyGenerator}
       */
      static fromXPub(kpub, cosigner_index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_fromXPub(retptr, addBorrowedObject2(kpub), isLikeNone2(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PublicKeyGenerator.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {XPrv | string} xprv
       * @param {boolean} is_multisig
       * @param {bigint} account_index
       * @param {number | null} [cosigner_index]
       * @returns {PublicKeyGenerator}
       */
      static fromMasterXPrv(xprv, is_multisig, account_index, cosigner_index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_fromMasterXPrv(retptr, addBorrowedObject2(xprv), is_multisig, account_index, isLikeNone2(cosigner_index) ? 4294967297 : cosigner_index >>> 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _PublicKeyGenerator.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate Receive Public Key derivations for a given range.
       * @param {number} start
       * @param {number} end
       * @returns {(PublicKey | string)[]}
       */
      receivePubkeys(start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receivePubkeys(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Receive Public Key derivation at a given index.
       * @param {number} index
       * @returns {PublicKey}
       */
      receivePubkey(index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receivePubkey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PublicKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a range of Receive Public Key derivations and return them as strings.
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      receivePubkeysAsStrings(start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receivePubkeysAsStrings(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Receive Public Key derivation at a given index and return it as a string.
       * @param {number} index
       * @returns {string}
       */
      receivePubkeyAsString(index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receivePubkeyAsString(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Receive Address derivations for a given range.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Address[]}
       */
      receiveAddresses(networkType, start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receiveAddresses(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a single Receive Address derivation at a given index.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {Address}
       */
      receiveAddress(networkType, index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receiveAddress(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a range of Receive Address derivations and return them as strings.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      receiveAddressAsStrings(networkType, start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receiveAddressAsStrings(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a single Receive Address derivation at a given index and return it as a string.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {string}
       */
      receiveAddressAsString(networkType, index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_receiveAddressAsString(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Change Public Key derivations for a given range.
       * @param {number} start
       * @param {number} end
       * @returns {(PublicKey | string)[]}
       */
      changePubkeys(start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changePubkeys(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Change Public Key derivation at a given index.
       * @param {number} index
       * @returns {PublicKey}
       */
      changePubkey(index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changePubkey(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PublicKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a range of Change Public Key derivations and return them as strings.
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      changePubkeysAsStrings(start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changePubkeysAsStrings(retptr, this.__wbg_ptr, start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Generate a single Change Public Key derivation at a given index and return it as a string.
       * @param {number} index
       * @returns {string}
       */
      changePubkeyAsString(index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changePubkeyAsString(retptr, this.__wbg_ptr, index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Generate Change Address derivations for a given range.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Address[]}
       */
      changeAddresses(networkType, start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changeAddresses(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a single Change Address derivation at a given index.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {Address}
       */
      changeAddress(networkType, index) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changeAddress(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a range of Change Address derivations and return them as strings.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} start
       * @param {number} end
       * @returns {Array<string>}
       */
      changeAddressAsStrings(networkType, start2, end) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changeAddressAsStrings(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), start2, end);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Generate a single Change Address derivation at a given index and return it as a string.
       * @param {NetworkType | NetworkId | string} networkType
       * @param {number} index
       * @returns {string}
       */
      changeAddressAsString(networkType, index) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_changeAddressAsString(retptr, this.__wbg_ptr, addBorrowedObject2(networkType), index);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.publickeygenerator_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    ReadStreamFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_readstream_free(ptr >>> 0, 1));
    ReadStream2 = class {
      static {
        __name$8(this, "ReadStream");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ReadStreamFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_readstream_free(ptr, 0);
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_open(listener) {
        try {
          const ret = wasm2.readstream_add_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_close(listener) {
        try {
          const ret = wasm2.readstream_add_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_open(listener) {
        try {
          const ret = wasm2.readstream_on_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_close(listener) {
        try {
          const ret = wasm2.readstream_on_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_open(listener) {
        try {
          const ret = wasm2.readstream_once_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_close(listener) {
        try {
          const ret = wasm2.readstream_once_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_open(listener) {
        try {
          const ret = wasm2.readstream_prepend_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_close(listener) {
        try {
          const ret = wasm2.readstream_prepend_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_open(listener) {
        try {
          const ret = wasm2.readstream_prepend_once_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_close(listener) {
        try {
          const ret = wasm2.readstream_prepend_once_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    ResolverFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_resolver_free(ptr >>> 0, 1));
    Resolver2 = class _Resolver {
      static {
        __name$8(this, "Resolver");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Resolver.prototype);
        obj.__wbg_ptr = ptr;
        ResolverFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          urls: this.urls
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ResolverFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_resolver_free(ptr, 0);
      }
      /**
       * List of public Kaspa Resolver URLs.
       * @returns {string[] | undefined}
       */
      get urls() {
        const ret = wasm2.resolver_urls(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Fetches a public Kaspa wRPC endpoint for the given encoding and network identifier.
       * @see {@link Encoding}, {@link NetworkId}, {@link Node}
       * @param {Encoding} encoding
       * @param {NetworkId | string} network_id
       * @returns {Promise<NodeDescriptor>}
       */
      getNode(encoding, network_id) {
        const ret = wasm2.resolver_getNode(this.__wbg_ptr, encoding, addHeapObject2(network_id));
        return takeObject2(ret);
      }
      /**
       * Fetches a public Kaspa wRPC endpoint URL for the given encoding and network identifier.
       * @see {@link Encoding}, {@link NetworkId}
       * @param {Encoding} encoding
       * @param {NetworkId | string} network_id
       * @returns {Promise<string>}
       */
      getUrl(encoding, network_id) {
        const ret = wasm2.resolver_getUrl(this.__wbg_ptr, encoding, addHeapObject2(network_id));
        return takeObject2(ret);
      }
      /**
       * Connect to a public Kaspa wRPC endpoint for the given encoding and network identifier
       * supplied via {@link IResolverConnect} interface.
       * @see {@link IResolverConnect}, {@link RpcClient}
       * @param {IResolverConnect | NetworkId | string} options
       * @returns {Promise<RpcClient>}
       */
      connect(options) {
        const ret = wasm2.resolver_connect(this.__wbg_ptr, addHeapObject2(options));
        return takeObject2(ret);
      }
      /**
       * Creates a new Resolver client with the given
       * configuration supplied as {@link IResolverConfig}
       * interface. If not supplied, the default configuration
       * containing a list of community-operated resolvers
       * will be used.
       * @param {IResolverConfig | string[] | null} [args]
       */
      constructor(args) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.resolver_ctor(retptr, isLikeNone2(args) ? 0 : addHeapObject2(args));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          ResolverFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    RpcClientFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_rpcclient_free(ptr >>> 0, 1));
    RpcClient2 = class _RpcClient {
      static {
        __name$8(this, "RpcClient");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_RpcClient.prototype);
        obj.__wbg_ptr = ptr;
        RpcClientFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          url: this.url,
          resolver: this.resolver,
          isConnected: this.isConnected,
          encoding: this.encoding,
          nodeId: this.nodeId
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RpcClientFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_rpcclient_free(ptr, 0);
      }
      /**
       * Retrieves the current number of blocks in the Kaspa BlockDAG.
       * This is not a block count, not a "block height" and can not be
       * used for transaction validation.
       * Returned information: Current block count.
       * @see {@link IGetBlockCountRequest}, {@link IGetBlockCountResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetBlockCountRequest | null} [request]
       * @returns {Promise<IGetBlockCountResponse>}
       */
      getBlockCount(request) {
        const ret = wasm2.rpcclient_getBlockCount(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Provides information about the Directed Acyclic Graph (DAG)
       * structure of the Kaspa BlockDAG.
       * Returned information: Number of blocks in the DAG,
       * number of tips in the DAG, hash of the selected parent block,
       * difficulty of the selected parent block, selected parent block
       * blue score, selected parent block time.
       * @see {@link IGetBlockDagInfoRequest}, {@link IGetBlockDagInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetBlockDagInfoRequest | null} [request]
       * @returns {Promise<IGetBlockDagInfoResponse>}
       */
      getBlockDagInfo(request) {
        const ret = wasm2.rpcclient_getBlockDagInfo(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Returns the total current coin supply of Kaspa network.
       * Returned information: Total coin supply.
       * @see {@link IGetCoinSupplyRequest}, {@link IGetCoinSupplyResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetCoinSupplyRequest | null} [request]
       * @returns {Promise<IGetCoinSupplyResponse>}
       */
      getCoinSupply(request) {
        const ret = wasm2.rpcclient_getCoinSupply(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves information about the peers connected to the Kaspa node.
       * Returned information: Peer ID, IP address and port, connection
       * status, protocol version.
       * @see {@link IGetConnectedPeerInfoRequest}, {@link IGetConnectedPeerInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetConnectedPeerInfoRequest | null} [request]
       * @returns {Promise<IGetConnectedPeerInfoResponse>}
       */
      getConnectedPeerInfo(request) {
        const ret = wasm2.rpcclient_getConnectedPeerInfo(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves general information about the Kaspa node.
       * Returned information: Version of the Kaspa node, protocol
       * version, network identifier.
       * This call is primarily used by gRPC clients.
       * For wRPC clients, use {@link RpcClient.getServerInfo}.
       * @see {@link IGetInfoRequest}, {@link IGetInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetInfoRequest | null} [request]
       * @returns {Promise<IGetInfoResponse>}
       */
      getInfo(request) {
        const ret = wasm2.rpcclient_getInfo(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Provides a list of addresses of known peers in the Kaspa
       * network that the node can potentially connect to.
       * Returned information: List of peer addresses.
       * @see {@link IGetPeerAddressesRequest}, {@link IGetPeerAddressesResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetPeerAddressesRequest | null} [request]
       * @returns {Promise<IGetPeerAddressesResponse>}
       */
      getPeerAddresses(request) {
        const ret = wasm2.rpcclient_getPeerAddresses(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves various metrics and statistics related to the
       * performance and status of the Kaspa node.
       * Returned information: Memory usage, CPU usage, network activity.
       * @see {@link IGetMetricsRequest}, {@link IGetMetricsResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetMetricsRequest | null} [request]
       * @returns {Promise<IGetMetricsResponse>}
       */
      getMetrics(request) {
        const ret = wasm2.rpcclient_getMetrics(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves current number of network connections
       * @see {@link IGetConnectionsRequest}, {@link IGetConnectionsResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetConnectionsRequest | null} [request]
       * @returns {Promise<IGetConnectionsResponse>}
       */
      getConnections(request) {
        const ret = wasm2.rpcclient_getConnections(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves the current sink block, which is the block with
       * the highest cumulative difficulty in the Kaspa BlockDAG.
       * Returned information: Sink block hash, sink block height.
       * @see {@link IGetSinkRequest}, {@link IGetSinkResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSinkRequest | null} [request]
       * @returns {Promise<IGetSinkResponse>}
       */
      getSink(request) {
        const ret = wasm2.rpcclient_getSink(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Returns the blue score of the current sink block, indicating
       * the total amount of work that has been done on the main chain
       * leading up to that block.
       * Returned information: Blue score of the sink block.
       * @see {@link IGetSinkBlueScoreRequest}, {@link IGetSinkBlueScoreResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSinkBlueScoreRequest | null} [request]
       * @returns {Promise<IGetSinkBlueScoreResponse>}
       */
      getSinkBlueScore(request) {
        const ret = wasm2.rpcclient_getSinkBlueScore(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Tests the connection and responsiveness of a Kaspa node.
       * Returned information: None.
       * @see {@link IPingRequest}, {@link IPingResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IPingRequest | null} [request]
       * @returns {Promise<IPingResponse>}
       */
      ping(request) {
        const ret = wasm2.rpcclient_ping(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Gracefully shuts down the Kaspa node.
       * Returned information: None.
       * @see {@link IShutdownRequest}, {@link IShutdownResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IShutdownRequest | null} [request]
       * @returns {Promise<IShutdownResponse>}
       */
      shutdown(request) {
        const ret = wasm2.rpcclient_shutdown(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves information about the Kaspa server.
       * Returned information: Version of the Kaspa server, protocol
       * version, network identifier.
       * @see {@link IGetServerInfoRequest}, {@link IGetServerInfoResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetServerInfoRequest | null} [request]
       * @returns {Promise<IGetServerInfoResponse>}
       */
      getServerInfo(request) {
        const ret = wasm2.rpcclient_getServerInfo(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Obtains basic information about the synchronization status of the Kaspa node.
       * Returned information: Syncing status.
       * @see {@link IGetSyncStatusRequest}, {@link IGetSyncStatusResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetSyncStatusRequest | null} [request]
       * @returns {Promise<IGetSyncStatusResponse>}
       */
      getSyncStatus(request) {
        const ret = wasm2.rpcclient_getSyncStatus(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Feerate estimates
       * @see {@link IGetFeeEstimateRequest}, {@link IGetFeeEstimateResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetFeeEstimateRequest | null} [request]
       * @returns {Promise<IGetFeeEstimateResponse>}
       */
      getFeeEstimate(request) {
        const ret = wasm2.rpcclient_getFeeEstimate(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves the current network configuration.
       * Returned information: Current network configuration.
       * @see {@link IGetCurrentNetworkRequest}, {@link IGetCurrentNetworkResponse}
       * @throws `string` on an RPC error or a server-side error.
       * @param {IGetCurrentNetworkRequest | null} [request]
       * @returns {Promise<IGetCurrentNetworkResponse>}
       */
      getCurrentNetwork(request) {
        const ret = wasm2.rpcclient_getCurrentNetwork(this.__wbg_ptr, isLikeNone2(request) ? 0 : addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Adds a peer to the Kaspa node's list of known peers.
       * Returned information: None.
       * @see {@link IAddPeerRequest}, {@link IAddPeerResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IAddPeerRequest} request
       * @returns {Promise<IAddPeerResponse>}
       */
      addPeer(request) {
        const ret = wasm2.rpcclient_addPeer(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Bans a peer from connecting to the Kaspa node for a specified duration.
       * Returned information: None.
       * @see {@link IBanRequest}, {@link IBanResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IBanRequest} request
       * @returns {Promise<IBanResponse>}
       */
      ban(request) {
        const ret = wasm2.rpcclient_ban(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Estimates the network's current hash rate in hashes per second.
       * Returned information: Estimated network hashes per second.
       * @see {@link IEstimateNetworkHashesPerSecondRequest}, {@link IEstimateNetworkHashesPerSecondResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IEstimateNetworkHashesPerSecondRequest} request
       * @returns {Promise<IEstimateNetworkHashesPerSecondResponse>}
       */
      estimateNetworkHashesPerSecond(request) {
        const ret = wasm2.rpcclient_estimateNetworkHashesPerSecond(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves the balance of a specific address in the Kaspa BlockDAG.
       * Returned information: Balance of the address.
       * @see {@link IGetBalanceByAddressRequest}, {@link IGetBalanceByAddressResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBalanceByAddressRequest} request
       * @returns {Promise<IGetBalanceByAddressResponse>}
       */
      getBalanceByAddress(request) {
        const ret = wasm2.rpcclient_getBalanceByAddress(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves balances for multiple addresses in the Kaspa BlockDAG.
       * Returned information: Balances of the addresses.
       * @see {@link IGetBalancesByAddressesRequest}, {@link IGetBalancesByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBalancesByAddressesRequest | Address[] | string[]} request
       * @returns {Promise<IGetBalancesByAddressesResponse>}
       */
      getBalancesByAddresses(request) {
        const ret = wasm2.rpcclient_getBalancesByAddresses(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves a specific block from the Kaspa BlockDAG.
       * Returned information: Block information.
       * @see {@link IGetBlockRequest}, {@link IGetBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlockRequest} request
       * @returns {Promise<IGetBlockResponse>}
       */
      getBlock(request) {
        const ret = wasm2.rpcclient_getBlock(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves multiple blocks from the Kaspa BlockDAG.
       * Returned information: List of block information.
       * @see {@link IGetBlocksRequest}, {@link IGetBlocksResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlocksRequest} request
       * @returns {Promise<IGetBlocksResponse>}
       */
      getBlocks(request) {
        const ret = wasm2.rpcclient_getBlocks(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Generates a new block template for mining.
       * Returned information: Block template information.
       * @see {@link IGetBlockTemplateRequest}, {@link IGetBlockTemplateResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetBlockTemplateRequest} request
       * @returns {Promise<IGetBlockTemplateResponse>}
       */
      getBlockTemplate(request) {
        const ret = wasm2.rpcclient_getBlockTemplate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Checks if block is blue or not.
       * Returned information: Block blueness.
       * @see {@link IGetCurrentBlockColorRequest}, {@link IGetCurrentBlockColorResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetCurrentBlockColorRequest} request
       * @returns {Promise<IGetCurrentBlockColorResponse>}
       */
      getCurrentBlockColor(request) {
        const ret = wasm2.rpcclient_getCurrentBlockColor(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves the estimated DAA (Difficulty Adjustment Algorithm)
       * score timestamp estimate.
       * Returned information: DAA score timestamp estimate.
       * @see {@link IGetDaaScoreTimestampEstimateRequest}, {@link IGetDaaScoreTimestampEstimateResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetDaaScoreTimestampEstimateRequest} request
       * @returns {Promise<IGetDaaScoreTimestampEstimateResponse>}
       */
      getDaaScoreTimestampEstimate(request) {
        const ret = wasm2.rpcclient_getDaaScoreTimestampEstimate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Feerate estimates (experimental)
       * @see {@link IGetFeeEstimateExperimentalRequest}, {@link IGetFeeEstimateExperimentalResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetFeeEstimateExperimentalRequest} request
       * @returns {Promise<IGetFeeEstimateExperimentalResponse>}
       */
      getFeeEstimateExperimental(request) {
        const ret = wasm2.rpcclient_getFeeEstimateExperimental(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves block headers from the Kaspa BlockDAG.
       * Returned information: List of block headers.
       * @see {@link IGetHeadersRequest}, {@link IGetHeadersResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetHeadersRequest} request
       * @returns {Promise<IGetHeadersResponse>}
       */
      getHeaders(request) {
        const ret = wasm2.rpcclient_getHeaders(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves mempool entries from the Kaspa node's mempool.
       * Returned information: List of mempool entries.
       * @see {@link IGetMempoolEntriesRequest}, {@link IGetMempoolEntriesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntriesRequest} request
       * @returns {Promise<IGetMempoolEntriesResponse>}
       */
      getMempoolEntries(request) {
        const ret = wasm2.rpcclient_getMempoolEntries(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves mempool entries associated with specific addresses.
       * Returned information: List of mempool entries.
       * @see {@link IGetMempoolEntriesByAddressesRequest}, {@link IGetMempoolEntriesByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntriesByAddressesRequest} request
       * @returns {Promise<IGetMempoolEntriesByAddressesResponse>}
       */
      getMempoolEntriesByAddresses(request) {
        const ret = wasm2.rpcclient_getMempoolEntriesByAddresses(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves a specific mempool entry by transaction ID.
       * Returned information: Mempool entry information.
       * @see {@link IGetMempoolEntryRequest}, {@link IGetMempoolEntryResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetMempoolEntryRequest} request
       * @returns {Promise<IGetMempoolEntryResponse>}
       */
      getMempoolEntry(request) {
        const ret = wasm2.rpcclient_getMempoolEntry(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves information about a subnetwork in the Kaspa BlockDAG.
       * Returned information: Subnetwork information.
       * @see {@link IGetSubnetworkRequest}, {@link IGetSubnetworkResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetSubnetworkRequest} request
       * @returns {Promise<IGetSubnetworkResponse>}
       */
      getSubnetwork(request) {
        const ret = wasm2.rpcclient_getSubnetwork(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves unspent transaction outputs (UTXOs) associated with
       * specific addresses.
       * Returned information: List of UTXOs.
       * @see {@link IGetUtxosByAddressesRequest}, {@link IGetUtxosByAddressesResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetUtxosByAddressesRequest | Address[] | string[]} request
       * @returns {Promise<IGetUtxosByAddressesResponse>}
       */
      getUtxosByAddresses(request) {
        const ret = wasm2.rpcclient_getUtxosByAddresses(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Retrieves the virtual chain corresponding to a specified block hash.
       * Returned information: Virtual chain information.
       * @see {@link IGetVirtualChainFromBlockRequest}, {@link IGetVirtualChainFromBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IGetVirtualChainFromBlockRequest} request
       * @returns {Promise<IGetVirtualChainFromBlockResponse>}
       */
      getVirtualChainFromBlock(request) {
        const ret = wasm2.rpcclient_getVirtualChainFromBlock(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Resolves a finality conflict in the Kaspa BlockDAG.
       * Returned information: None.
       * @see {@link IResolveFinalityConflictRequest}, {@link IResolveFinalityConflictResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IResolveFinalityConflictRequest} request
       * @returns {Promise<IResolveFinalityConflictResponse>}
       */
      resolveFinalityConflict(request) {
        const ret = wasm2.rpcclient_resolveFinalityConflict(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Submits a block to the Kaspa network.
       * Returned information: None.
       * @see {@link ISubmitBlockRequest}, {@link ISubmitBlockResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitBlockRequest} request
       * @returns {Promise<ISubmitBlockResponse>}
       */
      submitBlock(request) {
        const ret = wasm2.rpcclient_submitBlock(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Submits a transaction to the Kaspa network.
       * Returned information: Submitted Transaction Id.
       * @see {@link ISubmitTransactionRequest}, {@link ISubmitTransactionResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitTransactionRequest} request
       * @returns {Promise<ISubmitTransactionResponse>}
       */
      submitTransaction(request) {
        const ret = wasm2.rpcclient_submitTransaction(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Submits an RBF transaction to the Kaspa network.
       * Returned information: Submitted Transaction Id, Transaction that was replaced.
       * @see {@link ISubmitTransactionReplacementRequest}, {@link ISubmitTransactionReplacementResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {ISubmitTransactionReplacementRequest} request
       * @returns {Promise<ISubmitTransactionReplacementResponse>}
       */
      submitTransactionReplacement(request) {
        const ret = wasm2.rpcclient_submitTransactionReplacement(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Unbans a previously banned peer, allowing it to connect
       * to the Kaspa node again.
       * Returned information: None.
       * @see {@link IUnbanRequest}, {@link IUnbanResponse}
       * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
       * @param {IUnbanRequest} request
       * @returns {Promise<IUnbanResponse>}
       */
      unban(request) {
        const ret = wasm2.rpcclient_unban(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a block added notification event.
       * Block added notification event is produced when a new
       * block is added to the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeBlockAdded() {
        const ret = wasm2.rpcclient_subscribeBlockAdded(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeBlockAdded() {
        const ret = wasm2.rpcclient_unsubscribeBlockAdded(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a finality conflict notification event.
       * Finality conflict notification event is produced when a finality
       * conflict occurs in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeFinalityConflict() {
        const ret = wasm2.rpcclient_subscribeFinalityConflict(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeFinalityConflict() {
        const ret = wasm2.rpcclient_unsubscribeFinalityConflict(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a finality conflict resolved notification event.
       * Finality conflict resolved notification event is produced when a finality
       * conflict in the Kaspa BlockDAG is resolved.
       * @returns {Promise<void>}
       */
      subscribeFinalityConflictResolved() {
        const ret = wasm2.rpcclient_subscribeFinalityConflictResolved(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeFinalityConflictResolved() {
        const ret = wasm2.rpcclient_unsubscribeFinalityConflictResolved(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a sink blue score changed notification event.
       * Sink blue score changed notification event is produced when the blue
       * score of the sink block changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeSinkBlueScoreChanged() {
        const ret = wasm2.rpcclient_subscribeSinkBlueScoreChanged(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeSinkBlueScoreChanged() {
        const ret = wasm2.rpcclient_unsubscribeSinkBlueScoreChanged(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a pruning point UTXO set override notification event.
       * Pruning point UTXO set override notification event is produced when the
       * UTXO set override for the pruning point changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribePruningPointUtxoSetOverride() {
        const ret = wasm2.rpcclient_subscribePruningPointUtxoSetOverride(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribePruningPointUtxoSetOverride() {
        const ret = wasm2.rpcclient_unsubscribePruningPointUtxoSetOverride(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a new block template notification event.
       * New block template notification event is produced when a new block
       * template is generated for mining in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeNewBlockTemplate() {
        const ret = wasm2.rpcclient_subscribeNewBlockTemplate(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      unsubscribeNewBlockTemplate() {
        const ret = wasm2.rpcclient_unsubscribeNewBlockTemplate(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a virtual DAA score changed notification event.
       * Virtual DAA score changed notification event is produced when the virtual
       * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      subscribeVirtualDaaScoreChanged() {
        const ret = wasm2.rpcclient_subscribeVirtualDaaScoreChanged(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a virtual DAA score changed notification event.
       * Virtual DAA score changed notification event is produced when the virtual
       * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
       * @returns {Promise<void>}
       */
      unsubscribeVirtualDaaScoreChanged() {
        const ret = wasm2.rpcclient_unsubscribeVirtualDaaScoreChanged(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Subscribe for a UTXOs changed notification event.
       * UTXOs changed notification event is produced when the set
       * of unspent transaction outputs (UTXOs) changes in the
       * Kaspa BlockDAG. The event notification will be scoped to the
       * provided list of addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      subscribeUtxosChanged(addresses) {
        const ret = wasm2.rpcclient_subscribeUtxosChanged(this.__wbg_ptr, addHeapObject2(addresses));
        return takeObject2(ret);
      }
      /**
       * Unsubscribe from UTXOs changed notification event
       * for a specific set of addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      unsubscribeUtxosChanged(addresses) {
        const ret = wasm2.rpcclient_unsubscribeUtxosChanged(this.__wbg_ptr, addHeapObject2(addresses));
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a virtual chain changed notification event.
       * Virtual chain changed notification event is produced when the virtual
       * chain changes in the Kaspa BlockDAG.
       * @param {boolean} include_accepted_transaction_ids
       * @returns {Promise<void>}
       */
      subscribeVirtualChainChanged(include_accepted_transaction_ids) {
        const ret = wasm2.rpcclient_subscribeVirtualChainChanged(this.__wbg_ptr, include_accepted_transaction_ids);
        return takeObject2(ret);
      }
      /**
       * Manage subscription for a virtual chain changed notification event.
       * Virtual chain changed notification event is produced when the virtual
       * chain changes in the Kaspa BlockDAG.
       * @param {boolean} include_accepted_transaction_ids
       * @returns {Promise<void>}
       */
      unsubscribeVirtualChainChanged(include_accepted_transaction_ids) {
        const ret = wasm2.rpcclient_unsubscribeVirtualChainChanged(this.__wbg_ptr, include_accepted_transaction_ids);
        return takeObject2(ret);
      }
      /**
       * @param {Encoding} encoding
       * @param {NetworkType | NetworkId | string} network
       * @returns {number}
       */
      static defaultPort(encoding, network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_defaultPort(retptr, encoding, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return r0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Constructs an WebSocket RPC URL given the partial URL or an IP, RPC encoding
       * and a network type.
       *
       * # Arguments
       *
       * * `url` - Partial URL or an IP address
       * * `encoding` - RPC encoding
       * * `network_type` - Network type
       * @param {string} url
       * @param {Encoding} encoding
       * @param {NetworkId} network
       * @returns {string}
       */
      static parseUrl(url, encoding, network) {
        let deferred4_0;
        let deferred4_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(url, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          _assertClass2(network, NetworkId2);
          var ptr1 = network.__destroy_into_raw();
          wasm2.rpcclient_parseUrl(retptr, ptr0, len0, encoding, ptr1);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr3 = r0;
          var len3 = r1;
          if (r3) {
            ptr3 = 0;
            len3 = 0;
            throw takeObject2(r2);
          }
          deferred4_0 = ptr3;
          deferred4_1 = len3;
          return getStringFromWasm02(ptr3, len3);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
        }
      }
      /**
       *
       * Create a new RPC client with optional {@link Encoding} and a `url`.
       *
       * @see {@link IRpcConfig} interface for more details.
       * @param {IRpcConfig | null} [config]
       */
      constructor(config) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_ctor(retptr, isLikeNone2(config) ? 0 : addHeapObject2(config));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          RpcClientFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * The current URL of the RPC client.
       * @returns {string | undefined}
       */
      get url() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_url(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Current rpc resolver
       * @returns {Resolver | undefined}
       */
      get resolver() {
        const ret = wasm2.rpcclient_resolver(this.__wbg_ptr);
        return ret === 0 ? void 0 : Resolver2.__wrap(ret);
      }
      /**
       * Set the resolver for the RPC client.
       * This setting will take effect on the next connection.
       * @param {Resolver} resolver
       */
      setResolver(resolver) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(resolver, Resolver2);
          var ptr0 = resolver.__destroy_into_raw();
          wasm2.rpcclient_setResolver(retptr, this.__wbg_ptr, ptr0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Set the network id for the RPC client.
       * This setting will take effect on the next connection.
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_setNetworkId(retptr, this.__wbg_ptr, addBorrowedObject2(network_id));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * The current connection status of the RPC client.
       * @returns {boolean}
       */
      get isConnected() {
        const ret = wasm2.rpcclient_isConnected(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * The current protocol encoding.
       * @returns {string}
       */
      get encoding() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_encoding(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Optional: Resolver node id.
       * @returns {string | undefined}
       */
      get nodeId() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_nodeId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Connect to the Kaspa RPC server. This function starts a background
       * task that connects and reconnects to the server if the connection
       * is terminated.  Use [`disconnect()`](Self::disconnect()) to
       * terminate the connection.
       * @see {@link IConnectOptions} interface for more details.
       * @param {IConnectOptions | undefined | null} [args]
       * @returns {Promise<void>}
       */
      connect(args) {
        const ret = wasm2.rpcclient_connect(this.__wbg_ptr, isLikeNone2(args) ? 0 : addHeapObject2(args));
        return takeObject2(ret);
      }
      /**
       * Disconnect from the Kaspa RPC server.
       * @returns {Promise<void>}
       */
      disconnect() {
        const ret = wasm2.rpcclient_disconnect(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Start background RPC services (automatically started when invoking {@link RpcClient.connect}).
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm2.rpcclient_start(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Stop background RPC services (automatically stopped when invoking {@link RpcClient.disconnect}).
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm2.rpcclient_stop(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Triggers a disconnection on the underlying WebSocket
       * if the WebSocket is in connected state.
       * This is intended for debug purposes only.
       * Can be used to test application reconnection logic.
       */
      triggerAbort() {
        wasm2.rpcclient_triggerAbort(this.__wbg_ptr);
      }
      /**
       *
       * Register an event listener callback.
       *
       * Registers a callback function to be executed when a specific event occurs.
       * The callback function will receive an {@link RpcEvent} object with the event `type` and `data`.
       *
       * **RPC Subscriptions vs Event Listeners**
       *
       * Subscriptions are used to receive notifications from the RPC client.
       * Event listeners are client-side application registrations that are
       * triggered when notifications are received.
       *
       * If node is disconnected, upon reconnection you do not need to re-register event listeners,
       * however, you have to re-subscribe for Kaspa node notifications. As such, it is recommended
       * to register event listeners when the RPC `open` event is received.
       *
       * ```javascript
       * rpc.addEventListener("connect", async (event) => {
       *     console.log("Connected to", rpc.url);
       *     await rpc.subscribeDaaScore();
       *     // ... perform wallet address subscriptions
       * });
       * ```
       *
       * **Multiple events and listeners**
       *
       * `addEventListener` can be used to register multiple event listeners for the same event
       * as well as the same event listener for multiple events.
       *
       * ```javascript
       * // Registering a single event listener for multiple events:
       * rpc.addEventListener(["connect", "disconnect"], (event) => {
       *     console.log(event);
       * });
       *
       * // Registering event listener for all events:
       * // (by omitting the event type)
       * rpc.addEventListener((event) => {
       *     console.log(event);
       * });
       *
       * // Registering multiple event listeners for the same event:
       * rpc.addEventListener("connect", (event) => { // first listener
       *     console.log(event);
       * });
       * rpc.addEventListener("connect", (event) => { // second listener
       *     console.log(event);
       * });
       * ```
       *
       * **Use of context objects**
       *
       * You can also register an event with a `context` object. When the event is triggered,
       * the `handleEvent` method of the `context` object will be called while `this` value
       * will be set to the `context` object.
       * ```javascript
       * // Registering events with a context object:
       *
       * const context = {
       *     someProperty: "someValue",
       *     handleEvent: (event) => {
       *         // the following will log "someValue"
       *         console.log(this.someProperty);
       *         console.log(event);
       *     }
       * };
       * rpc.addEventListener(["connect","disconnect"], context);
       *
       * ```
       *
       * **General use examples**
       *
       * In TypeScript you can use {@link RpcEventType} enum (such as `RpcEventType.Connect`)
       * or `string` (such as "connect") to register event listeners.
       * In JavaScript you can only use `string`.
       *
       * ```typescript
       * // Example usage (TypeScript):
       *
       * rpc.addEventListener(RpcEventType.Connect, (event) => {
       *     console.log("Connected to", rpc.url);
       * });
       *
       * rpc.addEventListener(RpcEventType.VirtualDaaScoreChanged, (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeDaaScore();
       *
       * rpc.addEventListener(RpcEventType.BlockAdded, (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeBlockAdded();
       *
       * // Example usage (JavaScript):
       *
       * rpc.addEventListener("virtual-daa-score-changed", (event) => {
       *     console.log(event.type,event.data);
       * });
       *
       * await rpc.subscribeDaaScore();
       * rpc.addEventListener("block-added", (event) => {
       *     console.log(event.type,event.data);
       * });
       * await rpc.subscribeBlockAdded();
       * ```
       *
       * @see {@link RpcEventType} for a list of supported events.
       * @see {@link RpcEventData} for the event data interface specification.
       * @see {@link RpcClient.removeEventListener}, {@link RpcClient.removeAllEventListeners}
       * @param {RpcEventType | string | RpcEventCallback} event
       * @param {RpcEventCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_addEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister an event listener.
       * This function will remove the callback for the specified event.
       * If the `callback` is not supplied, all callbacks will be
       * removed for the specified event.
       *
       * @see {@link RpcClient.addEventListener}
       * @param {RpcEventType | string} event
       * @param {RpcEventCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_removeEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister a single event listener callback from all events.
       *
       *
       * @param {RpcEventCallback} callback
       */
      clearEventListener(callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_clearEventListener(retptr, this.__wbg_ptr, addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       *
       * Unregister all notification callbacks for all events.
       */
      removeAllEventListeners() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.rpcclient_removeAllEventListeners(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    ScriptBuilderFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_scriptbuilder_free(ptr >>> 0, 1));
    ScriptBuilder2 = class _ScriptBuilder {
      static {
        __name$8(this, "ScriptBuilder");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ScriptBuilder.prototype);
        obj.__wbg_ptr = ptr;
        ScriptBuilderFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {};
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptBuilderFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_scriptbuilder_free(ptr, 0);
      }
      constructor() {
        const ret = wasm2.scriptbuilder_new();
        this.__wbg_ptr = ret >>> 0;
        ScriptBuilderFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * Creates a new ScriptBuilder over an existing script.
       * Supplied script can be represented as an `Uint8Array` or a `HexString`.
       * @param {HexString | Uint8Array} script
       * @returns {ScriptBuilder}
       */
      static fromScript(script) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_fromScript(retptr, addHeapObject2(script));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Pushes the passed opcode to the end of the script. The script will not
       * be modified if pushing the opcode would cause the script to exceed the
       * maximum allowed script engine size.
       * @param {number} op
       * @returns {ScriptBuilder}
       */
      addOp(op) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addOp(retptr, this.__wbg_ptr, op);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Adds the passed opcodes to the end of the script.
       * Supplied opcodes can be represented as an `Uint8Array` or a `HexString`.
       * @param {HexString | Uint8Array} opcodes
       * @returns {ScriptBuilder}
       */
      addOps(opcodes) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addOps(retptr, this.__wbg_ptr, addHeapObject2(opcodes));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * AddData pushes the passed data to the end of the script. It automatically
       * chooses canonical opcodes depending on the length of the data.
       *
       * A zero length buffer will lead to a push of empty data onto the stack (Op0 = OpFalse)
       * and any push of data greater than [`MAX_SCRIPT_ELEMENT_SIZE`](kaspa_txscript::MAX_SCRIPT_ELEMENT_SIZE) will not modify
       * the script since that is not allowed by the script engine.
       *
       * Also, the script will not be modified if pushing the data would cause the script to
       * exceed the maximum allowed script engine size [`MAX_SCRIPTS_SIZE`](kaspa_txscript::MAX_SCRIPTS_SIZE).
       * @param {HexString | Uint8Array} data
       * @returns {ScriptBuilder}
       */
      addData(data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addData(retptr, this.__wbg_ptr, addHeapObject2(data));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} value
       * @returns {ScriptBuilder}
       */
      addI64(value2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addI64(retptr, this.__wbg_ptr, value2);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} lock_time
       * @returns {ScriptBuilder}
       */
      addLockTime(lock_time) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addLockTime(retptr, this.__wbg_ptr, lock_time);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {bigint} sequence
       * @returns {ScriptBuilder}
       */
      addSequence(sequence) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_addLockTime(retptr, this.__wbg_ptr, sequence);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _ScriptBuilder.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {HexString | Uint8Array} data
       * @returns {number}
       */
      static canonicalDataSize(data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_canonicalDataSize(retptr, addHeapObject2(data));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return r0 >>> 0;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Get script bytes represented by a hex string.
       * @returns {HexString}
       */
      toString() {
        const ret = wasm2.scriptbuilder_toString(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Drains (empties) the script builder, returning the
       * script bytes represented by a hex string.
       * @returns {HexString}
       */
      drain() {
        const ret = wasm2.scriptbuilder_drain(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Creates an equivalent pay-to-script-hash script.
       * Can be used to create an P2SH address.
       * @see {@link addressFromScriptPublicKey}
       * @returns {ScriptPublicKey}
       */
      createPayToScriptHashScript() {
        const ret = wasm2.scriptbuilder_createPayToScriptHashScript(this.__wbg_ptr);
        return ScriptPublicKey2.__wrap(ret);
      }
      /**
       * Generates a signature script that fits a pay-to-script-hash script.
       * @param {HexString | Uint8Array} signature
       * @returns {HexString}
       */
      encodePayToScriptHashSignatureScript(signature2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_encodePayToScriptHashSignatureScript(retptr, this.__wbg_ptr, addHeapObject2(signature2));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {IHexViewConfig | null} [args]
       * @returns {string}
       */
      hexView(args) {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptbuilder_hexView(retptr, this.__wbg_ptr, isLikeNone2(args) ? 0 : addHeapObject2(args));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
    };
    ScriptPublicKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_scriptpublickey_free(ptr >>> 0, 1));
    ScriptPublicKey2 = class _ScriptPublicKey {
      static {
        __name$8(this, "ScriptPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_ScriptPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        ScriptPublicKeyFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          version: this.version,
          script: this.script
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ScriptPublicKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_scriptpublickey_free(ptr, 0);
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm2.__wbg_get_scriptpublickey_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} arg0
       */
      set version(arg0) {
        wasm2.__wbg_set_scriptpublickey_version(this.__wbg_ptr, arg0);
      }
      /**
       * @param {number} version
       * @param {any} script
       */
      constructor(version3, script) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptpublickey_constructor(retptr, version3, addHeapObject2(script));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          ScriptPublicKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get script() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.scriptpublickey_script_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    SetAadOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_setaadoptions_free(ptr >>> 0, 1));
    SetAadOptions2 = class {
      static {
        __name$8(this, "SetAadOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SetAadOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_setaadoptions_free(ptr, 0);
      }
      /**
       * @param {Function} flush
       * @param {number} plaintext_length
       * @param {Function} transform
       */
      constructor(flush, plaintext_length, transform) {
        const ret = wasm2.setaadoptions_new(addHeapObject2(flush), plaintext_length, addHeapObject2(transform));
        this.__wbg_ptr = ret >>> 0;
        SetAadOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {Function}
       */
      get flush() {
        const ret = wasm2.setaadoptions_flush(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set flush(value2) {
        wasm2.setaadoptions_set_flush(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {number}
       */
      get plaintextLength() {
        const ret = wasm2.setaadoptions_plaintextLength(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} value
       */
      set plaintext_length(value2) {
        wasm2.setaadoptions_set_plaintext_length(this.__wbg_ptr, value2);
      }
      /**
       * @returns {Function}
       */
      get transform() {
        const ret = wasm2.setaadoptions_transform(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set transform(value2) {
        wasm2.setaadoptions_set_transform(this.__wbg_ptr, addHeapObject2(value2));
      }
    };
    SigHashTypeFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_sighashtype_free(ptr >>> 0, 1));
    SigHashType2 = class {
      static {
        __name$8(this, "SigHashType");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SigHashTypeFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_sighashtype_free(ptr, 0);
      }
    };
    StorageFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_storage_free(ptr >>> 0, 1));
    Storage2 = class {
      static {
        __name$8(this, "Storage");
      }
      toJSON() {
        return {
          filename: this.filename
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StorageFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_storage_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get filename() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.storage_filename(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    StreamTransformOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_streamtransformoptions_free(ptr >>> 0, 1));
    StreamTransformOptions2 = class {
      static {
        __name$8(this, "StreamTransformOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StreamTransformOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_streamtransformoptions_free(ptr, 0);
      }
      /**
       * @param {Function} flush
       * @param {Function} transform
       */
      constructor(flush, transform) {
        const ret = wasm2.streamtransformoptions_new(addHeapObject2(flush), addHeapObject2(transform));
        this.__wbg_ptr = ret >>> 0;
        StreamTransformOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {Function}
       */
      get flush() {
        const ret = wasm2.streamtransformoptions_flush(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set flush(value2) {
        wasm2.streamtransformoptions_set_flush(this.__wbg_ptr, addHeapObject2(value2));
      }
      /**
       * @returns {Function}
       */
      get transform() {
        const ret = wasm2.streamtransformoptions_transform(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {Function} value
       */
      set transform(value2) {
        wasm2.streamtransformoptions_set_transform(this.__wbg_ptr, addHeapObject2(value2));
      }
    };
    TransactionFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transaction_free(ptr >>> 0, 1));
    Transaction2 = class _Transaction {
      static {
        __name$8(this, "Transaction");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Transaction.prototype);
        obj.__wbg_ptr = ptr;
        TransactionFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          inputs: this.inputs,
          outputs: this.outputs,
          version: this.version,
          lockTime: this.lockTime,
          gas: this.gas,
          subnetworkId: this.subnetworkId,
          payload: this.payload,
          mass: this.mass
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transaction_free(ptr, 0);
      }
      /**
       * Determines whether or not a transaction is a coinbase transaction. A coinbase
       * transaction is a special transaction created by miners that distributes fees and block subsidy
       * to the previous blocks' miners, and specifies the script_pub_key that will be used to pay the current
       * miner in future blocks.
       * @returns {boolean}
       */
      is_coinbase() {
        const ret = wasm2.transaction_is_coinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Recompute and finalize the tx id based on updated tx fields
       * @returns {Hash}
       */
      finalize() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Hash2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Returns the transaction ID
       * @returns {string}
       */
      get id() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_id(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {ITransaction | Transaction} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_constructor(retptr, addBorrowedObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          TransactionFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {TransactionInput[]}
       */
      get inputs() {
        const ret = wasm2.transaction_get_inputs_as_js_array(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Returns a list of unique addresses used by transaction inputs.
       * This method can be used to determine addresses used by transaction inputs
       * in order to select private keys needed for transaction signing.
       * @param {NetworkType | NetworkId | string} network_type
       * @returns {Address[]}
       */
      addresses(network_type) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_addresses(retptr, this.__wbg_ptr, addBorrowedObject2(network_type));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {(ITransactionInput | TransactionInput)[]} js_value
       */
      set inputs(js_value) {
        try {
          wasm2.transaction_set_inputs_from_js_array(this.__wbg_ptr, addBorrowedObject2(js_value));
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {TransactionOutput[]}
       */
      get outputs() {
        const ret = wasm2.transaction_get_outputs_as_js_array(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {(ITransactionOutput | TransactionOutput)[]} js_value
       */
      set outputs(js_value) {
        try {
          wasm2.transaction_set_outputs_from_js_array(this.__wbg_ptr, addBorrowedObject2(js_value));
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {number}
       */
      get version() {
        const ret = wasm2.transaction_version(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} v
       */
      set version(v) {
        wasm2.transaction_set_version(this.__wbg_ptr, v);
      }
      /**
       * @returns {bigint}
       */
      get lockTime() {
        const ret = wasm2.transaction_lockTime(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set lockTime(v) {
        wasm2.transaction_set_lockTime(this.__wbg_ptr, v);
      }
      /**
       * @returns {bigint}
       */
      get gas() {
        const ret = wasm2.transaction_gas(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set gas(v) {
        wasm2.transaction_set_gas(this.__wbg_ptr, v);
      }
      /**
       * @returns {string}
       */
      get subnetworkId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_get_subnetwork_id_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set subnetworkId(js_value) {
        wasm2.transaction_set_subnetwork_id_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {string}
       */
      get payload() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_get_payload_as_hex_string(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {any} js_value
       */
      set payload(js_value) {
        wasm2.transaction_set_payload_from_js_value(this.__wbg_ptr, addHeapObject2(js_value));
      }
      /**
       * @returns {bigint}
       */
      get mass() {
        const ret = wasm2.transaction_get_mass(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set mass(v) {
        wasm2.transaction_set_mass(this.__wbg_ptr, v);
      }
      /**
       * Serializes the transaction to a pure JavaScript Object.
       * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
       * @see {@link ISerializableTransaction}
       * @returns {ISerializableTransaction}
       */
      serializeToObject() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_serializeToObject(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Serializes the transaction to a JSON string.
       * The schema of the JSON is defined by {@link ISerializableTransaction}.
       * @returns {string}
       */
      serializeToJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_serializeToJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
       * @returns {string}
       */
      serializeToSafeJSON() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a pure JavaScript Object.
       * @param {any} js_value
       * @returns {Transaction}
       */
      static deserializeFromObject(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transaction_deserializeFromObject(retptr, addBorrowedObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a JSON string.
       * @param {string} json
       * @returns {Transaction}
       */
      static deserializeFromJSON(json) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(json, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.transaction_deserializeFromJSON(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Deserialize the {@link Transaction} Object from a "Safe" JSON schema where all `bigint` values are represented as `string`.
       * @param {string} json
       * @returns {Transaction}
       */
      static deserializeFromSafeJSON(json) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(json, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.transaction_deserializeFromSafeJSON(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _Transaction.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    TransactionInputFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactioninput_free(ptr >>> 0, 1));
    TransactionInput2 = class _TransactionInput {
      static {
        __name$8(this, "TransactionInput");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionInput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionInputFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          previousOutpoint: this.previousOutpoint,
          signatureScript: this.signatureScript,
          sequence: this.sequence,
          sigOpCount: this.sigOpCount,
          utxo: this.utxo
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionInputFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactioninput_free(ptr, 0);
      }
      /**
       * @param {ITransactionInput | TransactionInput} value
       */
      constructor(value2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactioninput_constructor(retptr, addBorrowedObject2(value2));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          TransactionInputFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get previousOutpoint() {
        const ret = wasm2.transactioninput_get_previous_outpoint(this.__wbg_ptr);
        return TransactionOutpoint2.__wrap(ret);
      }
      /**
       * @param {any} js_value
       */
      set previousOutpoint(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactioninput_set_previous_outpoint(retptr, this.__wbg_ptr, addBorrowedObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {string | undefined}
       */
      get signatureScript() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactioninput_get_signature_script_as_hex(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} js_value
       */
      set signatureScript(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactioninput_set_signature_script_from_js_value(retptr, this.__wbg_ptr, addHeapObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {bigint}
       */
      get sequence() {
        const ret = wasm2.transactioninput_get_sequence(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} sequence
       */
      set sequence(sequence) {
        wasm2.transactioninput_set_sequence(this.__wbg_ptr, sequence);
      }
      /**
       * @returns {number}
       */
      get sigOpCount() {
        const ret = wasm2.transactioninput_get_sig_op_count(this.__wbg_ptr);
        return ret;
      }
      /**
       * @param {number} sig_op_count
       */
      set sigOpCount(sig_op_count) {
        wasm2.transactioninput_set_sig_op_count(this.__wbg_ptr, sig_op_count);
      }
      /**
       * @returns {UtxoEntryReference | undefined}
       */
      get utxo() {
        const ret = wasm2.transactioninput_get_utxo(this.__wbg_ptr);
        return ret === 0 ? void 0 : UtxoEntryReference2.__wrap(ret);
      }
    };
    TransactionOutpointFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionoutpoint_free(ptr >>> 0, 1));
    TransactionOutpoint2 = class _TransactionOutpoint {
      static {
        __name$8(this, "TransactionOutpoint");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionOutpoint.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutpointFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          transactionId: this.transactionId,
          index: this.index
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutpointFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionoutpoint_free(ptr, 0);
      }
      /**
       * @param {Hash} transaction_id
       * @param {number} index
       */
      constructor(transaction_id, index) {
        _assertClass2(transaction_id, Hash2);
        var ptr0 = transaction_id.__destroy_into_raw();
        const ret = wasm2.transactionoutpoint_ctor(ptr0, index);
        this.__wbg_ptr = ret >>> 0;
        TransactionOutpointFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string}
       */
      getId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionoutpoint_getId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get transactionId() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionoutpoint_transactionId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get index() {
        const ret = wasm2.transactionoutpoint_index(this.__wbg_ptr);
        return ret >>> 0;
      }
    };
    TransactionOutputFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionoutput_free(ptr >>> 0, 1));
    TransactionOutput2 = class _TransactionOutput {
      static {
        __name$8(this, "TransactionOutput");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionOutput.prototype);
        obj.__wbg_ptr = ptr;
        TransactionOutputFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          value: this.value,
          scriptPublicKey: this.scriptPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionOutputFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionoutput_free(ptr, 0);
      }
      /**
       * TransactionOutput constructor
       * @param {bigint} value
       * @param {ScriptPublicKey} script_public_key
       */
      constructor(value2, script_public_key) {
        _assertClass2(script_public_key, ScriptPublicKey2);
        const ret = wasm2.transactionoutput_ctor(value2, script_public_key.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        TransactionOutputFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {bigint}
       */
      get value() {
        const ret = wasm2.transactionoutput_value(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} v
       */
      set value(v) {
        wasm2.transactionoutput_set_value(this.__wbg_ptr, v);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm2.transactionoutput_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey2.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} v
       */
      set scriptPublicKey(v) {
        _assertClass2(v, ScriptPublicKey2);
        wasm2.transactionoutput_set_scriptPublicKey(this.__wbg_ptr, v.__wbg_ptr);
      }
    };
    TransactionRecordFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionrecord_free(ptr >>> 0, 1));
    TransactionRecord2 = class _TransactionRecord {
      static {
        __name$8(this, "TransactionRecord");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionRecord.prototype);
        obj.__wbg_ptr = ptr;
        TransactionRecordFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          id: this.id,
          unixtimeMsec: this.unixtimeMsec,
          network: this.network,
          note: this.note,
          metadata: this.metadata,
          value: this.value,
          blockDaaScore: this.blockDaaScore,
          binding: this.binding,
          data: this.data,
          type: this.type
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionRecordFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionrecord_free(ptr, 0);
      }
      /**
       * @returns {Hash}
       */
      get id() {
        const ret = wasm2.__wbg_get_transactionrecord_id(this.__wbg_ptr);
        return Hash2.__wrap(ret);
      }
      /**
       * @param {Hash} arg0
       */
      set id(arg0) {
        _assertClass2(arg0, Hash2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_transactionrecord_id(this.__wbg_ptr, ptr0);
      }
      /**
       * Unix time in milliseconds
       * @returns {bigint | undefined}
       */
      get unixtimeMsec() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_transactionrecord_unixtimeMsec(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r2 = getDataViewMemory02().getBigInt64(retptr + 8 * 1, true);
          return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Unix time in milliseconds
       * @param {bigint | null} [arg0]
       */
      set unixtimeMsec(arg0) {
        wasm2.__wbg_set_transactionrecord_unixtimeMsec(this.__wbg_ptr, !isLikeNone2(arg0), isLikeNone2(arg0) ? BigInt(0) : arg0);
      }
      /**
       * @returns {NetworkId}
       */
      get network() {
        const ret = wasm2.__wbg_get_transactionrecord_network(this.__wbg_ptr);
        return NetworkId2.__wrap(ret);
      }
      /**
       * @param {NetworkId} arg0
       */
      set network(arg0) {
        _assertClass2(arg0, NetworkId2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_transactionrecord_network(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {string | undefined}
       */
      get note() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_transactionrecord_note(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set note(arg0) {
        var ptr0 = isLikeNone2(arg0) ? 0 : passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_transactionrecord_note(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string | undefined}
       */
      get metadata() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_transactionrecord_metadata(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set metadata(arg0) {
        var ptr0 = isLikeNone2(arg0) ? 0 : passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_transactionrecord_metadata(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @param {bigint} currentDaaScore
       * @returns {string}
       */
      maturityProgress(currentDaaScore) {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionrecord_maturityProgress(retptr, this.__wbg_ptr, addHeapObject2(currentDaaScore));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {bigint}
       */
      get value() {
        const ret = wasm2.transactionrecord_value(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm2.transactionrecord_blockDaaScore(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {IBinding}
       */
      get binding() {
        const ret = wasm2.transactionrecord_binding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {ITransactionData}
       */
      get data() {
        const ret = wasm2.transactionrecord_data(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionrecord_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Check if the transaction record has the given address within the associated UTXO set.
       * @param {Address} address
       * @returns {boolean}
       */
      hasAddress(address) {
        _assertClass2(address, Address2);
        const ret = wasm2.transactionrecord_hasAddress(this.__wbg_ptr, address.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * Serialize the transaction record to a JavaScript object.
       * @returns {any}
       */
      serialize() {
        const ret = wasm2.transactionrecord_serialize(this.__wbg_ptr);
        return takeObject2(ret);
      }
    };
    TransactionRecordNotificationFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionrecordnotification_free(ptr >>> 0, 1));
    TransactionRecordNotification2 = class _TransactionRecordNotification {
      static {
        __name$8(this, "TransactionRecordNotification");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_TransactionRecordNotification.prototype);
        obj.__wbg_ptr = ptr;
        TransactionRecordNotificationFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          type: this.type,
          data: this.data
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionRecordNotificationFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionrecordnotification_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      get type() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_transactionrecordnotification_type(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} arg0
       */
      set type(arg0) {
        const ptr0 = passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_transactionrecordnotification_type(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {TransactionRecord}
       */
      get data() {
        const ret = wasm2.__wbg_get_transactionrecordnotification_data(this.__wbg_ptr);
        return TransactionRecord2.__wrap(ret);
      }
      /**
       * @param {TransactionRecord} arg0
       */
      set data(arg0) {
        _assertClass2(arg0, TransactionRecord2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_transactionrecordnotification_data(this.__wbg_ptr, ptr0);
      }
    };
    TransactionSigningHashFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionsigninghash_free(ptr >>> 0, 1));
    TransactionSigningHash2 = class {
      static {
        __name$8(this, "TransactionSigningHash");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionSigningHashFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionsigninghash_free(ptr, 0);
      }
      constructor() {
        const ret = wasm2.transactionsigninghash_new();
        this.__wbg_ptr = ret >>> 0;
        TransactionSigningHashFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {HexString | Uint8Array} data
       */
      update(data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionsigninghash_update(retptr, this.__wbg_ptr, addHeapObject2(data));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionsigninghash_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    TransactionSigningHashECDSAFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionsigninghashecdsa_free(ptr >>> 0, 1));
    TransactionSigningHashECDSA2 = class {
      static {
        __name$8(this, "TransactionSigningHashECDSA");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionSigningHashECDSAFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionsigninghashecdsa_free(ptr, 0);
      }
      constructor() {
        const ret = wasm2.transactionsigninghashecdsa_new();
        this.__wbg_ptr = ret >>> 0;
        TransactionSigningHashECDSAFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {HexString | Uint8Array} data
       */
      update(data) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionsigninghashecdsa_update(retptr, this.__wbg_ptr, addHeapObject2(data));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      finalize() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.transactionsigninghashecdsa_finalize(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    TransactionUtxoEntryFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_transactionutxoentry_free(ptr >>> 0, 1));
    TransactionUtxoEntry2 = class {
      static {
        __name$8(this, "TransactionUtxoEntry");
      }
      toJSON() {
        return {
          amount: this.amount,
          scriptPublicKey: this.scriptPublicKey,
          blockDaaScore: this.blockDaaScore,
          isCoinbase: this.isCoinbase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TransactionUtxoEntryFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_transactionutxoentry_free(ptr, 0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm2.__wbg_get_transactionutxoentry_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm2.__wbg_set_transactionutxoentry_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm2.__wbg_get_transactionutxoentry_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey2.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} arg0
       */
      set scriptPublicKey(arg0) {
        _assertClass2(arg0, ScriptPublicKey2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_transactionutxoentry_scriptPublicKey(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm2.__wbg_get_transactionutxoentry_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set blockDaaScore(arg0) {
        wasm2.__wbg_set_transactionutxoentry_blockDaaScore(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm2.__wbg_get_transactionutxoentry_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      set isCoinbase(arg0) {
        wasm2.__wbg_set_transactionutxoentry_isCoinbase(this.__wbg_ptr, arg0);
      }
    };
    UserInfoOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_userinfooptions_free(ptr >>> 0, 1));
    UserInfoOptions2 = class _UserInfoOptions {
      static {
        __name$8(this, "UserInfoOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UserInfoOptions.prototype);
        obj.__wbg_ptr = ptr;
        UserInfoOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UserInfoOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_userinfooptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       */
      constructor(encoding) {
        const ret = wasm2.userinfooptions_new_with_values(isLikeNone2(encoding) ? 0 : addHeapObject2(encoding));
        this.__wbg_ptr = ret >>> 0;
        UserInfoOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {UserInfoOptions}
       */
      static new() {
        const ret = wasm2.userinfooptions_new();
        return _UserInfoOptions.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.userinfooptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.userinfooptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
    };
    UtxoContextFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_utxocontext_free(ptr >>> 0, 1));
    UtxoContext2 = class {
      static {
        __name$8(this, "UtxoContext");
      }
      toJSON() {
        return {
          isActive: this.isActive,
          matureLength: this.matureLength,
          balance: this.balance,
          balanceStrings: this.balanceStrings
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoContextFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_utxocontext_free(ptr, 0);
      }
      /**
       * @param {IUtxoContextArgs} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxocontext_ctor(retptr, addHeapObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoContextFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Performs a scan of the given addresses and registers them in the context for event notifications.
       * @param {(Address | string)[]} addresses
       * @param {bigint | null} [optional_current_daa_score]
       * @returns {Promise<void>}
       */
      trackAddresses(addresses, optional_current_daa_score) {
        const ret = wasm2.utxocontext_trackAddresses(this.__wbg_ptr, addHeapObject2(addresses), isLikeNone2(optional_current_daa_score) ? 0 : addHeapObject2(optional_current_daa_score));
        return takeObject2(ret);
      }
      /**
       * Unregister a list of addresses from the context. This will stop tracking of these addresses.
       * @param {(Address | string)[]} addresses
       * @returns {Promise<void>}
       */
      unregisterAddresses(addresses) {
        const ret = wasm2.utxocontext_unregisterAddresses(this.__wbg_ptr, addHeapObject2(addresses));
        return takeObject2(ret);
      }
      /**
       * Clear the UtxoContext.  Unregister all addresses and clear all UTXO entries.
       * IMPORTANT: This function must be manually called when disconnecting or re-connecting to the node
       * (followed by address re-registration).
       * @returns {Promise<void>}
       */
      clear() {
        const ret = wasm2.utxocontext_clear(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {boolean}
       */
      get isActive() {
        const ret = wasm2.utxocontext_isActive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       *
       * Returns a range of mature UTXO entries that are currently
       * managed by the UtxoContext and are available for spending.
       *
       * NOTE: This function is provided for informational purposes only.
       * **You should not manage UTXO entries manually if they are owned by UtxoContext.**
       *
       * The resulting range may be less than requested if UTXO entries
       * have been spent asynchronously by UtxoContext or by other means
       * (i.e. UtxoContext has received notification from the network that
       * UtxoEntries have been spent externally).
       *
       * UtxoEntries are kept in in the ascending sorted order by their amount.
       * @param {number} from
       * @param {number} to
       * @returns {UtxoEntryReference[]}
       */
      getMatureRange(from2, to) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxocontext_getMatureRange(retptr, this.__wbg_ptr, from2, to);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Obtain the length of the mature UTXO entries that are currently
       * managed by the UtxoContext.
       * @returns {number}
       */
      get matureLength() {
        const ret = wasm2.utxocontext_matureLength(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * Returns pending UTXO entries that are currently managed by the UtxoContext.
       * @returns {UtxoEntryReference[]}
       */
      getPending() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxocontext_getPending(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Current {@link Balance} of the UtxoContext.
       * @returns {Balance | undefined}
       */
      get balance() {
        const ret = wasm2.utxocontext_balance(this.__wbg_ptr);
        return ret === 0 ? void 0 : Balance2.__wrap(ret);
      }
      /**
       * Current {@link BalanceStrings} of the UtxoContext.
       * @returns {BalanceStrings | undefined}
       */
      get balanceStrings() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxocontext_balanceStrings(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return r0 === 0 ? void 0 : BalanceStrings2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    UtxoEntriesFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_utxoentries_free(ptr >>> 0, 1));
    UtxoEntries2 = class {
      static {
        __name$8(this, "UtxoEntries");
      }
      toJSON() {
        return {
          items: this.items
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntriesFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_utxoentries_free(ptr, 0);
      }
      /**
       * Create a new `UtxoEntries` struct with a set of entries.
       * @param {any} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoentries_js_ctor(retptr, addHeapObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoEntriesFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {any}
       */
      get items() {
        const ret = wasm2.utxoentries_get_items_as_js_array(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {any} js_value
       */
      set items(js_value) {
        try {
          wasm2.utxoentries_set_items_from_js_array(this.__wbg_ptr, addBorrowedObject2(js_value));
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Sort the contained entries by amount. Please note that
       * this function is not intended for use with large UTXO sets
       * as it duplicates the whole contained UTXO set while sorting.
       */
      sort() {
        wasm2.utxoentries_sort(this.__wbg_ptr);
      }
      /**
       * @returns {bigint}
       */
      amount() {
        const ret = wasm2.utxoentries_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
    };
    UtxoEntryFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_utxoentry_free(ptr >>> 0, 1));
    UtxoEntry2 = class _UtxoEntry {
      static {
        __name$8(this, "UtxoEntry");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UtxoEntry.prototype);
        obj.__wbg_ptr = ptr;
        UtxoEntryFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          address: this.address,
          outpoint: this.outpoint,
          amount: this.amount,
          scriptPublicKey: this.scriptPublicKey,
          blockDaaScore: this.blockDaaScore,
          isCoinbase: this.isCoinbase
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntryFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_utxoentry_free(ptr, 0);
      }
      /**
       * @returns {Address | undefined}
       */
      get address() {
        const ret = wasm2.__wbg_get_utxoentry_address(this.__wbg_ptr);
        return ret === 0 ? void 0 : Address2.__wrap(ret);
      }
      /**
       * @param {Address | null} [arg0]
       */
      set address(arg0) {
        let ptr0 = 0;
        if (!isLikeNone2(arg0)) {
          _assertClass2(arg0, Address2);
          ptr0 = arg0.__destroy_into_raw();
        }
        wasm2.__wbg_set_utxoentry_address(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get outpoint() {
        const ret = wasm2.__wbg_get_utxoentry_outpoint(this.__wbg_ptr);
        return TransactionOutpoint2.__wrap(ret);
      }
      /**
       * @param {TransactionOutpoint} arg0
       */
      set outpoint(arg0) {
        _assertClass2(arg0, TransactionOutpoint2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_utxoentry_outpoint(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm2.__wbg_get_utxoentry_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set amount(arg0) {
        wasm2.__wbg_set_utxoentry_amount(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm2.__wbg_get_utxoentry_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey2.__wrap(ret);
      }
      /**
       * @param {ScriptPublicKey} arg0
       */
      set scriptPublicKey(arg0) {
        _assertClass2(arg0, ScriptPublicKey2);
        var ptr0 = arg0.__destroy_into_raw();
        wasm2.__wbg_set_utxoentry_scriptPublicKey(this.__wbg_ptr, ptr0);
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm2.__wbg_get_utxoentry_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @param {bigint} arg0
       */
      set blockDaaScore(arg0) {
        wasm2.__wbg_set_utxoentry_blockDaaScore(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm2.__wbg_get_utxoentry_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      set isCoinbase(arg0) {
        wasm2.__wbg_set_utxoentry_isCoinbase(this.__wbg_ptr, arg0);
      }
      /**
       * @returns {string}
       */
      toString() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoentry_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    UtxoEntryReferenceFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_utxoentryreference_free(ptr >>> 0, 1));
    UtxoEntryReference2 = class _UtxoEntryReference {
      static {
        __name$8(this, "UtxoEntryReference");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_UtxoEntryReference.prototype);
        obj.__wbg_ptr = ptr;
        UtxoEntryReferenceFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          entry: this.entry,
          outpoint: this.outpoint,
          address: this.address,
          amount: this.amount,
          isCoinbase: this.isCoinbase,
          blockDaaScore: this.blockDaaScore,
          scriptPublicKey: this.scriptPublicKey
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoEntryReferenceFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_utxoentryreference_free(ptr, 0);
      }
      /**
       * @returns {string}
       */
      toString() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoentryreference_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return takeObject2(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {UtxoEntry}
       */
      get entry() {
        const ret = wasm2.utxoentryreference_entry(this.__wbg_ptr);
        return UtxoEntry2.__wrap(ret);
      }
      /**
       * @returns {TransactionOutpoint}
       */
      get outpoint() {
        const ret = wasm2.utxoentryreference_outpoint(this.__wbg_ptr);
        return TransactionOutpoint2.__wrap(ret);
      }
      /**
       * @returns {Address | undefined}
       */
      get address() {
        const ret = wasm2.utxoentryreference_address(this.__wbg_ptr);
        return ret === 0 ? void 0 : Address2.__wrap(ret);
      }
      /**
       * @returns {bigint}
       */
      get amount() {
        const ret = wasm2.utxoentryreference_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @returns {boolean}
       */
      get isCoinbase() {
        const ret = wasm2.utxoentryreference_isCoinbase(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @returns {bigint}
       */
      get blockDaaScore() {
        const ret = wasm2.utxoentryreference_blockDaaScore(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
      }
      /**
       * @returns {ScriptPublicKey}
       */
      get scriptPublicKey() {
        const ret = wasm2.utxoentryreference_scriptPublicKey(this.__wbg_ptr);
        return ScriptPublicKey2.__wrap(ret);
      }
    };
    UtxoProcessorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_utxoprocessor_free(ptr >>> 0, 1));
    UtxoProcessor2 = class {
      static {
        __name$8(this, "UtxoProcessor");
      }
      toJSON() {
        return {
          rpc: this.rpc,
          networkId: this.networkId,
          isActive: this.isActive
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UtxoProcessorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_utxoprocessor_free(ptr, 0);
      }
      /**
       * @param {string | UtxoProcessorNotificationCallback} event
       * @param {UtxoProcessorNotificationCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_addEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {UtxoProcessorEventType | UtxoProcessorEventType[] | string | string[]} event
       * @param {UtxoProcessorNotificationCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_removeEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * UtxoProcessor constructor.
       *
       *
       *
       * @see {@link IUtxoProcessorArgs}
       * @param {IUtxoProcessorArgs} js_value
       */
      constructor(js_value) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_ctor(retptr, addHeapObject2(js_value));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          UtxoProcessorFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Starts the UtxoProcessor and begins processing UTXO and other notifications.
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm2.utxoprocessor_start(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * Stops the UtxoProcessor and ends processing UTXO and other notifications.
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm2.utxoprocessor_stop(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {RpcClient}
       */
      get rpc() {
        const ret = wasm2.utxoprocessor_rpc(this.__wbg_ptr);
        return RpcClient2.__wrap(ret);
      }
      /**
       * @returns {string | undefined}
       */
      get networkId() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_networkId(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_setNetworkId(retptr, this.__wbg_ptr, addBorrowedObject2(network_id));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @returns {boolean}
       */
      get isActive() {
        const ret = wasm2.utxoprocessor_isActive(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       *
       * Set the coinbase transaction maturity period DAA score for a given network.
       * This controls the DAA period after which the user transactions are considered mature
       * and the wallet subsystem emits the transaction maturity event.
       *
       * @see {@link TransactionRecord}
       * @see {@link IUtxoProcessorEvent}
       *
       * @category Wallet SDK
       * @param {NetworkId | string} network_id
       * @param {bigint} value
       */
      static setCoinbaseTransactionMaturityDAA(network_id, value2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_setCoinbaseTransactionMaturityDAA(retptr, addBorrowedObject2(network_id), value2);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       *
       * Set the user transaction maturity period DAA score for a given network.
       * This controls the DAA period after which the user transactions are considered mature
       * and the wallet subsystem emits the transaction maturity event.
       *
       * @see {@link TransactionRecord}
       * @see {@link IUtxoProcessorEvent}
       *
       * @category Wallet SDK
       * @param {NetworkId | string} network_id
       * @param {bigint} value
       */
      static setUserTransactionMaturityDAA(network_id, value2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.utxoprocessor_setUserTransactionMaturityDAA(retptr, addBorrowedObject2(network_id), value2);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    WalletFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_wallet_free(ptr >>> 0, 1));
    Wallet2 = class {
      static {
        __name$8(this, "Wallet");
      }
      toJSON() {
        return {
          rpc: this.rpc,
          isOpen: this.isOpen,
          isSynced: this.isSynced,
          descriptor: this.descriptor
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_wallet_free(ptr, 0);
      }
      /**
       * @param {IWalletConfig} config
       */
      constructor(config) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.wallet_constructor(retptr, addHeapObject2(config));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          WalletFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {RpcClient}
       */
      get rpc() {
        const ret = wasm2.wallet_rpc(this.__wbg_ptr);
        return RpcClient2.__wrap(ret);
      }
      /**
       * @remarks This is a local property indicating
       * if the wallet is currently open.
       * @returns {boolean}
       */
      get isOpen() {
        const ret = wasm2.wallet_isOpen(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @remarks This is a local property indicating
       * if the node is currently synced.
       * @returns {boolean}
       */
      get isSynced() {
        const ret = wasm2.wallet_isSynced(this.__wbg_ptr);
        return ret !== 0;
      }
      /**
       * @returns {WalletDescriptor | undefined}
       */
      get descriptor() {
        const ret = wasm2.wallet_descriptor(this.__wbg_ptr);
        return ret === 0 ? void 0 : WalletDescriptor2.__wrap(ret);
      }
      /**
       * Check if a wallet with a given name exists.
       * @param {string | null} [name]
       * @returns {Promise<boolean>}
       */
      exists(name2) {
        var ptr0 = isLikeNone2(name2) ? 0 : passStringToWasm02(name2, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.wallet_exists(this.__wbg_ptr, ptr0, len0);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      start() {
        const ret = wasm2.wallet_start(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      stop() {
        const ret = wasm2.wallet_stop(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {IConnectOptions | undefined | null} [args]
       * @returns {Promise<void>}
       */
      connect(args) {
        const ret = wasm2.wallet_connect(this.__wbg_ptr, isLikeNone2(args) ? 0 : addHeapObject2(args));
        return takeObject2(ret);
      }
      /**
       * @returns {Promise<void>}
       */
      disconnect() {
        const ret = wasm2.wallet_disconnect(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | WalletNotificationCallback} event
       * @param {WalletNotificationCallback | null} [callback]
       */
      addEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.wallet_addEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {WalletEventType | WalletEventType[] | string | string[]} event
       * @param {WalletNotificationCallback | null} [callback]
       */
      removeEventListener(event, callback) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.wallet_removeEventListener(retptr, this.__wbg_ptr, addHeapObject2(event), isLikeNone2(callback) ? 0 : addHeapObject2(callback));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {NetworkId | string} network_id
       */
      setNetworkId(network_id) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.wallet_setNetworkId(retptr, this.__wbg_ptr, addHeapObject2(network_id));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          if (r1) {
            throw takeObject2(r0);
          }
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Ping backend
       * @see {@link IBatchRequest} {@link IBatchResponse}
       * @throws `string` in case of an error.
       * @param {IBatchRequest} request
       * @returns {Promise<IBatchResponse>}
       */
      batch(request) {
        const ret = wasm2.wallet_batch(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IFlushRequest} {@link IFlushResponse}
       * @throws `string` in case of an error.
       * @param {IFlushRequest} request
       * @returns {Promise<IFlushResponse>}
       */
      flush(request) {
        const ret = wasm2.wallet_flush(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IRetainContextRequest} {@link IRetainContextResponse}
       * @throws `string` in case of an error.
       * @param {IRetainContextRequest} request
       * @returns {Promise<IRetainContextResponse>}
       */
      retainContext(request) {
        const ret = wasm2.wallet_retainContext(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IGetStatusRequest} {@link IGetStatusResponse}
       * @throws `string` in case of an error.
       * @param {IGetStatusRequest} request
       * @returns {Promise<IGetStatusResponse>}
       */
      getStatus(request) {
        const ret = wasm2.wallet_getStatus(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletEnumerateRequest} {@link IWalletEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IWalletEnumerateRequest} request
       * @returns {Promise<IWalletEnumerateResponse>}
       */
      walletEnumerate(request) {
        const ret = wasm2.wallet_walletEnumerate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletCreateRequest} {@link IWalletCreateResponse}
       * @throws `string` in case of an error.
       * @param {IWalletCreateRequest} request
       * @returns {Promise<IWalletCreateResponse>}
       */
      walletCreate(request) {
        const ret = wasm2.wallet_walletCreate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletOpenRequest} {@link IWalletOpenResponse}
       * @throws `string` in case of an error.
       * @param {IWalletOpenRequest} request
       * @returns {Promise<IWalletOpenResponse>}
       */
      walletOpen(request) {
        const ret = wasm2.wallet_walletOpen(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletReloadRequest} {@link IWalletReloadResponse}
       * @throws `string` in case of an error.
       * @param {IWalletReloadRequest} request
       * @returns {Promise<IWalletReloadResponse>}
       */
      walletReload(request) {
        const ret = wasm2.wallet_walletReload(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletCloseRequest} {@link IWalletCloseResponse}
       * @throws `string` in case of an error.
       * @param {IWalletCloseRequest} request
       * @returns {Promise<IWalletCloseResponse>}
       */
      walletClose(request) {
        const ret = wasm2.wallet_walletClose(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletChangeSecretRequest} {@link IWalletChangeSecretResponse}
       * @throws `string` in case of an error.
       * @param {IWalletChangeSecretRequest} request
       * @returns {Promise<IWalletChangeSecretResponse>}
       */
      walletChangeSecret(request) {
        const ret = wasm2.wallet_walletChangeSecret(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletExportRequest} {@link IWalletExportResponse}
       * @throws `string` in case of an error.
       * @param {IWalletExportRequest} request
       * @returns {Promise<IWalletExportResponse>}
       */
      walletExport(request) {
        const ret = wasm2.wallet_walletExport(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IWalletImportRequest} {@link IWalletImportResponse}
       * @throws `string` in case of an error.
       * @param {IWalletImportRequest} request
       * @returns {Promise<IWalletImportResponse>}
       */
      walletImport(request) {
        const ret = wasm2.wallet_walletImport(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IPrvKeyDataEnumerateRequest} {@link IPrvKeyDataEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataEnumerateRequest} request
       * @returns {Promise<IPrvKeyDataEnumerateResponse>}
       */
      prvKeyDataEnumerate(request) {
        const ret = wasm2.wallet_prvKeyDataEnumerate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IPrvKeyDataCreateRequest} {@link IPrvKeyDataCreateResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataCreateRequest} request
       * @returns {Promise<IPrvKeyDataCreateResponse>}
       */
      prvKeyDataCreate(request) {
        const ret = wasm2.wallet_prvKeyDataCreate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IPrvKeyDataRemoveRequest} {@link IPrvKeyDataRemoveResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataRemoveRequest} request
       * @returns {Promise<IPrvKeyDataRemoveResponse>}
       */
      prvKeyDataRemove(request) {
        const ret = wasm2.wallet_prvKeyDataRemove(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IPrvKeyDataGetRequest} {@link IPrvKeyDataGetResponse}
       * @throws `string` in case of an error.
       * @param {IPrvKeyDataGetRequest} request
       * @returns {Promise<IPrvKeyDataGetResponse>}
       */
      prvKeyDataGet(request) {
        const ret = wasm2.wallet_prvKeyDataGet(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsEnumerateRequest} {@link IAccountsEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEnumerateRequest} request
       * @returns {Promise<IAccountsEnumerateResponse>}
       */
      accountsEnumerate(request) {
        const ret = wasm2.wallet_accountsEnumerate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsRenameRequest} {@link IAccountsRenameResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsRenameRequest} request
       * @returns {Promise<IAccountsRenameResponse>}
       */
      accountsRename(request) {
        const ret = wasm2.wallet_accountsRename(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsDiscoveryRequest} {@link IAccountsDiscoveryResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsDiscoveryRequest} request
       * @returns {Promise<IAccountsDiscoveryResponse>}
       */
      accountsDiscovery(request) {
        const ret = wasm2.wallet_accountsDiscovery(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsCreateRequest} {@link IAccountsCreateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCreateRequest} request
       * @returns {Promise<IAccountsCreateResponse>}
       */
      accountsCreate(request) {
        const ret = wasm2.wallet_accountsCreate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsEnsureDefaultRequest} {@link IAccountsEnsureDefaultResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEnsureDefaultRequest} request
       * @returns {Promise<IAccountsEnsureDefaultResponse>}
       */
      accountsEnsureDefault(request) {
        const ret = wasm2.wallet_accountsEnsureDefault(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsImportRequest} {@link IAccountsImportResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsImportRequest} request
       * @returns {Promise<IAccountsImportResponse>}
       */
      accountsImport(request) {
        const ret = wasm2.wallet_accountsImport(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsActivateRequest} {@link IAccountsActivateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsActivateRequest} request
       * @returns {Promise<IAccountsActivateResponse>}
       */
      accountsActivate(request) {
        const ret = wasm2.wallet_accountsActivate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsDeactivateRequest} {@link IAccountsDeactivateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsDeactivateRequest} request
       * @returns {Promise<IAccountsDeactivateResponse>}
       */
      accountsDeactivate(request) {
        const ret = wasm2.wallet_accountsDeactivate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsGetRequest} {@link IAccountsGetResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsGetRequest} request
       * @returns {Promise<IAccountsGetResponse>}
       */
      accountsGet(request) {
        const ret = wasm2.wallet_accountsGet(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsCreateNewAddressRequest} {@link IAccountsCreateNewAddressResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCreateNewAddressRequest} request
       * @returns {Promise<IAccountsCreateNewAddressResponse>}
       */
      accountsCreateNewAddress(request) {
        const ret = wasm2.wallet_accountsCreateNewAddress(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsSendRequest} {@link IAccountsSendResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsSendRequest} request
       * @returns {Promise<IAccountsSendResponse>}
       */
      accountsSend(request) {
        const ret = wasm2.wallet_accountsSend(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsPskbSignRequest} {@link IAccountsPskbSignResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbSignRequest} request
       * @returns {Promise<IAccountsPskbSignResponse>}
       */
      accountsPskbSign(request) {
        const ret = wasm2.wallet_accountsPskbSign(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsPskbBroadcastRequest} {@link IAccountsPskbBroadcastResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbBroadcastRequest} request
       * @returns {Promise<IAccountsPskbBroadcastResponse>}
       */
      accountsPskbBroadcast(request) {
        const ret = wasm2.wallet_accountsPskbBroadcast(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsPskbSendRequest} {@link IAccountsPskbSendResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsPskbSendRequest} request
       * @returns {Promise<IAccountsPskbSendResponse>}
       */
      accountsPskbSend(request) {
        const ret = wasm2.wallet_accountsPskbSend(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsGetUtxosRequest} {@link IAccountsGetUtxosResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsGetUtxosRequest} request
       * @returns {Promise<IAccountsGetUtxosResponse>}
       */
      accountsGetUtxos(request) {
        const ret = wasm2.wallet_accountsGetUtxos(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsTransferRequest} {@link IAccountsTransferResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsTransferRequest} request
       * @returns {Promise<IAccountsTransferResponse>}
       */
      accountsTransfer(request) {
        const ret = wasm2.wallet_accountsTransfer(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsEstimateRequest} {@link IAccountsEstimateResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsEstimateRequest} request
       * @returns {Promise<IAccountsEstimateResponse>}
       */
      accountsEstimate(request) {
        const ret = wasm2.wallet_accountsEstimate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link ITransactionsDataGetRequest} {@link ITransactionsDataGetResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsDataGetRequest} request
       * @returns {Promise<ITransactionsDataGetResponse>}
       */
      transactionsDataGet(request) {
        const ret = wasm2.wallet_transactionsDataGet(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link ITransactionsReplaceNoteRequest} {@link ITransactionsReplaceNoteResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsReplaceNoteRequest} request
       * @returns {Promise<ITransactionsReplaceNoteResponse>}
       */
      transactionsReplaceNote(request) {
        const ret = wasm2.wallet_transactionsReplaceNote(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link ITransactionsReplaceMetadataRequest} {@link ITransactionsReplaceMetadataResponse}
       * @throws `string` in case of an error.
       * @param {ITransactionsReplaceMetadataRequest} request
       * @returns {Promise<ITransactionsReplaceMetadataResponse>}
       */
      transactionsReplaceMetadata(request) {
        const ret = wasm2.wallet_transactionsReplaceMetadata(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAddressBookEnumerateRequest} {@link IAddressBookEnumerateResponse}
       * @throws `string` in case of an error.
       * @param {IAddressBookEnumerateRequest} request
       * @returns {Promise<IAddressBookEnumerateResponse>}
       */
      addressBookEnumerate(request) {
        const ret = wasm2.wallet_addressBookEnumerate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IFeeRateEstimateRequest} {@link IFeeRateEstimateResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRateEstimateRequest} request
       * @returns {Promise<IFeeRateEstimateResponse>}
       */
      feeRateEstimate(request) {
        const ret = wasm2.wallet_feeRateEstimate(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IFeeRatePollerEnableRequest} {@link IFeeRatePollerEnableResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRatePollerEnableRequest} request
       * @returns {Promise<IFeeRatePollerEnableResponse>}
       */
      feeRatePollerEnable(request) {
        const ret = wasm2.wallet_feeRatePollerEnable(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IFeeRatePollerDisableRequest} {@link IFeeRatePollerDisableResponse}
       * @throws `string` in case of an error.
       * @param {IFeeRatePollerDisableRequest} request
       * @returns {Promise<IFeeRatePollerDisableResponse>}
       */
      feeRatePollerDisable(request) {
        const ret = wasm2.wallet_feeRatePollerDisable(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsCommitRevealRequest} {@link IAccountsCommitRevealResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCommitRevealRequest} request
       * @returns {Promise<IAccountsCommitRevealResponse>}
       */
      accountsCommitReveal(request) {
        const ret = wasm2.wallet_accountsCommitReveal(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
      /**
       * @see {@link IAccountsCommitRevealManualRequest} {@link IAccountsCommitRevealManualResponse}
       * @throws `string` in case of an error.
       * @param {IAccountsCommitRevealManualRequest} request
       * @returns {Promise<IAccountsCommitRevealManualResponse>}
       */
      accountsCommitRevealManual(request) {
        const ret = wasm2.wallet_accountsCommitRevealManual(this.__wbg_ptr, addHeapObject2(request));
        return takeObject2(ret);
      }
    };
    WalletDescriptorFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_walletdescriptor_free(ptr >>> 0, 1));
    WalletDescriptor2 = class _WalletDescriptor {
      static {
        __name$8(this, "WalletDescriptor");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_WalletDescriptor.prototype);
        obj.__wbg_ptr = ptr;
        WalletDescriptorFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          title: this.title,
          filename: this.filename
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletDescriptorFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_walletdescriptor_free(ptr, 0);
      }
      /**
       * @returns {string | undefined}
       */
      get title() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_walletdescriptor_title(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string | null} [arg0]
       */
      set title(arg0) {
        var ptr0 = isLikeNone2(arg0) ? 0 : passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        var len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_walletdescriptor_title(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {string}
       */
      get filename() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.__wbg_get_walletdescriptor_filename(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @param {string} arg0
       */
      set filename(arg0) {
        const ptr0 = passStringToWasm02(arg0, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN2;
        wasm2.__wbg_set_walletdescriptor_filename(this.__wbg_ptr, ptr0, len0);
      }
    };
    WasiOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_wasioptions_free(ptr >>> 0, 1));
    WasiOptions2 = class _WasiOptions {
      static {
        __name$8(this, "WasiOptions");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_WasiOptions.prototype);
        obj.__wbg_ptr = ptr;
        WasiOptionsFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasiOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_wasioptions_free(ptr, 0);
      }
      /**
       * @param {any[] | null | undefined} args
       * @param {object | null | undefined} env
       * @param {object} preopens
       */
      constructor(args, env, preopens) {
        var ptr0 = isLikeNone2(args) ? 0 : passArrayJsValueToWasm02(args, wasm2.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN2;
        const ret = wasm2.wasioptions_new_with_values(ptr0, len0, isLikeNone2(env) ? 0 : addHeapObject2(env), addHeapObject2(preopens));
        this.__wbg_ptr = ret >>> 0;
        WasiOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @param {object} preopens
       * @returns {WasiOptions}
       */
      static new(preopens) {
        const ret = wasm2.wasioptions_new(addHeapObject2(preopens));
        return _WasiOptions.__wrap(ret);
      }
      /**
       * @returns {any[] | undefined}
       */
      get args() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.wasioptions_args(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getArrayJsValueFromWasm02(r0, r1).slice();
            wasm2.__wbindgen_export_3(r0, r1 * 4, 4);
          }
          return v1;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any[] | null} [value]
       */
      set args(value2) {
        var ptr0 = isLikeNone2(value2) ? 0 : passArrayJsValueToWasm02(value2, wasm2.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN2;
        wasm2.wasioptions_set_args(this.__wbg_ptr, ptr0, len0);
      }
      /**
       * @returns {object | undefined}
       */
      get env() {
        const ret = wasm2.wasioptions_env(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {object | null} [value]
       */
      set env(value2) {
        wasm2.wasioptions_set_env(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {object}
       */
      get preopens() {
        const ret = wasm2.wasioptions_preopens(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {object} value
       */
      set preopens(value2) {
        wasm2.wasioptions_set_preopens(this.__wbg_ptr, addHeapObject2(value2));
      }
    };
    WriteFileSyncOptionsFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_writefilesyncoptions_free(ptr >>> 0, 1));
    WriteFileSyncOptions2 = class {
      static {
        __name$8(this, "WriteFileSyncOptions");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WriteFileSyncOptionsFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_writefilesyncoptions_free(ptr, 0);
      }
      /**
       * @param {string | null} [encoding]
       * @param {string | null} [flag]
       * @param {number | null} [mode]
       */
      constructor(encoding, flag, mode) {
        const ret = wasm2.writefilesyncoptions_new(isLikeNone2(encoding) ? 0 : addHeapObject2(encoding), isLikeNone2(flag) ? 0 : addHeapObject2(flag), isLikeNone2(mode) ? 4294967297 : mode >>> 0);
        this.__wbg_ptr = ret >>> 0;
        WriteFileSyncOptionsFinalization2.register(this, this.__wbg_ptr, this);
        return this;
      }
      /**
       * @returns {string | undefined}
       */
      get encoding() {
        const ret = wasm2.writefilesyncoptions_encoding(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set encoding(value2) {
        wasm2.writefilesyncoptions_set_encoding(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {string | undefined}
       */
      get flag() {
        const ret = wasm2.writefilesyncoptions_flag(this.__wbg_ptr);
        return takeObject2(ret);
      }
      /**
       * @param {string | null} [value]
       */
      set flag(value2) {
        wasm2.writefilesyncoptions_set_flag(this.__wbg_ptr, isLikeNone2(value2) ? 0 : addHeapObject2(value2));
      }
      /**
       * @returns {number | undefined}
       */
      get mode() {
        const ret = wasm2.writefilesyncoptions_mode(this.__wbg_ptr);
        return ret === 4294967297 ? void 0 : ret;
      }
      /**
       * @param {number | null} [value]
       */
      set mode(value2) {
        wasm2.writefilesyncoptions_set_mode(this.__wbg_ptr, isLikeNone2(value2) ? 4294967297 : value2 >>> 0);
      }
    };
    WriteStreamFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_writestream_free(ptr >>> 0, 1));
    WriteStream2 = class {
      static {
        __name$8(this, "WriteStream");
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WriteStreamFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_writestream_free(ptr, 0);
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_open(listener) {
        try {
          const ret = wasm2.writestream_add_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      add_listener_with_close(listener) {
        try {
          const ret = wasm2.writestream_add_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_open(listener) {
        try {
          const ret = wasm2.writestream_on_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      on_with_close(listener) {
        try {
          const ret = wasm2.writestream_on_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_open(listener) {
        try {
          const ret = wasm2.writestream_once_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      once_with_close(listener) {
        try {
          const ret = wasm2.writestream_once_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_open(listener) {
        try {
          const ret = wasm2.writestream_prepend_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_listener_with_close(listener) {
        try {
          const ret = wasm2.writestream_prepend_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_open(listener) {
        try {
          const ret = wasm2.writestream_prepend_once_listener_with_open(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Function} listener
       * @returns {any}
       */
      prepend_once_listener_with_close(listener) {
        try {
          const ret = wasm2.writestream_prepend_once_listener_with_close(this.__wbg_ptr, addBorrowedObject2(listener));
          return takeObject2(ret);
        } finally {
          heap2[stack_pointer2++] = void 0;
        }
      }
    };
    XOnlyPublicKeyFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_xonlypublickey_free(ptr >>> 0, 1));
    XOnlyPublicKey2 = class _XOnlyPublicKey {
      static {
        __name$8(this, "XOnlyPublicKey");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XOnlyPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        XOnlyPublicKeyFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XOnlyPublicKeyFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_xonlypublickey_free(ptr, 0);
      }
      /**
       * @param {string} key
       */
      constructor(key2) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(key2, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.xonlypublickey_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XOnlyPublicKeyFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xonlypublickey_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * Get the [`Address`] of this XOnlyPublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddress(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xonlypublickey_toAddress(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * Get `ECDSA` [`Address`] of this XOnlyPublicKey.
       * Receives a [`NetworkType`] to determine the prefix of the address.
       * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
       * @param {NetworkType | NetworkId | string} network
       * @returns {Address}
       */
      toAddressECDSA(network) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xonlypublickey_toAddressECDSA(retptr, this.__wbg_ptr, addBorrowedObject2(network));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return Address2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {Address} address
       * @returns {XOnlyPublicKey}
       */
      static fromAddress(address) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          _assertClass2(address, Address2);
          wasm2.xonlypublickey_fromAddress(retptr, address.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XOnlyPublicKey.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
    };
    XPrvFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_xprv_free(ptr >>> 0, 1));
    XPrv2 = class _XPrv {
      static {
        __name$8(this, "XPrv");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XPrv.prototype);
        obj.__wbg_ptr = ptr;
        XPrvFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          xprv: this.xprv,
          privateKey: this.privateKey,
          depth: this.depth,
          parentFingerprint: this.parentFingerprint,
          childNumber: this.childNumber,
          chainCode: this.chainCode
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XPrvFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_xprv_free(ptr, 0);
      }
      /**
       * @param {HexString} seed
       */
      constructor(seed) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_try_new(retptr, addHeapObject2(seed));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XPrvFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * Create {@link XPrv} from `xprvxxxx..` string
       * @param {string} xprv
       * @returns {XPrv}
       */
      static fromXPrv(xprv) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(xprv, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.xprv_fromXPrv(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       * @returns {XPrv}
       */
      deriveChild(child_number, hardened) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_deriveChild(retptr, this.__wbg_ptr, child_number, isLikeNone2(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} path
       * @returns {XPrv}
       */
      derivePath(path) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_derivePath(retptr, this.__wbg_ptr, addBorrowedObject2(path));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XPrv.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {string} prefix
       * @returns {string}
       */
      intoString(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(prefix, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.xprv_intoString(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject2(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm02(ptr2, len2);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      toString() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {XPub}
       */
      toXPub() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_toXPub(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return XPub2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {PrivateKey}
       */
      toPrivateKey() {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_toPrivateKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return PrivateKey2.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @returns {string}
       */
      get xprv() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_toString(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {string}
       */
      get privateKey() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_privateKey(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get depth() {
        const ret = wasm2.xprv_depth(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {string}
       */
      get parentFingerprint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_parentFingerprint(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get childNumber() {
        const ret = wasm2.xprv_childNumber(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {string}
       */
      get chainCode() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xprv_chainCode(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    XPubFinalization2 = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name$8(() => {
    }, "register"), unregister: /* @__PURE__ */ __name$8(() => {
    }, "unregister") } : new FinalizationRegistry((ptr) => wasm2.__wbg_xpub_free(ptr >>> 0, 1));
    XPub2 = class _XPub {
      static {
        __name$8(this, "XPub");
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_XPub.prototype);
        obj.__wbg_ptr = ptr;
        XPubFinalization2.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      toJSON() {
        return {
          xpub: this.xpub,
          depth: this.depth,
          parentFingerprint: this.parentFingerprint,
          childNumber: this.childNumber,
          chainCode: this.chainCode
        };
      }
      toString() {
        return JSON.stringify(this);
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        XPubFinalization2.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm2.__wbg_xpub_free(ptr, 0);
      }
      /**
       * @param {string} xpub
       */
      constructor(xpub) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(xpub, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.xpub_try_new(retptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          this.__wbg_ptr = r0 >>> 0;
          XPubFinalization2.register(this, this.__wbg_ptr, this);
          return this;
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} child_number
       * @param {boolean | null} [hardened]
       * @returns {XPub}
       */
      deriveChild(child_number, hardened) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xpub_deriveChild(retptr, this.__wbg_ptr, child_number, isLikeNone2(hardened) ? 16777215 : hardened ? 1 : 0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XPub.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {any} path
       * @returns {XPub}
       */
      derivePath(path) {
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xpub_derivePath(retptr, this.__wbg_ptr, addBorrowedObject2(path));
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject2(r1);
          }
          return _XPub.__wrap(r0);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          heap2[stack_pointer2++] = void 0;
        }
      }
      /**
       * @param {string} prefix
       * @returns {string}
       */
      intoString(prefix) {
        let deferred3_0;
        let deferred3_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm02(prefix, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN2;
          wasm2.xpub_intoString(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr2 = r0;
          var len2 = r1;
          if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject2(r2);
          }
          deferred3_0 = ptr2;
          deferred3_1 = len2;
          return getStringFromWasm02(ptr2, len2);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
        }
      }
      /**
       * @returns {PublicKey}
       */
      toPublicKey() {
        const ret = wasm2.xpub_toPublicKey(this.__wbg_ptr);
        return PublicKey2.__wrap(ret);
      }
      /**
       * @returns {string}
       */
      get xpub() {
        let deferred2_0;
        let deferred2_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xpub_xpub(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory02().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory02().getInt32(retptr + 4 * 3, true);
          var ptr1 = r0;
          var len1 = r1;
          if (r3) {
            ptr1 = 0;
            len1 = 0;
            throw takeObject2(r2);
          }
          deferred2_0 = ptr1;
          deferred2_1 = len1;
          return getStringFromWasm02(ptr1, len1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get depth() {
        const ret = wasm2.xpub_depth(this.__wbg_ptr);
        return ret;
      }
      /**
       * @returns {string}
       */
      get parentFingerprint() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xpub_parentFingerprint(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
      /**
       * @returns {number}
       */
      get childNumber() {
        const ret = wasm2.xpub_childNumber(this.__wbg_ptr);
        return ret >>> 0;
      }
      /**
       * @returns {string}
       */
      get chainCode() {
        let deferred1_0;
        let deferred1_1;
        try {
          const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
          wasm2.xpub_chainCode(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory02().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory02().getInt32(retptr + 4 * 1, true);
          deferred1_0 = r0;
          deferred1_1 = r1;
          return getStringFromWasm02(r0, r1);
        } finally {
          wasm2.__wbindgen_add_to_stack_pointer(16);
          wasm2.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
        }
      }
    };
    __name$8(__wbg_load2, "__wbg_load");
    __name$8(__wbg_get_imports2, "__wbg_get_imports");
    __name$8(__wbg_init_memory2, "__wbg_init_memory");
    __name$8(__wbg_finalize_init2, "__wbg_finalize_init");
    __name$8(initSync2, "initSync");
    __name$8(__wbg_init2, "__wbg_init");
    kaspa_default2 = __wbg_init2;
  }
});
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isNode = typeof process !== "undefined" && process.versions && process.versions.node;
var isWebWorker = typeof self !== "undefined" && typeof self.importScripts === "function";
function detectPlatform() {
  if (isNode) {
    return "node";
  }
  if (isWebWorker) {
    return "webworker";
  }
  if (isBrowser) {
    return "browser";
  }
  return "node";
}
__name$8(detectPlatform, "detectPlatform");
init_kaspa();
var wasmModule = null;
var isInitialized = false;
function getWasmUrl() {
  const platform = detectPlatform();
  if (platform === "node") {
    return new URL("/assets/kaspa_bg-DfnGiCXH.wasm", import.meta.url).href;
  } else {
    return new URL("/assets/kaspa_bg-DfnGiCXH.wasm", import.meta.url).href;
  }
}
__name$8(getWasmUrl, "getWasmUrl");
async function loadWasmModule() {
  if (wasmModule) {
    return wasmModule;
  }
  const platform = detectPlatform();
  try {
    if (platform === "node") {
      const module2 = await Promise.resolve().then(() => (init_kaspa2(), kaspa_exports2));
      wasmModule = module2;
    } else {
      const module2 = await Promise.resolve().then(() => (init_kaspa(), kaspa_exports));
      wasmModule = module2;
    }
    return wasmModule;
  } catch (error) {
    throw new Error(`Failed to load kaspa-wasm for platform ${platform}: ${error}`);
  }
}
__name$8(loadWasmModule, "loadWasmModule");
async function initKaspaWasm() {
  if (isInitialized) {
    return;
  }
  const module2 = await loadWasmModule();
  if (typeof module2.default === "function") {
    const wasmBinaryUrl = getWasmUrl();
    await module2.default({ module_or_path: wasmBinaryUrl });
  }
  isInitialized = true;
}
__name$8(initKaspaWasm, "initKaspaWasm");
async function getKaspaWasm() {
  const module2 = await loadWasmModule();
  return module2;
}
__name$8(getKaspaWasm, "getKaspaWasm");
async function getAddress() {
  const module2 = await getKaspaWasm();
  return module2.Address;
}
__name$8(getAddress, "getAddress");
async function getGenerator() {
  const module2 = await getKaspaWasm();
  return module2.Generator;
}
__name$8(getGenerator, "getGenerator");
async function getPaymentOutput() {
  const module2 = await getKaspaWasm();
  return module2.PaymentOutput;
}
__name$8(getPaymentOutput, "getPaymentOutput");
async function getPendingTransaction() {
  const module2 = await getKaspaWasm();
  return module2.PendingTransaction;
}
__name$8(getPendingTransaction, "getPendingTransaction");
async function getPrivateKeyGenerator() {
  const module2 = await getKaspaWasm();
  return module2.PrivateKeyGenerator;
}
__name$8(getPrivateKeyGenerator, "getPrivateKeyGenerator");
async function getPublicKeyGenerator() {
  const module2 = await getKaspaWasm();
  return module2.PublicKeyGenerator;
}
__name$8(getPublicKeyGenerator, "getPublicKeyGenerator");
async function getRpcClient() {
  const module2 = await getKaspaWasm();
  return module2.RpcClient;
}
__name$8(getRpcClient, "getRpcClient");
async function getResolver() {
  const module2 = await getKaspaWasm();
  return module2.Resolver;
}
__name$8(getResolver, "getResolver");
async function getEncoding() {
  const module2 = await getKaspaWasm();
  return module2.Encoding;
}
__name$8(getEncoding, "getEncoding");
async function getNetworkId() {
  const module2 = await getKaspaWasm();
  return module2.NetworkId;
}
__name$8(getNetworkId, "getNetworkId");
async function getInitSync() {
  const module2 = await getKaspaWasm();
  return module2.initSync;
}
__name$8(getInitSync, "getInitSync");
async function getUtxoContext() {
  const module2 = await getKaspaWasm();
  return module2.UtxoContext;
}
__name$8(getUtxoContext, "getUtxoContext");
async function getUtxoProcessor() {
  const module2 = await getKaspaWasm();
  return module2.UtxoProcessor;
}
__name$8(getUtxoProcessor, "getUtxoProcessor");
async function getUtxoEntry() {
  const module2 = await getKaspaWasm();
  return module2.UtxoEntry;
}
__name$8(getUtxoEntry, "getUtxoEntry");
async function getUtxoEntries() {
  const module2 = await getKaspaWasm();
  return module2.UtxoEntries;
}
__name$8(getUtxoEntries, "getUtxoEntries");
async function getUtxoEntryReference() {
  const module2 = await getKaspaWasm();
  return module2.UtxoEntryReference;
}
__name$8(getUtxoEntryReference, "getUtxoEntryReference");
async function getBalance() {
  const module2 = await getKaspaWasm();
  return module2.Balance;
}
__name$8(getBalance, "getBalance");
var __defProp$7 = Object.defineProperty;
var __name$7 = (target, value2) => __defProp$7(target, "name", { value: value2, configurable: true });
var emitterLogger = createLogger("kasstamp:rpc:events");
var UniversalEventEmitter = class {
  static {
    __name$7(this, "UniversalEventEmitter");
  }
  events = /* @__PURE__ */ new Map();
  /**
   * Register an event listener
   *
   * @param event - Event name to listen for
   * @param listener - Callback function to invoke when event is emitted
   * @returns This emitter instance for chaining
   */
  on(event, listener) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event).push(listener);
    return this;
  }
  /**
   * Emit an event to all registered listeners
   *
   * @param event - Event name to emit
   * @param args - Arguments to pass to event listeners
   * @returns True if the event had listeners, false otherwise
   */
  emit(event, ...args) {
    const listeners = this.events.get(event);
    if (!listeners) return false;
    listeners.forEach((listener) => {
      try {
        listener(...args);
      } catch (error) {
        emitterLogger.error(`Error in event listener for ${event}`, error);
      }
    });
    return true;
  }
  /**
   * Remove a specific event listener
   *
   * @param event - Event name
   * @param listener - The listener function to remove
   * @returns This emitter instance for chaining
   */
  off(event, listener) {
    const listeners = this.events.get(event);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    return this;
  }
  /**
   * Remove all listeners for an event or all events
   *
   * @param event - Optional event name. If not provided, removes all listeners
   * @returns This emitter instance for chaining
   */
  removeAllListeners(event) {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
    return this;
  }
};
var KaspaRpcClientError = class _KaspaRpcClientError extends Error {
  static {
    __name$7(this, "KaspaRpcClientError");
  }
  name = "KaspaRpcClientError";
  cause;
  toString() {
    return `${this.name}: ${this.message}`;
  }
  constructor(message2, cause) {
    super(message2);
    this.name = "KaspaRpcClientError";
    this.cause = cause;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _KaspaRpcClientError);
    }
  }
};
var KaspaConnectionError = class extends KaspaRpcClientError {
  static {
    __name$7(this, "KaspaConnectionError");
  }
  name = "KaspaConnectionError";
};
var clientLogger = createLogger("kasstamp:rpc:client");
var KaspaRpcClient = class extends UniversalEventEmitter {
  static {
    __name$7(this, "KaspaRpcClient");
  }
  rpcClient = null;
  options;
  connectionState;
  isWasmInitialized = false;
  constructor(options) {
    super();
    this.options = {
      network: options.network,
      nodeUrl: options.nodeUrl,
      connectTimeout: options.connectTimeout ?? 5e3,
      retryInterval: options.retryInterval ?? 1e3,
      maxRetries: options.maxRetries ?? 5,
      debug: options.debug ?? false
    };
    this.connectionState = {
      isConnected: false,
      isConnecting: false,
      retryCount: 0
    };
    clientLogger.debug("KaspaRpcClient initialized", { network: this.options.network });
  }
  /**
   * Initialize WASM module
   */
  async initializeWasm() {
    if (this.isWasmInitialized) {
      return;
    }
    try {
      clientLogger.debug("Initializing kaspa-wasm module");
      await initKaspaWasm();
      this.isWasmInitialized = true;
      clientLogger.info("kaspa-wasm initialized successfully");
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      clientLogger.error("Failed to initialize kaspa-wasm", error);
      throw new KaspaRpcClientError(
        `Failed to initialize kaspa-wasm: ${errorMsg}`,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Connect to the Kaspa network using official kaspa-wasm Resolver
   */
  async connect() {
    if (this.connectionState.isConnected) {
      clientLogger.debug("Already connected");
      return;
    }
    if (this.connectionState.isConnecting) {
      throw new KaspaConnectionError("Connection already in progress");
    }
    this.connectionState.isConnecting = true;
    this.connectionState.retryCount = 0;
    this.emit("connecting");
    await this.attemptConnection();
  }
  async attemptConnection() {
    const { maxRetries, retryInterval, connectTimeout } = this.options;
    if (this.connectionState.retryCount >= maxRetries) {
      const error = new KaspaConnectionError(`Failed to connect after ${maxRetries} attempts`);
      this.connectionState.isConnecting = false;
      this.emit("error", error);
      throw error;
    }
    try {
      clientLogger.info("Connection attempt", {
        attempt: this.connectionState.retryCount + 1,
        maxRetries
      });
      await this.initializeWasm();
      clientLogger.debug("Creating RpcClient with official kaspa-wasm Resolver", {
        network: this.options.network,
        nodeUrl: this.options.nodeUrl
      });
      this.rpcClient = new RpcClient({
        resolver: new Resolver(),
        networkId: this.options.network,
        encoding: Encoding.Borsh,
        url: this.options.nodeUrl
      });
      clientLogger.debug("Connecting via official kaspa-wasm Resolver");
      await Promise.race([
        this.rpcClient.connect({
          blockAsyncConnect: true,
          retryInterval: 0,
          timeoutDuration: connectTimeout
        }),
        new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Connection timeout")), connectTimeout + 2e3);
        })
      ]);
      if (this.rpcClient && this.rpcClient.isConnected) {
        if (this.options.debug) {
          clientLogger.debug("RPC client connected", {
            availableMethods: Object.getOwnPropertyNames(
              Object.getPrototypeOf(this.rpcClient)
            ).slice(0, 10)
          });
        }
        this.connectionState.isConnected = true;
        this.connectionState.isConnecting = false;
        this.connectionState.currentUrl = this.rpcClient.url;
        this.connectionState.lastError = void 0;
        clientLogger.info("Connected successfully", {
          url: this.rpcClient.url,
          network: this.options.network
        });
        await this.updateNodeInfo();
        this.emit("connected", {
          url: this.rpcClient.url,
          networkId: this.options.network
        });
        return;
      } else {
        throw new Error("Connection lost after initial establishment");
      }
    } catch (error) {
      this.connectionState.retryCount++;
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.connectionState.lastError = errorMsg;
      clientLogger.warn("Connection attempt failed", {
        attempt: this.connectionState.retryCount,
        error: errorMsg
      });
      if (this.connectionState.retryCount < maxRetries) {
        clientLogger.debug("Retrying connection", { retryInMs: retryInterval });
        this.emit("reconnecting", { attempt: this.connectionState.retryCount });
        await new Promise((resolve) => setTimeout(resolve, retryInterval));
        return this.attemptConnection();
      }
      this.connectionState.isConnecting = false;
      const finalError = new KaspaConnectionError(
        `Failed to connect after ${maxRetries} attempts. Last error: ${errorMsg}`,
        error instanceof Error ? error : void 0
      );
      this.emit("error", finalError);
      throw finalError;
    }
  }
  /**
   * Update node information after connection
   */
  async updateNodeInfo() {
    try {
      if (this.rpcClient && this.rpcClient.isConnected) {
        const info = await this.rpcClient.getInfo();
        clientLogger.debug("Node capabilities retrieved", {
          synced: info.isSynced,
          utxoIndex: info.hasUtxoIndex ?? info.isUtxoIndexed,
          version: info.serverVersion
        });
      }
    } catch (error) {
      clientLogger.warn("Failed to get node info", { error });
    }
  }
  /**
   * Disconnect from the Kaspa network
   */
  async disconnect() {
    if (this.rpcClient && this.connectionState.isConnected) {
      try {
        await this.rpcClient.disconnect();
        clientLogger.info("Disconnected from node");
      } catch (error) {
        clientLogger.warn("Disconnect error", { error });
      }
    }
    this.connectionState.isConnected = false;
    this.connectionState.isConnecting = false;
    this.connectionState.currentUrl = void 0;
    this.rpcClient = null;
    this.emit("disconnected", { reason: "manual_disconnect" });
  }
  /**
   * Check if client is connected
   */
  get isConnected() {
    return this.connectionState.isConnected && !!this.rpcClient?.isConnected;
  }
  /**
   * Get the underlying WASM RPC client for direct method access
   */
  get wasmRpcClient() {
    return this.rpcClient;
  }
  /**
   * Direct access to kaspa-wasm RpcClient
   */
  get rpc() {
    if (!this.rpcClient) {
      throw new KaspaRpcClientError("Not connected to Kaspa network");
    }
    return this.rpcClient;
  }
  /**
   * Get fee estimate from the network
   */
  async getFeeEstimate() {
    if (!this.isConnected) {
      throw new KaspaRpcClientError("Not connected to Kaspa network");
    }
    try {
      clientLogger.debug("Getting fee estimate from network");
      const feeEstimate = await this.rpcClient.getFeeEstimate();
      if (!feeEstimate || typeof feeEstimate !== "object") {
        throw new KaspaRpcClientError("Invalid fee estimate response from network");
      }
      const priorityBucket = feeEstimate.estimate.priorityBucket;
      const normalBuckets = feeEstimate.estimate.normalBuckets || [];
      const lowBuckets = feeEstimate.estimate.lowBuckets || [];
      const priorityFeeRate = priorityBucket?.feerate || 1e3;
      const normalFeeRate = normalBuckets[0]?.feerate || 500;
      const lowFeeRate = lowBuckets[0]?.feerate || 100;
      clientLogger.debug("Fee estimate retrieved", {
        priorityFeeRate,
        normalFeeRate,
        lowFeeRate
      });
      return {
        priorityFeeRate,
        normalFeeRate,
        lowFeeRate
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      clientLogger.error("Failed to get fee estimate", error);
      throw new KaspaRpcClientError(
        `Failed to get fee estimate: ${errorMsg}`,
        error instanceof Error ? error : void 0
      );
    }
  }
  /**
   * Call any RPC method directly
   */
  async call(method, params) {
    if (!this.isConnected) {
      throw new KaspaRpcClientError("Not connected to Kaspa network");
    }
    try {
      if (this.options.debug) {
        clientLogger.debug("RPC call", { method, params });
      }
      const rpcClient = this.rpcClient;
      const methodFn = rpcClient[method];
      if (typeof methodFn === "function") {
        return await methodFn.call(rpcClient, params);
      } else {
        throw new KaspaRpcClientError(`RPC method '${method}' not available`);
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      clientLogger.error(`RPC call '${method}' failed`, error, { method, params });
      throw new KaspaRpcClientError(
        `RPC call '${method}' failed: ${errorMsg}`,
        error instanceof Error ? error : void 0
      );
    }
  }
};
function createKaspaClient(options) {
  return new KaspaRpcClient(options);
}
__name$7(createKaspaClient, "createKaspaClient");
var __defProp$6 = Object.defineProperty;
var __name$6 = (target, value2) => __defProp$6(target, "name", { value: value2, configurable: true });
function buildStampingPayload(envelope) {
  const metadataJson = JSON.stringify(envelope.metadata);
  const metadataBytes = new TextEncoder().encode(metadataJson);
  const separator = new Uint8Array([0, 0, 0, 0]);
  const chunkData = envelope.chunkData || new Uint8Array(0);
  const metadataLength = new Uint8Array(new Uint32Array([metadataBytes.length]).buffer);
  const payload = new Uint8Array(
    metadataLength.length + metadataBytes.length + separator.length + chunkData.length
  );
  let offset = 0;
  payload.set(metadataLength, offset);
  offset += metadataLength.length;
  payload.set(metadataBytes, offset);
  offset += metadataBytes.length;
  payload.set(separator, offset);
  offset += separator.length;
  payload.set(chunkData, offset);
  const structure = {
    metadataLength: metadataLength.length,
    metadataBytes: metadataBytes.length,
    separatorBytes: separator.length,
    chunkDataBytes: chunkData.length,
    totalBytes: payload.length
  };
  const BASE_TX_OVERHEAD = 200;
  const INPUT_MASS = 1118;
  const OUTPUT_MASS = 846;
  const PAYLOAD_MASS = payload.length;
  const totalEstimate = BASE_TX_OVERHEAD + INPUT_MASS + OUTPUT_MASS + PAYLOAD_MASS;
  const MASS_LIMIT = 1e5;
  const massEstimate = {
    baseTransaction: BASE_TX_OVERHEAD,
    inputs: INPUT_MASS,
    outputs: OUTPUT_MASS,
    payloadMass: PAYLOAD_MASS,
    totalEstimate,
    massLimit: MASS_LIMIT,
    withinLimit: totalEstimate < MASS_LIMIT
  };
  const debug = {
    metadataJson,
    metadataLengthHex: Array.from(metadataLength).map((b) => b.toString(16).padStart(2, "0")).join(""),
    separatorHex: Array.from(separator).map((b) => b.toString(16).padStart(2, "0")).join(""),
    payloadPreviewHex: Array.from(payload.slice(0, 100)).map((b) => b.toString(16).padStart(2, "0")).join(" ")
  };
  return {
    payload,
    structure,
    debug,
    massEstimate
  };
}
__name$6(buildStampingPayload, "buildStampingPayload");
function decodeStampingPayload(hexPayload) {
  const cleanHex = hexPayload.replace(/^0x/, "").replace(/\s+/g, "");
  if (!/^[0-9a-fA-F]*$/.test(cleanHex)) {
    throw new Error("Invalid hex string: contains non-hex characters");
  }
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string: odd length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i2 = 0; i2 < cleanHex.length; i2 += 2) {
    bytes[i2 / 2] = parseInt(cleanHex.substring(i2, i2 + 2), 16);
  }
  if (bytes.length < 8) {
    throw new Error("Payload too short: must be at least 8 bytes (header + separator)");
  }
  const metadataLength = bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24;
  if (metadataLength < 0 || metadataLength > 1e4) {
    throw new Error(`Invalid metadata length: ${metadataLength} (expected 0-10000)`);
  }
  if (bytes.length < 4 + metadataLength + 4) {
    throw new Error(
      `Payload too short: expected at least ${4 + metadataLength + 4} bytes, got ${bytes.length}`
    );
  }
  const metadataBytes = bytes.slice(4, 4 + metadataLength);
  let metadataJson;
  let metadata;
  try {
    metadataJson = new TextDecoder("utf-8", { fatal: true }).decode(metadataBytes);
  } catch (error) {
    throw new Error(`Failed to decode metadata as UTF-8: ${error}`);
  }
  try {
    metadata = JSON.parse(metadataJson);
  } catch (error) {
    throw new Error(`Failed to parse metadata JSON: ${error}`);
  }
  const separatorStart = 4 + metadataLength;
  const separator = bytes.slice(separatorStart, separatorStart + 4);
  const validSeparator = separator.every((b) => b === 0);
  const chunkDataStart = separatorStart + 4;
  const chunkData = bytes.slice(chunkDataStart);
  const chunkDataPreview = chunkData.slice(0, 256);
  const baseTransactionMass = 200;
  const payloadMass = bytes.length;
  const estimatedMass = baseTransactionMass + payloadMass;
  const withinMassLimit = estimatedMass <= 1e5;
  return {
    totalBytes: bytes.length,
    metadataLength,
    metadata,
    chunkDataSize: chunkData.length,
    chunkData,
    // Full chunk data
    chunkDataPreview,
    // Preview only
    validSeparator,
    separator,
    estimatedMass,
    withinMassLimit,
    structure: {
      headerBytes: 4,
      metadataBytes: metadataLength,
      separatorBytes: 4,
      chunkDataBytes: chunkData.length
    }
  };
}
__name$6(decodeStampingPayload, "decodeStampingPayload");
var generatorLogger = createLogger("kasstamp:tx:generator");
var GeneratorTransactionService = class {
  static {
    __name$6(this, "GeneratorTransactionService");
  }
  /**
   * Estimate stamping transaction before sending
   *
   * Provides a dry-run preview of what will happen when you send.
   * Use this to show fees and mass to the user before confirming.
   *
   * @param params - Transaction parameters
   * @returns Estimation details
   *
   * @example
   * ```typescript
   * const estimate = await service.estimateStampingTransaction({
   *   recipient: wallet.receiveAddress,
   *   changeAddress: wallet.changeAddress,
   *   utxos: await wallet.getUtxos(accountId),
   *   payload: chunkPayload,
   *   networkId: 'testnet-10'
   * });
   *
   * console.log(`Will create ${estimate.transactionCount} transactions`);
   * console.log(`Total fees: ${estimate.totalFees} sompi`);
   * ```
   */
  static async estimateStampingTransaction(params) {
    const {
      recipient,
      changeAddress,
      utxos,
      payload,
      networkId,
      priorityFee = 0n,
      // No priority fee by default - only minimum network fee
      amount = 100000000n,
      // 1 KAS
      feeRate
    } = params;
    generatorLogger.debug("UTXOs retrieved", { utxoCount: utxos.length });
    if (utxos.length > 0) {
      const firstUtxo = utxos[0];
      generatorLogger.debug("First UTXO structure", {
        keys: Object.keys(firstUtxo),
        hasScriptPublicKey: "scriptPublicKey" in firstUtxo,
        hasAddress: "address" in firstUtxo,
        hasOutpoint: "outpoint" in firstUtxo,
        hasAmount: "amount" in firstUtxo,
        amountValue: firstUtxo.amount,
        amountType: typeof firstUtxo.amount,
        scriptPublicKeyType: firstUtxo.scriptPublicKey ? typeof firstUtxo.scriptPublicKey : "undefined",
        addressType: firstUtxo.address ? typeof firstUtxo.address : "undefined"
      });
    }
    const summary = await estimateTransactions({
      outputs: amount > 0n ? [{ address: recipient, amount }] : [],
      changeAddress,
      entries: utxos,
      payload,
      priorityFee,
      feeRate,
      networkId
    });
    return {
      transactionCount: summary.transactions,
      totalFees: summary.fees,
      totalMass: summary.mass,
      utxoCount: summary.utxos,
      finalAmount: summary.finalAmount,
      needsBatching: summary.transactions > 1,
      summary
    };
  }
};
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var __defProp$5 = Object.defineProperty;
var __name$5 = (target, value2) => __defProp$5(target, "name", { value: value2, configurable: true });
var platformLogger = createLogger("kasstamp:crypto:platform");
function detectPlatformCapabilities() {
  const hasWebCrypto = typeof globalThis.crypto?.subtle !== "undefined";
  const hasFileSystem = typeof process !== "undefined" && process.versions?.node;
  const hasStreams = typeof ReadableStream !== "undefined";
  let platform = "unknown";
  if (typeof process !== "undefined" && process.versions?.node) {
    platform = "node";
  } else if (typeof window !== "undefined") {
    platform = "browser";
  }
  return {
    hasWebCrypto,
    hasFileSystem: !!hasFileSystem,
    hasStreams,
    platform
  };
}
__name$5(detectPlatformCapabilities, "detectPlatformCapabilities");
function initializeCryptoPlatform() {
  const capabilities = detectPlatformCapabilities();
  if (!capabilities.hasWebCrypto) {
    const nodeVersion = typeof process !== "undefined" ? process.version : "unknown";
    let versionSpecificHelp = "";
    if (typeof process !== "undefined" && process.versions?.node) {
      const majorVersion = parseInt(process.versions.node.split(".")[0], 10);
      if (majorVersion < 20) {
        versionSpecificHelp = `
⚠️  Node.js ${majorVersion} is not supported. Please upgrade to Node.js 20+ (LTS).`;
      }
    }
    throw new Error(
      `WebCrypto API not available.

Requirements:
- Node.js 20.0.0 or later (current: ${nodeVersion})
- Modern browser with Web Crypto API support

Platform detected: ${capabilities.platform}${versionSpecificHelp}
For Node.js: Update to Node.js 20+ for full WebCrypto support
For browsers: Use a modern browser (Chrome 37+, Firefox 34+, Safari 7+)`
    );
  }
  return {
    subtle: globalThis.crypto.subtle,
    getRandomValues: /* @__PURE__ */ __name$5((array) => globalThis.crypto.getRandomValues(array), "getRandomValues"),
    capabilities
  };
}
__name$5(initializeCryptoPlatform, "initializeCryptoPlatform");
var cryptoPlatform = initializeCryptoPlatform();
async function initializeCompressionPlatform() {
  const capabilities = detectPlatformCapabilities();
  if (typeof CompressionStream !== "undefined" && typeof DecompressionStream !== "undefined") {
    return {
      gzip: /* @__PURE__ */ __name$5(async (data) => {
        try {
          const stream = new CompressionStream("gzip");
          const writer = stream.writable.getWriter();
          const reader = stream.readable.getReader();
          await writer.write(new Uint8Array(data));
          await writer.close();
          const chunks = [];
          let done = false;
          while (!done) {
            const { value: value2, done: readerDone } = await reader.read();
            if (value2) {
              chunks.push(new Uint8Array(value2));
            }
            done = readerDone;
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            result.set(chunk, offset);
            offset += chunk.length;
          }
          return result;
        } catch (error) {
          platformLogger.error("Compression failed", error);
          throw new Error(
            `Compression failed: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }, "gzip"),
      gunzip: /* @__PURE__ */ __name$5(async (data) => {
        try {
          const stream = new DecompressionStream("gzip");
          const writer = stream.writable.getWriter();
          const reader = stream.readable.getReader();
          await writer.write(new Uint8Array(data));
          await writer.close();
          const chunks = [];
          let done = false;
          while (!done) {
            const { value: value2, done: readerDone } = await reader.read();
            if (value2) {
              chunks.push(new Uint8Array(value2));
            }
            done = readerDone;
          }
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const result = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            result.set(chunk, offset);
            offset += chunk.length;
          }
          return result;
        } catch (error) {
          platformLogger.error("Decompression failed", error);
          throw new Error(
            `Decompression failed: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }, "gunzip"),
      supportsStreaming: true
    };
  }
  if (capabilities.hasFileSystem) {
    try {
      const zlib = await __vitePreload(() => Promise.resolve().then(() => __viteBrowserExternal$1), true ? void 0 : void 0);
      const { promisify } = await __vitePreload(async () => {
        const { promisify: promisify2 } = await Promise.resolve().then(() => __viteBrowserExternal$1);
        return { promisify: promisify2 };
      }, true ? void 0 : void 0);
      const gzipAsync = promisify(zlib.gzip);
      const gunzipAsync = promisify(zlib.gunzip);
      return {
        gzip: /* @__PURE__ */ __name$5(async (data) => {
          const result = await gzipAsync(data);
          return new Uint8Array(result);
        }, "gzip"),
        gunzip: /* @__PURE__ */ __name$5(async (data) => {
          const result = await gunzipAsync(data);
          return new Uint8Array(result);
        }, "gunzip"),
        supportsStreaming: true
      };
    } catch (error) {
      throw new Error(
        `Node.js zlib not available: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  platformLogger.warn(
    "Compression not available in this environment. Data will not be compressed."
  );
  return {
    gzip: /* @__PURE__ */ __name$5(async (data) => data, "gzip"),
    // Pass-through
    gunzip: /* @__PURE__ */ __name$5(async (data) => data, "gunzip"),
    // Pass-through
    supportsStreaming: false
  };
}
__name$5(initializeCompressionPlatform, "initializeCompressionPlatform");
var { subtle } = cryptoPlatform;
async function sha256Bytes(data) {
  const buf = await subtle.digest("SHA-256", data);
  return new Uint8Array(buf);
}
__name$5(sha256Bytes, "sha256Bytes");
async function sha256Hex(data) {
  const hashBytes = await sha256Bytes(data);
  return [...hashBytes].map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name$5(sha256Hex, "sha256Hex");
var { subtle: subtle2, getRandomValues: getRandomValues$1 } = cryptoPlatform;
function randomNonce12() {
  const n2 = new Uint8Array(12);
  return getRandomValues$1(n2);
}
__name$5(randomNonce12, "randomNonce12");
async function encryptAesGcm(key2, plain, nonce = randomNonce12(), tagLengthBits = 128) {
  const params = {
    name: "AES-GCM",
    iv: nonce,
    tagLength: tagLengthBits
  };
  const ct = await subtle2.encrypt(params, key2, plain);
  return { cipherText: new Uint8Array(ct), nonce, tagLengthBits };
}
__name$5(encryptAesGcm, "encryptAesGcm");
async function decryptAesGcm(key2, cipher) {
  const params = {
    name: "AES-GCM",
    iv: cipher.nonce,
    tagLength: cipher.tagLengthBits
  };
  const pt = await subtle2.decrypt(params, key2, cipher.cipherText);
  return new Uint8Array(pt);
}
__name$5(decryptAesGcm, "decryptAesGcm");
async function encryptBytes(data, key2) {
  const encrypted = await encryptAesGcm(key2, data);
  const result = new Uint8Array(encrypted.nonce.length + encrypted.cipherText.length);
  result.set(encrypted.nonce, 0);
  result.set(encrypted.cipherText, encrypted.nonce.length);
  return result;
}
__name$5(encryptBytes, "encryptBytes");
async function decryptBytes(encryptedData, key2) {
  if (encryptedData.length < 12) {
    throw new Error("Invalid encrypted data: too short");
  }
  const nonce = encryptedData.slice(0, 12);
  const cipherText = encryptedData.slice(12);
  const cipher = {
    cipherText,
    nonce,
    tagLengthBits: 128
  };
  return await decryptAesGcm(key2, cipher);
}
__name$5(decryptBytes, "decryptBytes");
var { subtle: subtle3 } = cryptoPlatform;
async function deriveKeyFromPrivateKey(privateKey, salt) {
  const saltBytes = new TextEncoder().encode(salt);
  const keyMaterial = await subtle3.importKey(
    "raw",
    privateKey,
    { name: "HKDF" },
    false,
    ["deriveKey"]
  );
  return await subtle3.deriveKey(
    {
      name: "HKDF",
      hash: "SHA-256",
      salt: saltBytes,
      info: new TextEncoder().encode("kasstamp-file-encryption")
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
}
__name$5(deriveKeyFromPrivateKey, "deriveKeyFromPrivateKey");
var compressionPlatform = null;
async function ensureCompressionPlatform() {
  if (!compressionPlatform) {
    compressionPlatform = await initializeCompressionPlatform();
  }
}
__name$5(ensureCompressionPlatform, "ensureCompressionPlatform");
async function gzipBytes(data, _level = 6) {
  await ensureCompressionPlatform();
  return compressionPlatform.gzip(data);
}
__name$5(gzipBytes, "gzipBytes");
async function gunzipBytes(data) {
  await ensureCompressionPlatform();
  return compressionPlatform.gunzip(data);
}
__name$5(gunzipBytes, "gunzipBytes");
var __defProp$4 = Object.defineProperty;
var __name$4 = (target, value2) => __defProp$4(target, "name", { value: value2, configurable: true });
async function deriveEncryptionKey(password, salt) {
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);
  const keyMaterial = await crypto.subtle.importKey("raw", passwordBuffer, "PBKDF2", false, [
    "deriveKey"
  ]);
  return await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt: new Uint8Array(salt),
      // Explicitly cast to BufferSource
      iterations: 1e5,
      // 100k iterations for security
      hash: "SHA-256"
    },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    // AES-256-GCM
    false,
    ["encrypt", "decrypt"]
  );
}
__name$4(deriveEncryptionKey, "deriveEncryptionKey");
async function encryptData(plaintext, key2) {
  const encoder = new TextEncoder();
  const data = encoder.encode(plaintext);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key2, data);
  const combined = new Uint8Array(iv.length + encrypted.byteLength);
  combined.set(iv, 0);
  combined.set(new Uint8Array(encrypted), iv.length);
  return btoa(String.fromCharCode(...combined));
}
__name$4(encryptData, "encryptData");
async function decryptData(ciphertext, key2) {
  const combined = Uint8Array.from(atob(ciphertext), (c2) => c2.charCodeAt(0));
  const iv = combined.slice(0, 12);
  const encrypted = combined.slice(12);
  const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key2, encrypted);
  const decoder = new TextDecoder();
  return decoder.decode(decrypted);
}
__name$4(decryptData, "decryptData");
function generateSalt() {
  return crypto.getRandomValues(new Uint8Array(16));
}
__name$4(generateSalt, "generateSalt");
function derivePrivateKey(mnemonic, bip39Passphrase, accountIndex, addressIndex, isReceive) {
  const mnemonicObj = new Mnemonic$1(mnemonic);
  const seedHex = mnemonicObj.toSeed(bip39Passphrase);
  const xprv = new XPrv(seedHex);
  const privateKeyGen = new PrivateKeyGenerator(
    xprv,
    false,
    // isMultisig (false for standard wallets)
    BigInt(accountIndex)
  );
  const privateKey = isReceive ? privateKeyGen.receiveKey(addressIndex) : privateKeyGen.changeKey(addressIndex);
  return privateKey;
}
__name$4(derivePrivateKey, "derivePrivateKey");
function deriveMultipleKeys(mnemonic, bip39Passphrase, derivations) {
  const mnemonicObj = new Mnemonic$1(mnemonic);
  const seedHex = mnemonicObj.toSeed(bip39Passphrase);
  const xprv = new XPrv(seedHex);
  const keysByAccount = /* @__PURE__ */ new Map();
  for (const derivation of derivations) {
    if (!keysByAccount.has(derivation.accountIndex)) {
      keysByAccount.set(derivation.accountIndex, []);
    }
    const privateKeyGen = new PrivateKeyGenerator(xprv, false, BigInt(derivation.accountIndex));
    const privateKey = derivation.isReceive ? privateKeyGen.receiveKey(derivation.addressIndex) : privateKeyGen.changeKey(derivation.addressIndex);
    keysByAccount.get(derivation.accountIndex).push(privateKey);
  }
  const keys = [];
  for (const derivation of derivations) {
    const privateKeyGen = new PrivateKeyGenerator(xprv, false, BigInt(derivation.accountIndex));
    const privateKey = derivation.isReceive ? privateKeyGen.receiveKey(derivation.addressIndex) : privateKeyGen.changeKey(derivation.addressIndex);
    keys.push(privateKey);
  }
  return keys;
}
__name$4(deriveMultipleKeys, "deriveMultipleKeys");
var enclaveLogger = createLogger("kasstamp:wallet:signing");
var ENCLAVE_STORAGE_PREFIX = ".enclave";
function createSigningEnclave(storage2, walletId) {
  const storageBackend = storage2;
  let encryptedMnemonic = null;
  let encryptionSalt = null;
  let encryptionKey = null;
  let bip39Passphrase = "";
  let isUnlocked = false;
  let unlockTimeout = null;
  let unlockTimeMs = null;
  let autoLockDurationMs = null;
  const storageKey = walletId ? `${walletId}${ENCLAVE_STORAGE_PREFIX}` : null;
  const encryptionKeyCache = /* @__PURE__ */ new Map();
  function saveToLocalStorage() {
    if (!storageKey) {
      enclaveLogger.warn("⚠️ No wallet ID provided - encrypted mnemonic not persisted");
      return;
    }
    if (!encryptedMnemonic || !encryptionSalt) {
      enclaveLogger.warn("⚠️ No encrypted data to save");
      return;
    }
    try {
      const encryptedBytes = Uint8Array.from(atob(encryptedMnemonic), (c2) => c2.charCodeAt(0));
      const version3 = 1;
      const saltLength = encryptionSalt.length;
      const encDataLength = encryptedBytes.length;
      const totalSize = 1 + 2 + saltLength + 4 + encDataLength;
      const buffer = new Uint8Array(totalSize);
      let offset = 0;
      buffer[offset++] = version3;
      buffer[offset++] = saltLength >> 8 & 255;
      buffer[offset++] = saltLength & 255;
      buffer.set(encryptionSalt, offset);
      offset += saltLength;
      buffer[offset++] = encDataLength >> 24 & 255;
      buffer[offset++] = encDataLength >> 16 & 255;
      buffer[offset++] = encDataLength >> 8 & 255;
      buffer[offset++] = encDataLength & 255;
      buffer.set(encryptedBytes, offset);
      const hexString = Array.from(buffer).map((b) => b.toString(16).padStart(2, "0")).join("");
      storageBackend.setItem(storageKey, hexString);
      enclaveLogger.debug(
        `💾 Encrypted data saved to localStorage (${storageKey}) - ${buffer.length} bytes`
      );
    } catch (error) {
      enclaveLogger.error("❌ Failed to save to localStorage:", error);
    }
  }
  __name$4(saveToLocalStorage, "saveToLocalStorage");
  function loadFromLocalStorage() {
    if (!storageKey) {
      return false;
    }
    try {
      const stored = storageBackend.getItem(storageKey);
      if (!stored) {
        return false;
      }
      const isBinaryFormat = !stored.startsWith("{");
      if (isBinaryFormat) {
        try {
          const bytes = new Uint8Array(stored.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
          let offset = 0;
          const version3 = bytes[offset++];
          if (version3 !== 1) {
            enclaveLogger.warn(`⚠️ Unknown enclave version: ${version3}`);
            return false;
          }
          const saltLength = bytes[offset++] << 8 | bytes[offset++];
          const salt = bytes.slice(offset, offset + saltLength);
          offset += saltLength;
          const encDataLength = bytes[offset++] << 24 | bytes[offset++] << 16 | bytes[offset++] << 8 | bytes[offset++];
          const encData = bytes.slice(offset, offset + encDataLength);
          encryptedMnemonic = btoa(String.fromCharCode(...encData));
          encryptionSalt = salt;
          enclaveLogger.debug(
            `📂 Encrypted data loaded from localStorage (${storageKey}) - binary format`
          );
          return true;
        } catch (err) {
          enclaveLogger.error("Failed to parse binary format", err);
          return false;
        }
      } else {
        const data = JSON.parse(stored);
        const encData = data.d || data.encryptedMnemonic;
        const saltData = data.s || data.salt;
        if (!encData || !saltData) {
          enclaveLogger.warn("⚠️ Invalid enclave data in localStorage");
          return false;
        }
        encryptedMnemonic = encData;
        encryptionSalt = Uint8Array.from(atob(saltData), (c2) => c2.charCodeAt(0));
        enclaveLogger.debug("🔄 Migrating to binary format...");
        saveToLocalStorage();
        enclaveLogger.debug(
          `📂 Encrypted data loaded from localStorage (${storageKey}) - JSON format (migrated)`
        );
        return true;
      }
    } catch (error) {
      enclaveLogger.error("❌ Failed to load from localStorage:", error);
      return false;
    }
  }
  __name$4(loadFromLocalStorage, "loadFromLocalStorage");
  function removeFromLocalStorage() {
    if (!storageKey) {
      return;
    }
    try {
      storageBackend.removeItem(storageKey);
      enclaveLogger.debug(`🗑️ Encrypted mnemonic removed from storage (${storageKey})`);
    } catch (error) {
      enclaveLogger.error("❌ Failed to remove from storage:", error);
    }
  }
  __name$4(removeFromLocalStorage, "removeFromLocalStorage");
  enclaveLogger.debug(`🔐 Initializing signing enclave with storage key: ${storageKey || "none"}`);
  const loaded = loadFromLocalStorage();
  if (loaded) {
    enclaveLogger.debug(`✅ Enclave initialized with encrypted mnemonic from storage`);
  } else {
    enclaveLogger.debug(`ℹ️ Enclave initialized without stored mnemonic`);
  }
  return {
    /**
     * Store mnemonic in encrypted form
     * Saves to both memory (closure scope) and localStorage
     */
    async storeMnemonic(options) {
      const { mnemonic, password, bip39Passphrase: passphrase } = options;
      if (!mnemonic || mnemonic.trim().length === 0) {
        throw new Error("Mnemonic cannot be empty");
      }
      if (!password || password.length < 8) {
        throw new Error("Password must be at least 8 characters");
      }
      try {
        enclaveLogger.debug("🔐 Storing mnemonic in secure enclave...");
        bip39Passphrase = passphrase || "";
        encryptionSalt = generateSalt();
        const key2 = await deriveEncryptionKey(password, encryptionSalt);
        encryptedMnemonic = await encryptData(mnemonic, key2);
        saveToLocalStorage();
        enclaveLogger.debug("✅ Mnemonic stored securely (encrypted in closure + localStorage)");
      } catch (error) {
        enclaveLogger.error("❌ Failed to store mnemonic:", error);
        throw new Error(`Failed to store mnemonic: ${error.message}`);
      }
    },
    /**
     * Unlock the enclave with password
     */
    async unlock(options) {
      const { password, autoLockMs = 30 * 60 * 1e3 } = options;
      if (!encryptedMnemonic || !encryptionSalt) {
        throw new Error("No mnemonic stored. Call storeMnemonic() first.");
      }
      if (isUnlocked) {
        enclaveLogger.debug("⚠️ Enclave is already unlocked");
        return;
      }
      try {
        enclaveLogger.debug("🔓 Unlocking signing enclave...");
        const key2 = await deriveEncryptionKey(password, encryptionSalt);
        await decryptData(encryptedMnemonic, key2);
        encryptionKey = key2;
        isUnlocked = true;
        unlockTimeMs = Date.now();
        autoLockDurationMs = autoLockMs;
        if (autoLockMs > 0) {
          unlockTimeout = setTimeout(() => {
            enclaveLogger.debug("⏰ Auto-lock timeout expired - locking enclave");
            this.lock();
          }, autoLockMs);
        }
        enclaveLogger.debug(`✅ Enclave unlocked (auto-lock in ${autoLockMs / 1e3}s)`);
      } catch (error) {
        enclaveLogger.error("❌ Failed to unlock enclave:", error);
        throw new Error("Invalid password or corrupted data");
      }
    },
    /**
     * Lock the enclave
     */
    lock() {
      encryptionKey = null;
      isUnlocked = false;
      unlockTimeMs = null;
      autoLockDurationMs = null;
      if (unlockTimeout) {
        clearTimeout(unlockTimeout);
        unlockTimeout = null;
      }
      encryptionKeyCache.clear();
      enclaveLogger.debug("🔒 Signing enclave locked");
    },
    /**
     * Clear all stored data from memory AND localStorage
     * This is equivalent to logging out and removing the wallet
     */
    clear() {
      encryptedMnemonic = null;
      encryptionSalt = null;
      encryptionKey = null;
      bip39Passphrase = "";
      isUnlocked = false;
      unlockTimeMs = null;
      autoLockDurationMs = null;
      if (unlockTimeout) {
        clearTimeout(unlockTimeout);
        unlockTimeout = null;
      }
      removeFromLocalStorage();
      enclaveLogger.debug("🗑️ Signing enclave cleared (memory + localStorage)");
    },
    /**
     * Check if enclave is locked
     */
    isLocked() {
      return !isUnlocked;
    },
    /**
     * Check if mnemonic is stored
     */
    hasMnemonic() {
      return encryptedMnemonic !== null;
    },
    /**
     * Get enclave status
     */
    getStatus() {
      let timeUntilLock = null;
      if (isUnlocked && unlockTimeMs && autoLockDurationMs) {
        const elapsed = Date.now() - unlockTimeMs;
        timeUntilLock = Math.max(0, autoLockDurationMs - elapsed);
      }
      return {
        isLocked: !isUnlocked,
        hasMnemonic: encryptedMnemonic !== null,
        autoLockMs: autoLockDurationMs,
        timeUntilLock
      };
    },
    /**
     * Sign a transaction with a single key
     */
    async sign(transaction, options = {}) {
      if (!isUnlocked || !encryptionKey) {
        throw new Error("Signing enclave is locked. Call unlock() first.");
      }
      if (!encryptedMnemonic) {
        throw new Error("No mnemonic stored in enclave.");
      }
      const { accountIndex = 0, addressIndex = 0, isReceive = true } = options;
      let mnemonic;
      let privateKey;
      try {
        mnemonic = await decryptData(encryptedMnemonic, encryptionKey);
        privateKey = derivePrivateKey(
          mnemonic,
          bip39Passphrase,
          accountIndex,
          addressIndex,
          isReceive
        );
        await transaction.sign([privateKey]);
        enclaveLogger.debug(
          `✅ Transaction signed with key (account: ${accountIndex}, address: ${addressIndex}, receive: ${isReceive})`
        );
      } catch (error) {
        enclaveLogger.error("❌ Failed to sign transaction:", error);
        throw new Error(`Failed to sign transaction: ${error.message}`);
      } finally {
        mnemonic = void 0;
        privateKey = void 0;
      }
    },
    /**
     * Sign a transaction with multiple keys
     */
    async signMultiple(transaction, derivations) {
      if (!isUnlocked || !encryptionKey) {
        throw new Error("Signing enclave is locked. Call unlock() first.");
      }
      if (!encryptedMnemonic) {
        throw new Error("No mnemonic stored in enclave.");
      }
      if (derivations.length === 0) {
        throw new Error("No key derivations specified");
      }
      let mnemonic;
      let privateKeys;
      try {
        mnemonic = await decryptData(encryptedMnemonic, encryptionKey);
        privateKeys = deriveMultipleKeys(mnemonic, bip39Passphrase, derivations);
        await transaction.sign(privateKeys);
        enclaveLogger.debug(`✅ Transaction signed with ${privateKeys.length} keys`);
      } catch (error) {
        enclaveLogger.error("❌ Failed to sign transaction with multiple keys:", error);
        throw new Error(`Failed to sign transaction: ${error.message}`);
      } finally {
        mnemonic = void 0;
        privateKeys = void 0;
      }
    },
    /**
     * Sign a transaction by auto-discovering required keys
     *
     * This method:
     * 1. Gets addresses from transaction.addresses()
     * 2. Scans receive/change addresses (indices 0-9) to find matches
     * 3. Signs with only the required keys
     */
    async signWithAutoDiscovery(transaction, network, accountIndex = 0) {
      if (!isUnlocked || !encryptionKey) {
        throw new Error("Signing enclave is locked. Call unlock() first.");
      }
      if (!encryptedMnemonic) {
        throw new Error("No mnemonic stored in enclave.");
      }
      let requiredAddresses;
      try {
        requiredAddresses = transaction.addresses();
        enclaveLogger.debug(
          `🔍 Transaction requires signatures for ${requiredAddresses.length} address(es):`,
          requiredAddresses
        );
      } catch (error) {
        throw new Error(`Failed to get transaction addresses: ${error.message}`);
      }
      if (requiredAddresses.length === 0) {
        throw new Error("Transaction has no addresses to sign");
      }
      let mnemonic;
      let privateKeys;
      try {
        mnemonic = await decryptData(encryptedMnemonic, encryptionKey);
        privateKeys = [];
        const foundAddresses = /* @__PURE__ */ new Set();
        const networkId = new NetworkId(network);
        enclaveLogger.debug(`🔍 Scanning receive addresses (indices 0-9)...`);
        for (let addressIndex = 0; addressIndex < 10 && foundAddresses.size < requiredAddresses.length; addressIndex++) {
          const key2 = derivePrivateKey(mnemonic, bip39Passphrase, accountIndex, addressIndex, true);
          const publicKey = key2.toPublicKey();
          const address = publicKey.toAddress(networkId).toString();
          enclaveLogger.debug(`  Receive[${addressIndex}]: ${address}`);
          if (requiredAddresses.includes(address)) {
            privateKeys.push(key2);
            foundAddresses.add(address);
            enclaveLogger.debug(`✅ Found key for receive address[${addressIndex}]: ${address}`);
          }
        }
        enclaveLogger.debug(`🔍 Scanning change addresses (indices 0-9)...`);
        for (let addressIndex = 0; addressIndex < 10 && foundAddresses.size < requiredAddresses.length; addressIndex++) {
          const key2 = derivePrivateKey(
            mnemonic,
            bip39Passphrase,
            accountIndex,
            addressIndex,
            false
          );
          const publicKey = key2.toPublicKey();
          const address = publicKey.toAddress(networkId).toString();
          enclaveLogger.debug(`  Change[${addressIndex}]: ${address}`);
          if (requiredAddresses.includes(address)) {
            privateKeys.push(key2);
            foundAddresses.add(address);
            enclaveLogger.debug(`✅ Found key for change address[${addressIndex}]: ${address}`);
          }
        }
        if (foundAddresses.size < requiredAddresses.length) {
          const missingAddresses = requiredAddresses.filter((addr) => !foundAddresses.has(addr));
          throw new Error(
            `Could not find private keys for addresses: ${missingAddresses.join(", ")}`
          );
        }
        transaction.sign(privateKeys);
        enclaveLogger.debug(`Transaction signed with ${privateKeys.length} auto-discovered keys`);
      } catch (error) {
        enclaveLogger.error("❌ Failed to sign transaction with auto-discovery:", error);
        throw new Error(`Failed to sign transaction: ${error.message}`);
      } finally {
        mnemonic = void 0;
        privateKeys = void 0;
      }
    },
    /**
     * Encrypt data using wallet-derived key
     *
     * SECURITY: Private key NEVER leaves the enclave!
     * - Derives private key from mnemonic (in closure)
     * - Generates encryption key from private key
     * - Encrypts data
     * - Returns only encrypted data
     * - Private key destroyed immediately
     *
     * @param data - Data to encrypt
     * @param groupId - Group ID used as salt for key derivation
     * @param accountIndex - Account index (default: 0)
     * @returns Encrypted data
     */
    async encryptWithWalletKey(data, groupId, accountIndex = 0) {
      if (!encryptionKey) {
        throw new Error("Enclave is locked. Please unlock first.");
      }
      const cacheKey = `${groupId}:${accountIndex}`;
      let encryptionAesKey;
      const cached = encryptionKeyCache.get(cacheKey);
      if (cached) {
        encryptionAesKey = cached.aesKey;
      } else {
        let mnemonic;
        let privateKeyBytes;
        try {
          mnemonic = await decryptData(encryptedMnemonic, encryptionKey);
          const privateKey = derivePrivateKey(mnemonic, bip39Passphrase, accountIndex, 0, true);
          const privateKeyHex = privateKey.toString();
          privateKeyBytes = new Uint8Array(
            privateKeyHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
          );
          encryptionAesKey = await deriveKeyFromPrivateKey(privateKeyBytes, groupId);
          encryptionKeyCache.set(cacheKey, { aesKey: encryptionAesKey, accountIndex });
          enclaveLogger.debug(`⚡ [ENCLAVE] Derived and cached AES key for groupId: ${groupId}`);
        } finally {
          mnemonic = void 0;
          privateKeyBytes = void 0;
        }
      }
      try {
        return await encryptBytes(data, encryptionAesKey);
      } catch (error) {
        throw new Error(`Failed to encrypt data: ${error.message}`);
      }
    },
    /**
     * Decrypt data using wallet-derived key
     *
     * SECURITY: Private key NEVER leaves the enclave!
     * - Derives private key from mnemonic (in closure)
     * - Generates decryption key from private key
     * - Decrypts data
     * - Returns only decrypted data
     * - Private key destroyed immediately
     *
     * @param encryptedData - Data to decrypt
     * @param groupId - Group ID used as salt for key derivation
     * @param accountIndex - Account index (default: 0)
     * @returns Decrypted data
     */
    async decryptWithWalletKey(encryptedData, groupId, accountIndex = 0) {
      if (!encryptionKey) {
        throw new Error("Enclave is locked. Please unlock first.");
      }
      const cacheKey = `${groupId}:${accountIndex}`;
      let decryptionKey;
      const cached = encryptionKeyCache.get(cacheKey);
      if (cached) {
        decryptionKey = cached.aesKey;
      } else {
        let mnemonic;
        let privateKeyBytes;
        try {
          mnemonic = await decryptData(encryptedMnemonic, encryptionKey);
          const privateKey = derivePrivateKey(mnemonic, bip39Passphrase, accountIndex, 0, true);
          const privateKeyHex = privateKey.toString();
          privateKeyBytes = new Uint8Array(
            privateKeyHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
          );
          decryptionKey = await deriveKeyFromPrivateKey(privateKeyBytes, groupId);
          encryptionKeyCache.set(cacheKey, { aesKey: decryptionKey, accountIndex });
          enclaveLogger.debug(
            `⚡ [ENCLAVE] Derived and cached AES key for decryption, groupId: ${groupId}`
          );
        } finally {
          mnemonic = void 0;
          privateKeyBytes = void 0;
        }
      }
      try {
        return await decryptBytes(encryptedData, decryptionKey);
      } catch (error) {
        throw new Error(
          `Failed to decrypt data: ${error.message}. This usually means the wallet used for decryption is different from the one used for encryption. Make sure you're using the same wallet (same mnemonic and BIP39 passphrase) that was used to create this encrypted data.`
        );
      }
    }
  };
}
__name$4(createSigningEnclave, "createSigningEnclave");
var walletLogger = createLogger("kasstamp:wallet:simple");
var SimpleWalletImpl = class {
  static {
    __name$4(this, "SimpleWalletImpl");
  }
  wasmWallet;
  network;
  accounts = [];
  locked = true;
  descriptor;
  // ✅ NEW: Secure signing enclave (replaces unsafe mnemonic/walletSecret)
  signingEnclave;
  // UTXO management
  processor;
  context;
  transactionMonitors = /* @__PURE__ */ new Map();
  transactionListeners = /* @__PURE__ */ new Set();
  balanceListeners = /* @__PURE__ */ new Set();
  constructor(wasmWallet, network, descriptor) {
    this.wasmWallet = wasmWallet;
    this.network = network;
    this.descriptor = descriptor;
    const walletId = descriptor?.filename || descriptor?.title || "default-wallet";
    const storage2 = typeof localStorage !== "undefined" ? localStorage : {
      getItem: /* @__PURE__ */ __name$4(() => null, "getItem"),
      setItem: /* @__PURE__ */ __name$4(() => {
      }, "setItem"),
      removeItem: /* @__PURE__ */ __name$4(() => {
      }, "removeItem")
    };
    this.signingEnclave = createSigningEnclave(storage2, walletId);
  }
  /**
   * Initialize the wallet after construction
   * This should be called after the wallet is created to load accounts
   */
  async initialize() {
    if (!this.locked) {
      try {
        walletLogger.debug("📋 Loading existing accounts...");
        const response = await this.wasmWallet.accountsEnumerate({});
        this.accounts = response.accountDescriptors || [];
        walletLogger.debug(`✅ Loaded ${this.accounts.length} existing accounts`);
        await this.initializeUtxoProcessor();
      } catch (error) {
        walletLogger.error("❌ Failed to load existing accounts:", error);
      }
    }
  }
  /**
   * Initialize UTXO processor and context (like Kasia does)
   */
  async initializeUtxoProcessor() {
    try {
      walletLogger.debug("📦 Initializing UTXO processor and context...");
      const rpcClient = this.wasmWallet.rpc;
      if (!rpcClient) {
        walletLogger.warn("⚠️ No RPC client available for UTXO processor");
        return;
      }
      const UtxoProcessor3 = await getUtxoProcessor();
      const UtxoContext3 = await getUtxoContext();
      this.processor = new UtxoProcessor3({
        networkId: this.network,
        rpc: rpcClient
      });
      this.context = new UtxoContext3({ processor: this.processor });
      await this.processor.start();
      if (this.accounts.length > 0) {
        const addressesToTrack = [];
        for (const account of this.accounts) {
          if (account.receiveAddress) {
            addressesToTrack.push(account.receiveAddress.toString());
          }
          if (account.changeAddress) {
            addressesToTrack.push(account.changeAddress.toString());
          }
        }
        if (addressesToTrack.length > 0) {
          walletLogger.debug(
            `📦 Tracking ${addressesToTrack.length} addresses for UTXO discovery:`,
            addressesToTrack
          );
          await this.context.trackAddresses(addressesToTrack);
          walletLogger.debug("✅ Addresses tracked for UTXO discovery");
        }
      }
      walletLogger.debug("✅ UTXO processor and context initialized");
    } catch (error) {
      walletLogger.error("❌ Failed to initialize UTXO processor:", error);
    }
  }
  /**
   * Derive and add the next account
   * Note: This is a simplified implementation that relies on the wallet having existing accounts
   * For full account creation, use the SDK's wallet factory methods
   */
  async deriveNextAccount(change = 0) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before deriving accounts.");
    }
    try {
      walletLogger.debug(`🔑 Getting existing accounts (change: ${change})...`);
      const existingAccounts = await this.getExistingAccounts();
      if (existingAccounts.length === 0) {
        throw new Error(
          "No accounts found. Use SDK wallet factory methods to create accounts with proper private key data."
        );
      }
      const account = existingAccounts[0];
      walletLogger.debug(`✅ Using existing account: ${account.receiveAddress?.toString()}`);
      return account;
    } catch (error) {
      walletLogger.error("❌ Failed to get account:", error);
      throw error;
    }
  }
  /**
   * Get existing accounts from the wallet
   */
  async getExistingAccounts() {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before getting accounts.");
    }
    try {
      walletLogger.debug("📋 Getting existing accounts...");
      const response = await this.wasmWallet.accountsEnumerate({});
      this.accounts = response.accountDescriptors || [];
      walletLogger.debug(`✅ Found ${this.accounts.length} existing accounts`);
      return this.accounts;
    } catch (error) {
      walletLogger.error("❌ Failed to get existing accounts:", error);
      throw error;
    }
  }
  /**
   * Find an account by its address
   */
  getAccountByAddress(address) {
    return this.accounts.find((account) => account.receiveAddress?.toString() === address);
  }
  /**
   * Lock the wallet
   */
  /**
   * Lock wallet
   *
   * This locks BOTH the WASM wallet AND the signing enclave.
   * After locking, unlock() must be called again before signing transactions.
   */
  lock() {
    walletLogger.debug("🔒 Locking wallet and signing enclave...");
    this.locked = true;
    this.signingEnclave.lock();
    this.transactionMonitors.forEach((monitor) => {
      monitor.stop().catch((error) => {
        walletLogger.warn("⚠️ Failed to stop transaction monitor:", error);
      });
    });
    this.transactionMonitors.clear();
    walletLogger.debug("✅ Wallet and signing enclave locked");
  }
  /**
   * Unlock the wallet with password
   */
  /**
   * Unlock wallet from password
   *
   * This unlocks BOTH the WASM wallet AND the signing enclave.
   * After unlocking, the wallet can:
   * - Send transactions via accountsSend() (slow, waits for confirmations)
   * - Sign transactions via signTransaction() (fast, transaction chaining)
   */
  async unlockFromPassword(password) {
    if (!this.locked) {
      walletLogger.debug("⚠️ Wallet is already unlocked");
      return;
    }
    try {
      walletLogger.debug("🔓 Unlocking wallet and signing enclave...");
      walletLogger.debug("📋 Getting existing accounts...");
      const response = await this.wasmWallet.accountsEnumerate({});
      const accounts = response.accountDescriptors || [];
      if (this.signingEnclave.hasMnemonic()) {
        await this.signingEnclave.unlock({
          password,
          autoLockMs: 30 * 60 * 1e3
          // Auto-lock after 30 minutes
        });
      }
      this.locked = false;
      this.accounts = accounts;
      walletLogger.debug(`✅ Found ${accounts.length} existing accounts`);
      walletLogger.debug("✅ Wallet and signing enclave unlocked successfully");
    } catch (error) {
      walletLogger.error("❌ Failed to unlock wallet:", error);
      throw error;
    }
  }
  /**
   * Export wallet to encrypted keystore
   */
  async toEncryptedKeystore(_password, _meta) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before exporting.");
    }
    try {
      walletLogger.debug("📤 Exporting wallet to encrypted keystore...");
      const response = await this.wasmWallet.walletExport({
        walletSecret: "",
        // Empty string - WASM wallet is already unlocked
        includeTransactions: false
      });
      walletLogger.debug("✅ Wallet exported successfully");
      return response;
    } catch (error) {
      walletLogger.error("❌ Failed to export wallet:", error);
      throw error;
    }
  }
  /**
   * Get wallet balance for an account
   */
  async getBalance(accountId) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before getting balance.");
    }
    try {
      walletLogger.debug(`💰 Getting balance for account: ${accountId}`);
      const response = await this.wasmWallet.accountsGet({
        accountId
      });
      if (!response.accountDescriptor) {
        throw new Error("Account not found");
      }
      const balance = response.accountDescriptor.balance || 0n;
      walletLogger.debug(`💰 Balance: ${balance.toString()} sompi`);
      return balance;
    } catch (error) {
      walletLogger.error("❌ Failed to get balance:", error);
      throw error;
    }
  }
  /**
   * Send transaction using WASM wallet
   */
  async sendTransaction(request) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before sending transactions.");
    }
    try {
      walletLogger.debug(`💸 Sending transaction from account: ${request.accountId}`);
      const response = await this.wasmWallet.accountsSend({
        accountId: request.accountId,
        walletSecret: request.walletSecret,
        destination: request.destination,
        priorityFeeSompi: request.priorityFeeSompi
      });
      walletLogger.debug(`✅ Transaction sent! IDs: ${response.transactionIds.join(", ")}`);
      return response;
    } catch (error) {
      walletLogger.error("❌ Failed to send transaction:", error);
      throw error;
    }
  }
  /**
   * Get transaction history for an account
   */
  async getTransactionHistory(accountId, options) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before getting transaction history.");
    }
    try {
      walletLogger.debug(`📋 Getting transaction history for account: ${accountId}`);
      try {
        walletLogger.debug(`📋 Activating account for transaction history...`);
        await this.wasmWallet.accountsActivate({ accountIds: [accountId] });
        walletLogger.debug(`✅ Account activated successfully`);
      } catch (activationError) {
        walletLogger.warn("⚠️ Failed to activate account:", activationError);
      }
      const networkId = new NetworkId(this.network);
      const request = {
        accountId,
        networkId,
        start: options?.start || 0n,
        end: options?.end || 20n
        // Use same page size as official wallet (20)
      };
      const response = await this.wasmWallet.transactionsDataGet(request);
      walletLogger.debug(`📋 Response details:`, {
        accountId: response.accountId,
        start: response.start,
        total: response.total,
        transactionsCount: response.transactions?.length || 0
      });
      if (response.total === 0n) {
        walletLogger.debug(
          "📋 Wallet appears to be not yet synced (total: 0). This is normal for new wallets."
        );
        walletLogger.debug(
          "📋 The wallet needs to synchronize with the network before transaction history is available."
        );
        walletLogger.debug(
          "📋 This process can take a few minutes depending on network conditions."
        );
        return [];
      }
      walletLogger.debug(`✅ Retrieved ${response.transactions?.length || 0} transactions`);
      return response.transactions || [];
    } catch (error) {
      walletLogger.error("❌ Failed to get transaction history:", error);
      throw error;
    }
  }
  /**
   * Get UTXOs for an account using UtxoContext (like Kasia does)
   * This is a synchronous query of current wallet state - does NOT wait for discovery
   * If you need to wait for UTXOs, call waitForUtxos() instead
   * @param accountId - The account ID to get UTXOs for
   * @returns Array of UTXOs - either UtxoEntry instances from accountsGetUtxos or IUtxoEntry-compatible objects from UtxoContext
   */
  async getUtxos(accountId) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before getting UTXOs.");
    }
    try {
      walletLogger.debug(`📦 Getting UTXOs for account: ${accountId}`);
      const account = this.accounts.find((acc) => acc.accountId === accountId);
      if (!account || !account.receiveAddress) {
        walletLogger.debug("📦 No receive address found for account");
        return [];
      }
      const address = account.receiveAddress.toString();
      walletLogger.debug(`📦 Looking for UTXOs for address: ${address}`);
      try {
        if (this.context) {
          walletLogger.debug("📦 Found our UtxoContext, checking for UTXOs...");
          if (this.context.getMatureRange && this.context.matureLength !== void 0) {
            const matureUtxos = this.context.getMatureRange(0, this.context.matureLength);
            walletLogger.debug(
              `📦 Found ${matureUtxos?.length || 0} mature UTXOs from our context`
            );
            let pendingUtxos = [];
            if (this.context.getPending) {
              pendingUtxos = this.context.getPending() || [];
              walletLogger.debug(`📦 Found ${pendingUtxos.length} pending UTXOs from our context`);
            }
            const allUtxos = [...matureUtxos || [], ...pendingUtxos];
            walletLogger.debug(
              `📦 Total UTXOs from our context: ${allUtxos.length} (${matureUtxos?.length || 0} mature + ${pendingUtxos.length} pending)`
            );
            if (allUtxos.length > 0) {
              walletLogger.debug(`📦 Returning ${allUtxos.length} UTXOs from context`);
              return allUtxos;
            }
          } else {
            walletLogger.debug(
              "📦 Our UtxoContext found but getMatureRange or matureLength not available"
            );
          }
        } else {
          walletLogger.debug(
            "📦 No UtxoContext available - need to initialize UTXO processor first"
          );
        }
      } catch (contextError) {
        walletLogger.warn("📦 Failed to get UTXOs from our context:", contextError);
      }
      if (this.context && this.context.matureLength !== void 0 && this.context.matureLength < 2) {
        walletLogger.debug("📦 Context has limited UTXOs, trying to refresh tracking...");
        try {
          const addressesToTrack = [];
          for (const account2 of this.accounts) {
            if (account2.receiveAddress) {
              addressesToTrack.push(account2.receiveAddress.toString());
            }
            if (account2.changeAddress) {
              addressesToTrack.push(account2.changeAddress.toString());
            }
          }
          if (addressesToTrack.length > 0) {
            walletLogger.debug("📦 Re-tracking addresses for better UTXO discovery...");
            await this.context.trackAddresses(addressesToTrack);
            const matureUtxos = this.context.getMatureRange(0, this.context.matureLength);
            const pendingUtxos = this.context.getPending() || [];
            const allUtxos = [...matureUtxos || [], ...pendingUtxos];
            if (allUtxos.length > 0) {
              walletLogger.debug(`📦 Found ${allUtxos.length} UTXOs after re-tracking`);
              return allUtxos;
            }
          }
        } catch (refreshError) {
          walletLogger.warn("📦 Failed to refresh UTXO context:", refreshError);
        }
      }
      try {
        walletLogger.debug(`📦 Calling accountsGetUtxos for account: ${accountId}`);
        const allAddresses = [];
        const account2 = this.accounts.find((acc) => acc.accountId === accountId);
        if (account2) {
          walletLogger.debug(`📦 Using addresses from cached account`);
          if (account2.receiveAddress) {
            allAddresses.push(account2.receiveAddress.toString());
          }
          if (account2.changeAddress) {
            allAddresses.push(account2.changeAddress.toString());
          }
        } else {
          walletLogger.debug(`📦 Getting all addresses for account from WASM wallet: ${accountId}`);
          const accountResponse = await this.wasmWallet.accountsGet({
            accountId
          });
          if (accountResponse.accountDescriptor) {
            if (accountResponse.accountDescriptor.receiveAddress) {
              allAddresses.push(accountResponse.accountDescriptor.receiveAddress.toString());
            }
            if (accountResponse.accountDescriptor.changeAddress) {
              allAddresses.push(accountResponse.accountDescriptor.changeAddress.toString());
            }
          }
        }
        walletLogger.debug(`📦 Found ${allAddresses.length} addresses for account:`, allAddresses);
        const utxosResponse = await this.wasmWallet.accountsGetUtxos({
          accountId,
          addresses: allAddresses
        });
        walletLogger.debug(`📦 accountsGetUtxos response:`, {
          utxosCount: utxosResponse.utxos?.length || 0,
          hasUtxos: !!utxosResponse.utxos,
          utxosType: typeof utxosResponse.utxos
        });
        if (utxosResponse.utxos && utxosResponse.utxos.length > 0) {
          walletLogger.debug(`📦 Found ${utxosResponse.utxos.length} UTXOs from wallet state`);
          const utxosWithBigint = utxosResponse.utxos.map((utxo) => ({
            ...utxo,
            amount: typeof utxo.amount === "string" ? BigInt(utxo.amount) : utxo.amount,
            blockDaaScore: typeof utxo.blockDaaScore === "string" ? BigInt(utxo.blockDaaScore) : utxo.blockDaaScore
          }));
          return utxosWithBigint;
        }
        walletLogger.debug(
          `📦 No UTXOs found with all addresses, trying with receive address only: ${address}`
        );
        const utxosResponseWithAddress = await this.wasmWallet.accountsGetUtxos({
          accountId,
          addresses: [address]
        });
        walletLogger.debug(`accountsGetUtxos with address response`, {
          utxosCount: utxosResponseWithAddress.utxos?.length || 0,
          hasUtxos: !!utxosResponseWithAddress.utxos
        });
        if (utxosResponseWithAddress.utxos && utxosResponseWithAddress.utxos.length > 0) {
          walletLogger.debug(
            `📦 Found ${utxosResponseWithAddress.utxos.length} UTXOs with address filter`
          );
          const utxosWithBigint = utxosResponseWithAddress.utxos.map((utxo) => ({
            ...utxo,
            amount: typeof utxo.amount === "string" ? BigInt(utxo.amount) : utxo.amount,
            blockDaaScore: typeof utxo.blockDaaScore === "string" ? BigInt(utxo.blockDaaScore) : utxo.blockDaaScore
          }));
          return utxosWithBigint;
        }
        walletLogger.debug("📦 No UTXOs found with any approach");
        walletLogger.debug(
          "💡 Tip: If wallet has a balance but no UTXOs, try calling waitForUtxos() to wait for discovery"
        );
        return [];
      } catch (walletError) {
        walletLogger.warn("Failed to get UTXOs from wallet state", walletError);
        return [];
      }
    } catch (error) {
      walletLogger.error("❌ Failed to get UTXOs:", error);
      walletLogger.debug("📦 No UTXOs found from any source");
      return [];
    }
  }
  /**
   * Check if the wallet is synced with the network
   */
  isSynced() {
    return this.wasmWallet.isSynced;
  }
  /**
   * Wait for the wallet to be synced with the network
   */
  async waitForSync(timeoutMs = 6e4) {
    if (this.isSynced()) {
      walletLogger.debug("✅ Wallet is already synced");
      return true;
    }
    walletLogger.debug("⏳ Waiting for wallet to sync...");
    return new Promise((resolve) => {
      const cleanup = /* @__PURE__ */ __name$4(() => {
        if (timeout) clearTimeout(timeout);
        if (checkInterval) clearInterval(checkInterval);
      }, "cleanup");
      const timeout = setTimeout(() => {
        cleanup();
        walletLogger.debug("⏰ Timeout waiting for wallet sync");
        resolve(false);
      }, timeoutMs);
      const checkInterval = setInterval(() => {
        if (this.isSynced()) {
          walletLogger.debug("✅ Wallet sync completed!");
          cleanup();
          resolve(true);
        }
      }, 1e3);
    });
  }
  /**
   * Get transaction count for an account
   */
  async getTransactionCount(accountId) {
    if (this.locked) {
      throw new Error("Wallet is locked. Unlock before getting transaction count.");
    }
    try {
      walletLogger.debug(`📊 Getting transaction count for account: ${accountId}`);
      const request = {
        accountId,
        networkId: new NetworkId(this.network),
        start: 0n,
        end: 1n
        // Just get 1 transaction to check total count
      };
      const response = await this.wasmWallet.transactionsDataGet(request);
      const count = Number(response.total || 0);
      walletLogger.debug(`✅ Transaction count: ${count}`);
      return count;
    } catch (error) {
      walletLogger.error("❌ Failed to get transaction count:", error);
      throw error;
    }
  }
  /**
   * Add transaction update listener
   */
  onTransactionUpdate(callback) {
    this.transactionListeners.add(callback);
  }
  /**
   * Add balance update listener
   */
  onBalanceUpdate(callback) {
    this.balanceListeners.add(callback);
  }
  /**
   * Remove transaction update listener
   */
  removeTransactionListener(callback) {
    this.transactionListeners.delete(callback);
  }
  /**
   * Remove balance update listener
   */
  removeBalanceListener(callback) {
    this.balanceListeners.delete(callback);
  }
  /**
   * Sign a transaction using the secure enclave (fast transaction chaining)
   *
   * This is for fast stamping and transaction chaining that bypasses
   * the WASM wallet's accountsSend() method (which waits for confirmations).
   *
   * The mnemonic and private key exist in memory ONLY during signing (~0.2s),
   * then are immediately cleared.
   *
   * @param transaction - PendingTransaction to sign
   * @param options - Key derivation options
   * @throws Error if wallet or enclave is locked
   */
  async signTransaction(transaction, options) {
    if (this.locked) {
      throw new Error("Wallet is locked. Call unlockFromPassword() first.");
    }
    if (this.signingEnclave.isLocked()) {
      throw new Error("Signing enclave is locked. Call unlockFromPassword() first.");
    }
    await this.signingEnclave.sign(transaction, options);
  }
  /**
   * Cleanup resources
   */
  async cleanup() {
    walletLogger.debug("🧹 Cleaning up wallet resources...");
    this.signingEnclave.clear();
    for (const [accountId, monitor] of this.transactionMonitors) {
      try {
        await monitor.stop();
      } catch (error) {
        walletLogger.warn(`Failed to stop monitor for account ${accountId}`, error);
      }
    }
    this.transactionMonitors.clear();
    this.transactionListeners.clear();
    this.balanceListeners.clear();
    walletLogger.debug("✅ Wallet cleanup completed");
  }
};
var storageLogger = createLogger("kasstamp:wallet:storage");
(class {
  static {
    __name$4(this, "SimpleWalletStorageManager");
  }
  isInitialized = false;
  currentNetwork = null;
  async initialize() {
    if (!this.isInitialized) {
      await initKaspaWasm();
      this.isInitialized = true;
    }
  }
  /**
   * Set the current network for wallet enumeration
   * This ensures we only list wallets for the active network
   * Must be called before listing wallets
   */
  setNetwork(network) {
    this.currentNetwork = network;
  }
  /**
   * List all available wallets using WASM SDK for the current network
   */
  async listWallets() {
    if (!this.currentNetwork) {
      throw new Error("Network not set. Call setNetwork() before listing wallets.");
    }
    await this.initialize();
    const tempWallet = new Wallet$1({
      resident: true,
      // Don't persist this temporary wallet
      networkId: this.currentNetwork
    });
    try {
      const response = await tempWallet.walletEnumerate({});
      const allWallets = response.walletDescriptors;
      const networkSuffix = this.currentNetwork === "mainnet" ? "-mainnet" : "-testnet-10";
      const filteredWallets = allWallets.filter(
        (wallet) => wallet.filename.endsWith(networkSuffix)
      );
      filteredWallets.forEach((wallet) => {
        if (!wallet.title || wallet.title === wallet.filename) {
          wallet.title = wallet.filename.replace(networkSuffix, "");
        }
      });
      return filteredWallets;
    } finally {
      tempWallet.free();
    }
  }
  /**
   * Check if a wallet exists
   */
  async walletExists(walletName) {
    const wallets = await this.listWallets();
    return wallets.some((wallet) => wallet.filename === walletName || wallet.title === walletName);
  }
  /**
   * Get wallet descriptor by name
   */
  async getWalletDescriptor(walletName) {
    const wallets = await this.listWallets();
    return wallets.find((wallet) => wallet.filename === walletName || wallet.title === walletName) ?? null;
  }
  /**
   * Delete a wallet from storage
   * Removes the wallet from local storage by deleting the <walletname.wallet> key
   * Also removes the associated signing enclave data (<walletname.enclave>)
   */
  async deleteWallet(walletName) {
    try {
      await this.initialize();
      const walletDescriptor = await this.getWalletDescriptor(walletName);
      if (!walletDescriptor) {
        throw new Error(`Wallet "${walletName}" not found`);
      }
      const filename = walletDescriptor.filename;
      const storageKey = `${filename}.wallet`;
      const enclaveKey = `${filename}.enclave`;
      let walletDeleted = false;
      if (localStorage.getItem(storageKey)) {
        localStorage.removeItem(storageKey);
        storageLogger.debug(`✅ Wallet "${walletName}" (${storageKey}) deleted from local storage`);
        walletDeleted = true;
      } else {
        const altKey = filename;
        if (localStorage.getItem(altKey)) {
          localStorage.removeItem(altKey);
          storageLogger.debug(`✅ Wallet "${walletName}" (${altKey}) deleted from local storage`);
          walletDeleted = true;
        }
      }
      if (localStorage.getItem(enclaveKey)) {
        localStorage.removeItem(enclaveKey);
        storageLogger.debug(`✅ Signing enclave data (${enclaveKey}) deleted from local storage`);
      }
      if (!walletDeleted) {
        throw new Error(
          `Wallet storage key not found in local storage. Expected: ${storageKey} or ${filename}`
        );
      }
      return true;
    } catch (error) {
      storageLogger.error("Operation failed", error);
      throw error;
    }
  }
  /**
   * Rename a wallet by updating both the storage keys and internal title
   * Updates both .wallet and .enclave localStorage keys, and the title in the binary data
   */
  async renameWallet(oldName, newName) {
    try {
      if (!newName.trim()) {
        throw new Error("Wallet name cannot be empty");
      }
      await this.initialize();
      storageLogger.debug(`✏️ Renaming wallet from "${oldName}" to "${newName}"...`);
      const wallets = await this.listWallets();
      const descriptor = wallets.find((w) => w.title === oldName || w.filename === oldName);
      if (!descriptor) {
        throw new Error(`Wallet "${oldName}" not found`);
      }
      const oldFilename = descriptor.filename;
      storageLogger.debug(`📝 Found wallet with filename: ${oldFilename}`);
      const networkSuffixMatch = oldFilename.match(/-(mainnet|testnet-10)$/);
      if (!networkSuffixMatch) {
        throw new Error(`Could not extract network suffix from filename: ${oldFilename}`);
      }
      const networkSuffix = networkSuffixMatch[0];
      const newFilename = `${newName}${networkSuffix}`;
      storageLogger.debug(`📝 New filename will be: ${newFilename}`);
      const oldWalletKey = `${oldFilename}.wallet`;
      const oldEnclaveKey = `${oldFilename}.enclave`;
      const newWalletKey = `${newFilename}.wallet`;
      const newEnclaveKey = `${newFilename}.enclave`;
      const walletData = localStorage.getItem(oldWalletKey);
      if (!walletData) {
        throw new Error(`Wallet storage not found for "${oldFilename}"`);
      }
      storageLogger.debug(`📝 Found wallet data, length: ${walletData.length}`);
      const stringToHex = /* @__PURE__ */ __name$4((str) => {
        return Array.from(str).map((char) => char.charCodeAt(0).toString(16).padStart(2, "0")).join("");
      }, "stringToHex");
      const oldNameHex = stringToHex(oldName);
      const newNameHex = stringToHex(newName);
      storageLogger.debug(`📝 Updating title in binary data from "${oldName}" to "${newName}"`);
      const oldLengthPrefix = oldName.length.toString(16).padStart(8, "0");
      const newLengthPrefix = newName.length.toString(16).padStart(8, "0");
      const reverseLittleEndian = /* @__PURE__ */ __name$4((hex) => {
        return hex.match(/.{2}/g)?.reverse().join("") || hex;
      }, "reverseLittleEndian");
      const oldLengthLE = reverseLittleEndian(oldLengthPrefix);
      const newLengthLE = reverseLittleEndian(newLengthPrefix);
      const oldPattern = oldLengthLE + oldNameHex;
      const newPattern = newLengthLE + newNameHex;
      let updatedData = walletData.replace(oldPattern, newPattern);
      if (updatedData === walletData) {
        storageLogger.warn(
          "⚠️ Pattern with length prefix not found, trying without length prefix..."
        );
        updatedData = walletData.replace(oldNameHex, newNameHex);
        if (updatedData === walletData) {
          throw new Error("Could not find wallet name in storage data");
        }
      }
      localStorage.setItem(newWalletKey, updatedData);
      storageLogger.debug(`✅ Wallet storage saved to new key: ${newWalletKey}`);
      const enclaveData = localStorage.getItem(oldEnclaveKey);
      if (enclaveData) {
        localStorage.setItem(newEnclaveKey, enclaveData);
        storageLogger.debug(`✅ Enclave data moved to new key: ${newEnclaveKey}`);
        localStorage.removeItem(oldEnclaveKey);
        storageLogger.debug(`🗑️ Removed old enclave key: ${oldEnclaveKey}`);
      }
      localStorage.removeItem(oldWalletKey);
      storageLogger.debug(`🗑️ Removed old wallet key: ${oldWalletKey}`);
      descriptor.filename = newFilename;
      descriptor.title = newName;
      storageLogger.debug(`✅ Wallet renamed successfully: "${oldName}" -> "${newName}"`);
    } catch (error) {
      storageLogger.error("Operation failed", error);
      throw error;
    }
  }
});
(class {
  static {
    __name$4(this, "KaspaWalletFactory");
  }
  isWasmInitialized = false;
  /**
   * Ensure WASM is initialized before wallet operations
   */
  async ensureWasmReady() {
    if (!this.isWasmInitialized) {
      await initKaspaWasm();
      this.isWasmInitialized = true;
    }
  }
  networkToString(network) {
    return network;
  }
  /**
   * Connect WASM wallet to RPC with resolver and blockAsyncConnect
   */
  async connectWallet(wasmWallet) {
    const walletLogger2 = createLogger("kasstamp:sdk:wallet:connection");
    try {
      walletLogger2.info("Connecting WASM wallet to RPC");
      const connectOptions = {
        blockAsyncConnect: true,
        strategy: ConnectStrategy.Retry,
        timeoutDuration: 5e3,
        // 15 seconds total timeout
        retryInterval: 2e3
        // 2 seconds retry interval for faster node discovery
      };
      walletLogger2.debug("Connecting wallet with options", connectOptions);
      await wasmWallet.connect(connectOptions);
      walletLogger2.info("WASM wallet connected to RPC successfully");
    } catch (error) {
      walletLogger2.error("Failed to connect WASM wallet to RPC", error);
      throw error;
    }
  }
  /**
   * Create a new wallet with randomly generated mnemonic
   */
  async createNewWallet(options) {
    await this.ensureWasmReady();
    if (!options.network) {
      throw new Error("Network is required for wallet creation");
    }
    const networkString = this.networkToString(options.network);
    if (!Wallet$1) {
      throw new Error("Wallet class not available - WASM may not be properly initialized");
    }
    const mnemonic = Mnemonic$1.random(options.words);
    const mnemonicPhrase = mnemonic.phrase;
    const wasmWalletInstance = new Wallet$1({
      resident: false,
      networkId: networkString,
      resolver: new Resolver()
    });
    const networkSuffix = options.network === "mainnet" ? "mainnet" : "testnet-10";
    const filenameWithNetwork = `${options.name}-${networkSuffix}`;
    const createRequest = {
      walletSecret: options.walletSecret,
      filename: filenameWithNetwork,
      title: options.name,
      // Keep the display title without network
      overwriteWalletStorage: true
    };
    const createWalletLogger = createLogger("kasstamp:sdk:wallet:create");
    createWalletLogger.info("Creating wallet", {
      walletName: options.name,
      network: networkSuffix
    });
    const createResponse = await wasmWalletInstance.walletCreate(createRequest);
    createWalletLogger.info("Wallet created successfully", {
      filename: createResponse.walletDescriptor.filename
    });
    const actualFilename = createResponse.walletDescriptor.filename;
    const openRequest = {
      walletSecret: options.walletSecret,
      filename: actualFilename,
      accountDescriptors: true
    };
    createWalletLogger.debug("Opening wallet", { filename: actualFilename });
    const openResponse = await wasmWalletInstance.walletOpen(openRequest);
    const accountDescriptors = openResponse.accountDescriptors || [];
    await this.connectWallet(wasmWalletInstance);
    createWalletLogger.info("Starting wallet synchronization");
    await wasmWalletInstance.start();
    createWalletLogger.info("Wallet started successfully");
    const descriptor = {
      filename: actualFilename,
      // WASM needs the actual filename for storage operations
      title: options.name
      // But display the user's original name
    };
    const wallet = new SimpleWalletImpl(wasmWalletInstance, options.network.toString(), descriptor);
    await wallet.signingEnclave.storeMnemonic({
      mnemonic: mnemonicPhrase,
      password: options.walletSecret,
      bip39Passphrase: options.passphrase
      // BIP39 passphrase (undefined = no passphrase)
    });
    await wallet.initialize();
    if (accountDescriptors.length === 0) {
      createWalletLogger.info("No existing accounts found, creating first account");
      try {
        createWalletLogger.debug("Creating private key data from mnemonic");
        const prvKeyDataResponse = await wasmWalletInstance.prvKeyDataCreate({
          walletSecret: options.walletSecret,
          name: "Main Key",
          mnemonic: mnemonicPhrase,
          kind: "mnemonic",
          paymentSecret: options.passphrase || void 0
          // BIP39 passphrase (optional)
        });
        createWalletLogger.debug("Private key data created", {
          prvKeyDataId: prvKeyDataResponse.prvKeyDataId
        });
        createWalletLogger.debug("Creating first account");
        const accountResponse = await wasmWalletInstance.accountsCreate({
          walletSecret: options.walletSecret,
          type: "bip32",
          accountName: "Main Account",
          accountIndex: 0,
          prvKeyDataId: prvKeyDataResponse.prvKeyDataId,
          paymentSecret: options.passphrase || void 0
          // BIP39 passphrase (optional)
        });
        createWalletLogger.info("Account created successfully", {
          accountId: accountResponse.accountDescriptor?.accountId
        });
        await wallet.initialize();
      } catch (error) {
        createWalletLogger.error("Failed to create account", error);
        throw error;
      }
    } else {
      createWalletLogger.info("Found existing accounts", { count: accountDescriptors.length });
    }
    return { wallet, mnemonic: mnemonicPhrase };
  }
  /**
   * Import wallet from existing mnemonic
   */
  async createWalletFromMnemonic(mnemonic, options) {
    await this.ensureWasmReady();
    if (!options.network) {
      throw new Error("Network is required for wallet creation");
    }
    const networkString = this.networkToString(options.network);
    if (!Wallet$1) {
      throw new Error("Wallet class not available - WASM may not be properly initialized");
    }
    const wasmWalletInstance = new Wallet$1({
      resident: false,
      networkId: networkString,
      resolver: new Resolver()
    });
    const networkSuffix = options.network === "mainnet" ? "mainnet" : "testnet-10";
    const filenameWithNetwork = `${options.name}-${networkSuffix}`;
    const createRequest = {
      walletSecret: options.walletSecret,
      filename: filenameWithNetwork,
      title: options.name,
      // Keep the display title without network
      overwriteWalletStorage: true
    };
    const importLogger = createLogger("kasstamp:sdk:wallet:import");
    importLogger.info("Importing wallet", { walletName: options.name, network: networkSuffix });
    const createResponse = await wasmWalletInstance.walletCreate(createRequest);
    const actualFilename = createResponse.walletDescriptor.filename;
    const openRequest = {
      walletSecret: options.walletSecret,
      filename: actualFilename,
      accountDescriptors: true
    };
    await wasmWalletInstance.walletOpen(openRequest);
    importLogger.info("Importing mnemonic as private key data");
    const prvKeyDataRequest = {
      walletSecret: options.walletSecret,
      mnemonic,
      paymentSecret: options.passphrase || void 0,
      // BIP39 passphrase (optional)
      kind: "mnemonic"
    };
    const prvKeyDataResponse = await wasmWalletInstance.prvKeyDataCreate(prvKeyDataRequest);
    importLogger.debug("Mnemonic imported into wallet", {
      prvKeyDataId: prvKeyDataResponse.prvKeyDataId
    });
    importLogger.debug("Creating default account from imported private key data");
    const createAccountRequest = {
      walletSecret: options.walletSecret,
      type: "bip32",
      accountName: "Main Account",
      // Match creation flow naming
      accountIndex: 0,
      prvKeyDataId: prvKeyDataResponse.prvKeyDataId,
      paymentSecret: options.passphrase || void 0
      // BIP39 passphrase (optional)
    };
    const accountResponse = await wasmWalletInstance.accountsCreate(createAccountRequest);
    importLogger.info("Default account created", {
      accountId: accountResponse.accountDescriptor.accountId
    });
    await this.connectWallet(wasmWalletInstance);
    importLogger.info("Starting wallet synchronization");
    await wasmWalletInstance.start();
    importLogger.info("Wallet started successfully");
    const descriptor = {
      filename: actualFilename,
      // WASM needs the actual filename for storage operations
      title: options.name
      // But display the user's original name
    };
    const wallet = new SimpleWalletImpl(wasmWalletInstance, options.network.toString(), descriptor);
    await wallet.signingEnclave.storeMnemonic({
      mnemonic,
      password: options.walletSecret,
      bip39Passphrase: options.passphrase
      // BIP39 passphrase (undefined = no passphrase)
    });
    await wallet.initialize();
    importLogger.info("Unlocking imported wallet");
    await wallet.unlockFromPassword(options.walletSecret);
    importLogger.debug("Wallet unlocked", { locked: wallet.locked });
    importLogger.info("Wallet imported", { accountCount: wallet.accounts.length });
    return wallet;
  }
  /**
   * Open an existing wallet from storage
   */
  async openExistingWallet(walletName, walletSecret, network) {
    await this.ensureWasmReady();
    if (!walletSecret) {
      throw new Error("walletSecret is required for wallet operations");
    }
    if (!network) {
      throw new Error("Network is required for opening existing wallet");
    }
    const networkString = this.networkToString(network);
    const networkSuffix = network === "mainnet" ? "mainnet" : "testnet-10";
    const filenameWithNetwork = `${walletName}-${networkSuffix}`;
    const openRequest = {
      walletSecret,
      filename: filenameWithNetwork,
      accountDescriptors: true
    };
    const wasmWalletInstance = new Wallet$1({
      resident: false,
      networkId: networkString,
      resolver: new Resolver()
    });
    await wasmWalletInstance.walletOpen(openRequest);
    const wasmWallet = wasmWalletInstance;
    await this.connectWallet(wasmWalletInstance);
    const openLogger = createLogger("kasstamp:sdk:wallet:open");
    openLogger.info("Starting wallet synchronization");
    await wasmWalletInstance.start();
    openLogger.info("Wallet started successfully");
    const descriptor = {
      filename: filenameWithNetwork,
      // Must match the actual storage filename
      title: walletName
      // Display name without network suffix
    };
    const wallet = new SimpleWalletImpl(
      wasmWallet,
      network.toString(),
      descriptor
      // Pass descriptor so enclave can use correct storage key
    );
    await wallet.initialize();
    return wallet;
  }
  /**
   * Legacy method for basic wallet creation
   */
  async createWallet(options) {
    const result = await this.createNewWallet(options);
    return result.wallet;
  }
});
var monitoringLogger = createLogger("kasstamp:wallet:monitoring");
var BalanceMonitoringService = class {
  static {
    __name$4(this, "BalanceMonitoringService");
  }
  config;
  listeners = {};
  isMonitoring = false;
  pollingInterval;
  utxoSubscriptionActive = false;
  lastKnownBalance = null;
  constructor(config) {
    this.config = config;
  }
  /**
   * Add event listener
   */
  on(event, listener) {
    this.listeners[event] = listener;
  }
  /**
   * Remove event listener
   */
  off(event) {
    delete this.listeners[event];
  }
  /**
   * Emit event to listeners
   */
  emit(event, ...args) {
    const listener = this.listeners[event];
    if (listener) {
      try {
        listener(...args);
      } catch (error) {
        monitoringLogger.error(`Error in balance monitoring listener for ${event}`, error);
      }
    }
  }
  /**
   * Start monitoring for balance changes
   */
  async startMonitoring() {
    if (this.isMonitoring) {
      monitoringLogger.warn("Balance monitoring already active", { address: this.config.address });
      return;
    }
    monitoringLogger.info("Starting balance monitoring", { address: this.config.address });
    this.isMonitoring = true;
    try {
      await this.setupUtxoSubscription();
      this.startPeriodicPolling();
      await this.refreshBalance("manual-refresh");
      monitoringLogger.info("Balance monitoring started successfully", {
        address: this.config.address
      });
    } catch (error) {
      monitoringLogger.warn("Failed to start full monitoring, using polling only", {
        address: this.config.address,
        error
      });
      this.emit("error", error);
      this.startPeriodicPolling();
    }
  }
  /**
   * Stop all monitoring
   */
  async stopMonitoring() {
    if (!this.isMonitoring) {
      return;
    }
    monitoringLogger.info("Stopping balance monitoring", { address: this.config.address });
    this.isMonitoring = false;
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = void 0;
    }
    this.utxoSubscriptionActive = false;
    monitoringLogger.info("Balance monitoring stopped", { address: this.config.address });
  }
  /**
   * Get current balance using WASM wallet or RPC
   */
  async getCurrentBalance() {
    if (this.config.wasmWallet && this.config.accountId) {
      try {
        const accountResponse = await this.config.wasmWallet.accountsGet({
          accountId: this.config.accountId
        });
        if (accountResponse.accountDescriptor && accountResponse.accountDescriptor.balance !== void 0) {
          let totalBalance;
          if (typeof accountResponse.accountDescriptor.balance === "object" && accountResponse.accountDescriptor.balance !== null) {
            const balanceObj = accountResponse.accountDescriptor.balance;
            const mature = BigInt(balanceObj.mature || 0);
            const pending = BigInt(balanceObj.pending || 0);
            totalBalance = mature + pending;
            monitoringLogger.debug("WASM wallet balance retrieved", {
              accountId: this.config.accountId,
              mature: mature.toString(),
              pending: pending.toString(),
              total: totalBalance.toString()
            });
          } else {
            totalBalance = BigInt(accountResponse.accountDescriptor.balance || 0);
          }
          const balanceKas2 = this.sompiToKas(totalBalance).toString();
          monitoringLogger.debug("WASM wallet balance", {
            accountId: this.config.accountId,
            balanceSompi: totalBalance.toString(),
            balanceKas: balanceKas2
          });
          const response2 = {
            entries: [
              {
                address: new Address(this.config.address),
                balance: totalBalance
              }
            ]
          };
          return {
            response: response2,
            balanceKas: balanceKas2,
            source: "wasm-native"
          };
        }
      } catch (error) {
        monitoringLogger.warn("WASM balance not available, using RPC", { error });
      }
    }
    if (!this.config.rpcClient) {
      throw new Error("No balance source available (neither WASM wallet nor RPC client)");
    }
    const response = await this.config.rpcClient.call(
      "getBalancesByAddresses",
      {
        addresses: [this.config.address]
      }
    );
    const balanceInSompi = response.entries[0]?.balance ?? BigInt(0);
    const balanceKas = this.sompiToKas(balanceInSompi).toString();
    return {
      response,
      balanceKas,
      source: "rpc-query"
    };
  }
  /**
   * Manually refresh balance
   */
  async refreshBalance(source = "manual-refresh") {
    try {
      const { response, balanceKas, source: balanceSource } = await this.getCurrentBalance();
      if (this.lastKnownBalance !== balanceKas || source === "manual-refresh") {
        this.lastKnownBalance = balanceKas;
        this.emit("balance-updated", {
          response,
          balanceKas,
          source: balanceSource === "wasm-native" ? "wasm-native" : source,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      return balanceKas;
    } catch (error) {
      monitoringLogger.error("Failed to refresh balance", error, {
        address: this.config.address
      });
      this.emit("error", error);
      throw error;
    }
  }
  /**
   * Set up real-time UTXO subscription
   */
  async setupUtxoSubscription() {
    if (!this.config.rpcClient) {
      throw new Error("RPC client not available for UTXO subscription");
    }
    try {
      if (this.config.debug) {
        monitoringLogger.debug("Setting up UTXO subscription", {
          address: this.config.address,
          addressType: typeof this.config.address,
          addressLength: this.config.address?.length
        });
      }
      const wasmRpcClient = this.config.rpcClient.wasmRpcClient;
      if (!wasmRpcClient) {
        throw new Error("WASM RPC client not available for subscription");
      }
      await wasmRpcClient.subscribeUtxosChanged([this.config.address]);
      this.utxoSubscriptionActive = true;
      monitoringLogger.info("UTXO subscription active for real-time balance updates", {
        address: this.config.address
      });
    } catch (error) {
      monitoringLogger.error("Failed to set up UTXO subscription", error, {
        address: this.config.address
      });
      throw error;
    }
  }
  /**
   * Start periodic polling (fallback method)
   */
  startPeriodicPolling() {
    const interval = this.config.pollingInterval ?? 3e4;
    if (this.pollingInterval) {
      clearInterval(this.pollingInterval);
    }
    this.pollingInterval = setInterval(async () => {
      if (!this.isMonitoring) return;
      try {
        await this.refreshBalance("periodic-polling");
      } catch (error) {
        monitoringLogger.error("Periodic balance update failed", error, {
          address: this.config.address
        });
        this.emit("error", error);
      }
    }, interval);
    monitoringLogger.info("Periodic balance polling started", {
      address: this.config.address,
      intervalMs: interval
    });
  }
  /**
   * Convert Sompi to KAS
   * @param sompi - Amount in Sompi
   * @param rate - Conversion rate (default: 100000000)
   * @returns Amount in KAS
   */
  sompiToKas(sompi, rate = 1e8) {
    return Number(sompi) / rate;
  }
  /**
   * Convert KAS to Sompi
   * @param kas - Amount in KAS
   * @param rate - Conversion rate (default: 100000000)
   * @returns Amount in Sompi
   */
  kasToSompi(kas, rate = 1e8) {
    return BigInt(Math.floor(kas * rate));
  }
};
function createBalanceMonitoringService(config) {
  return new BalanceMonitoringService(config);
}
__name$4(createBalanceMonitoringService, "createBalanceMonitoringService");
var monitoringLogger2 = createLogger("kasstamp:wallet:monitoring");
var TransactionMonitoringService = class {
  static {
    __name$4(this, "TransactionMonitoringService");
  }
  wasmWallet;
  accountId;
  networkId;
  config;
  events;
  isRunning = false;
  pollTimer;
  knownTransactions = /* @__PURE__ */ new Set();
  constructor(wasmWallet, accountId, networkId, config = {}, events = {}) {
    this.wasmWallet = wasmWallet;
    this.accountId = accountId;
    this.networkId = networkId;
    this.config = {
      pollInterval: config.pollInterval || 1e4,
      // 10 seconds default
      autoStart: config.autoStart ?? false
    };
    this.events = events;
    if (this.config.autoStart) {
      this.start();
    }
  }
  /**
   * Start monitoring transactions
   */
  async start() {
    if (this.isRunning) {
      monitoringLogger2.warn("Transaction monitoring already running");
      return;
    }
    monitoringLogger2.info("Starting transaction monitoring");
    this.isRunning = true;
    await this.poll();
    this.scheduleNextPoll();
  }
  /**
   * Stop monitoring transactions
   */
  async stop() {
    monitoringLogger2.info("Stopping transaction monitoring");
    this.isRunning = false;
    if (this.pollTimer) {
      clearTimeout(this.pollTimer);
      this.pollTimer = void 0;
    }
  }
  /**
   * Poll for new transactions and balance changes
   */
  async poll() {
    try {
      const transactions = await this.wasmWallet.transactionsDataGet({
        accountId: this.accountId,
        networkId: new NetworkId(this.networkId),
        start: BigInt(0),
        end: BigInt(100)
      });
      for (const tx of transactions.transactions || []) {
        const txId = tx.id || "";
        if (!this.knownTransactions.has(txId)) {
          this.knownTransactions.add(txId);
          this.emitTransactionEvent(tx);
        }
      }
    } catch (error) {
      monitoringLogger2.error("Error polling transactions", error);
      if (this.events.onError) {
        this.events.onError(error);
      }
    }
  }
  /**
   * Emit transaction event
   */
  emitTransactionEvent(tx) {
    if (this.events.onTransaction) {
      const event = {
        type: "confirmed",
        transactionId: tx.id || "",
        timestamp: Date.now()
      };
      this.events.onTransaction(event);
    }
  }
  /**
   * Schedule next poll
   */
  scheduleNextPoll() {
    if (!this.isRunning) return;
    this.pollTimer = setTimeout(() => {
      this.poll().then(() => this.scheduleNextPoll());
    }, this.config.pollInterval);
  }
};
function createTransactionMonitoringService(wasmWallet, accountId, networkId, config, events) {
  return new TransactionMonitoringService(wasmWallet, accountId, networkId, config, events);
}
__name$4(createTransactionMonitoringService, "createTransactionMonitoringService");
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = { randomUUID };
function _v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  return _v4(options);
}
var __defProp$3 = Object.defineProperty;
var __name$3 = (target, value2) => __defProp$3(target, "name", { value: value2, configurable: true });
function generateGroupId() {
  return v4();
}
__name$3(generateGroupId, "generateGroupId");
async function splitArtifact(data, opts = {}) {
  const chunkSize = opts.chunkSize || 2e4;
  const groupId = opts.groupId || generateGroupId();
  const minChunks = opts.minChunks || 1;
  if (data.length <= chunkSize && minChunks <= 1) {
    const digest10 = await sha256Hex(data);
    return [
      {
        groupId,
        index: 0,
        total: 1,
        data,
        digest: digest10
      }
    ];
  }
  const totalChunks = Math.max(minChunks, Math.ceil(data.length / chunkSize));
  const chunks = [];
  for (let i2 = 0; i2 < totalChunks; i2++) {
    const start2 = i2 * chunkSize;
    const end = Math.min(start2 + chunkSize, data.length);
    const chunkData = data.slice(start2, end);
    const digest10 = await sha256Hex(chunkData);
    chunks.push({
      groupId,
      index: i2,
      total: totalChunks,
      data: chunkData,
      digest: digest10
    });
  }
  return chunks;
}
__name$3(splitArtifact, "splitArtifact");
const PATH_PARAM_RE = /\{[^{}]+\}/g;
const supportsRequestInitExt = () => {
  return typeof process === "object" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;
};
function randomID() {
  return Math.random().toString(36).slice(2, 11);
}
function createClient(clientOptions) {
  let {
    baseUrl = "",
    Request: CustomRequest = globalThis.Request,
    fetch: baseFetch = globalThis.fetch,
    querySerializer: globalQuerySerializer,
    bodySerializer: globalBodySerializer,
    headers: baseHeaders,
    requestInitExt = void 0,
    ...baseOptions
  } = { ...clientOptions };
  requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;
  baseUrl = removeTrailingSlash(baseUrl);
  const globalMiddlewares = [];
  async function coreFetch(schemaPath, fetchOptions) {
    const {
      baseUrl: localBaseUrl,
      fetch: fetch2 = baseFetch,
      Request: Request2 = CustomRequest,
      headers,
      params = {},
      parseAs = "json",
      querySerializer: requestQuerySerializer,
      bodySerializer = globalBodySerializer ?? defaultBodySerializer,
      body,
      middleware: requestMiddlewares = [],
      ...init3
    } = fetchOptions || {};
    let finalBaseUrl = baseUrl;
    if (localBaseUrl) {
      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
    }
    let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
    if (requestQuerySerializer) {
      querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
        ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
        ...requestQuerySerializer
      });
    }
    const serializedBody = body === void 0 ? void 0 : bodySerializer(
      body,
      // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:
      // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,
      // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,
      // setting the content-type at the very beginning to be overwritten.
      // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.
      mergeHeaders(baseHeaders, headers, params.header)
    );
    const finalHeaders = mergeHeaders(
      // with no body, we should not to set Content-Type
      serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression
      serializedBody instanceof FormData ? {} : {
        "Content-Type": "application/json"
      },
      baseHeaders,
      headers,
      params.header
    );
    const finalMiddlewares = [...globalMiddlewares, ...requestMiddlewares];
    const requestInit = {
      redirect: "follow",
      ...baseOptions,
      ...init3,
      body: serializedBody,
      headers: finalHeaders
    };
    let id;
    let options;
    let request = new Request2(
      createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),
      requestInit
    );
    let response;
    for (const key2 in init3) {
      if (!(key2 in request)) {
        request[key2] = init3[key2];
      }
    }
    if (finalMiddlewares.length) {
      id = randomID();
      options = Object.freeze({
        baseUrl: finalBaseUrl,
        fetch: fetch2,
        parseAs,
        querySerializer,
        bodySerializer
      });
      for (const m2 of finalMiddlewares) {
        if (m2 && typeof m2 === "object" && typeof m2.onRequest === "function") {
          const result = await m2.onRequest({
            request,
            schemaPath,
            params,
            options,
            id
          });
          if (result) {
            if (result instanceof Request2) {
              request = result;
            } else if (result instanceof Response) {
              response = result;
              break;
            } else {
              throw new Error("onRequest: must return new Request() or Response() when modifying the request");
            }
          }
        }
      }
    }
    if (!response) {
      try {
        response = await fetch2(request, requestInitExt);
      } catch (error2) {
        let errorAfterMiddleware = error2;
        if (finalMiddlewares.length) {
          for (let i2 = finalMiddlewares.length - 1; i2 >= 0; i2--) {
            const m2 = finalMiddlewares[i2];
            if (m2 && typeof m2 === "object" && typeof m2.onError === "function") {
              const result = await m2.onError({
                request,
                error: errorAfterMiddleware,
                schemaPath,
                params,
                options,
                id
              });
              if (result) {
                if (result instanceof Response) {
                  errorAfterMiddleware = void 0;
                  response = result;
                  break;
                }
                if (result instanceof Error) {
                  errorAfterMiddleware = result;
                  continue;
                }
                throw new Error("onError: must return new Response() or instance of Error");
              }
            }
          }
        }
        if (errorAfterMiddleware) {
          throw errorAfterMiddleware;
        }
      }
      if (finalMiddlewares.length) {
        for (let i2 = finalMiddlewares.length - 1; i2 >= 0; i2--) {
          const m2 = finalMiddlewares[i2];
          if (m2 && typeof m2 === "object" && typeof m2.onResponse === "function") {
            const result = await m2.onResponse({
              request,
              response,
              schemaPath,
              params,
              options,
              id
            });
            if (result) {
              if (!(result instanceof Response)) {
                throw new Error("onResponse: must return new Response() when modifying the response");
              }
              response = result;
            }
          }
        }
      }
    }
    if (response.status === 204 || request.method === "HEAD" || response.headers.get("Content-Length") === "0") {
      return response.ok ? { data: void 0, response } : { error: void 0, response };
    }
    if (response.ok) {
      if (parseAs === "stream") {
        return { data: response.body, response };
      }
      return { data: await response[parseAs](), response };
    }
    let error = await response.text();
    try {
      error = JSON.parse(error);
    } catch {
    }
    return { error, response };
  }
  return {
    request(method, url, init3) {
      return coreFetch(url, { ...init3, method: method.toUpperCase() });
    },
    /** Call a GET endpoint */
    GET(url, init3) {
      return coreFetch(url, { ...init3, method: "GET" });
    },
    /** Call a PUT endpoint */
    PUT(url, init3) {
      return coreFetch(url, { ...init3, method: "PUT" });
    },
    /** Call a POST endpoint */
    POST(url, init3) {
      return coreFetch(url, { ...init3, method: "POST" });
    },
    /** Call a DELETE endpoint */
    DELETE(url, init3) {
      return coreFetch(url, { ...init3, method: "DELETE" });
    },
    /** Call a OPTIONS endpoint */
    OPTIONS(url, init3) {
      return coreFetch(url, { ...init3, method: "OPTIONS" });
    },
    /** Call a HEAD endpoint */
    HEAD(url, init3) {
      return coreFetch(url, { ...init3, method: "HEAD" });
    },
    /** Call a PATCH endpoint */
    PATCH(url, init3) {
      return coreFetch(url, { ...init3, method: "PATCH" });
    },
    /** Call a TRACE endpoint */
    TRACE(url, init3) {
      return coreFetch(url, { ...init3, method: "TRACE" });
    },
    /** Register middleware */
    use(...middleware) {
      for (const m2 of middleware) {
        if (!m2) {
          continue;
        }
        if (typeof m2 !== "object" || !("onRequest" in m2 || "onResponse" in m2 || "onError" in m2)) {
          throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
        }
        globalMiddlewares.push(m2);
      }
    },
    /** Unregister middleware */
    eject(...middleware) {
      for (const m2 of middleware) {
        const i2 = globalMiddlewares.indexOf(m2);
        if (i2 !== -1) {
          globalMiddlewares.splice(i2, 1);
        }
      }
    }
  };
}
function serializePrimitiveParam(name2, value2, options) {
  if (value2 === void 0 || value2 === null) {
    return "";
  }
  if (typeof value2 === "object") {
    throw new Error(
      "Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these."
    );
  }
  return `${name2}=${options?.allowReserved === true ? value2 : encodeURIComponent(value2)}`;
}
function serializeObjectParam(name2, value2, options) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  const values = [];
  const joiner = {
    simple: ",",
    label: ".",
    matrix: ";"
  }[options.style] || "&";
  if (options.style !== "deepObject" && options.explode === false) {
    for (const k in value2) {
      values.push(k, options.allowReserved === true ? value2[k] : encodeURIComponent(value2[k]));
    }
    const final2 = values.join(",");
    switch (options.style) {
      case "form": {
        return `${name2}=${final2}`;
      }
      case "label": {
        return `.${final2}`;
      }
      case "matrix": {
        return `;${name2}=${final2}`;
      }
      default: {
        return final2;
      }
    }
  }
  for (const k in value2) {
    const finalName = options.style === "deepObject" ? `${name2}[${k}]` : k;
    values.push(serializePrimitiveParam(finalName, value2[k], options));
  }
  const final = values.join(joiner);
  return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
}
function serializeArrayParam(name2, value2, options) {
  if (!Array.isArray(value2)) {
    return "";
  }
  if (options.explode === false) {
    const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
    const final = (options.allowReserved === true ? value2 : value2.map((v) => encodeURIComponent(v))).join(joiner2);
    switch (options.style) {
      case "simple": {
        return final;
      }
      case "label": {
        return `.${final}`;
      }
      case "matrix": {
        return `;${name2}=${final}`;
      }
      default: {
        return `${name2}=${final}`;
      }
    }
  }
  const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
  const values = [];
  for (const v of value2) {
    if (options.style === "simple" || options.style === "label") {
      values.push(options.allowReserved === true ? v : encodeURIComponent(v));
    } else {
      values.push(serializePrimitiveParam(name2, v, options));
    }
  }
  return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
}
function createQuerySerializer(options) {
  return function querySerializer(queryParams) {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name2 in queryParams) {
        const value2 = queryParams[name2];
        if (value2 === void 0 || value2 === null) {
          continue;
        }
        if (Array.isArray(value2)) {
          if (value2.length === 0) {
            continue;
          }
          search.push(
            serializeArrayParam(name2, value2, {
              style: "form",
              explode: true,
              ...options?.array,
              allowReserved: options?.allowReserved || false
            })
          );
          continue;
        }
        if (typeof value2 === "object") {
          search.push(
            serializeObjectParam(name2, value2, {
              style: "deepObject",
              explode: true,
              ...options?.object,
              allowReserved: options?.allowReserved || false
            })
          );
          continue;
        }
        search.push(serializePrimitiveParam(name2, value2, options));
      }
    }
    return search.join("&");
  };
}
function defaultPathSerializer(pathname, pathParams) {
  let nextURL = pathname;
  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
    let name2 = match.substring(1, match.length - 1);
    let explode = false;
    let style = "simple";
    if (name2.endsWith("*")) {
      explode = true;
      name2 = name2.substring(0, name2.length - 1);
    }
    if (name2.startsWith(".")) {
      style = "label";
      name2 = name2.substring(1);
    } else if (name2.startsWith(";")) {
      style = "matrix";
      name2 = name2.substring(1);
    }
    if (!pathParams || pathParams[name2] === void 0 || pathParams[name2] === null) {
      continue;
    }
    const value2 = pathParams[name2];
    if (Array.isArray(value2)) {
      nextURL = nextURL.replace(match, serializeArrayParam(name2, value2, { style, explode }));
      continue;
    }
    if (typeof value2 === "object") {
      nextURL = nextURL.replace(match, serializeObjectParam(name2, value2, { style, explode }));
      continue;
    }
    if (style === "matrix") {
      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name2, value2)}`);
      continue;
    }
    nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value2)}` : encodeURIComponent(value2));
  }
  return nextURL;
}
function defaultBodySerializer(body, headers) {
  if (body instanceof FormData) {
    return body;
  }
  if (headers) {
    const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
    if (contentType === "application/x-www-form-urlencoded") {
      return new URLSearchParams(body).toString();
    }
  }
  return JSON.stringify(body);
}
function createFinalURL(pathname, options) {
  let finalURL = `${options.baseUrl}${pathname}`;
  if (options.params?.path) {
    finalURL = defaultPathSerializer(finalURL, options.params.path);
  }
  let search = options.querySerializer(options.params.query ?? {});
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    finalURL += `?${search}`;
  }
  return finalURL;
}
function mergeHeaders(...allHeaders) {
  const finalHeaders = new Headers();
  for (const h of allHeaders) {
    if (!h || typeof h !== "object") {
      continue;
    }
    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);
    for (const [k, v] of iterator) {
      if (v === null) {
        finalHeaders.delete(k);
      } else if (Array.isArray(v)) {
        for (const v2 of v) {
          finalHeaders.append(k, v2);
        }
      } else if (v !== void 0) {
        finalHeaders.set(k, v);
      }
    }
  }
  return finalHeaders;
}
function removeTrailingSlash(url) {
  if (url.endsWith("/")) {
    return url.substring(0, url.length - 1);
  }
  return url;
}
var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value2) => __defProp$2(target, "name", { value: value2, configurable: true });
function getApiBaseUrl(network) {
  switch (network) {
    case "mainnet":
      return "https://api.kaspa.org";
    case "testnet-10":
      return "https://api-tn10.kaspa.org";
    default:
      throw new Error(
        `Invalid network: ${network}. Only 'mainnet' and 'testnet-10' are supported.`
      );
  }
}
__name$2(getApiBaseUrl, "getApiBaseUrl");
function createKaspaApiClient(config) {
  const baseUrl = config.baseUrl || getApiBaseUrl(config.network);
  const client = createClient({ baseUrl });
  if (config.timeout) {
    const timeoutMiddleware = {
      async onRequest({ request }) {
        const controller = new AbortController();
        setTimeout(() => controller.abort(), config.timeout);
        return new Request(request, {
          signal: controller.signal
        });
      }
    };
    client.use(timeoutMiddleware);
  }
  return client;
}
__name$2(createKaspaApiClient, "createKaspaApiClient");
var KaspaApiClient = class {
  static {
    __name$2(this, "KaspaApiClient");
  }
  client;
  network;
  baseUrl;
  constructor(config) {
    this.network = config.network;
    this.baseUrl = config.baseUrl || getApiBaseUrl(config.network);
    this.client = createKaspaApiClient(config);
  }
  /**
   * Get transaction by ID
   *
   * @param transactionId - Transaction ID (hex string)
   * @param resolvePreviousOutpoints - Whether to resolve previous outpoints ('no' | 'light' | 'full')
   */
  async getTransaction(transactionId, resolvePreviousOutpoints = "light") {
    return await this.client.GET("/transactions/{transactionId}", {
      params: {
        path: { transactionId },
        query: { resolve_previous_outpoints: resolvePreviousOutpoints }
      }
    });
  }
  /**
   * Get transaction with full payload data
   * This is the method you'll want to use for file reconstruction
   */
  async getTransactionWithPayload(transactionId) {
    return await this.getTransaction(transactionId, "light");
  }
  /**
   * Get block by hash or blue score
   */
  async getBlock(blockId) {
    return await this.client.GET("/blocks/{blockId}", {
      params: {
        path: { blockId }
      }
    });
  }
  /**
   * Get address UTXOs
   */
  async getAddressUtxos(kaspaAddress) {
    return await this.client.GET("/addresses/{kaspaAddress}/utxos", {
      params: {
        path: { kaspaAddress }
      }
    });
  }
  /**
   * Get address balance
   */
  async getAddressBalance(kaspaAddress) {
    return await this.client.GET("/addresses/{kaspaAddress}/balance", {
      params: {
        path: { kaspaAddress }
      }
    });
  }
  /**
   * Get address transactions
   */
  async getAddressTransactions(kaspaAddress, options) {
    return await this.client.GET("/addresses/{kaspaAddress}/full-transactions", {
      params: {
        path: { kaspaAddress },
        query: options
      }
    });
  }
  /**
   * Get network info
   */
  async getNetworkInfo() {
    return await this.client.GET("/info/blockdag");
  }
  /**
   * Get fee estimate
   */
  async getFeeEstimate() {
    return await this.client.GET("/info/fee-estimate");
  }
};
var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value2) => __defProp$1(target, "name", { value: value2, configurable: true });
var KASPA_CONSTRAINTS = {
  /**
   * Maximum safe payload size per transaction chunk.
   *
   * This is limited by TRANSIENT MASS (KIP-0013), not compute or storage mass!
   *
   * Formula: transient_mass = tx_size × TRANSIENT_BYTE_TO_MASS_FACTOR
   * Where TRANSIENT_BYTE_TO_MASS_FACTOR = 4
   *
   * Calculation:
   * - Maximum allowed mass: 100,000
   * - Max tx_size: 100,000 / 4 = 25,000 bytes
   * - Minus overhead (~250 bytes for base tx + inputs + outputs): 24,750 bytes
   * - Safe value with 19% margin: 20,000 bytes (20KB)
   *
   * Mass breakdown for 20KB payload:
   * - Compute mass: ~22,000 (22% of limit)
   * - Transient mass: ~81,000 (81% of limit) ← THE BOTTLENECK!
   * - Storage mass: ~10,000 (10% of limit, with 1 KAS outputs)
   * - Network mass = max(22K, 81K, 10K) = 81,000 ✅
   *
   * Why not 24KB (theoretical max)?
   * - Would use 97% of transient mass limit
   * - Too risky - overhead varies with transaction structure
   * - 20KB provides reliable 19% safety buffer
   *
   * @see https://github.com/kaspanet/rusty-kaspa/blob/master/consensus/core/src/constants.rs#L21
   * @see README_STORAGE_MASS_CALCULATION.md for complete explanation
   */
  MAX_SAFE_PAYLOAD_SIZE: 2e4
  // 20KB - optimal for transient mass limit
};
var prepareLogger = createLogger("kasstamp:stamping:preparation");
async function prepareFileForPublicMode(file, options) {
  prepareLogger.debug("prepareFileForPublicMode called", {
    fileName: file.name,
    fileSize: file.size
  });
  prepareLogger.debug("Preparation options", { options });
  const arrayBuffer = await file.arrayBuffer();
  const data = new Uint8Array(arrayBuffer);
  prepareLogger.debug("File converted to Uint8Array", { length: data.length });
  const originalDigest = await sha256Hex(data);
  prepareLogger.debug("Original digest calculated", { digest: originalDigest });
  const groupId = options?.groupId || v4();
  prepareLogger.debug("Group ID generated", { groupId });
  const shouldCompress = options?.compression !== false;
  prepareLogger.debug(`STAMPING: Compression: ${shouldCompress ? "ENABLED" : "DISABLED"}`);
  let processedData = data;
  let compressed = false;
  let compressionRatio;
  if (shouldCompress) {
    prepareLogger.debug("Attempting compression");
    try {
      const compressedData = await gzipBytes(data);
      prepareLogger.debug("Compression completed", {
        original: data.length,
        compressed: compressedData.length
      });
      if (compressedData.length < data.length) {
        processedData = new Uint8Array(compressedData);
        compressed = true;
        compressionRatio = data.length / compressedData.length;
        prepareLogger.debug("Compression successful", { ratio: compressionRatio });
      } else {
        prepareLogger.warn("Compression did not reduce file size, skipping compression");
      }
    } catch (e2) {
      prepareLogger.error("Failed to compress data", e2);
    }
  } else {
    prepareLogger.debug("Compression disabled");
  }
  const maxChunkSize = KASPA_CONSTRAINTS.MAX_SAFE_PAYLOAD_SIZE;
  let chunks = [];
  let isChunked = false;
  prepareLogger.debug("Processed data info", { length: processedData.length, maxChunkSize });
  if (processedData.length > maxChunkSize) {
    prepareLogger.debug("Data needs chunking, calling splitArtifact");
    isChunked = true;
    const splitChunks = await splitArtifact(processedData, {
      chunkSize: maxChunkSize,
      groupId,
      minChunks: 1
    });
    prepareLogger.debug("splitArtifact completed", { chunkCount: splitChunks.length });
    chunks = splitChunks.map(
      (c2) => ({
        groupId: c2.groupId,
        index: c2.index,
        total: c2.total,
        data: c2.data,
        digest: c2.digest
      })
    );
  } else {
    prepareLogger.debug("Data fits in single chunk");
    chunks = [
      {
        groupId,
        index: 0,
        total: 1,
        data: processedData,
        digest: await sha256Hex(processedData)
      }
    ];
  }
  prepareLogger.debug("Building result object");
  const result = {
    originalFile: {
      name: file.name,
      size: file.size,
      originalDigest
    },
    processing: {
      compressed,
      compressionRatio,
      encrypted: false,
      chunked: isChunked,
      totalProcessedSize: processedData.length
    },
    chunks
  };
  prepareLogger.debug("Result completed", { result });
  return result;
}
__name$1(prepareFileForPublicMode, "prepareFileForPublicMode");
async function prepareFileForPrivateMode(file, enclave, options) {
  prepareLogger.debug("Private mode processing start");
  prepareLogger.debug("Processing file for private mode", {
    fileName: file.name,
    fileSize: file.size
  });
  prepareLogger.debug("Enclave status", { provided: !!enclave });
  if (!enclave) {
    prepareLogger.error("Signing enclave is required for private mode");
    throw new Error("Signing enclave is required for private mode");
  }
  const status = enclave.getStatus();
  prepareLogger.debug(`🔐 Enclave status BEFORE processing:`, {
    isLocked: status.isLocked,
    hasMnemonic: status.hasMnemonic
  });
  if (enclave.isLocked()) {
    prepareLogger.error("Signing enclave is locked. Please unlock your wallet first.");
    throw new Error("Signing enclave is locked. Please unlock your wallet first.");
  }
  if (!enclave.hasMnemonic()) {
    prepareLogger.error("Signing enclave has no mnemonic stored.");
    throw new Error("Signing enclave has no mnemonic stored.");
  }
  prepareLogger.debug("Enclave validation passed - proceeding with processing");
  prepareLogger.debug("Reading file into memory");
  const arrayBuffer = await file.arrayBuffer();
  const data = new Uint8Array(arrayBuffer);
  prepareLogger.debug("File loaded into memory", { bytes: data.length });
  prepareLogger.debug("Computing original digest");
  const originalDigest = await sha256Hex(data);
  prepareLogger.debug("Original digest computed", { digest: originalDigest });
  const groupId = options?.groupId || v4();
  prepareLogger.debug("Group ID", { groupId });
  const shouldCompress = options?.compression !== false;
  prepareLogger.debug(
    `⚙️ Compression: ${shouldCompress ? "ENABLED" : "DISABLED"} (user option: ${options?.compression})`
  );
  let processedData = data;
  let compressed = false;
  let compressionRatio;
  if (shouldCompress) {
    prepareLogger.debug(`🗜️ Starting compression...`);
    try {
      const compressedData = await gzipBytes(data);
      prepareLogger.debug(`📦 Compression result: ${data.length} → ${compressedData.length} bytes`);
      if (compressedData.length < data.length) {
        processedData = new Uint8Array(compressedData);
        compressed = true;
        compressionRatio = data.length / compressedData.length;
        prepareLogger.debug(`✅ Compression successful: ratio ${compressionRatio.toFixed(2)}x`);
      } else {
        prepareLogger.warn("⚠️ Compression did not reduce file size, skipping compression.");
      }
    } catch (e2) {
      prepareLogger.error("Compression failed", e2);
    }
  } else {
    prepareLogger.debug(`⏭️ Compression disabled by config`);
  }
  prepareLogger.debug(`🔐 ====== STARTING ENCRYPTION ======`);
  prepareLogger.debug(`🔐 Data to encrypt: ${processedData.length} bytes`);
  prepareLogger.debug(`🔐 Group ID for encryption: ${groupId}`);
  prepareLogger.debug(`🔐 About to call enclave.encryptWithWalletKey()...`);
  const encryptStartTime = Date.now();
  let encryptedData;
  try {
    encryptedData = await enclave.encryptWithWalletKey(processedData, groupId);
    const encryptDuration = Date.now() - encryptStartTime;
    prepareLogger.debug(
      `✅ Encryption complete: ${processedData.length} → ${encryptedData.length} bytes (took ${encryptDuration}ms)`
    );
  } catch (error) {
    prepareLogger.error("Encryption failed", error);
    throw error;
  }
  prepareLogger.debug(`🔐 ====== ENCRYPTION FINISHED ======`);
  const encryptedDataHash = await sha256Hex(encryptedData);
  prepareLogger.debug(`🔑 Encrypted data hash: ${encryptedDataHash}`);
  const maxChunkSize = KASPA_CONSTRAINTS.MAX_SAFE_PAYLOAD_SIZE;
  let chunks = [];
  let isChunked = false;
  if (encryptedData.length > maxChunkSize) {
    isChunked = true;
    const splitChunks = await splitArtifact(encryptedData, {
      chunkSize: maxChunkSize,
      groupId,
      minChunks: 1
    });
    chunks = splitChunks.map(
      (c2) => ({
        groupId: c2.groupId,
        index: c2.index,
        total: c2.total,
        data: c2.data,
        digest: c2.digest
      })
    );
  } else {
    chunks = [
      {
        groupId,
        index: 0,
        total: 1,
        data: encryptedData,
        digest: await sha256Hex(encryptedData)
      }
    ];
  }
  const result = {
    originalFile: {
      name: file.name,
      size: file.size,
      originalDigest,
      encryptedDigest: encryptedDataHash
      // Hash of encrypted data (privacy-safe)
    },
    processing: {
      compressed,
      compressionRatio,
      encrypted: true,
      encryptedWithWalletKey: true,
      chunked: isChunked,
      totalProcessedSize: encryptedData.length
    },
    chunks
  };
  return result;
}
__name$1(prepareFileForPrivateMode, "prepareFileForPrivateMode");
async function prepareTextForPublicMode(text, options) {
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const originalDigest = await sha256Hex(data);
  const groupId = options?.groupId || v4();
  const shouldCompress = options?.compression !== false;
  let processedData = data;
  let compressed = false;
  let compressionRatio;
  if (shouldCompress) {
    try {
      const compressedData = await gzipBytes(data);
      if (compressedData.length < data.length) {
        processedData = new Uint8Array(compressedData);
        compressed = true;
        compressionRatio = data.length / compressedData.length;
      } else {
        prepareLogger.warn("Compression did not reduce text size, skipping compression.");
      }
    } catch (e2) {
      prepareLogger.error("Failed to compress text data", e2);
    }
  }
  const maxChunkSize = KASPA_CONSTRAINTS.MAX_SAFE_PAYLOAD_SIZE;
  let chunks = [];
  let isChunked = false;
  if (processedData.length > maxChunkSize) {
    isChunked = true;
    const splitChunks = await splitArtifact(processedData, {
      chunkSize: maxChunkSize,
      groupId,
      minChunks: 1
    });
    chunks = splitChunks.map(
      (c2) => ({
        groupId: c2.groupId,
        index: c2.index,
        total: c2.total,
        data: c2.data,
        digest: c2.digest
      })
    );
  } else {
    chunks = [
      {
        groupId,
        index: 0,
        total: 1,
        data: processedData,
        digest: await sha256Hex(processedData)
      }
    ];
  }
  const result = {
    originalFile: {
      name: "text-input.txt",
      size: data.length,
      originalDigest
    },
    processing: {
      compressed,
      compressionRatio,
      encrypted: false,
      chunked: isChunked,
      totalProcessedSize: processedData.length
    },
    chunks
  };
  return result;
}
__name$1(prepareTextForPublicMode, "prepareTextForPublicMode");
async function prepareTextForPrivateMode(text, enclave, options) {
  if (!enclave) {
    throw new Error("Signing enclave is required for private mode");
  }
  if (enclave.isLocked()) {
    throw new Error("Signing enclave is locked. Please unlock your wallet first.");
  }
  if (!enclave.hasMnemonic()) {
    throw new Error("Signing enclave has no mnemonic stored.");
  }
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const originalDigest = await sha256Hex(data);
  const groupId = options?.groupId || v4();
  const shouldCompress = options?.compression !== false;
  let processedData = data;
  let compressed = false;
  let compressionRatio;
  if (shouldCompress) {
    try {
      const compressedData = await gzipBytes(data);
      if (compressedData.length < data.length) {
        processedData = new Uint8Array(compressedData);
        compressed = true;
        compressionRatio = data.length / compressedData.length;
        prepareLogger.debug(
          `🗜️ Text compression successful: ${data.length} → ${compressedData.length} bytes (${compressionRatio.toFixed(2)}x)`
        );
      } else {
        prepareLogger.warn("Compression did not reduce text size, skipping compression.");
      }
    } catch (e2) {
      prepareLogger.error("Failed to compress text data", e2);
    }
  }
  prepareLogger.debug(`🔐 Encrypting text with enclave (groupId: ${groupId})...`);
  const encryptedData = await enclave.encryptWithWalletKey(processedData, groupId);
  prepareLogger.debug(
    `✅ Encryption complete: ${processedData.length} → ${encryptedData.length} bytes`
  );
  const encryptedDataHash = await sha256Hex(encryptedData);
  prepareLogger.debug(`🔑 Encrypted data hash: ${encryptedDataHash}`);
  const maxChunkSize = KASPA_CONSTRAINTS.MAX_SAFE_PAYLOAD_SIZE;
  let chunks = [];
  let isChunked = false;
  if (encryptedData.length > maxChunkSize) {
    isChunked = true;
    const splitChunks = await splitArtifact(encryptedData, {
      chunkSize: maxChunkSize,
      groupId,
      minChunks: 1
    });
    chunks = splitChunks.map(
      (c2) => ({
        groupId: c2.groupId,
        index: c2.index,
        total: c2.total,
        data: c2.data,
        digest: c2.digest
      })
    );
  } else {
    chunks = [
      {
        groupId,
        index: 0,
        total: 1,
        data: encryptedData,
        digest: await sha256Hex(encryptedData)
      }
    ];
  }
  const result = {
    originalFile: {
      name: "text-input.txt",
      size: data.length,
      originalDigest,
      encryptedDigest: encryptedDataHash
      // Hash of encrypted data
    },
    processing: {
      compressed,
      compressionRatio,
      encrypted: true,
      encryptedWithWalletKey: true,
      chunked: isChunked,
      totalProcessedSize: encryptedData.length
    },
    chunks
  };
  return result;
}
__name$1(prepareTextForPrivateMode, "prepareTextForPrivateMode");
function uint8ArrayToBase64(uint8Array) {
  let binary = "";
  for (let i2 = 0; i2 < uint8Array.length; i2++) {
    binary += String.fromCharCode(uint8Array[i2]);
  }
  return btoa(binary);
}
__name$1(uint8ArrayToBase64, "uint8ArrayToBase64");
function getRawProcessingData(result) {
  const serializableChunks = result.chunks.map((chunk) => ({
    ...chunk,
    data: uint8ArrayToBase64(chunk.data)
    // Browser-compatible base64 encoding
  }));
  return {
    ...result,
    chunks: serializableChunks
  };
}
__name$1(getRawProcessingData, "getRawProcessingData");
function serializePayload(payload) {
  const metadata = {
    fileName: payload.fileName,
    chunkIndex: payload.chunkIndex,
    totalChunks: payload.totalChunks,
    digest: payload.digest,
    timestamp: payload.timestamp
  };
  const metadataJson = JSON.stringify(metadata);
  const metadataBytes = new TextEncoder().encode(metadataJson);
  const separator = new Uint8Array([0, 0, 0, 0]);
  const chunkData = payload.chunkData || new Uint8Array(0);
  const metadataLength = new Uint8Array(new Uint32Array([metadataBytes.length]).buffer);
  const totalLength = metadataLength.length + metadataBytes.length + separator.length + chunkData.length;
  const serialized = new Uint8Array(totalLength);
  let offset = 0;
  serialized.set(metadataLength, offset);
  offset += metadataLength.length;
  serialized.set(metadataBytes, offset);
  offset += metadataBytes.length;
  serialized.set(separator, offset);
  offset += separator.length;
  serialized.set(chunkData, offset);
  return serialized;
}
__name$1(serializePayload, "serializePayload");
function deserializePayload(serialized) {
  const metadataLengthBytes = serialized.slice(0, 4);
  const metadataLength = new Uint32Array(metadataLengthBytes.buffer)[0];
  const metadataStart = 4;
  const metadataEnd = metadataStart + metadataLength;
  const metadataBytes = serialized.slice(metadataStart, metadataEnd);
  const metadataJson = new TextDecoder().decode(metadataBytes);
  const metadata = JSON.parse(metadataJson);
  const chunkDataStart = metadataEnd + 4;
  const chunkData = chunkDataStart < serialized.length ? serialized.slice(chunkDataStart) : new Uint8Array(0);
  return {
    fileName: metadata.fileName,
    chunkIndex: metadata.chunkIndex,
    totalChunks: metadata.totalChunks,
    digest: metadata.digest,
    timestamp: metadata.timestamp,
    chunkData: chunkData.length > 0 ? chunkData : void 0
  };
}
__name$1(deserializePayload, "deserializePayload");
var chainLogger = createLogger("kasstamp:stamping:chain");
async function submitChainedTransaction(utxos, payload, signingFunction, rpcClient, options) {
  const { receiveAddress, changeAddress, outputAmount, priorityFee, networkId } = options;
  const utxoArray = Array.isArray(utxos) ? utxos : [utxos];
  const totalInputAmount = utxoArray.reduce((sum, u) => sum + u.amount, 0n);
  chainLogger.debug("Creating chained transaction", {
    payloadBytes: payload.length,
    inputUtxoCount: utxoArray.length,
    totalInputKAS: (Number(totalInputAmount) / 1e8).toFixed(2),
    firstUtxoIsVirtual: utxoArray[0].blockDaaScore === 18446744073709551615n
  });
  if (utxoArray.length > 0) {
    const firstUtxo = utxoArray[0];
    chainLogger.debug("UTXO passed to createTransactions", {
      hasAmount: "amount" in firstUtxo,
      amountValue: firstUtxo.amount.toString(),
      amountType: typeof firstUtxo.amount,
      hasAddress: "address" in firstUtxo,
      hasOutpoint: "outpoint" in firstUtxo,
      hasScriptPublicKey: "scriptPublicKey" in firstUtxo,
      keys: Object.keys(firstUtxo)
    });
  }
  chainLogger.debug("Creating transaction", {
    priorityFeeSompi: priorityFee.toString(),
    priorityFeeKAS: (Number(priorityFee) / 1e8).toFixed(8),
    payloadBytes: payload.length,
    outputAmountSompi: outputAmount.toString(),
    outputAmountKAS: (Number(outputAmount) / 1e8).toFixed(8)
  });
  let result;
  try {
    result = await createTransactions({
      outputs: outputAmount > 0n ? [{ address: receiveAddress, amount: outputAmount }] : [],
      // NO explicit output when amount is 0 - only change + payload!
      changeAddress,
      entries: utxoArray,
      payload,
      priorityFee,
      networkId
    });
  } catch (createError) {
    chainLogger.error("createTransactions() failed", createError, {
      payloadBytes: payload.length,
      outputAmountKAS: (Number(outputAmount) / 1e8).toFixed(8),
      note: "This suggests payload/storage mass limits exceeded"
    });
    throw createError;
  }
  if (!result.transactions || result.transactions.length === 0) {
    throw new Error("createTransactions produced no transactions");
  }
  const pendingTx = result.transactions[0];
  try {
    const tx2 = pendingTx.transaction;
    chainLogger.debug("Transaction Details", {
      inputCount: tx2.inputs.length,
      outputCount: tx2.outputs.length,
      payloadBytes: payload.length
    });
    const txSizeEstimate = tx2.inputs.length * 118 + // Each input ~118 bytes
    tx2.outputs.length * 43 + // Each output ~43 bytes
    payload.length + // Payload
    50;
    chainLogger.debug("Estimated TX size", { bytes: txSizeEstimate });
    const inputValues = tx2.inputs.map(
      (input) => {
        const utxo = utxoArray.find(
          (u) => u.outpoint.transactionId === input.previousOutpoint.transactionId && u.outpoint.index === input.previousOutpoint.index
        );
        return utxo ? Number(utxo.amount) : 0;
      }
    );
    const outputValues = tx2.outputs.map((output) => Number(output.value));
    chainLogger.debug("Input and output values", {
      inputValuesKAS: inputValues.map((v) => (v / 1e8).toFixed(8)).join(", "),
      outputValuesKAS: outputValues.map((v) => (v / 1e8).toFixed(8)).join(", ")
    });
    const totalMass = calculateTransactionMass(networkId, tx2);
    const storageMassActual = calculateStorageMass(networkId, inputValues, outputValues);
    chainLogger.debug("Mass Analysis", {
      totalTransactionMass: totalMass.toLocaleString(),
      storageMass: storageMassActual ? storageMassActual.toLocaleString() : "N/A",
      maximumAllowed: "100,000",
      remaining: (1e5 - Number(totalMass)).toLocaleString()
    });
    if (Number(totalMass) > 1e5) {
      const excessMass = Number(totalMass) - 1e5;
      const safePayloadSize = payload.length - Math.ceil(excessMass * 1.2);
      chainLogger.error("Mass EXCEEDS LIMIT", {
        excess: excessMass.toLocaleString(),
        suggestedMaxPayloadBytes: safePayloadSize,
        reason: `Total TX size (${txSizeEstimate} bytes) contributes to compute mass`
      });
    } else {
      chainLogger.debug("Mass within limits");
    }
  } catch (massError) {
    chainLogger.error("Could not calculate transaction mass", massError, {
      message: massError instanceof Error ? massError.message : String(massError),
      type: massError instanceof Error ? massError.constructor.name : typeof massError
    });
  }
  chainLogger.debug("Signing transaction with secure enclave", {
    inputCount: pendingTx.transaction.inputs.length,
    usingSecureEnclave: true
  });
  try {
    const addresses = pendingTx.addresses();
    chainLogger.debug("Addresses needing signatures", { addresses });
  } catch (e2) {
    chainLogger.debug("Could not get addresses", { error: e2 });
  }
  try {
    await signingFunction(pendingTx);
    chainLogger.debug("Transaction signed successfully with secure enclave");
  } catch (signError) {
    chainLogger.error("Signing failed", signError);
    throw signError;
  }
  const txId = await pendingTx.submit(rpcClient);
  chainLogger.info("Transaction submitted", {
    txId,
    feesKAS: (Number(result.summary.fees) / 1e8).toFixed(8)
  });
  try {
    const tx2 = pendingTx.transaction;
    const minimumFee = calculateTransactionFee(networkId, tx2);
    if (minimumFee) {
      const actualPriorityFee = Number(result.summary.fees) - Number(minimumFee);
      chainLogger.debug("Fee breakdown", {
        minimumFeeKAS: (Number(minimumFee) / 1e8).toFixed(8),
        priorityFeeKAS: actualPriorityFee > 0 ? (actualPriorityFee / 1e8).toFixed(8) : "0 (only paying minimum)"
      });
    }
  } catch (calcError) {
    chainLogger.warn("Could not calculate fee verification", { error: calcError });
  }
  const changeScript = payToAddressScript(new Address(changeAddress));
  const tx = pendingTx.transaction;
  chainLogger.debug("Transaction outputs", { count: tx.outputs.length });
  let changeOutputIndex = -1;
  let changeOutput = null;
  for (let i2 = 0; i2 < tx.outputs.length; i2++) {
    const output = tx.outputs[i2];
    const outputScript = output.scriptPublicKey;
    if (outputScript && changeScript) {
      const outputScriptStr = typeof outputScript.toString === "function" ? outputScript.toString() : JSON.stringify(outputScript);
      const changeScriptStr = typeof changeScript.toString === "function" ? changeScript.toString() : JSON.stringify(changeScript);
      if (outputScriptStr === changeScriptStr) {
        changeOutputIndex = i2;
        changeOutput = output;
        chainLogger.debug("Found change output", { index: i2 });
        break;
      }
    }
  }
  let virtualUtxo = null;
  if (changeOutput && changeOutputIndex >= 0) {
    virtualUtxo = {
      address: new Address(changeAddress),
      amount: changeOutput.value,
      scriptPublicKey: changeOutput.scriptPublicKey,
      outpoint: {
        transactionId: txId,
        index: changeOutputIndex
      },
      blockDaaScore: 18446744073709551615n,
      // u64::MAX = unconfirmed/virtual
      isCoinbase: false
      // Change outputs are never coinbase
    };
    chainLogger.debug("Created virtual UTXO", {
      valueKAS: (Number(changeOutput.value) / 1e8).toFixed(2)
    });
  } else {
    chainLogger.warn("No change output found - transaction may have consumed exact UTXO amount");
  }
  return {
    transactionId: txId,
    fees: result.summary.fees,
    mass: result.summary.mass,
    virtualUtxo
  };
}
__name$1(submitChainedTransaction, "submitChainedTransaction");
async function submitTransactionChain(initialUtxos, payloads, signingFunction, rpcClient, options) {
  const startTime = Date.now();
  const transactionIds = [];
  let totalFees = 0n;
  let totalMass = 0n;
  let currentUtxo = initialUtxos;
  chainLogger.info("Starting fast transaction chain", { transactionCount: payloads.length });
  chainLogger.info("No confirmation waits - rapid submission");
  for (let i2 = 0; i2 < payloads.length; i2++) {
    const payload = payloads[i2];
    try {
      const result = await submitChainedTransaction(
        currentUtxo,
        payload,
        signingFunction,
        // Pass secure enclave signing function
        rpcClient,
        options
      );
      transactionIds.push(result.transactionId);
      totalFees += result.fees;
      totalMass += result.mass;
      chainLogger.info("Transaction submitted in chain", {
        index: i2 + 1,
        total: payloads.length,
        txId: result.transactionId
      });
      if (i2 < payloads.length - 1) {
        if (!result.virtualUtxo) {
          throw new Error(
            `No change output found for transaction ${i2 + 1} - cannot continue chain`
          );
        }
        currentUtxo = result.virtualUtxo;
      }
    } catch (error) {
      chainLogger.error("Transaction failed in chain", error, {
        index: i2 + 1,
        total: payloads.length
      });
      throw new Error(`Transaction ${i2 + 1} failed in chain: ${error}`);
    }
  }
  const elapsedMs = Date.now() - startTime;
  const elapsedSec = (elapsedMs / 1e3).toFixed(1);
  chainLogger.info("Chain complete", {
    transactionCount: transactionIds.length,
    elapsedSeconds: elapsedSec,
    totalFeesKAS: (Number(totalFees) / 1e8).toFixed(8),
    avgTimePerTxMs: (elapsedMs / payloads.length).toFixed(0)
  });
  return {
    transactionIds,
    totalFees,
    totalMass,
    elapsedMs
  };
}
__name$1(submitTransactionChain, "submitTransactionChain");
async function buildUnifiedEnvelope(fullPayload, mode, groupId) {
  const payload = serializePayload(fullPayload);
  return {
    metadata: {
      groupId,
      mode
    },
    payload
  };
}
__name$1(buildUnifiedEnvelope, "buildUnifiedEnvelope");
var stampLogger = createLogger("kasstamp:stamping:file");
async function stampFiles(artifactProcessingResults, wallet, options, getNetwork, priorityFee) {
  const startTime = Date.now();
  const batchLogger = stampLogger.child("batch");
  batchLogger.info("Starting batched fast stamping", {
    artifactCount: artifactProcessingResults.length
  });
  const accounts = wallet.accounts;
  if (!accounts || accounts.length === 0) {
    throw new Error("No accounts available in wallet");
  }
  const accountId = accounts[0].accountId;
  const receiveAddress = accounts[0].receiveAddress?.toString();
  const changeAddress = accounts[0].changeAddress?.toString();
  if (!receiveAddress || !changeAddress) {
    throw new Error("No receive or change address available");
  }
  const utxos = await wallet.getUtxos(accountId);
  if (!utxos || utxos.length === 0) {
    throw new Error("No UTXOs available for stamping");
  }
  if (utxos.length > 0) {
    const firstUtxo = utxos[0];
    batchLogger.debug("UTXO properties", {
      keys: Object.keys(firstUtxo),
      blockDaaScore: firstUtxo.blockDaaScore.toString(),
      isCoinbase: firstUtxo.isCoinbase,
      amount: firstUtxo.amount.toString()
    });
  }
  const matureUtxos = utxos;
  if (matureUtxos.length === 0) {
    throw new Error("No mature UTXOs available. Please wait for pending transactions to confirm.");
  }
  batchLogger.info("Starting batched stamping", {
    matureUtxoCount: matureUtxos.length
  });
  batchLogger.info("Using FAST transaction chaining - no confirmation waits");
  const sortedUtxos = [...matureUtxos].sort((a2, b) => Number(b.amount - a2.amount));
  const largestUtxo = sortedUtxos[0];
  batchLogger.info("Using largest UTXO for batched stamping chain", {
    utxoValueKAS: (Number(largestUtxo.amount) / 1e8).toFixed(2)
  });
  batchLogger.debug("Creating secure signing function from enclave");
  if (!wallet.signingEnclave) {
    throw new Error("Wallet does not have a signing enclave");
  }
  if (wallet.signingEnclave.isLocked()) {
    throw new Error("Signing enclave is locked. Please unlock your wallet first.");
  }
  if (!wallet.signingEnclave.hasMnemonic()) {
    throw new Error(
      "Signing enclave has no mnemonic stored. Please unlock your wallet with your recovery phrase."
    );
  }
  const signingFunction = /* @__PURE__ */ __name$1(async (transaction) => {
    await wallet.signingEnclave.signWithAutoDiscovery(
      transaction,
      wallet.network,
      0
      // accountIndex
    );
  }, "signingFunction");
  batchLogger.info("Secure signing function ready - enclave will auto-discover required keys");
  const allPayloads = [];
  const allDebugInfo = [];
  const artifactPayloadRanges = [];
  let currentPayloadIndex = 0;
  const batchStartTime = Date.now();
  batchLogger.debug("Processing artifacts with parallel envelope building", {
    artifactCount: artifactProcessingResults.length
  });
  const artifactProcessingPromises = artifactProcessingResults.map(async ({ processingResult }) => {
    const groupId = processingResult.chunks[0]?.groupId;
    const chunkEnvelopePromises = processingResult.chunks.map(async (chunk) => {
      const fullPayload = {
        fileName: processingResult.originalFile.name,
        chunkIndex: chunk.index,
        totalChunks: processingResult.chunks.length,
        digest: chunk.digest,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        chunkData: chunk.data
      };
      return await buildUnifiedEnvelope(fullPayload, options.mode, groupId);
    });
    const envelopes = await Promise.all(chunkEnvelopePromises);
    const payloadPromises = envelopes.map(async (envelope) => {
      const payloadInfo = buildStampingPayload({
        metadata: envelope.metadata,
        chunkData: envelope.payload
      });
      return {
        payload: payloadInfo.payload,
        debugInfo: options.includeDebugInfo ? payloadInfo : null
      };
    });
    const payloadResults = await Promise.all(payloadPromises);
    return {
      payloads: payloadResults.map((r2) => r2.payload),
      debugInfo: payloadResults.map((r2) => r2.debugInfo).filter(Boolean),
      envelopeCount: envelopes.length
    };
  });
  const artifactResults = await Promise.all(artifactProcessingPromises);
  for (const result of artifactResults) {
    const startIndex = currentPayloadIndex;
    allPayloads.push(...result.payloads);
    allDebugInfo.push(...result.debugInfo);
    currentPayloadIndex += result.envelopeCount;
    const endIndex = currentPayloadIndex - 1;
    artifactPayloadRanges.push({
      start: startIndex,
      end: endIndex,
      chunkCount: result.envelopeCount
    });
    batchLogger.debug("Artifact payloads added", {
      startIndex,
      endIndex,
      chunkCount: result.envelopeCount
    });
  }
  const batchDuration = ((Date.now() - batchStartTime) / 1e3).toFixed(2);
  batchLogger.info("All artifacts processed", {
    durationSeconds: batchDuration,
    mode: "parallel"
  });
  batchLogger.info("Total payloads to chain", { transactionCount: allPayloads.length });
  const wasmWallet = wallet.wasmWallet;
  if (!wasmWallet) {
    throw new Error("WASM wallet not available");
  }
  const rpcClient = wasmWallet.rpc;
  if (!rpcClient) {
    throw new Error("RPC client not available");
  }
  const networkId = getNetwork();
  const utxoValueKAS = Number(largestUtxo.amount) / 1e8;
  batchLogger.info("Starting batched transaction chain", {
    utxoValueKAS: utxoValueKAS.toFixed(4),
    transactionCount: allPayloads.length
  });
  batchLogger.debug("No stamp outputs - everything goes to change except fees");
  const chainResult = await submitTransactionChain(
    largestUtxo,
    // Use ONLY the largest UTXO to minimize mass
    allPayloads,
    signingFunction,
    rpcClient,
    {
      receiveAddress,
      changeAddress,
      outputAmount: 0n,
      // NO explicit output - only change + payload!
      priorityFee,
      networkId
    }
  );
  const totalTime = ((Date.now() - startTime) / 1e3).toFixed(1);
  batchLogger.info("All batched transactions submitted", {
    transactionCount: chainResult.transactionIds.length,
    totalTimeSeconds: totalTime
  });
  batchLogger.info("FAST MODE: No confirmation waits");
  const results = [];
  for (let i2 = 0; i2 < artifactProcessingResults.length; i2++) {
    const { file, processingResult } = artifactProcessingResults[i2];
    const payloadRange = artifactPayloadRanges[i2];
    const artifactTransactionIds = chainResult.transactionIds.slice(
      payloadRange.start,
      payloadRange.end + 1
    );
    const artifactFees = chainResult.totalFees * BigInt(artifactTransactionIds.length) / BigInt(chainResult.transactionIds.length);
    const totalTxs = artifactTransactionIds.length;
    const totalCost = Number(artifactFees) / 1e8;
    const groupId = processingResult.chunks[0]?.groupId;
    const isPrivate2 = options.mode === "private";
    let transactionIdsField = artifactTransactionIds;
    let transactionIdsEncrypted = false;
    let encryptedMetadata;
    if (isPrivate2 && wallet.signingEnclave) {
      batchLogger.info("Encrypting sensitive receipt data for artifact", {
        artifactIndex: i2 + 1,
        totalArtifacts: artifactProcessingResults.length
      });
      const txIdsJson = JSON.stringify(artifactTransactionIds);
      const txIdsBytes = new TextEncoder().encode(txIdsJson);
      const encryptedTxIds = await wallet.signingEnclave.encryptWithWalletKey(txIdsBytes, groupId);
      transactionIdsField = btoa(String.fromCharCode(...encryptedTxIds));
      transactionIdsEncrypted = true;
      batchLogger.debug("Transaction IDs encrypted", { count: artifactTransactionIds.length });
      const metadataToEncrypt = {
        fileName: file.name,
        fileSize: file.size,
        hash: processingResult.originalFile.originalDigest
      };
      const metadataJson = JSON.stringify(metadataToEncrypt);
      const metadataBytes = new TextEncoder().encode(metadataJson);
      const encryptedMetadataBytes = await wallet.signingEnclave.encryptWithWalletKey(
        metadataBytes,
        groupId
      );
      encryptedMetadata = btoa(String.fromCharCode(...encryptedMetadataBytes));
      batchLogger.debug("Metadata encrypted", { fileName: file.name });
    }
    const receipt = {
      // Core identifiers
      id: artifactTransactionIds[0],
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      // File metadata (placeholder for private, real for public)
      fileName: isPrivate2 ? "[encrypted]" : file.name,
      fileSize: isPrivate2 ? 0 : file.size,
      hash: isPrivate2 ? "[encrypted]" : processingResult.originalFile.originalDigest,
      // Encrypted metadata (private mode only)
      encryptedMetadata,
      // Privacy & encryption
      privacy: options.mode,
      encrypted: isPrivate2,
      compressed: processingResult.processing.compressed,
      groupId: isPrivate2 ? groupId : void 0,
      // Transaction data (ENCRYPTED in private mode!)
      transactionIds: transactionIdsField,
      transactionIdsEncrypted,
      chunkCount: totalTxs,
      // Cost & network
      totalCostKAS: totalCost,
      network: networkId,
      walletAddress: receiveAddress
    };
    const result = {
      transactionIds: artifactTransactionIds,
      envelopes: [],
      // Could be populated with the actual envelopes if needed
      processingResult,
      receipt,
      debugInfo: options.includeDebugInfo ? {
        payloadStructures: allDebugInfo.slice(payloadRange.start, payloadRange.end + 1),
        estimatedMasses: allDebugInfo.slice(payloadRange.start, payloadRange.end + 1).map((d2) => d2.massEstimate.totalEstimate)
      } : void 0
    };
    results.push(result);
    batchLogger.info("Receipt generated", {
      receiptIndex: i2 + 1,
      fileName: file.name,
      transactionCount: artifactTransactionIds.length,
      costKAS: totalCost.toFixed(6)
    });
  }
  return results;
}
__name$1(stampFiles, "stampFiles");
var reconstructLogger = createLogger("kasstamp:sdk:reconstruction");
async function reconstructFileFromReceipt(receipt, wallet, onProgress) {
  const isEncrypted = receipt.privacy === "private" || receipt.encrypted === true;
  if (isEncrypted && (!wallet || !wallet.wasmWallet)) {
    throw new Error("WASM wallet required for private/encrypted receipts");
  }
  let accountId;
  if (wallet && wallet.wasmWallet) {
    accountId = wallet.accounts?.[0]?.accountId;
    if (isEncrypted && !accountId) {
      throw new Error("No account ID available for private receipt");
    }
  }
  let transactionIds;
  if (typeof receipt.transactionIds === "string" && receipt.transactionIdsEncrypted) {
    reconstructLogger.info("Transaction IDs are encrypted, decrypting");
    if (!wallet || !wallet.signingEnclave) {
      throw new Error("Wallet with signing enclave required to decrypt transaction IDs");
    }
    if (wallet.signingEnclave.isLocked()) {
      throw new Error("Wallet signing enclave is locked. Please unlock your wallet first.");
    }
    if (!wallet.signingEnclave.hasMnemonic()) {
      throw new Error("Wallet signing enclave has no mnemonic stored.");
    }
    if (!receipt.groupId) {
      throw new Error("Receipt missing groupId - cannot decrypt transaction IDs");
    }
    try {
      const encryptedBytes = Uint8Array.from(atob(receipt.transactionIds), (c2) => c2.charCodeAt(0));
      reconstructLogger.debug("Decrypting transaction IDs", {
        encryptedBytes: encryptedBytes.length
      });
      const decryptedBytes = await wallet.signingEnclave.decryptWithWalletKey(
        encryptedBytes,
        receipt.groupId
      );
      const decryptedJson = new TextDecoder().decode(decryptedBytes);
      transactionIds = JSON.parse(decryptedJson);
      reconstructLogger.info("Transaction IDs decrypted", { count: transactionIds.length });
    } catch (error) {
      reconstructLogger.error("Failed to decrypt transaction IDs", error);
      throw new Error(`Failed to decrypt transaction IDs: ${error.message}`);
    }
  } else if (Array.isArray(receipt.transactionIds)) {
    transactionIds = receipt.transactionIds;
    reconstructLogger.debug("Using plaintext transaction IDs", { count: transactionIds.length });
  } else {
    throw new Error("Invalid receipt format: transactionIds must be array or encrypted string");
  }
  onProgress?.({
    stage: "fetching",
    current: 0,
    total: transactionIds.length,
    message: "Fetching transactions from blockchain..."
  });
  if (!receipt.network) {
    throw new Error("Receipt does not contain network information. Cannot reconstruct file.");
  }
  let networkType;
  const networkStr = receipt.network;
  if (networkStr === "testnet-10") {
    networkType = "testnet-10";
  } else if (networkStr === "mainnet") {
    networkType = "mainnet";
  } else {
    throw new Error(
      `Invalid network in receipt: ${networkStr}. Only 'mainnet' and 'testnet-10' are supported.`
    );
  }
  const apiClient = new KaspaApiClient({ network: networkType });
  const CONCURRENCY = 10;
  const chunkPayloads = [];
  let completed = 0;
  const fetchChunk = /* @__PURE__ */ __name$1(async (txId, index) => {
    try {
      const { data: txData, error } = await apiClient.getTransactionWithPayload(txId);
      if (error || !txData) {
        throw new Error(`Failed to fetch transaction ${txId}: ${error || "No data returned"}`);
      }
      const txDataWithPayload = txData;
      const payloadHex = txDataWithPayload.payload;
      if (!payloadHex || payloadHex === "00" || payloadHex === "") {
        throw new Error(`Transaction ${txId} has no payload data`);
      }
      const decoded = decodeStampingPayload(payloadHex);
      chunkPayloads.push({
        index,
        data: decoded.chunkData,
        // Store unified payload (will deserialize later)
        encrypted: decoded.metadata.encrypted === true
        // Track if encrypted
      });
      completed++;
      onProgress?.({
        stage: "fetching",
        current: completed,
        total: transactionIds.length,
        message: `Fetching chunk ${completed}/${transactionIds.length}...`
      });
    } catch (error) {
      throw new Error(`Failed to fetch chunk ${index} from transaction ${txId}: ${error}`);
    }
  }, "fetchChunk");
  for (let i2 = 0; i2 < transactionIds.length; i2 += CONCURRENCY) {
    const batch = transactionIds.slice(i2, i2 + CONCURRENCY);
    const promises = batch.map((txId, batchIndex) => fetchChunk(txId, i2 + batchIndex));
    await Promise.all(promises);
  }
  if (chunkPayloads.length === 0) {
    throw new Error("No chunk data found in transactions");
  }
  chunkPayloads.sort((a2, b) => a2.index - b.index);
  onProgress?.({
    stage: "assembling",
    current: 0,
    total: chunkPayloads.length,
    message: `Assembling ${chunkPayloads.length} chunks...`
  });
  const deserializedChunks = [];
  for (const chunk of chunkPayloads) {
    const payloadData = chunk.data;
    const fullPayload = deserializePayload(payloadData);
    if (fullPayload.chunkData) {
      deserializedChunks.push(fullPayload.chunkData);
      reconstructLogger.debug("Chunk extracted", {
        chunkIndex: chunk.index,
        chunkSize: fullPayload.chunkData.length
      });
    }
  }
  const totalSize = deserializedChunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const reassembled = new Uint8Array(totalSize);
  let offset = 0;
  for (const chunk of deserializedChunks) {
    reassembled.set(chunk, offset);
    offset += chunk.length;
  }
  reconstructLogger.debug("All chunks reassembled", {
    totalSize,
    isEncrypted,
    isCompressed: receipt.compressed
  });
  let finalData = reassembled;
  let decompressed = false;
  const decrypted = isEncrypted;
  if (isEncrypted) {
    if (!wallet || !wallet.signingEnclave) {
      throw new Error("Wallet with signing enclave is required for private/encrypted receipts");
    }
    if (wallet.signingEnclave.isLocked()) {
      throw new Error("Wallet signing enclave is locked. Please unlock your wallet first.");
    }
    if (!wallet.signingEnclave.hasMnemonic()) {
      throw new Error("Wallet signing enclave has no mnemonic stored.");
    }
    if (!receipt.groupId) {
      throw new Error("Receipt missing groupId - cannot decrypt private stamping");
    }
    onProgress?.({
      stage: "decrypting",
      current: 0,
      total: 1,
      message: "Decrypting file..."
    });
    reconstructLogger.debug("Decrypting entire file with enclave", {
      groupId: receipt.groupId,
      encryptedSize: reassembled.length
    });
    try {
      const decryptedData = await wallet.signingEnclave.decryptWithWalletKey(
        reassembled,
        receipt.groupId
      );
      finalData = new Uint8Array(decryptedData);
      reconstructLogger.debug("File decryption complete", {
        encryptedSize: reassembled.length,
        decryptedSize: decryptedData.length
      });
    } catch (decryptError) {
      reconstructLogger.error("File decryption failed", {
        groupId: receipt.groupId,
        encryptedSize: reassembled.length,
        error: decryptError.message
      });
      throw new Error(`Failed to decrypt file: ${decryptError.message}`);
    }
  }
  if (receipt.compressed) {
    onProgress?.({
      stage: "decompressing",
      current: 0,
      total: 1,
      message: "Decompressing file..."
    });
    const decompressedData = await gunzipBytes(finalData);
    finalData = new Uint8Array(decompressedData);
    decompressed = true;
    reconstructLogger.debug("Decompression complete", { decompressedBytes: finalData.length });
  }
  const reconstructedHash = await sha256Hex(finalData);
  onProgress?.({
    stage: "complete",
    current: 1,
    total: 1,
    message: "File reconstruction complete!"
  });
  return {
    filename: receipt.fileName,
    data: finalData,
    originalHash: receipt.hash,
    reconstructedHash,
    matched: reconstructedHash === receipt.hash,
    chunks: chunkPayloads.length,
    decompressed,
    decrypted
  };
}
__name$1(reconstructFileFromReceipt, "reconstructFileFromReceipt");
function downloadReconstructedFile(result) {
  const sourceView = new Uint8Array(
    result.data.buffer,
    result.data.byteOffset,
    result.data.byteLength
  );
  const arrayBuffer = new ArrayBuffer(sourceView.byteLength);
  new Uint8Array(arrayBuffer).set(sourceView);
  const blob = new Blob([arrayBuffer], { type: "application/octet-stream" });
  const url = URL.createObjectURL(blob);
  const a2 = document.createElement("a");
  a2.href = url;
  a2.download = result.filename || "reconstructed-file";
  document.body.appendChild(a2);
  a2.click();
  document.body.removeChild(a2);
  URL.revokeObjectURL(url);
}
__name$1(downloadReconstructedFile, "downloadReconstructedFile");
var DANGEROUS_EXTENSIONS = [
  ".exe",
  ".dll",
  ".bat",
  ".cmd",
  ".com",
  ".scr",
  ".pif",
  // Windows executables
  ".app",
  ".dmg",
  ".pkg",
  // macOS executables
  ".sh",
  ".bash",
  ".zsh",
  // Shell scripts
  ".ps1",
  ".psm1",
  // PowerShell
  ".vbs",
  ".vbe",
  ".js",
  ".jse",
  ".wsf",
  ".wsh",
  // Scripts
  ".msi",
  ".msp",
  // Installers
  ".jar",
  // Java
  ".apk",
  // Android
  ".deb",
  ".rpm"
  // Linux packages
];
var SUSPICIOUS_PATTERNS = [
  /<script[^>]*>/i,
  // Script tags
  /javascript:/i,
  // JavaScript protocol
  /on\w+\s*=/i,
  // Event handlers
  /data:text\/html/i,
  // Data URI HTML
  /vbscript:/i,
  // VBScript protocol
  /<iframe[^>]*>/i,
  // IFrame tags
  /<object[^>]*>/i,
  // Object tags
  /<embed[^>]*>/i,
  // Embed tags
  /\.\.[\\/]/,
  // Path traversal
  /[<>'"]/
  // HTML special chars (basic check)
];
var MAX_VALUES = {
  FILE_SIZE: 10 * 1024 * 1024 * 1024,
  // 10 GB
  CHUNK_COUNT: 1e5,
  // 100k chunks
  TRANSACTION_IDS: 1e5,
  // 100k transactions
  FILENAME_LENGTH: 255,
  // Standard max filename
  COST_KAS: 1e6,
  // 1M KAS (sanity check)
  STRING_FIELD_LENGTH: 1e4
  // Max length for string fields
};
function validateStringField(value2, fieldName, maxLength = MAX_VALUES.STRING_FIELD_LENGTH) {
  const errors = [];
  const warnings = [];
  if (typeof value2 !== "string") {
    errors.push(`${fieldName} must be a string`);
    return { valid: false, errors, warnings };
  }
  if (value2.length > maxLength) {
    errors.push(`${fieldName} exceeds maximum length (${maxLength})`);
  }
  for (const pattern of SUSPICIOUS_PATTERNS) {
    if (pattern.test(value2)) {
      warnings.push(`${fieldName} contains suspicious pattern: ${pattern.source}`);
    }
  }
  return { valid: errors.length === 0, errors, warnings };
}
__name$1(validateStringField, "validateStringField");
function validateFilename(filename) {
  const errors = [];
  const warnings = [];
  const ext = filename.toLowerCase().split(".").pop();
  if (ext && DANGEROUS_EXTENSIONS.some((dangerous) => dangerous === `.${ext}`)) {
    warnings.push(
      `Filename has potentially dangerous extension: .${ext}. Only download if you trust the source!`
    );
  }
  if (filename.includes("\0")) {
    errors.push("Filename contains null bytes");
  }
  if (filename.includes("/") || filename.includes("\\")) {
    warnings.push("Filename contains path separators (should be just a filename)");
  }
  return { errors, warnings };
}
__name$1(validateFilename, "validateFilename");
function validateTransactionId(txId) {
  return /^[a-f0-9]{64}$/i.test(txId);
}
__name$1(validateTransactionId, "validateTransactionId");
function validateEncryptedField(value2, fieldName) {
  const errors = [];
  if (typeof value2 !== "string") {
    errors.push(`${fieldName} must be a string`);
    return errors;
  }
  try {
    atob(value2);
  } catch {
    errors.push(`${fieldName} is not valid base64`);
  }
  if (value2.length > MAX_VALUES.STRING_FIELD_LENGTH) {
    errors.push(`${fieldName} is suspiciously large`);
  }
  return errors;
}
__name$1(validateEncryptedField, "validateEncryptedField");
function validateReceipt(receipt) {
  const errors = [];
  const warnings = [];
  if (!receipt || typeof receipt !== "object") {
    return {
      valid: false,
      errors: ["Receipt must be a non-null object"],
      warnings: []
    };
  }
  const r2 = receipt;
  if (typeof r2.id !== "string") {
    errors.push("Receipt id must be a string");
  } else if (!validateTransactionId(r2.id)) {
    errors.push("Receipt id is not a valid transaction ID format");
  }
  if (typeof r2.timestamp !== "string") {
    errors.push("Receipt timestamp must be a string");
  } else {
    const date = new Date(r2.timestamp);
    if (isNaN(date.getTime())) {
      errors.push("Receipt timestamp is not a valid ISO 8601 date");
    }
  }
  const filenameValidation = validateStringField(
    r2.fileName,
    "fileName",
    MAX_VALUES.FILENAME_LENGTH
  );
  errors.push(...filenameValidation.errors);
  warnings.push(...filenameValidation.warnings);
  if (typeof r2.fileName === "string") {
    const nameValidation = validateFilename(r2.fileName);
    errors.push(...nameValidation.errors);
    warnings.push(...nameValidation.warnings);
  }
  if (typeof r2.fileSize !== "number") {
    errors.push("Receipt fileSize must be a number");
  } else {
    if (r2.fileSize < 0) {
      errors.push("Receipt fileSize cannot be negative");
    }
    if (r2.fileSize > MAX_VALUES.FILE_SIZE) {
      warnings.push(`Receipt fileSize is very large (${r2.fileSize} bytes)`);
    }
  }
  const hashValidation = validateStringField(r2.hash, "hash", 128);
  errors.push(...hashValidation.errors);
  warnings.push(...hashValidation.warnings);
  if (r2.encryptedMetadata !== void 0) {
    if (typeof r2.encryptedMetadata !== "string") {
      errors.push("Receipt encryptedMetadata must be a string");
    } else {
      errors.push(...validateEncryptedField(r2.encryptedMetadata, "encryptedMetadata"));
    }
  }
  if (typeof r2.privacy !== "string") {
    errors.push("Receipt privacy must be a string");
  } else if (r2.privacy !== "public" && r2.privacy !== "private") {
    errors.push('Receipt privacy must be "public" or "private"');
  }
  if (typeof r2.encrypted !== "boolean") {
    errors.push("Receipt encrypted must be a boolean");
  }
  if (typeof r2.compressed !== "boolean") {
    errors.push("Receipt compressed must be a boolean");
  }
  if (r2.groupId !== void 0) {
    if (typeof r2.groupId !== "string") {
      errors.push("Receipt groupId must be a string");
    } else if (!/^[a-f0-9-]{36}$/i.test(r2.groupId)) {
      warnings.push("Receipt groupId is not a valid UUID format");
    }
  } else if (r2.privacy === "private") {
    errors.push("Receipt groupId is required for private mode");
  }
  if (Array.isArray(r2.transactionIds)) {
    if (r2.transactionIds.length === 0) {
      errors.push("Receipt transactionIds array is empty");
    }
    if (r2.transactionIds.length > MAX_VALUES.TRANSACTION_IDS) {
      warnings.push(`Receipt has very many transactions (${r2.transactionIds.length})`);
    }
    for (let i2 = 0; i2 < Math.min(r2.transactionIds.length, 10); i2++) {
      const txId = r2.transactionIds[i2];
      if (typeof txId !== "string") {
        errors.push(`Transaction ID at index ${i2} is not a string`);
      } else if (!validateTransactionId(txId)) {
        errors.push(`Transaction ID at index ${i2} is not a valid format`);
      }
    }
  } else if (typeof r2.transactionIds === "string") {
    errors.push(...validateEncryptedField(r2.transactionIds, "transactionIds"));
  } else {
    errors.push("Receipt transactionIds must be an array or encrypted string");
  }
  if (r2.transactionIdsEncrypted !== void 0 && typeof r2.transactionIdsEncrypted !== "boolean") {
    errors.push("Receipt transactionIdsEncrypted must be a boolean");
  }
  if (typeof r2.chunkCount !== "number") {
    errors.push("Receipt chunkCount must be a number");
  } else {
    if (r2.chunkCount <= 0) {
      errors.push("Receipt chunkCount must be positive");
    }
    if (r2.chunkCount > MAX_VALUES.CHUNK_COUNT) {
      warnings.push(`Receipt has very many chunks (${r2.chunkCount})`);
    }
  }
  if (typeof r2.totalCostKAS !== "number") {
    errors.push("Receipt totalCostKAS must be a number");
  } else {
    if (r2.totalCostKAS < 0) {
      errors.push("Receipt totalCostKAS cannot be negative");
    }
    if (r2.totalCostKAS > MAX_VALUES.COST_KAS) {
      warnings.push(`Receipt cost is very high (${r2.totalCostKAS} KAS)`);
    }
  }
  if (r2.network !== void 0) {
    const networkValidation = validateStringField(r2.network, "network", 50);
    errors.push(...networkValidation.errors);
    warnings.push(...networkValidation.warnings);
  }
  if (r2.walletAddress !== void 0) {
    const addressValidation = validateStringField(r2.walletAddress, "walletAddress", 200);
    errors.push(...addressValidation.errors);
    warnings.push(...addressValidation.warnings);
  }
  if (Array.isArray(r2.transactionIds) && typeof r2.chunkCount === "number") {
    if (r2.transactionIds.length !== r2.chunkCount) {
      warnings.push(
        `Chunk count mismatch: chunkCount (${r2.chunkCount}) !== transactionIds.length (${r2.transactionIds.length})`
      );
    }
  }
  if (r2.privacy === "private") {
    if (!r2.encrypted) {
      warnings.push("Receipt is marked as private but encrypted flag is false");
    }
    if (!r2.groupId) {
      errors.push("Private receipt must have a groupId");
    }
    if (!r2.transactionIdsEncrypted && Array.isArray(r2.transactionIds)) {
      warnings.push("Private receipt has plaintext transaction IDs (old format?)");
    }
  }
  if (r2.privacy === "public" && r2.transactionIdsEncrypted === true) {
    warnings.push("Public receipt has encrypted transaction IDs");
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
__name$1(validateReceipt, "validateReceipt");
var __defProp = Object.defineProperty;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var KaspaSDK = class _KaspaSDK {
  static {
    __name(this, "KaspaSDK");
  }
  static instance = null;
  static logger = createLogger("kasstamp:sdk");
  config;
  rpcClient = null;
  isInitialized = false;
  walletFactory = null;
  constructor(config, walletFactory) {
    this.config = config;
    this.walletFactory = walletFactory ?? null;
  }
  /**
   * Initialize the Professional Kaspa SDK
   *
   * @param config - SDK configuration (network is required)
   * @param walletFactory - Optional wallet factory for dependency injection
   * @returns Promise<KaspaSDK> - Initialized SDK instance
   */
  static async init(config, walletFactory) {
    if (_KaspaSDK.instance && _KaspaSDK.instance.isInitialized) {
      return _KaspaSDK.instance;
    }
    try {
      if (config.debug) {
        _KaspaSDK.logger.info("Initializing Professional Enterprise Kaspa SDK");
      }
      await initKaspaWasm();
      if (config.debug) {
        _KaspaSDK.logger.info("WASM initialized");
      }
      const instance = new _KaspaSDK(config, walletFactory);
      await instance.initialize();
      _KaspaSDK.instance = instance;
      instance.isInitialized = true;
      if (config.debug) {
        _KaspaSDK.logger.info("Enterprise Kaspa SDK ready for professional use");
      }
      return instance;
    } catch (error) {
      _KaspaSDK.logger.error("Failed to initialize Professional Kaspa SDK", error);
      throw new Error(`Failed to initialize Professional Kaspa SDK: ${error}`);
    }
  }
  /**
   * Internal initialization with clean dependency injection
   */
  async initialize() {
    const networkString = this.networkToString(this.config.network);
    const rpcOptions = {
      network: networkString,
      // Network string for WASM RpcClient
      nodeUrl: this.config.nodeUrl,
      ...this.config.rpcOptions
    };
    this.rpcClient = createKaspaClient(rpcOptions);
    await this.rpcClient.connect();
  }
  /**
   * Create a new wallet with randomly generated mnemonic
   *
   * @param options - Wallet creation options
   * @returns Object containing the wallet and mnemonic
   */
  async createNewWallet(options) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    if (!this.walletFactory) {
      throw new Error(
        "Wallet factory not provided - inject wallet factory during SDK initialization"
      );
    }
    if (!options.walletSecret) {
      throw new Error("walletSecret is required for wallet operations");
    }
    if (this.config.debug) {
      _KaspaSDK.logger.info("Creating new enterprise-grade wallet with mnemonic", {
        walletName: options.name,
        network: options.network || this.config.network
      });
    }
    const walletOptions = {
      ...options,
      network: options.network || this.config.network
    };
    return await this.walletFactory.createNewWallet(walletOptions);
  }
  /**
   * Import wallet from existing mnemonic
   *
   * @param mnemonic - BIP39 mnemonic phrase
   * @param options - Wallet options
   * @returns Wallet instance
   */
  async importWallet(mnemonic, options) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    if (!this.walletFactory) {
      throw new Error(
        "Wallet factory not provided - inject wallet factory during SDK initialization"
      );
    }
    if (!options.walletSecret) {
      throw new Error("walletSecret is required for wallet operations");
    }
    if (this.config.debug) {
      _KaspaSDK.logger.info("Importing enterprise-grade wallet from mnemonic", {
        walletName: options.name,
        network: options.network || this.config.network
      });
    }
    const walletOptions = {
      ...options,
      network: options.network || this.config.network
    };
    return await this.walletFactory.createWalletFromMnemonic(mnemonic, walletOptions);
  }
  /**
   * Open an existing wallet from storage
   *
   * @param walletName - Name of the wallet to open
   * @param walletSecret - Wallet encryption secret
   * @returns Wallet instance
   */
  async openExistingWallet(walletName, walletSecret) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    if (!this.walletFactory) {
      throw new Error(
        "Wallet factory not provided - inject wallet factory during SDK initialization"
      );
    }
    if (this.config.debug) {
      _KaspaSDK.logger.info("Opening existing wallet", { walletName, network: this.config.network });
    }
    return await this.walletFactory.openExistingWallet(
      walletName,
      walletSecret,
      this.config.network
    );
  }
  /**
   * Get current network information
   */
  getNetwork() {
    return this.config.network;
  }
  /**
   * Check if SDK is ready
   */
  isReady() {
    return this.isInitialized && !!this.rpcClient;
  }
  /**
   * Get fee estimate from the network (without wallet)
   */
  async getFeeEstimate() {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    if (!this.rpcClient) {
      throw new Error("RPC client not available");
    }
    try {
      _KaspaSDK.logger.debug("Getting fee estimate from network");
      return await this.rpcClient.getFeeEstimate();
    } catch (error) {
      _KaspaSDK.logger.error("Failed to get fee estimate", error);
      throw new Error(`Failed to get fee estimate: ${error}`);
    }
  }
  /**
   * Estimate stamping fees using real processing pipeline with fallback fee calculation
   *
   * This method uses the exact same processing pipeline as real stamping, but with
   * fallback fee calculation when wallet is not available. The chunking and processing
   * logic is identical to the real stamping process.
   *
   * @param file - File to estimate
   * @param options - Stamping options
   * @param wallet - Optional wallet (if available, uses real fee calculation)
   * @returns Accurate estimation using real processing pipeline
   */
  async estimateStampingWithFallback(file, options, wallet) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    const estimationLogger = _KaspaSDK.logger.child("estimation-fallback");
    estimationLogger.info("Starting fallback-aware estimation", {
      fileName: file.name,
      fileSizeKB: (file.size / 1024).toFixed(2),
      hasWallet: !!wallet,
      mode: options.mode
    });
    const processingMode = options.mode === "private" && !wallet ? "public" : options.mode;
    const processingResult = await this.processFileForStamping(
      file,
      processingMode,
      {
        compression: options.compression ?? true
      },
      wallet
      // Pass wallet for private mode encryption
    );
    const needsEncryptionOverhead = options.mode === "private" && !wallet;
    estimationLogger.info("File processed using real pipeline", {
      chunkCount: processingResult.chunks.length,
      processedSizeKB: (processingResult.processing.totalProcessedSize / 1024).toFixed(2)
    });
    const groupId = processingResult.chunks[0]?.groupId;
    const enclave = options.mode === "private" && wallet ? wallet.signingEnclave : void 0;
    const envelopes = [];
    for (const chunk of processingResult.chunks) {
      const fullPayload = {
        fileName: processingResult.originalFile.name,
        chunkIndex: chunk.index,
        totalChunks: processingResult.chunks.length,
        digest: chunk.digest,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        chunkData: chunk.data
      };
      const serialized = serializePayload(fullPayload);
      let payload = serialized;
      if (options.mode === "private" && enclave) {
        payload = await enclave.encryptWithWalletKey(serialized, groupId);
      } else if (needsEncryptionOverhead) {
        const ENCRYPTION_OVERHEAD = 64;
        const estimatedEncryptedSize = serialized.length + ENCRYPTION_OVERHEAD;
        const dummyEncrypted = new Uint8Array(estimatedEncryptedSize);
        dummyEncrypted.set(serialized);
        payload = dummyEncrypted;
      }
      envelopes.push({
        metadata: {
          groupId,
          mode: options.mode
        },
        payload
      });
    }
    let totalTransactions = 0;
    let totalFees = 0n;
    let totalMass = 0n;
    let feeCalculationMethod = "static";
    if (wallet) {
      try {
        const accounts = wallet.accounts;
        if (accounts && accounts.length > 0) {
          const accountId = accounts[0].accountId;
          const receiveAddress = accounts[0].receiveAddress?.toString();
          const changeAddress = accounts[0].changeAddress?.toString();
          const networkId = wallet.network?.toString() || "testnet-10";
          if (receiveAddress && changeAddress) {
            const utxos = await wallet.getUtxos(accountId);
            estimationLogger.info("Using wallet-based fee calculation", {
              utxoCount: utxos.length,
              address: receiveAddress
            });
            const estimationPromises = envelopes.map(async (envelope) => {
              const payloadInfo = buildStampingPayload({
                metadata: envelope.metadata,
                chunkData: envelope.payload
              });
              return await GeneratorTransactionService.estimateStampingTransaction({
                recipient: receiveAddress,
                changeAddress,
                utxos,
                payload: payloadInfo.payload,
                networkId,
                priorityFee: options.priorityFee,
                amount: 0n
                // No explicit output - only change + payload
              });
            });
            const estimations = await Promise.all(estimationPromises);
            for (const estimation of estimations) {
              estimationLogger.debug("Wallet estimation (real UTXOs)", {
                mass: estimation.totalMass.toString(),
                fees: estimation.totalFees.toString(),
                feesKAS: (Number(estimation.totalFees) / 1e8).toFixed(8),
                transactionCount: estimation.transactionCount
              });
              totalTransactions += estimation.transactionCount;
              totalFees += estimation.totalFees;
              totalMass += estimation.totalMass;
            }
            feeCalculationMethod = "wallet";
            estimationLogger.info("Wallet-based estimation complete", {
              totalTransactions,
              totalFeesSompi: totalFees.toString(),
              totalMass: totalMass.toString()
            });
          }
        }
      } catch (error) {
        estimationLogger.warn(
          "Wallet-based estimation failed, falling back to RPC",
          error
        );
      }
    }
    if (feeCalculationMethod === "static") {
      try {
        estimationLogger.info("Using RPC-based fee calculation (WASM SDK with dummy UTXOs)");
        const networkString = this.networkToString(this.config.network);
        const NetworkIdClass = await getNetworkId();
        const networkId = new NetworkIdClass(networkString);
        const addressPrefix = networkId.addressPrefix();
        const dummyAddress = new Address(
          `${addressPrefix}:qq9ur9d9zu7qrc36607legtfjldpcrj0t75gl3lgnz2ytj6jly30s9mrz0zrf`
        );
        const dummyUtxo = {
          address: dummyAddress,
          outpoint: {
            transactionId: "0000000000000000000000000000000000000000000000000000000000000000",
            index: 0
          },
          amount: 1000000000n,
          // 10 KAS dummy amount
          scriptPublicKey: {
            version: 0,
            script: "76a914000000000000000000000000000000000000000088ac"
            // P2PKH script as hex string
          },
          blockDaaScore: 1000000n,
          isCoinbase: false
        };
        for (const envelope of envelopes) {
          const payloadInfo = buildStampingPayload({
            metadata: envelope.metadata,
            chunkData: envelope.payload
          });
          try {
            const priorityFeeSompi = options.priorityFee !== void 0 ? options.priorityFee : 0n;
            const summary = await estimateTransactions({
              outputs: [],
              // No explicit outputs - only change + payload
              changeAddress: dummyAddress,
              entries: [dummyUtxo],
              payload: payloadInfo.payload,
              priorityFee: priorityFeeSompi,
              networkId: networkString
              // NO feeRate parameter - let WASM SDK fetch from network automatically
            });
            const chunkMass = summary.mass;
            const chunkFees = summary.fees;
            estimationLogger.debug("WASM SDK estimation (dummy UTXOs)", {
              mass: chunkMass.toString(),
              fees: chunkFees.toString(),
              feesKAS: (Number(chunkFees) / 1e8).toFixed(8)
            });
            totalTransactions += summary.transactions;
            totalFees += chunkFees;
            totalMass += chunkMass;
          } catch (error) {
            estimationLogger.warn(
              "WASM estimateTransactions failed, falling back to static",
              error
            );
            const STATIC_FEE_RATE = 1e3;
            const BASE_TX_OVERHEAD = 200;
            const INPUT_MASS = 1118;
            const OUTPUT_MASS = 846;
            const PAYLOAD_MASS = payloadInfo.payload.length;
            const networkMass = BASE_TX_OVERHEAD + INPUT_MASS + OUTPUT_MASS + PAYLOAD_MASS;
            const massGrams = networkMass / 1e3;
            const massBasedFeeSompi = BigInt(Math.ceil(massGrams * STATIC_FEE_RATE));
            const priorityFeeSompi = options.priorityFee !== void 0 ? options.priorityFee : 0n;
            const chunkFeeSompi = massBasedFeeSompi + priorityFeeSompi;
            totalTransactions += 1;
            totalFees += chunkFeeSompi;
            totalMass += BigInt(networkMass);
          }
        }
        feeCalculationMethod = "rpc";
        estimationLogger.info("RPC-based estimation complete", {
          totalTransactions,
          totalFeesSompi: totalFees.toString(),
          totalMass: totalMass.toString()
        });
      } catch (error) {
        estimationLogger.warn(
          "RPC-based estimation failed, falling back to static",
          error
        );
      }
    }
    if (feeCalculationMethod === "static") {
      const STATIC_FEE_RATE = 1e3;
      estimationLogger.info("Using static fee calculation", {
        staticFeeRate: STATIC_FEE_RATE
      });
      for (const envelope of envelopes) {
        const payloadInfo = buildStampingPayload({
          metadata: envelope.metadata,
          chunkData: envelope.payload
        });
        const BASE_TX_OVERHEAD = 200;
        const INPUT_MASS = 1118;
        const OUTPUT_MASS = 846;
        const PAYLOAD_MASS = payloadInfo.payload.length;
        const networkMass = BASE_TX_OVERHEAD + INPUT_MASS + OUTPUT_MASS + PAYLOAD_MASS;
        const massGrams = networkMass / 1e3;
        const massBasedFeeSompi = BigInt(Math.ceil(massGrams * STATIC_FEE_RATE));
        const priorityFeeSompi = options.priorityFee !== void 0 ? options.priorityFee : 0n;
        const chunkFeeSompi = massBasedFeeSompi + priorityFeeSompi;
        totalTransactions += 1;
        totalFees += chunkFeeSompi;
        totalMass += BigInt(networkMass);
      }
      estimationLogger.info("Static estimation complete", {
        totalTransactions,
        totalFeesSompi: totalFees.toString(),
        totalMass: totalMass.toString()
      });
    }
    const storageAmountKAS = 0;
    const estimatedFeesKAS = Number(totalFees) / 1e8;
    const totalCostKAS = storageAmountKAS + estimatedFeesKAS;
    estimationLogger.info("Fallback-aware estimation complete", {
      feeCalculationMethod,
      envelopeCount: envelopes.length,
      totalTransactions,
      totalFeesSompi: totalFees.toString(),
      totalFeesKAS: estimatedFeesKAS.toFixed(8),
      totalMass: totalMass.toString(),
      avgMassPerTx: Number(totalMass) / totalTransactions,
      totalCostKAS: totalCostKAS.toFixed(8)
    });
    return {
      originalSize: processingResult.originalFile.size,
      processedSize: processingResult.processing.totalProcessedSize,
      chunkCount: processingResult.chunks.length,
      estimatedTransactions: totalTransactions,
      estimatedFeesSompi: totalFees,
      estimatedFeesKAS,
      estimatedMass: totalMass,
      storageAmountKAS,
      totalCostKAS,
      processingResult,
      feeCalculationMethod
    };
  }
  /**
   * Convert Network enum to network string for WASM RpcClient
   */
  networkToString(network) {
    return network;
  }
  /**
   * Create balance monitoring service for a wallet address
   * Uses WASM types directly - no custom conversions
   */
  createBalanceMonitoringService(address, wasmWallet, accountId) {
    if (!this.isInitialized || !this.rpcClient) {
      throw new Error("SDK not initialized - call KaspaSDK.init() first");
    }
    const config = {
      address,
      wasmWallet,
      accountId,
      rpcClient: this.rpcClient,
      pollingInterval: this.config.pollingIntervals?.balanceMonitoring ?? 3e4,
      // 30 seconds default
      debug: this.config.debug ?? false
    };
    return createBalanceMonitoringService(config);
  }
  /**
   * Create transaction monitoring service for a wallet and account
   * Uses wallet instances for better integration
   */
  createTransactionMonitoringService(wallet, accountId) {
    return createTransactionMonitoringService(
      wallet.wasmWallet,
      accountId,
      wallet.network,
      // Pass the network ID from wallet
      {
        pollInterval: this.config.pollingIntervals?.transactionMonitoring ?? 6e4
      }
    );
  }
  /**
   * Create a complete wallet service orchestration
   * Returns all monitoring services for a wallet (all accounts)
   */
  createWalletServices(wallet) {
    const accounts = wallet.accounts;
    if (accounts.length === 0) {
      throw new Error("No accounts found in wallet");
    }
    const primaryAccount = accounts[0];
    const address = primaryAccount.receiveAddress?.toString();
    if (!address) {
      throw new Error(`Primary account has no receive address`);
    }
    return {
      balanceMonitoring: this.createBalanceMonitoringService(
        address,
        wallet.wasmWallet,
        primaryAccount.accountId
      ),
      transactionMonitoring: this.createTransactionMonitoringService(
        wallet,
        primaryAccount.accountId
      )
    };
  }
  /**
   * Process file for stamping
   *
   * @param file - File to process
   * @param mode - Stamping mode (public, private)
   * @param options - Processing options
   * @param wallet - Optional wallet (required for private mode)
   * @returns Processing result with chunks and fee estimate
   */
  async processFileForStamping(file, mode, options, wallet) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    const processingLogger = _KaspaSDK.logger.child("processing");
    processingLogger.debug("processFileForStamping called", {
      fileName: file.name,
      fileSize: file.size,
      mode,
      options
    });
    const processingOptions = {
      mode,
      compression: true,
      ...options
    };
    processingLogger.debug("Processing options configured", processingOptions);
    try {
      let result;
      switch (mode) {
        case "public":
          processingLogger.debug("Calling prepareFileForPublicMode");
          result = await prepareFileForPublicMode(file, processingOptions);
          break;
        case "private": {
          if (!wallet) {
            throw new Error("Wallet is required for private mode. Please pass a wallet parameter.");
          }
          if (!wallet.signingEnclave) {
            throw new Error("Wallet does not have a signing enclave.");
          }
          processingLogger.debug("Calling prepareFileForPrivateMode with enclave");
          result = await prepareFileForPrivateMode(file, wallet.signingEnclave, processingOptions);
          break;
        }
        default:
          throw new Error(`Unknown stamping mode: ${mode}`);
      }
      processingLogger.debug("Processing completed", { chunkCount: result.chunks?.length });
      return result;
    } catch (error) {
      processingLogger.error("Error in processFileForStamping", error, {
        fileName: file.name,
        mode
      });
      throw error;
    }
  }
  /**
   * Reconstruct file from stamping receipt
   *
   * Downloads all chunk transactions from blockchain and reassembles the original file
   *
   * @param receipt - Stamping receipt with transaction IDs
   * @param wallet - Wallet to fetch transactions from (optional for public receipts)
   * @param onProgress - Optional progress callback
   * @returns Reconstructed file data
   *
   * @example
   * ```typescript
   * // Public receipt - no wallet needed
   * const result = await sdk.reconstructFile(publicReceipt, null, (progress) => {
   *   console.log(`${progress.stage}: ${progress.current}/${progress.total}`);
   * });
   *
   * // Private receipt - wallet required
   * const result = await sdk.reconstructFile(privateReceipt, wallet, (progress) => {
   *   console.log(`${progress.stage}: ${progress.current}/${progress.total}`);
   * });
   * console.log(`File reconstructed: ${result.filename}`);
   * console.log(`Hash matched: ${result.matched}`);
   * ```
   */
  async reconstructFile(receipt, wallet, onProgress) {
    return await reconstructFileFromReceipt(receipt, wallet, onProgress);
  }
  /**
   * Download reconstructed file to user's device
   *
   * @param result - Reconstruction result from reconstructFile()
   */
  downloadFile(result) {
    downloadReconstructedFile(result);
  }
  /**
   * Decrypt an encrypted receipt (private mode only)
   *
   * This automatically decrypts the transaction IDs in a private receipt,
   * making it ready for display or file reconstruction.
   *
   * @param receipt - The receipt to decrypt (can be public or private)
   * @param wallet - Wallet required for private receipts (optional for public)
   * @returns Decrypted receipt with plaintext transaction IDs
   *
   * @throws Error if wallet is missing/locked or decryption fails
   *
   * @example
   * // Decrypt a private receipt
   * const decrypted = await sdk.decryptReceipt(encryptedReceipt, wallet);
   * console.log(decrypted.transactionIds); // Now an array
   *
   * @example
   * // Public receipts pass through unchanged
   * const publicReceipt = await sdk.decryptReceipt(receipt, null);
   */
  async decryptReceipt(receipt, wallet) {
    const decryptLogger = _KaspaSDK.logger.child("decrypt");
    decryptLogger.info("Attempting to decrypt receipt", { receiptId: receipt.id });
    decryptLogger.debug("Validating receipt structure");
    const validationResult = validateReceipt(receipt);
    if (validationResult.warnings.length > 0) {
      decryptLogger.warn("Receipt validation warnings", { warnings: validationResult.warnings });
    }
    if (!validationResult.valid) {
      decryptLogger.error("Receipt validation failed", { errors: validationResult.errors });
      throw new Error(`Invalid receipt: ${validationResult.errors.join(", ")}`);
    }
    decryptLogger.debug("Receipt validation passed");
    decryptLogger.debug("Receipt details", {
      privacy: receipt.privacy,
      transactionIdsEncrypted: receipt.transactionIdsEncrypted
    });
    if (receipt.privacy !== "private" || !receipt.transactionIdsEncrypted) {
      decryptLogger.info("Receipt is public or already decrypted");
      return receipt;
    }
    if (!wallet || !wallet.signingEnclave) {
      throw new Error("Wallet connection required to decrypt private receipt");
    }
    if (wallet.signingEnclave.isLocked()) {
      throw new Error("Wallet is locked. Please unlock your wallet to decrypt this receipt.");
    }
    if (!wallet.signingEnclave.hasMnemonic()) {
      throw new Error("Wallet is corrupt, please re-import your wallet.");
    }
    if (!receipt.groupId) {
      throw new Error("Receipt missing groupId - cannot decrypt");
    }
    try {
      decryptLogger.info("Decrypting transaction IDs");
      const encryptedTxIds = receipt.transactionIds;
      const encryptedBytes = Uint8Array.from(atob(encryptedTxIds), (c2) => c2.charCodeAt(0));
      const decryptedBytes = await wallet.signingEnclave.decryptWithWalletKey(
        encryptedBytes,
        receipt.groupId
      );
      const decryptedJson = new TextDecoder().decode(decryptedBytes);
      const transactionIds = JSON.parse(decryptedJson);
      decryptLogger.info("Transaction IDs decrypted", { count: transactionIds.length });
      decryptLogger.debug("Checking for encrypted metadata", {
        hasEncryptedMetadata: !!receipt.encryptedMetadata,
        currentFileName: receipt.fileName,
        currentFileSize: receipt.fileSize
      });
      if (receipt.encryptedMetadata) {
        decryptLogger.info("Decrypting receipt metadata");
        try {
          const encryptedMetadataBytes = Uint8Array.from(
            atob(receipt.encryptedMetadata),
            (c2) => c2.charCodeAt(0)
          );
          const decryptedMetadataBytes = await wallet.signingEnclave.decryptWithWalletKey(
            encryptedMetadataBytes,
            receipt.groupId
          );
          const decryptedMetadataJson = new TextDecoder().decode(decryptedMetadataBytes);
          const metadata = JSON.parse(decryptedMetadataJson);
          decryptLogger.info("Metadata decrypted", {
            fileName: metadata.fileName,
            fileSize: metadata.fileSize
          });
          return {
            ...receipt,
            transactionIds,
            transactionIdsEncrypted: false,
            fileName: metadata.fileName,
            fileSize: metadata.fileSize,
            hash: metadata.hash
          };
        } catch (metadataError) {
          decryptLogger.error(
            "Failed to decrypt metadata - this receipt may have been created with a different wallet",
            metadataError
          );
          decryptLogger.error("Metadata decryption error details", {
            error: metadataError.message,
            groupId: receipt.groupId,
            hasEncryptedMetadata: !!receipt.encryptedMetadata
          });
        }
      } else {
        decryptLogger.warn("No encrypted metadata found in receipt - created with old version");
      }
      return {
        ...receipt,
        transactionIds,
        transactionIdsEncrypted: false
      };
    } catch (error) {
      decryptLogger.error("Failed to decrypt receipt", error);
      throw new Error(`Failed to decrypt receipt: ${error.message}`);
    }
  }
  /**
   * Estimate stamping cost and details BEFORE actually stamping
   * Uses official Kaspa Generator for accurate estimation
   */
  async estimateStamping(file, wallet, options) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    const accounts = wallet.accounts;
    if (!accounts || accounts.length === 0) {
      throw new Error("No accounts available in wallet");
    }
    const accountId = accounts[0].accountId;
    const receiveAddress = accounts[0].receiveAddress?.toString();
    const changeAddress = accounts[0].changeAddress?.toString();
    if (!receiveAddress || !changeAddress) {
      throw new Error("No receive or change address available");
    }
    const stampingLogger = _KaspaSDK.logger.child("stamping");
    const utxos = await wallet.getUtxos(accountId);
    const networkId = wallet.network?.toString() || "testnet-10";
    const estimationLogger = stampingLogger.child("estimation");
    estimationLogger.info("Estimating stamping", {
      fileName: file.name,
      fileSizeKB: (file.size / 1024).toFixed(2)
    });
    estimationLogger.debug("Using optimal 20KB chunks limited by KIP-0013 transient mass");
    const processingResult = await this.processFileForStamping(
      file,
      options.mode,
      {
        compression: options.compression ?? true
      },
      wallet
    );
    estimationLogger.info("File will be split into chunks", {
      chunkCount: processingResult.chunks.length
    });
    const groupId = processingResult.chunks[0]?.groupId;
    const enclave = options.mode === "private" ? wallet.signingEnclave : void 0;
    const envelopes = [];
    estimationLogger.debug("Building unified envelopes for estimation", { mode: options.mode });
    for (const chunk of processingResult.chunks) {
      const fullPayload = {
        fileName: processingResult.originalFile.name,
        chunkIndex: chunk.index,
        totalChunks: processingResult.chunks.length,
        digest: chunk.digest,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        chunkData: chunk.data
      };
      const serialized = serializePayload(fullPayload);
      let payload = serialized;
      if (options.mode === "private" && enclave) {
        payload = await enclave.encryptWithWalletKey(serialized, groupId);
      }
      envelopes.push({
        metadata: {
          groupId,
          mode: options.mode
        },
        payload
      });
    }
    let totalTransactions = 0;
    let totalFees = 0n;
    let totalMass = 0n;
    estimationLogger.info("Running Generator estimation", { envelopeCount: envelopes.length });
    const estimationStartTime = Date.now();
    const estimationPromises = envelopes.map(async (envelope, i2) => {
      const payloadInfo = buildStampingPayload({
        metadata: envelope.metadata,
        chunkData: envelope.payload
        // Unified payload (encrypted or plaintext)
      });
      const estimation = await GeneratorTransactionService.estimateStampingTransaction({
        recipient: receiveAddress,
        changeAddress,
        utxos,
        payload: payloadInfo.payload,
        networkId,
        priorityFee: options.priorityFee,
        amount: 0n
        // No explicit output - only change + payload (matches actual stamping)
      });
      estimationLogger.debug("Envelope estimated", { envelope: i2 + 1, total: envelopes.length });
      return estimation;
    });
    const estimations = await Promise.all(estimationPromises);
    for (const estimation of estimations) {
      totalTransactions += estimation.transactionCount;
      totalFees += estimation.totalFees;
      totalMass += estimation.totalMass;
    }
    const estimationDuration = ((Date.now() - estimationStartTime) / 1e3).toFixed(2);
    estimationLogger.info("Parallel estimation complete", { durationSeconds: estimationDuration });
    const storageAmountKAS = 0;
    const estimatedFeesKAS = Number(totalFees) / 1e8;
    const totalCostKAS = storageAmountKAS + estimatedFeesKAS;
    const priorityFeePerTx = Number(options.priorityFee);
    const totalPriorityFeeSompi = BigInt(priorityFeePerTx * totalTransactions);
    const totalPriorityFeeKAS = Number(totalPriorityFeeSompi) / 1e8;
    estimationLogger.info("Estimation complete using official Kaspa WASM SDK", {
      envelopeCount: envelopes.length,
      totalTransactions,
      priorityFeePerTxSompi: priorityFeePerTx,
      priorityFeePerTxKAS: (priorityFeePerTx / 1e8).toFixed(8),
      totalPriorityFeesSompi: totalPriorityFeeSompi.toString(),
      totalPriorityFeesKAS: totalPriorityFeeKAS.toFixed(8),
      totalFeesSompi: totalFees.toString(),
      totalFeesKAS: estimatedFeesKAS.toFixed(8),
      avgFeePerTxKAS: (Number(totalFees) / totalTransactions / 1e8).toFixed(8),
      totalMass: totalMass.toString(),
      avgMassPerTx: Number(totalMass) / totalTransactions,
      storageAmountKAS: storageAmountKAS.toFixed(2),
      totalCostKAS: totalCostKAS.toFixed(8)
    });
    return {
      originalSize: processingResult.originalFile.size,
      processedSize: processingResult.processing.totalProcessedSize,
      chunkCount: processingResult.chunks.length,
      estimatedTransactions: totalTransactions,
      estimatedFeesSompi: totalFees,
      estimatedFeesKAS,
      estimatedMass: totalMass,
      storageAmountKAS,
      totalCostKAS,
      processingResult
    };
  }
  /**
   * Stamp multiple artifacts (files and text) to the Kaspa blockchain in a single batched transaction chain
   *
   * This method processes multiple artifacts separately but executes all transactions in one chain
   * using the same UTXO to avoid UTXO conflicts. Each artifact gets its own receipt.
   *
   * @param artifacts - Array of artifacts to stamp (files and text)
   * @param wallet - Wallet containing the mnemonic for signing
   * @param options - Stamping options
   * @returns Array of stamping results, one for each artifact
   */
  async stampMultipleArtifacts(artifacts, wallet, options) {
    if (!this.isInitialized) {
      throw new Error("Professional SDK not initialized - call KaspaSDK.init() first");
    }
    if (!artifacts || artifacts.length === 0) {
      throw new Error("No artifacts provided for stamping");
    }
    const batchLogger = _KaspaSDK.logger.child("batch-stamping");
    batchLogger.info("Batch stamping artifacts", { artifactCount: artifacts.length });
    const artifactProcessingResults = [];
    for (let i2 = 0; i2 < artifacts.length; i2++) {
      const artifact = artifacts[i2];
      let file;
      if (artifact.type === "file" && artifact.file) {
        file = artifact.file;
      } else if (artifact.type === "text" && artifact.text) {
        const textBlob = new Blob([artifact.text], { type: "text/plain" });
        file = new File([textBlob], artifact.filename || `text-${i2 + 1}.txt`, {
          type: "text/plain"
        });
      } else {
        throw new Error(`Invalid artifact at index ${i2}: missing file or text`);
      }
      batchLogger.info("Processing artifact", {
        index: i2 + 1,
        total: artifacts.length,
        fileName: file.name,
        fileSizeKB: (file.size / 1024).toFixed(2)
      });
      const processingResult = await this.processFileForStamping(
        file,
        options.mode,
        {
          compression: options.compression ?? true
        },
        wallet
      );
      batchLogger.info("Artifact processed", {
        index: i2 + 1,
        chunkCount: processingResult.chunks.length
      });
      artifactProcessingResults.push({
        artifact,
        file,
        processingResult
      });
    }
    return await stampFiles(
      artifactProcessingResults,
      wallet,
      options,
      () => this.getNetwork(),
      options.priorityFee
    );
  }
  /**
   * Disconnect and cleanup
   */
  async disconnect() {
    if (this.rpcClient) {
      await this.rpcClient.disconnect();
      this.rpcClient = null;
    }
    this.isInitialized = false;
    _KaspaSDK.instance = null;
  }
};
initializeLoggers();
const hostnameParts = location.hostname.split(".");
const OWNER = hostnameParts[0];
const REPO = location.pathname === "/" || location.pathname === "" ? `${OWNER}.github.io` : location.pathname.split("/")[1];
const FQ_REPO = `${OWNER}/${REPO}`;
const SERVER_PEER_PATH = "data/server-peer.json";
const SERVER_PEER_URL = `https://api.github.com/repos/${FQ_REPO}/contents/${SERVER_PEER_PATH}`;
const SERVER_PEER_RAW_URL = `https://raw.githubusercontent.com/${FQ_REPO}/main/${SERVER_PEER_PATH}`;
const STATE_PATH = "data/state.json";
const STATE_URL = `https://api.github.com/repos/${FQ_REPO}/contents/${STATE_PATH}`;
const GITHUB_ACCESS_TOKEN_KEY = "gitchain_github_access_token";
const ISSUES_URL = `https://api.github.com/repos/${FQ_REPO}/issues`;
const PROTOCOL = "/gitchain/tx/1.0.0";
const UPDATE_INTERVAL = 2 * 60 * 1e3;
let libp2p = null;
let isServer = false;
let serverPeers = [];
class KaspaSignalling {
  chainId;
  provider;
  wallet;
  mnemonic = null;
  address = null;
  listeners = [];
  pollingInterval = null;
  constructor(chainId = "tn-10") {
    this.chainId = chainId;
  }
  async generateWallet() {
    KaspaSDK.setNetwork(this.chainId === "tn-10" || this.chainId === "tn-11" ? KaspaSDK.NetworkType.Testnet : KaspaSDK.NetworkType.Mainnet);
    await KaspaSDK.rpcClient.connect();
    this.startPolling();
    this.mnemonic = Mnemonic.random(12);
    if (!this.mnemonic)
      throw new Error("Mnemonic not generated");
    this.wallet = Wallet.fromMnemonic(this.mnemonic);
    this.address = this.wallet.getAddress().toString();
    return { mnemonic: this.mnemonic, address: this.address };
  }
  async connect() {
    KaspaSDK.setNetwork(this.chainId === "tn-10" || this.chainId === "tn-11" ? KaspaSDK.NetworkType.Testnet : KaspaSDK.NetworkType.Mainnet);
    await KaspaSDK.rpcClient.connect();
    this.startPolling();
  }
  async sendMessage(to, type, data) {
    if (!this.wallet)
      throw new Error("Wallet not generated");
    const payload = JSON.stringify({ from: this.address, to, type, data });
    const txData = "0x" + Buffer.from(payload, "utf8").toString("hex");
    const tx = await this.wallet.sendTransaction({
      to: "0x0000000000000000000000000000000000000000",
      data: txData,
      value: 0n,
      gasLimit: 21000n
    });
    await tx.wait();
    console.log(`[Kaspla] Sent ${type} to ${to.slice(-8)}`);
  }
  startPolling() {
    this.pollingInterval = setInterval(async () => {
      try {
        const blockNumber = await this.provider.getBlockNumber();
        const block = await this.provider.getBlock(blockNumber, true);
        for (const tx of block.transactions) {
          if (tx.to?.toLowerCase() === "0x0000000000000000000000000000000000000000" && tx.input) {
            const raw = Buffer.from(tx.input.slice(2), "hex").toString("utf8");
            let parsed;
            try {
              parsed = JSON.parse(raw);
            } catch {
              continue;
            }
            if (parsed.to === this.address) {
              this.listeners.forEach((cb) => cb(parsed));
            }
          }
        }
      } catch (e2) {
        console.error("Polling error:", e2);
      }
    }, 5e3);
  }
  on(event, cb) {
    if (event === "message")
      this.listeners.push(cb);
  }
  destroy() {
    if (this.pollingInterval)
      clearInterval(this.pollingInterval);
  }
}
class WebRTCConnection {
  signaling;
  localPeerId;
  remotePeerId;
  pc;
  dc = null;
  constructor(signaling, localPeerId, remotePeerId) {
    this.signaling = signaling;
    this.localPeerId = localPeerId;
    this.remotePeerId = remotePeerId;
    this.pc = new RTCPeerConnection({
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" }
      ]
    });
    this.signaling.on("message", (msg) => this.handleSignaling(msg));
    this.setupDataChannel();
    this.initiateOffer();
  }
  setupDataChannel() {
    this.dc = this.pc.createDataChannel("gitchain-chat", { ordered: true });
    this.dc.onopen = () => console.log(`Data channel open → ${this.remotePeerId.slice(-8)}`);
    this.dc.onmessage = (e2) => {
      const chat = document.getElementById("chat");
      const p2 = document.createElement("p");
      p2.textContent = `${this.remotePeerId.slice(-8)}: ${e2.data}`;
      chat.appendChild(p2);
      chat.scrollTop = chat.scrollHeight;
    };
    this.pc.onicecandidate = (ev) => {
      if (ev.candidate)
        this.signaling.sendMessage(this.remotePeerId, "candidate", ev.candidate);
    };
  }
  async initiateOffer() {
    const offer = await this.pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
    await this.pc.setLocalDescription(offer);
    this.signaling.sendMessage(this.remotePeerId, "offer", this.pc.localDescription);
  }
  async handleSignaling(msg) {
    if (msg.from !== this.remotePeerId)
      return;
    try {
      if (msg.type === "offer") {
        await this.pc.setRemoteDescription(msg.data);
        const answer = await this.pc.createAnswer();
        await this.pc.setLocalDescription(answer);
        this.signaling.sendMessage(msg.from, "answer", this.pc.localDescription);
      } else if (msg.type === "answer") {
        await this.pc.setRemoteDescription(msg.data);
      } else if (msg.type === "candidate") {
        await this.pc.addIceCandidate(msg.data);
      }
    } catch (e2) {
      console.error("Signaling handling error:", e2);
    }
  }
  send(text) {
    if (this.dc?.readyState === "open")
      this.dc.send(text);
  }
  get state() {
    return this.pc.connectionState;
  }
}
function calculateHash(index, previousHash, timestamp, transactions) {
  const value2 = `${index}${previousHash}${timestamp}${JSON.stringify(transactions)}`;
  return CryptoJS.SHA256(value2).toString();
}
function createOriginalBlock() {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  return {
    index: 0,
    previousHash: "0",
    timestamp,
    transactions: [],
    hash: calculateHash(0, "0", timestamp, [])
  };
}
function serializeTxn(txn) {
  return JSON.stringify(txn, Object.keys(txn).sort());
}
function keccak256Bytes(input) {
  return Uint8Array.from(sha3Exports.keccak256.array(input));
}
function hexToBytes(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < hex.length; i2 += 2) {
    bytes[i2 / 2] = parseInt(hex.substr(i2, 2), 16);
  }
  return bytes;
}
function bytesToHex(bytes) {
  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
}
function verifyTxn(txn) {
  try {
    const msgHash = keccak256Bytes(fromString(serializeTxn({ from: txn.from, to: txn.to, amount: txn.amount, nonce: txn.nonce })));
    const sigBytes = hexToBytes(txn.signature);
    if (sigBytes.length !== 65)
      return false;
    const r2 = bytesToHex(sigBytes.slice(0, 32));
    const s2 = bytesToHex(sigBytes.slice(32, 64));
    const v = sigBytes[64] - 27;
    const curve2 = new elliptic.ec("secp256k1");
    const msgHashHex = bytesToHex(msgHash);
    const signature2 = { r: r2, s: s2 };
    const publicKey = curve2.recoverPubKey(msgHashHex, signature2, v);
    const pubKeyBytes = publicKey.encode("array", true).slice(1);
    const pubKeyHex = pubKeyBytes.map((b) => b.toString(16).padStart(2, "0")).join("");
    const addrHash = keccak256Bytes(fromString(pubKeyHex));
    const recoveredAddr = `0x${bytesToHex(addrHash.slice(-20))}`;
    return recoveredAddr.toLowerCase() === txn.from.toLowerCase();
  } catch {
    return false;
  }
}
async function processTxn(txn, state) {
  const txid = bytesToHex(keccak256Bytes(fromString(serializeTxn({ from: txn.from, to: txn.to, amount: txn.amount, nonce: txn.nonce }))));
  if (!verifyTxn(txn))
    return { valid: false, txid };
  if ((state.nonces[txn.from] || 0) + 1 !== txn.nonce)
    return { valid: false, txid };
  if (txn.from.toLowerCase() !== ADMIN_ADDRESS.toLowerCase() && (state.balances[txn.from] || 0) < txn.amount)
    return { valid: false, txid };
  if (!/^0x[a-fA-F0-9]{40}$/.test(txn.from) || !/^0x[a-fA-F0-9]{40}$/.test(txn.to))
    return { valid: false, txid };
  state.pending.push(txn);
  return { valid: true, txid };
}
async function createBlock(state) {
  if (state.pending.length === 0)
    return null;
  const validTxns = [];
  const newBalances = { ...state.balances };
  const newNonces = { ...state.nonces };
  for (const txn of state.pending) {
    if (verifyTxn(txn) && (newNonces[txn.from] || 0) + 1 === txn.nonce && (txn.from.toLowerCase() === ADMIN_ADDRESS.toLowerCase() || (newBalances[txn.from] || 0) >= txn.amount)) {
      if (txn.from.toLowerCase() !== ADMIN_ADDRESS.toLowerCase()) {
        newBalances[txn.from] = (newBalances[txn.from] || 0) - txn.amount;
      }
      newBalances[txn.to] = (newBalances[txn.to] || 0) + txn.amount;
      newNonces[txn.from] = txn.nonce;
      validTxns.push(txn);
    }
  }
  if (validTxns.length === 0) {
    state.pending = [];
    return null;
  }
  const nextIndex = state.chain.length;
  const previousHash = state.chain.length > 0 ? state.chain[state.chain.length - 1].hash : "0";
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const hash3 = calculateHash(nextIndex, previousHash, timestamp, validTxns);
  const newBlock = { index: nextIndex, previousHash, timestamp, transactions: validTxns, hash: hash3 };
  state.chain.push(newBlock);
  state.pending = [];
  state.balances = newBalances;
  state.nonces = newNonces;
  return nextIndex;
}
function getGithubAccessToken() {
  let githubAccessToken = localStorage.getItem(GITHUB_ACCESS_TOKEN_KEY);
  if (!githubAccessToken) {
    githubAccessToken = document.getElementById("patInput")?.value;
    if (!githubAccessToken) {
      console.log("No GitHub access token provided");
      alert("Please enter your GitHub access token.");
      return null;
    }
    localStorage.setItem(GITHUB_ACCESS_TOKEN_KEY, githubAccessToken);
  }
  console.log("Retrieved GitHub access token");
  return githubAccessToken;
}
async function initP2P(host) {
  console.log("Entering initP2P, host:", host);
  isServer = host;
  if (libp2p) {
    console.log("libp2p already initialized, reusing instance");
    return;
  }
  localStorage.setItem("debug", "libp2p:*");
  try {
    const response = await fetch(SERVER_PEER_RAW_URL);
    if (response.ok) {
      let data = await response.json();
      for (const peer of data) {
        if (peer.length > 40 && serverPeers.indexOf(peer) == -1) {
          serverPeers.push(peer);
        }
      }
      console.log("Loaded server peers:", serverPeers);
    } else if (response.status === 404) {
      console.log("server-peer.json not found");
    } else {
      console.log("Error fetching server-peer.json, status:", response.status);
    }
  } catch (error) {
    console.error("Error loading server-peer.json:", error);
  }
  const config = {
    addresses: { listen: ["/webrtc"] },
    transports: [
      webRTC({
        rtcConfiguration: {
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:global.stun.twilio.com:3478" },
            { urls: "stun:stun.nextcloud.com:3478" },
            { urls: "stun:stun.1und1.de:3478" },
            { urls: "stun:stun.stunprotocol.org:3478" },
            { urls: "stun:stun.services.mozilla.com:3478" },
            { urls: "stun:stun.ekiga.net:3478" },
            { urls: "stun:stun.voipbuster.com:3478" }
          ]
        }
      }),
      webSockets(),
      circuitRelayTransport()
    ],
    connectionEncryption: [noise()],
    streamMuxers: [yamux()],
    services: {
      identify: identify(),
      pubsub: gossipsub({ emitSelf: true })
    },
    peerDiscovery: [
      pubsubPeerDiscovery({ interval: 2e4 })
    ]
  };
  if (serverPeers.length > 0) {
    config.peerDiscovery.push(bootstrap({ list: serverPeers }));
  } else {
    console.log("No valid peers in serverPeers, initializing without bootstrap");
  }
  libp2p = await createLibp2p(config);
  console.log("P2P node started:", libp2p.peerId.toString());
  libp2p.addEventListener("peer:discovery", (evt) => {
    console.log("Peer discovered:", evt.detail.id.toString());
  });
  libp2p.services.pubsub.addEventListener("subscription-change", (evt) => {
    console.log("Subscription change:", evt.detail);
  });
  await libp2p.handle(PROTOCOL, async ({ stream, connection }) => {
    console.debug("Received P2P stream from:", connection.remotePeer.toString());
    const chunks = [];
    for await (const chunk of stream.source) {
      chunks.push(chunk);
    }
    const data = concat(chunks);
    const txn = JSON.parse(toString$1(data));
    console.debug("Received transaction via P2P:", txn);
  });
  const peerId = libp2p.peerId.toString();
  console.log(`My peer ID is: ${peerId}`);
  if (isServer) {
    if (peerId.length > 40 && !peerId.startsWith("/webrtc/p2p")) {
      try {
        const ma = multiaddr(`/webrtc/p2p/${peerId}`);
        serverPeers.push(ma.toString());
      } catch (error) {
        console.debug(`ERROR: Bad multiaddr: /webrtc/p2p/${peerId}`);
      }
      serverPeers = await updateServerPeers();
      console.log("Added my server peer address to server-peer.json.");
      for (const peer of serverPeers) {
        if (peer.length < 40)
          continue;
        try {
          console.log("Dialing peer: " + peer);
          const ma = multiaddr(peer);
          await libp2p.dial(ma, { signal: AbortSignal.timeout(6e4) });
        } catch (error) {
          console.error(`Failed to dial ${peer}: ${error}`);
        }
      }
    }
  }
}
async function updateServerPeers() {
  console.debug("Entering updateServerPeers() with serverPeers: " + JSON.stringify(serverPeers));
  const githubAccessToken = getGithubAccessToken();
  if (!githubAccessToken) {
    console.error("No PAT available for updating server-peer.json");
    return serverPeers;
  }
  try {
    const response = await fetch(SERVER_PEER_URL + "?ref=main", {
      headers: {
        "Authorization": `token ${githubAccessToken}`,
        "Accept": "application/vnd.github.v3+json"
      }
    });
    let sha2 = null;
    let data = [];
    if (response.ok) {
      data = await response.json();
      sha2 = data.sha;
      data = JSON.parse(atob(data.content));
    } else if (response.status === 404) {
      data = [];
      sha2 = null;
    } else {
      console.error("Error fetching server-peer.json:", response.status, await response.text());
      return serverPeers;
    }
    if (!Array.isArray(data))
      data = [];
    for (let i2 = 0; i2 < serverPeers.length; i2++) {
      if (serverPeers[i2].startsWith("/webrtc/p2p/") && !data.includes(serverPeers[i2])) {
        data.push(serverPeers[i2]);
      }
    }
    const body = {
      message: "Update server peer IDs",
      content: btoa(JSON.stringify(data, null, 2)),
      branch: "main",
      sha: sha2 || void 0
    };
    const updateResponse = await fetch(SERVER_PEER_URL + "?ref=main", {
      method: "PUT",
      headers: {
        "Authorization": `token ${githubAccessToken}`,
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (updateResponse.ok) {
      console.log("server-peer.json updated successfully");
      serverPeers = data;
      return data;
    } else {
      console.error("Failed to update server-peer.json:", updateResponse.status, await updateResponse.text());
      return serverPeers;
    }
  } catch (error) {
    console.error("Error updating server-peer.json:", error);
    return serverPeers;
  }
}
async function removeHostPeerId() {
  if (!isServer || !libp2p)
    return;
  const peerId = libp2p.peerId.toString();
  serverPeers = serverPeers.filter((id) => id !== peerId);
  await updateServerPeers();
}
async function connectAndSendTx(tx) {
  if (isServer) {
    const issueBody = JSON.stringify({
      type: "gitchain_txn",
      repo: FQ_REPO,
      txn: tx
    });
    const response = await fetch(ISSUES_URL, {
      method: "POST",
      headers: {
        "Authorization": `token ${getGithubAccessToken()}`,
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        title: `tx ${tx.from} to ${tx.to}`,
        body: issueBody
      })
    });
    if (response.ok) {
      console.log("Host created issue for TX");
    } else {
      console.error("Host failed to create issue:", response.status, await response.text());
    }
    return;
  }
  let peers = [];
  try {
    const res = await fetch(SERVER_PEER_RAW_URL);
    if (res.ok) {
      peers = await res.json();
      console.log("Loaded active server peers:", peers);
    } else if (res.status === 404) {
      alert("The server is currently not running.");
      return;
    } else {
      alert("Failed to fetch server peer info. Please try again or notify the administrator.");
      return;
    }
  } catch (error) {
    console.error("Failed to fetch server-peer.json:", error);
    alert("Failed to connect to server. Please try again or notify the server administrator.");
    return;
  }
  if (peers.length === 0) {
    alert("The server is currently not running.");
    return;
  }
  let connected = false;
  for (const peer of peers) {
    try {
      const ma = multiaddr(peer);
      const connection = await libp2p.dial(ma, { signal: AbortSignal.timeout(6e4) });
      const stream = await connection.newStream(PROTOCOL);
      const txJson = JSON.stringify(tx);
      const data = fromString(txJson);
      await stream.sink([data]);
      console.log("TX sent to server peer:", peer);
      connected = true;
      break;
    } catch (error) {
      console.error("Failed to dial server peer:", peer, error);
    }
  }
  if (!connected) {
    alert("Failed to connect to any server. Please try again or notify the server administrator.");
  }
}
function saveGithubAccessToken() {
  console.log("Entering saveGithubAccessToken");
  const githubAccessToken = document.getElementById("patInput")?.value;
  if (githubAccessToken) {
    localStorage.setItem(GITHUB_ACCESS_TOKEN_KEY, githubAccessToken);
    console.log("PAT saved, initializing P2P as host");
    initP2P(true);
  } else {
    console.error("No GitHub access token provided");
    throw new Error("Enter a GitHub access token first.");
  }
}
async function fetchState() {
  console.log("Entering fetchState");
  const githubAccessToken = getGithubAccessToken();
  if (!githubAccessToken) {
    console.log("No PAT available for fetching state");
    return null;
  }
  try {
    console.log("Fetching state from:", STATE_URL);
    const response = await fetch(`${STATE_URL}?ref=main`, {
      headers: {
        "Authorization": `token ${githubAccessToken}`,
        "Accept": "application/vnd.github.v3+json"
      }
    });
    if (!response.ok) {
      if (response.status === 404) {
        console.log("State file not found");
        return null;
      }
      console.error("Error fetching state:", response.status, await response.text());
      throw new Error(`Error fetching state: ${response.statusText}`);
    }
    const file = await response.json();
    const content = JSON.parse(atob(file.content));
    console.log("State fetched, chain length:", content.chain.length);
    return { content, sha: file.sha };
  } catch (error) {
    console.error("Error fetching state:", error);
    return null;
  }
}
async function updateState(newContent, oldSha, message2, retries = 3) {
  console.log("Entering updateState, message:", message2);
  const githubAccessToken = getGithubAccessToken();
  if (!githubAccessToken) {
    console.log("No PAT available for updating state");
    return false;
  }
  const fileContent = btoa(JSON.stringify(newContent, null, 2));
  try {
    const body = { message: message2, content: fileContent, branch: "main" };
    if (oldSha)
      body.sha = oldSha;
    console.log("Sending PUT request to update state");
    const response = await fetch(STATE_URL + "?ref=main", {
      method: "PUT",
      headers: {
        "Authorization": `token ${githubAccessToken}`,
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      if (response.status === 409 && retries > 0) {
        console.log("Conflict detected, retrying...");
        const current = await fetchState();
        if (!current)
          throw new Error("Failed to refetch state during conflict resolution");
        return updateState(newContent, current.sha, message2, retries - 1);
      }
      console.error("Error updating state:", response.status, await response.text());
      throw new Error(`Error updating state: ${response.statusText}`);
    }
    console.log("State updated successfully");
    return true;
  } catch (error) {
    console.error("Error updating state:", error);
    return false;
  }
}
async function closeIssueWithComment(issueNumber, blockIndex, valid) {
  console.log("Entering closeIssueWithComment, issue:", issueNumber);
  const githubAccessToken = getGithubAccessToken();
  if (!githubAccessToken) {
    console.log("No PAT available for closing issue");
    return;
  }
  const status = valid && blockIndex !== null ? `Confirmed in block ${blockIndex}` : "Invalid transaction";
  const intro = "Gitchain is an innovative centralized chain on GitHub. It enables secure, transparent transactions.";
  const gitchain_url = `https://github.com/${FQ_REPO}`;
  const commentBody = `${status}. ${intro} Learn more: ${gitchain_url} (Repo: ${FQ_REPO})`;
  console.log("Creating comment for issue:", issueNumber);
  await fetch(`${ISSUES_URL}/${issueNumber}/comments`, {
    method: "POST",
    headers: {
      "Authorization": `token ${githubAccessToken}`,
      "Accept": "application/vnd.github.v3+json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ body: commentBody })
  });
  console.log("Closing issue:", issueNumber);
  await fetch(`${ISSUES_URL}/${issueNumber}`, {
    method: "PATCH",
    headers: {
      "Authorization": `token ${githubAccessToken}`,
      "Accept": "application/vnd.github.v3+json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({ state: "closed" })
  });
}
async function processTxns() {
  console.log("Entering processTxns");
  const output = document.getElementById("output");
  const processingMessage = document.getElementById("processing-message");
  processingMessage.classList.add("visible");
  let stateData = await fetchState();
  let state = stateData?.content;
  if (!state) {
    console.log("No state found, initializing");
    state = {
      chain: [createOriginalBlock()],
      pending: [],
      balances: { [ADMIN_ADDRESS]: 1e6 },
      nonces: {},
      lastProcessedDate: (/* @__PURE__ */ new Date(0)).toISOString()
    };
    const success = await updateState(state, null, "Initialize state");
    if (!success) {
      console.log("Failed to initialize state");
      output.textContent += "\nFailed to initialize.";
      processingMessage.classList.remove("visible");
      return;
    }
    stateData = await fetchState();
    state = stateData.content;
  }
  console.log("Fetching open issues");
  const issuesRes = await fetch(`${ISSUES_URL}?state=open&sort=created&direction=asc&per_page=100`, {
    headers: { "Authorization": `token ${getGithubAccessToken()}`, "Accept": "application/vnd.github.v3+json" }
  });
  const issues = await issuesRes.json();
  let newLastDate = state.lastProcessedDate;
  for (const issue of issues) {
    if (!issue.title.toLowerCase().startsWith("tx"))
      continue;
    if (new Date(issue.created_at) <= new Date(state.lastProcessedDate))
      continue;
    let txn;
    try {
      const parsed = JSON.parse(issue.body);
      if (parsed.type !== "gitchain_txn") {
        console.log("Skipping non-tx issue:", issue.number);
        await closeIssueWithComment(issue.number, null, false);
        continue;
      }
      if (parsed.repo !== FQ_REPO) {
        console.log("Skipping issue from wrong repo:", issue.number);
        await closeIssueWithComment(issue.number, null, false);
        continue;
      }
      txn = parsed.txn;
    } catch {
      console.log("Invalid issue body, closing:", issue.number);
      await closeIssueWithComment(issue.number, null, false);
      continue;
    }
    console.log("Processing transaction from issue:", issue.number);
    const { valid, txid } = await processTxn(txn, state);
    console.log(`Transaction ID: ${txid}, valid: ${valid}`);
    const blockIndex = valid ? await createBlock(state) : null;
    await closeIssueWithComment(issue.number, blockIndex, valid);
    if (valid && blockIndex !== null) {
      console.log(`Transaction ID: ${txid} settled in block ${blockIndex}`);
      output.textContent += `
Processed txn ${txid} from issue #${issue.number} in block ${blockIndex}`;
    } else {
      console.log(`Rejected invalid txn from issue #${issue.number}`);
      output.textContent += `
Rejected invalid txn from issue #${issue.number}`;
    }
    const success = await updateState(state, stateData.sha, `Process issue #${issue.number}`);
    if (!success) {
      console.log("Failed to update state after issue:", issue.number);
      output.textContent += `
Failed to update state after issue #${issue.number}`;
      processingMessage.classList.remove("visible");
      return;
    }
    stateData = await fetchState();
    state = stateData.content;
    const issueCreated = issue.created_at;
    if (new Date(issueCreated) > new Date(newLastDate)) {
      newLastDate = issueCreated;
    }
  }
  if (newLastDate !== state.lastProcessedDate) {
    console.log("Updating last processed date:", newLastDate);
    state.lastProcessedDate = newLastDate;
    await updateState(state, stateData.sha, "Update last processed date");
  }
  console.log("processTxns completed");
  processingMessage.classList.remove("visible");
}
async function viewChain() {
  console.log("Entering viewChain");
  const output = document.getElementById("output");
  const state = await fetchState();
  if (!state || !state.content.chain || state.content.chain.length === 0) {
    console.log("No transactions in chain");
    output.textContent = "No transactions in the chain yet.";
    return;
  }
  const chain = state.content.chain;
  const balances = state.content.balances;
  let text = `Chain length: ${chain.length}
Pending txns: ${state.content.pending.length}
Last processed: ${state.content.lastProcessedDate}
Balances:
`;
  for (const [addr, bal] of Object.entries(balances)) {
    text += ` ${addr}: ${bal}
`;
  }
  text += "\n";
  chain.forEach((b) => {
    text += `Block ${b.index}:
 Hash: ${b.hash}
 Prev Hash: ${b.previousHash}
 Timestamp: ${b.timestamp}
 Transactions:
` + b.transactions.map((t2) => ` ${t2.from} sends ${t2.amount} to ${t2.to} (nonce ${t2.nonce})`).join("\n") + "\n\n";
  });
  output.textContent = text;
  console.log("viewChain completed, chain length:", chain.length);
}
window.addEventListener("load", () => {
  console.log("Window loaded, checking for PAT");
  if (!localStorage.getItem(GITHUB_ACCESS_TOKEN_KEY)) {
    console.log("No PAT found, prompting user");
    alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.");
  } else {
    console.log("PAT found, initializing P2P as host");
    initP2P(true);
  }
  console.log("Setting interval for transaction processing");
  setInterval(() => {
    processTxns();
  }, UPDATE_INTERVAL);
});
window.addEventListener("unload", async () => {
  await removeHostPeerId();
});
window.gitchain = {
  saveGithubAccessToken,
  viewChain,
  processTxns,
  fetchState,
  connectAndSendTx,
  KaspaSignalling,
  WebRTCConnection
};
window.dispatchEvent(new Event("gitchain:init"));
//# sourceMappingURL=bundle.js.map
