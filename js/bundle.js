var Pg=Object.defineProperty;var Sc=r=>{throw TypeError(r)};var Rg=(r,t,e)=>t in r?Pg(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var l=(r,t,e)=>Rg(r,typeof t!="symbol"?t+"":t,e),Ji=(r,t,e)=>t.has(r)||Sc("Cannot "+e);var $=(r,t,e)=>(Ji(r,t,"read from private field"),e?e.call(r):t.get(r)),he=(r,t,e)=>t.has(r)?Sc("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(r):t.set(r,e),fe=(r,t,e,n)=>(Ji(r,t,"write to private field"),n?n.call(r,e):t.set(r,e),e),H=(r,t,e)=>(Ji(r,t,"access private method"),e);var ar=(r,t,e,n)=>({set _(s){fe(r,t,s,e)},get _(){return $(r,t,n)}});const Ks="0x097efb2a92bc5205e1615db52338a118f1619f3f",kg=Symbol.for("@libp2p/connection"),xc=Symbol.for("@libp2p/content-routing");var Lo;let Lr=(Lo=class extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}},l(Lo,"name","AbortError"),Lo);class Ju extends Error{constructor(t="Unexpected Peer"){super(t),this.name="UnexpectedPeerError"}}l(Ju,"name","UnexpectedPeerError");var Do;let Mg=(Do=class extends Error{constructor(t="Invalid crypto exchange"){super(t),this.name="InvalidCryptoExchangeError"}},l(Do,"name","InvalidCryptoExchangeError"),Do);var Po;let W=(Po=class extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}},l(Po,"name","InvalidParametersError"),Po);class Ta extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}l(Ta,"name","InvalidPublicKeyError");class Vs extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}l(Vs,"name","ConnectionClosedError");class ju extends Error{constructor(t="Connection failed"){super(t),this.name="ConnectionFailedError"}}l(ju,"name","ConnectionFailedError");class bn extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}l(bn,"name","MuxerClosedError");class La extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}l(La,"name","StreamResetError");class Yt extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}l(Yt,"name","StreamStateError");class Bo extends Error{constructor(t="The stream buffer was full"){super(t),this.name="StreamBufferError"}}l(Bo,"name","StreamBufferError");var Ro;let $o=(Ro=class extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}},l(Ro,"name","NotFoundError"),Ro);class Da extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}l(Da,"name","InvalidPeerIdError");var ko;let Pi=(ko=class extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}},l(ko,"name","InvalidMultiaddrError"),ko);class ed extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}l(ed,"name","InvalidCIDError");class td extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}l(td,"name","InvalidMultihashError");class nd extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}l(nd,"name","UnsupportedProtocolError");class it extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}l(it,"name","InvalidMessageError");var Mo;let Ng=(Mo=class extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}},l(Mo,"name","TimeoutError"),Mo);class Dr extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}l(Dr,"name","NotStartedError");class Er extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}l(Er,"name","DialError");class Ws extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}l(Ws,"name","ListenError");class Uo extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}l(Uo,"name","LimitedConnectionError");class rd extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}l(rd,"name","TooManyInboundProtocolStreamsError");class Pa extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}l(Pa,"name","TooManyOutboundProtocolStreamsError");class Ri extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}l(Ri,"name","UnsupportedKeyTypeError");class Og extends Event{constructor(e,n){super("message",n);l(this,"data");this.data=e}}class ki extends Event{constructor(e,n,s){super("close",s);l(this,"error");l(this,"local");this.error=n,this.local=e}}class Fg extends ki{constructor(t,e){super(!0,t,e)}}class Bg extends ki{constructor(t,e){super(!1,t,e)}}const zo=Symbol.for("@libp2p/peer-discovery"),Ra=Symbol.for("@libp2p/peer-id");function vr(r){return!!(r!=null&&r[Ra])}const Ac=Symbol.for("@libp2p/peer-routing"),ka="keep-alive";function Ma(r){return r!=null&&typeof r.start=="function"&&typeof r.stop=="function"}async function sd(...r){const t=[];for(const e of r)Ma(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(t.map(async e=>{await e.start()})),await Promise.all(t.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function id(...r){const t=[];for(const e of r)Ma(e)&&t.push(e);await Promise.all(t.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(t.map(async e=>{await e.stop()})),await Promise.all(t.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}const od=Symbol.for("@libp2p/transport");var Hs;(function(r){r[r.FATAL_ALL=0]="FATAL_ALL",r[r.NO_FATAL=1]="NO_FATAL"})(Hs||(Hs={}));var dt;class Xe extends EventTarget{constructor(){super();he(this,dt,new Map)}listenerCount(e){const n=$(this,dt).get(e);return n==null?0:n.length}addEventListener(e,n,s){super.addEventListener(e,n,s);let i=$(this,dt).get(e);i==null&&(i=[],$(this,dt).set(e,i)),i.push({callback:n,once:(s!==!0&&s!==!1&&(s==null?void 0:s.once))??!1})}removeEventListener(e,n,s){super.removeEventListener(e.toString(),n??null,s);let i=$(this,dt).get(e);i!=null&&(i=i.filter(({callback:o})=>o!==n),$(this,dt).set(e,i))}dispatchEvent(e){const n=super.dispatchEvent(e);let s=$(this,dt).get(e.type);return s==null||(s=s.filter(({once:i})=>!i),$(this,dt).set(e.type,s)),n}safeDispatchEvent(e,n={}){return this.dispatchEvent(new CustomEvent(e,n))}}dt=new WeakMap;const Ct=Symbol.for("@libp2p/service-capabilities"),Gs=Symbol.for("@libp2p/service-dependencies");function $g(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function Mi(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function Ug(r){return new TextEncoder().encode(r)}function zg(r){return new TextDecoder().decode(r)}function qg(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var s=0;s<r.length;s++){var i=r.charAt(s),o=i.charCodeAt(0);if(e[o]!==255)throw new TypeError(i+" is ambiguous");e[o]=s}var a=r.length,c=r.charAt(0),u=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function h(g){if(g instanceof Uint8Array||(ArrayBuffer.isView(g)?g=new Uint8Array(g.buffer,g.byteOffset,g.byteLength):Array.isArray(g)&&(g=Uint8Array.from(g))),!(g instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(g.length===0)return"";for(var y=0,m=0,S=0,v=g.length;S!==v&&g[S]===0;)S++,y++;for(var E=(v-S)*d+1>>>0,L=new Uint8Array(E);S!==v;){for(var x=g[S],_=0,N=E-1;(x!==0||_<m)&&N!==-1;N--,_++)x+=256*L[N]>>>0,L[N]=x%a>>>0,x=x/a>>>0;if(x!==0)throw new Error("Non-zero carry");m=_,S++}for(var T=E-m;T!==E&&L[T]===0;)T++;for(var I=c.repeat(y);T<E;++T)I+=r.charAt(L[T]);return I}function f(g){if(typeof g!="string")throw new TypeError("Expected String");if(g.length===0)return new Uint8Array;var y=0;if(g[y]!==" "){for(var m=0,S=0;g[y]===c;)m++,y++;for(var v=(g.length-y)*u+1>>>0,E=new Uint8Array(v);g[y];){var L=e[g.charCodeAt(y)];if(L===255)return;for(var x=0,_=v-1;(L!==0||x<S)&&_!==-1;_--,x++)L+=a*E[_]>>>0,E[_]=L%256>>>0,L=L/256>>>0;if(L!==0)throw new Error("Non-zero carry");S=x,y++}if(g[y]!==" "){for(var N=v-S;N!==v&&E[N]===0;)N++;for(var T=new Uint8Array(m+(v-N)),I=m;N!==v;)T[I++]=E[N++];return T}}}function p(g){var y=f(g);if(y)return y;throw new Error(`Non-${t} character`)}return{encode:h,decodeUnsafe:f,decode:p}}var Kg=qg,Vg=Kg;class Wg{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}let Hg=class{constructor(t,e,n){l(this,"name");l(this,"prefix");l(this,"baseDecode");l(this,"prefixCodePoint");this.name=t,this.prefix=e;const s=e.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return ad(this,t)}};class Gg{constructor(t){l(this,"decoders");this.decoders=t}or(t){return ad(this,t)}decode(t){const e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function ad(r,t){return new Gg({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}class Yg{constructor(t,e,n,s){l(this,"name");l(this,"prefix");l(this,"baseEncode");l(this,"baseDecode");l(this,"encoder");l(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=s,this.encoder=new Wg(t,e,n),this.decoder=new Hg(t,e,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function Ni({name:r,prefix:t,encode:e,decode:n}){return new Yg(r,t,e,n)}function Yr({name:r,prefix:t,alphabet:e}){const{encode:n,decode:s}=Vg(e,r);return Ni({prefix:t,name:r,encode:n,decode:i=>Mi(s(i))})}function Xg(r,t,e,n){let s=r.length;for(;r[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const d=t[r[u]];if(d===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<e|d,o+=e,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=e||255&a<<8-o)throw new SyntaxError("Unexpected end of data");return i}function Qg(r,t,e){const n=t[t.length-1]==="=",s=(1<<e)-1;let i="",o=0,a=0;for(let c=0;c<r.length;++c)for(a=a<<8|r[c],o+=8;o>e;)o-=e,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<e-o]),n)for(;i.length*e&7;)i+="=";return i}function Zg(r){const t={};for(let e=0;e<r.length;++e)t[r[e]]=e;return t}function Pe({name:r,prefix:t,bitsPerChar:e,alphabet:n}){const s=Zg(n);return Ni({prefix:t,name:r,encode(i){return Qg(i,n,e)},decode(i){return Xg(i,s,e,r)}})}const Ie=Yr({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Jg=Yr({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),jg=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Ie,base58flickr:Jg},Symbol.toStringTag,{value:"Module"})),Ut=Pe({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),em=Pe({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),tm=Pe({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),nm=Pe({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),rm=Pe({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),sm=Pe({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),im=Pe({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),om=Pe({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),am=Pe({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),cm=Object.freeze(Object.defineProperty({__proto__:null,base32:Ut,base32hex:rm,base32hexpad:im,base32hexpadupper:om,base32hexupper:sm,base32pad:tm,base32padupper:nm,base32upper:em,base32z:am},Symbol.toStringTag,{value:"Module"})),Ds=Yr({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),lm=Yr({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),um=Object.freeze(Object.defineProperty({__proto__:null,base36:Ds,base36upper:lm},Symbol.toStringTag,{value:"Module"}));var dm=cd,Cc=128,hm=-128,fm=Math.pow(2,31);function cd(r,t,e){t=t||[],e=e||0;for(var n=e;r>=fm;)t[e++]=r&255|Cc,r/=128;for(;r&hm;)t[e++]=r&255|Cc,r>>>=7;return t[e]=r|0,cd.bytes=e-n+1,t}var gm=qo,mm=128,_c=127;function qo(r,n){var e=0,n=n||0,s=0,i=n,o,a=r.length;do{if(i>=a)throw qo.bytes=0,new RangeError("Could not decode varint");o=r[i++],e+=s<28?(o&_c)<<s:(o&_c)*Math.pow(2,s),s+=7}while(o>=mm);return qo.bytes=i-n,e}var pm=Math.pow(2,7),ym=Math.pow(2,14),wm=Math.pow(2,21),bm=Math.pow(2,28),Em=Math.pow(2,35),vm=Math.pow(2,42),Sm=Math.pow(2,49),xm=Math.pow(2,56),Am=Math.pow(2,63),Cm=function(r){return r<pm?1:r<ym?2:r<wm?3:r<bm?4:r<Em?5:r<vm?6:r<Sm?7:r<xm?8:r<Am?9:10},_m={encode:dm,decode:gm,encodingLength:Cm},Ys=_m;function Ko(r,t=0){return[Ys.decode(r,t),Ys.decode.bytes]}function Xs(r,t,e=0){return Ys.encode(r,t,e),t}function Qs(r){return Ys.encodingLength(r)}function Oi(r,t){const e=t.byteLength,n=Qs(r),s=n+Qs(e),i=new Uint8Array(s+e);return Xs(r,i,0),Xs(e,i,n),i.set(t,s),new Na(r,e,t,i)}function Xr(r){const t=Mi(r),[e,n]=Ko(t),[s,i]=Ko(t.subarray(n)),o=t.subarray(n+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new Na(e,s,o,t)}function Im(r,t){if(r===t)return!0;{const e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&$g(r.bytes,e.bytes)}}class Na{constructor(t,e,n,s){l(this,"code");l(this,"size");l(this,"digest");l(this,"bytes");this.code=t,this.size=e,this.digest=n,this.bytes=s}}function Ic(r,t){const{bytes:e,version:n}=r;switch(n){case 0:return Lm(e,Vo(r),t??Ie.encoder);default:return Dm(e,Vo(r),t??Ut.encoder)}}const Tc=new WeakMap;function Vo(r){const t=Tc.get(r);if(t==null){const e=new Map;return Tc.set(r,e),e}return t}var du;class ge{constructor(t,e,n,s){l(this,"code");l(this,"version");l(this,"multihash");l(this,"bytes");l(this,"/");l(this,du,"CID");this.code=e,this.version=t,this.multihash=n,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==cr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Pm)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ge.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,n=Oi(t,e);return ge.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return ge.equals(this,t)}static equals(t,e){const n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Im(t.multihash,n.multihash)}toString(t){return Ic(this,t)}toJSON(){return{"/":Ic(this)}}link(){return this}[(du=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof ge)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:n,code:s,multihash:i,bytes:o}=e;return new ge(n,s,i,o??Lc(n,s,i.bytes))}else if(e[Rm]===!0){const{version:n,multihash:s,code:i}=e,o=Xr(s);return ge.create(n,i,o)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==cr)throw new Error(`Version 0 CID must use dag-pb (code: ${cr}) block encoding`);return new ge(t,e,n,n.bytes)}case 1:{const s=Lc(t,e,n.bytes);return new ge(t,e,n,s)}default:throw new Error("Invalid version")}}static createV0(t){return ge.create(0,cr,t)}static createV1(t,e){return ge.create(1,t,e)}static decode(t){const[e,n]=ge.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=ge.inspectBytes(t),n=e.size-e.multihashSize,s=Mi(t.subarray(n,n+e.multihashSize));if(s.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=s.subarray(e.multihashSize-e.digestSize),o=new Na(e.multihashCode,e.digestSize,i,s);return[e.version===0?ge.createV0(o):ge.createV1(e.codec,o),t.subarray(e.size)]}static inspectBytes(t){let e=0;const n=()=>{const[h,f]=Ko(t.subarray(e));return e+=f,h};let s=n(),i=cr;if(s===18?(s=0,e=0):i=n(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=e,a=n(),c=n(),u=e+c,d=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:d,size:u}}static parse(t,e){const[n,s]=Tm(t,e),i=ge.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Vo(i).set(n,t),i}}function Tm(r,t){switch(r[0]){case"Q":{const e=t??Ie;return[Ie.prefix,e.decode(`${Ie.prefix}${r}`)]}case Ie.prefix:{const e=t??Ie;return[Ie.prefix,e.decode(r)]}case Ut.prefix:{const e=t??Ut;return[Ut.prefix,e.decode(r)]}case Ds.prefix:{const e=t??Ds;return[Ds.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function Lm(r,t,e){const{prefix:n}=e;if(n!==Ie.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const s=t.get(n);if(s==null){const i=e.encode(r).slice(1);return t.set(n,i),i}else return s}function Dm(r,t,e){const{prefix:n}=e,s=t.get(n);if(s==null){const i=e.encode(r);return t.set(n,i),i}else return s}const cr=112,Pm=18;function Lc(r,t,e){const n=Qs(r),s=n+Qs(t),i=new Uint8Array(s+e.byteLength);return Xs(r,i,0),Xs(t,i,n),i.set(e,s),i}const Rm=Symbol.for("@ipld/js-cid/CID"),ld=0,km="identity",ud=Mi;function Mm(r,t){if((t==null?void 0:t.truncate)!=null&&t.truncate!==r.byteLength){if(t.truncate<0||t.truncate>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,t.truncate)}return Oi(ld,ud(r))}const Qr={code:ld,name:km,encode:ud,digest:Mm};function qe(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function oe(r=0){return new Uint8Array(r)}function gt(r=0){return new Uint8Array(r)}function qt(r,t){t==null&&(t=r.reduce((s,i)=>s+i.length,0));const e=gt(t);let n=0;for(const s of r)e.set(s,n),n+=s.length;return e}const dd=Symbol.for("@achingbrain/uint8arraylist");function Dc(r,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let e=0;for(const n of r){const s=e+n.byteLength;if(t<s)return{buf:n,index:t-e};e=s}throw new RangeError("index is out of bounds")}function as(r){return!!(r!=null&&r[dd])}var hu;class J{constructor(...t){l(this,"bufs");l(this,"length");l(this,hu,!0);this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[(hu=dd,Symbol.iterator)](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let e=0;for(const n of t)if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.push(n);else if(as(n))e+=n.byteLength,this.bufs.push(...n.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}prepend(...t){this.prependAll(t)}prependAll(t){let e=0;for(const n of t.reverse())if(n instanceof Uint8Array)e+=n.byteLength,this.bufs.unshift(n);else if(as(n))e+=n.byteLength,this.bufs.unshift(...n.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=e}get(t){const e=Dc(this.bufs,t);return e.buf[e.index]}set(t,e){const n=Dc(this.bufs,t);n.buf[n.index]=e}write(t,e=0){if(t instanceof Uint8Array)for(let n=0;n<t.length;n++)this.set(e+n,t[n]);else if(as(t))for(let n=0;n<t.length;n++)this.set(e+n,t.get(n));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,e){const{bufs:n,length:s}=this._subList(t,e);return qt(n,s)}subarray(t,e){const{bufs:n,length:s}=this._subList(t,e);return n.length===1?n[0]:qt(n,s)}sublist(t,e){const{bufs:n,length:s}=this._subList(t,e),i=new J;return i.length=s,i.bufs=[...n],i}_subList(t,e){if(t=t??0,e=e??this.length,t<0&&(t=this.length+t),e<0&&(e=this.length+e),t<0||e>this.length)throw new RangeError("index is out of bounds");if(t===e)return{bufs:[],length:0};if(t===0&&e===this.length)return{bufs:this.bufs,length:this.length};const n=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const u=t>=a&&t<c,d=e>a&&e<=c;if(u&&d){if(t===a&&e===c){n.push(o);break}const h=t-a;n.push(o.subarray(h,h+(e-t)));break}if(u){if(t===0){n.push(o);continue}n.push(o.subarray(t-a));continue}if(d){if(e===c){n.push(o);break}n.push(o.subarray(0,e-a));break}n.push(o)}return{bufs:n,length:e-t}}indexOf(t,e=0){if(!as(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const n=t instanceof Uint8Array?t:t.subarray();if(e=Number(e??0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const s=n.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let h=0;h<i;h++)o[h]=-1;for(let h=0;h<s;h++)o[n[h]]=h;const a=o,c=this.byteLength-n.byteLength,u=n.byteLength-1;let d;for(let h=e;h<=c;h+=d){d=0;for(let f=u;f>=0;f--){const p=this.get(h+f);if(n[f]!==p){d=Math.max(1,f-a[p]);break}}if(d===0)return h}return-1}getInt8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getInt8(0)}setInt8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setInt8(0,e),this.write(n,t)}getInt16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt16(0,e)}setInt16(t,e,n){const s=oe(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,e,n),this.write(s,t)}getInt32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt32(0,e)}setInt32(t,e,n){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,e,n),this.write(s,t)}getBigInt64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigInt64(0,e)}setBigInt64(t,e,n){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,e,n),this.write(s,t)}getUint8(t){const e=this.subarray(t,t+1);return new DataView(e.buffer,e.byteOffset,e.byteLength).getUint8(0)}setUint8(t,e){const n=gt(1);new DataView(n.buffer,n.byteOffset,n.byteLength).setUint8(0,e),this.write(n,t)}getUint16(t,e){const n=this.subarray(t,t+2);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint16(0,e)}setUint16(t,e,n){const s=oe(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,e,n),this.write(s,t)}getUint32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint32(0,e)}setUint32(t,e,n){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,e,n),this.write(s,t)}getBigUint64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getBigUint64(0,e)}setBigUint64(t,e,n){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,e,n),this.write(s,t)}getFloat32(t,e){const n=this.subarray(t,t+4);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat32(0,e)}setFloat32(t,e,n){const s=oe(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,e,n),this.write(s,t)}getFloat64(t,e){const n=this.subarray(t,t+8);return new DataView(n.buffer,n.byteOffset,n.byteLength).getFloat64(0,e)}setFloat64(t,e,n){const s=oe(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,e,n),this.write(s,t)}equals(t){if(t==null||!(t instanceof J)||t.bufs.length!==this.bufs.length)return!1;for(let e=0;e<this.bufs.length;e++)if(!qe(this.bufs[e],t.bufs[e]))return!1;return!0}static fromUint8Arrays(t,e){const n=new J;return n.bufs=t,e==null&&(e=t.reduce((s,i)=>s+i.byteLength,0)),n.length=e,n}}const Nm=Yr({prefix:"9",name:"base10",alphabet:"0123456789"}),Om=Object.freeze(Object.defineProperty({__proto__:null,base10:Nm},Symbol.toStringTag,{value:"Module"})),Fm=Pe({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Bm=Pe({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),$m=Object.freeze(Object.defineProperty({__proto__:null,base16:Fm,base16upper:Bm},Symbol.toStringTag,{value:"Module"})),Um=Pe({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),zm=Object.freeze(Object.defineProperty({__proto__:null,base2:Um},Symbol.toStringTag,{value:"Module"})),hd=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),qm=hd.reduce((r,t,e)=>(r[e]=t,r),[]),Km=hd.reduce((r,t,e)=>{const n=t.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${t}`);return r[n]=e,r},[]);function Vm(r){return r.reduce((t,e)=>(t+=qm[e],t),"")}function Wm(r){const t=[];for(const e of r){const n=e.codePointAt(0);if(n==null)throw new Error(`Invalid character: ${e}`);const s=Km[n];if(s==null)throw new Error(`Non-base256emoji character: ${e}`);t.push(s)}return new Uint8Array(t)}const Hm=Ni({prefix:"ðŸš€",name:"base256emoji",encode:Vm,decode:Wm}),Gm=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Hm},Symbol.toStringTag,{value:"Module"})),fd=Pe({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ym=Pe({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),gd=Pe({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Xm=Pe({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Qm=Object.freeze(Object.defineProperty({__proto__:null,base64:fd,base64pad:Ym,base64url:gd,base64urlpad:Xm},Symbol.toStringTag,{value:"Module"})),Zm=Pe({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Jm=Object.freeze(Object.defineProperty({__proto__:null,base8:Zm},Symbol.toStringTag,{value:"Module"})),jm=Ni({prefix:"\0",name:"identity",encode:r=>zg(r),decode:r=>Ug(r)}),ep=Object.freeze(Object.defineProperty({__proto__:null,identity:jm},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const tp=20;function np({name:r,code:t,encode:e,minDigestLength:n,maxDigestLength:s}){return new rp(r,t,e,n,s)}class rp{constructor(t,e,n,s,i){l(this,"name");l(this,"code");l(this,"encode");l(this,"minDigestLength");l(this,"maxDigestLength");this.name=t,this.code=e,this.encode=n,this.minDigestLength=s??tp,this.maxDigestLength=i}digest(t,e){if((e==null?void 0:e.truncate)!=null){if(e.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&e.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const n=this.encode(t);return n instanceof Uint8Array?Pc(n,this.code,e==null?void 0:e.truncate):n.then(s=>Pc(s,this.code,e==null?void 0:e.truncate))}else throw Error("Unknown type, must be binary type")}}function Pc(r,t,e){if(e!=null&&e!==r.byteLength){if(e>r.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${r.byteLength}`);r=r.subarray(0,e)}return Oi(t,r)}function sp(r){return async t=>new Uint8Array(await crypto.subtle.digest(r,t))}const md=np({name:"sha2-256",code:18,encode:sp("SHA-256")}),Wo={...ep,...zm,...Jm,...Om,...$m,...cm,...um,...jg,...Qm,...Gm};function pd(r,t,e,n){return{name:r,prefix:t,encoder:{name:r,prefix:t,encode:e},decoder:{decode:n}}}const Rc=pd("utf8","u",r=>"u"+new TextDecoder("utf8").decode(r),r=>new TextEncoder().encode(r.substring(1))),ji=pd("ascii","a",r=>{let t="a";for(let e=0;e<r.length;e++)t+=String.fromCharCode(r[e]);return t},r=>{r=r.substring(1);const t=gt(r.length);for(let e=0;e<r.length;e++)t[e]=r.charCodeAt(e);return t}),yd={utf8:Rc,"utf-8":Rc,hex:Wo.base16,latin1:ji,ascii:ji,binary:ji,...Wo};function Y(r,t="utf8"){const e=yd[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.decoder.decode(`${e.prefix}${r}`)}function Z(r,t="utf8"){const e=yd[t];if(e==null)throw new Error(`Unsupported encoding "${t}"`);return e.encoder.encode(r).substring(1)}const ip=parseInt("11111",2),Ho=parseInt("10000000",2),op=parseInt("01111111",2),kc={0:lr,1:lr,2:ap,3:up,4:dp,5:lp,6:cp,16:lr,22:lr,48:lr};function Fi(r,t={offset:0}){const e=r[t.offset]&ip;if(t.offset++,kc[e]!=null)return kc[e](r,t);throw new Error("No decoder for tag "+e)}function Zr(r,t){let e=0;if((r[t.offset]&Ho)===Ho){const n=r[t.offset]&op;let s="0x";t.offset++;for(let i=0;i<n;i++,t.offset++)s+=r[t.offset].toString(16).padStart(2,"0");e=parseInt(s,16)}else e=r[t.offset],t.offset++;return e}function lr(r,t){Zr(r,t);const e=[];for(;!(t.offset>=r.byteLength);){const n=Fi(r,t);if(n===null)break;e.push(n)}return e}function ap(r,t){const e=Zr(r,t),n=t.offset,s=t.offset+e,i=[];for(let o=n;o<s;o++)o===n&&r[o]===0||i.push(r[o]);return t.offset+=e,Uint8Array.from(i)}function cp(r,t){const e=Zr(r,t),n=t.offset+e,s=r[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<n;){const u=r[t.offset];if(t.offset++,c.push(u&127),u<128){c.reverse();let d=0;for(let h=0;h<c.length;h++)d+=c[h]<<h*7;a+=`.${d}`,c=[]}}return a}function lp(r,t){return t.offset++,null}function up(r,t){const e=Zr(r,t),n=r[t.offset];t.offset++;const s=r.subarray(t.offset,t.offset+e-1);if(t.offset+=e,n!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function dp(r,t){const e=Zr(r,t),n=r.subarray(t.offset,t.offset+e);return t.offset+=e,n}function hp(r){let t=r.toString(16);t.length%2===1&&(t="0"+t);const e=new J;for(let n=0;n<t.length;n+=2)e.append(Uint8Array.from([parseInt(`${t[n]}${t[n+1]}`,16)]));return e}function Oa(r){if(r.byteLength<128)return Uint8Array.from([r.byteLength]);const t=hp(r.byteLength);return new J(Uint8Array.from([t.byteLength|Ho]),t)}function Go(r){const t=new J,e=128;return(r.subarray()[0]&e)===e&&t.append(Uint8Array.from([0])),t.append(r),new J(Uint8Array.from([2]),Oa(t),t)}function wd(r){const t=Uint8Array.from([0]),e=new J(t,r);return new J(Uint8Array.from([3]),Oa(e),e)}function Sr(r,t=48){const e=new J;for(const n of r)e.append(n);return new J(Uint8Array.from([t]),Oa(e),e)}async function fp(r,t,e,n){var o,a;const s=await crypto.subtle.importKey("jwk",r,{name:"ECDSA",namedCurve:r.crv??"P-256"},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}const gp=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),mp=Uint8Array.from([6,5,43,129,4,0,34]),pp=Uint8Array.from([6,5,43,129,4,0,35]),yp={ext:!0,kty:"EC",crv:"P-256"},wp={ext:!0,kty:"EC",crv:"P-384"},bp={ext:!0,kty:"EC",crv:"P-521"},eo=32,to=48,no=66;function bd(r){const t=Fi(r);return Ep(t)}function Ep(r){const t=r[1][1][0],e=1;let n,s;if(t.byteLength===eo*2+1)return n=Z(t.subarray(e,e+eo),"base64url"),s=Z(t.subarray(e+eo),"base64url"),new ro({...yp,key_ops:["verify"],x:n,y:s});if(t.byteLength===to*2+1)return n=Z(t.subarray(e,e+to),"base64url"),s=Z(t.subarray(e+to),"base64url"),new ro({...wp,key_ops:["verify"],x:n,y:s});if(t.byteLength===no*2+1)return n=Z(t.subarray(e,e+no),"base64url"),s=Z(t.subarray(e+no),"base64url"),new ro({...bp,key_ops:["verify"],x:n,y:s});throw new W(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function vp(r){return Sr([Go(Uint8Array.from([1])),Sr([Sp(r.crv)],160),Sr([wd(new J(Uint8Array.from([4]),Y(r.x??"","base64url"),Y(r.y??"","base64url")))],161)]).subarray()}function Sp(r){if(r==="P-256")return gp;if(r==="P-384")return mp;if(r==="P-521")return pp;throw new W(`Invalid curve ${r}`)}class ro{constructor(t){l(this,"type","ECDSA");l(this,"jwk");l(this,"_raw");this.jwk=t}get raw(){return this._raw==null&&(this._raw=vp(this.jwk)),this._raw}toMultihash(){return Qr.digest(xt(this))}toCID(){return ge.createV1(114,this.toMultihash())}toString(){return Ie.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qe(this.raw,t.raw)}async verify(t,e,n){return fp(this.jwk,e,t,n)}}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Bi(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Kt(r,t=""){if(!Number.isSafeInteger(r)||r<0){const e=t&&`"${t}" `;throw new Error(`${e}expected integer >= 0, got ${r}`)}}function G(r,t,e=""){const n=Bi(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function $i(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Kt(r.outputLen),Kt(r.blockLen)}function Zs(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function xp(r,t){G(r,void 0,"digestInto() output");const e=t.outputLen;if(r.length<e)throw new Error('"digestInto() output" expected to be of length >='+e)}function on(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function so(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}function ut(r,t){return r<<32-t|r>>>t}const Ed=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Ap=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function Jr(r){if(G(r),Ed)return r.toHex();let t="";for(let e=0;e<r.length;e++)t+=Ap[r[e]];return t}const mt={_0:48,_9:57,A:65,F:70,a:97,f:102};function Mc(r){if(r>=mt._0&&r<=mt._9)return r-mt._0;if(r>=mt.A&&r<=mt.F)return r-(mt.A-10);if(r>=mt.a&&r<=mt.f)return r-(mt.a-10)}function Pr(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(Ed)return Uint8Array.fromHex(r);const t=r.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let s=0,i=0;s<e;s++,i+=2){const o=Mc(r.charCodeAt(i)),a=Mc(r.charCodeAt(i+1));if(o===void 0||a===void 0){const c=r[i]+r[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}n[s]=o*16+a}return n}function ft(...r){let t=0;for(let n=0;n<r.length;n++){const s=r[n];G(s),t+=s.length}const e=new Uint8Array(t);for(let n=0,s=0;n<r.length;n++){const i=r[n];e.set(i,s),s+=i.length}return e}function vd(r,t={}){const e=(s,i)=>r(i).update(s).digest(),n=r(void 0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>r(s),Object.assign(e,t),Object.freeze(e)}function jr(r=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof(t==null?void 0:t.getRandomValues)!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(r))}const Sd=r=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,r])});function Cp(r,t,e){return r&t^~r&e}function _p(r,t,e){return r&t^r&e^t&e}class xd{constructor(t,e,n,s){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=s,this.buffer=new Uint8Array(t),this.view=so(this.buffer)}update(t){Zs(this),G(t);const{view:e,buffer:n,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=so(t);for(;s<=i-o;o+=s)this.process(c,o);continue}n.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Zs(this),xp(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:s,isLE:i}=this;let{pos:o}=this;e[o++]=128,on(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(n,0),o=0);for(let h=o;h<s;h++)e[h]=0;n.setBigUint64(s-8,BigInt(this.length*8),i),this.process(n,0);const a=so(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,d[h],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const Tt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Re=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),cs=BigInt(2**32-1),Nc=BigInt(32);function Ip(r,t=!1){return t?{h:Number(r&cs),l:Number(r>>Nc&cs)}:{h:Number(r>>Nc&cs)|0,l:Number(r&cs)|0}}function Tp(r,t=!1){const e=r.length;let n=new Uint32Array(e),s=new Uint32Array(e);for(let i=0;i<e;i++){const{h:o,l:a}=Ip(r[i],t);[n[i],s[i]]=[o,a]}return[n,s]}const Oc=(r,t,e)=>r>>>e,Fc=(r,t,e)=>r<<32-e|t>>>e,mn=(r,t,e)=>r>>>e|t<<32-e,pn=(r,t,e)=>r<<32-e|t>>>e,ls=(r,t,e)=>r<<64-e|t>>>e-32,us=(r,t,e)=>r>>>e-32|t<<64-e;function pt(r,t,e,n){const s=(t>>>0)+(n>>>0);return{h:r+e+(s/2**32|0)|0,l:s|0}}const Lp=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),Dp=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,Pp=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),Rp=(r,t,e,n,s)=>t+e+n+s+(r/2**32|0)|0,kp=(r,t,e,n,s)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(s>>>0),Mp=(r,t,e,n,s,i)=>t+e+n+s+i+(r/2**32|0)|0,Np=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Lt=new Uint32Array(64);class Op extends xd{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:e,C:n,D:s,E:i,F:o,G:a,H:c}=this;return[t,e,n,s,i,o,a,c]}set(t,e,n,s,i,o,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)Lt[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const f=Lt[h-15],p=Lt[h-2],g=ut(f,7)^ut(f,18)^f>>>3,y=ut(p,17)^ut(p,19)^p>>>10;Lt[h]=y+Lt[h-7]+g+Lt[h-16]|0}let{A:n,B:s,C:i,D:o,E:a,F:c,G:u,H:d}=this;for(let h=0;h<64;h++){const f=ut(a,6)^ut(a,11)^ut(a,25),p=d+f+Cp(a,c,u)+Np[h]+Lt[h]|0,y=(ut(n,2)^ut(n,13)^ut(n,22))+_p(n,s,i)|0;d=u,u=c,c=a,a=o+p|0,o=i,i=s,s=n,n=p+y|0}n=n+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(n,s,i,o,a,c,u,d)}roundClean(){on(Lt)}destroy(){this.set(0,0,0,0,0,0,0,0),on(this.buffer)}}class Fp extends Op{constructor(){super(32);l(this,"A",Tt[0]|0);l(this,"B",Tt[1]|0);l(this,"C",Tt[2]|0);l(this,"D",Tt[3]|0);l(this,"E",Tt[4]|0);l(this,"F",Tt[5]|0);l(this,"G",Tt[6]|0);l(this,"H",Tt[7]|0)}}const Ad=Tp(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),Bp=Ad[0],$p=Ad[1],Dt=new Uint32Array(80),Pt=new Uint32Array(80);class Up extends xd{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:e,Bh:n,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:d,Fh:h,Fl:f,Gh:p,Gl:g,Hh:y,Hl:m}=this;return[t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m]}set(t,e,n,s,i,o,a,c,u,d,h,f,p,g,y,m){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=d|0,this.Fh=h|0,this.Fl=f|0,this.Gh=p|0,this.Gl=g|0,this.Hh=y|0,this.Hl=m|0}process(t,e){for(let E=0;E<16;E++,e+=4)Dt[E]=t.getUint32(e),Pt[E]=t.getUint32(e+=4);for(let E=16;E<80;E++){const L=Dt[E-15]|0,x=Pt[E-15]|0,_=mn(L,x,1)^mn(L,x,8)^Oc(L,x,7),N=pn(L,x,1)^pn(L,x,8)^Fc(L,x,7),T=Dt[E-2]|0,I=Pt[E-2]|0,B=mn(T,I,19)^ls(T,I,61)^Oc(T,I,6),U=pn(T,I,19)^us(T,I,61)^Fc(T,I,6),k=Pp(N,U,Pt[E-7],Pt[E-16]),M=Rp(k,_,B,Dt[E-7],Dt[E-16]);Dt[E]=M|0,Pt[E]=k|0}let{Ah:n,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:d,Eh:h,El:f,Fh:p,Fl:g,Gh:y,Gl:m,Hh:S,Hl:v}=this;for(let E=0;E<80;E++){const L=mn(h,f,14)^mn(h,f,18)^ls(h,f,41),x=pn(h,f,14)^pn(h,f,18)^us(h,f,41),_=h&p^~h&y,N=f&g^~f&m,T=kp(v,x,N,$p[E],Pt[E]),I=Mp(T,S,L,_,Bp[E],Dt[E]),B=T|0,U=mn(n,s,28)^ls(n,s,34)^ls(n,s,39),k=pn(n,s,28)^us(n,s,34)^us(n,s,39),M=n&i^n&a^i&a,w=s&o^s&c^o&c;S=y|0,v=m|0,y=p|0,m=g|0,p=h|0,g=f|0,{h,l:f}=pt(u|0,d|0,I|0,B|0),u=a|0,d=c|0,a=i|0,c=o|0,i=n|0,o=s|0;const b=Lp(B,k,w);n=Dp(b,I,U,M),s=b|0}({h:n,l:s}=pt(this.Ah|0,this.Al|0,n|0,s|0)),{h:i,l:o}=pt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=pt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:d}=pt(this.Dh|0,this.Dl|0,u|0,d|0),{h,l:f}=pt(this.Eh|0,this.El|0,h|0,f|0),{h:p,l:g}=pt(this.Fh|0,this.Fl|0,p|0,g|0),{h:y,l:m}=pt(this.Gh|0,this.Gl|0,y|0,m|0),{h:S,l:v}=pt(this.Hh|0,this.Hl|0,S|0,v|0),this.set(n,s,i,o,a,c,u,d,h,f,p,g,y,m,S,v)}roundClean(){on(Dt,Pt)}destroy(){on(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class zp extends Up{constructor(){super(64);l(this,"Ah",Re[0]|0);l(this,"Al",Re[1]|0);l(this,"Bh",Re[2]|0);l(this,"Bl",Re[3]|0);l(this,"Ch",Re[4]|0);l(this,"Cl",Re[5]|0);l(this,"Dh",Re[6]|0);l(this,"Dl",Re[7]|0);l(this,"Eh",Re[8]|0);l(this,"El",Re[9]|0);l(this,"Fh",Re[10]|0);l(this,"Fl",Re[11]|0);l(this,"Gh",Re[12]|0);l(this,"Gl",Re[13]|0);l(this,"Hh",Re[14]|0);l(this,"Hl",Re[15]|0)}}const xr=vd(()=>new Fp,Sd(1)),qp=vd(()=>new zp,Sd(3));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fa=BigInt(0),Yo=BigInt(1);function an(r,t=""){if(typeof r!="boolean"){const e=t&&`"${t}" `;throw new Error(e+"expected boolean, got type="+typeof r)}return r}function Cd(r){if(typeof r=="bigint"){if(!Ps(r))throw new Error("positive bigint expected, got "+r)}else Kt(r);return r}function ds(r){const t=Cd(r).toString(16);return t.length&1?"0"+t:t}function _d(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Fa:BigInt("0x"+r)}function Ui(r){return _d(Jr(r))}function cn(r){return _d(Jr(Rr(G(r)).reverse()))}function Ba(r,t){Kt(t),r=Cd(r);const e=Pr(r.toString(16).padStart(t*2,"0"));if(e.length!==t)throw new Error("number too large");return e}function $a(r,t){return Ba(r,t).reverse()}function Rr(r){return Uint8Array.from(r)}const Ps=r=>typeof r=="bigint"&&Fa<=r;function Kp(r,t,e){return Ps(r)&&Ps(t)&&Ps(e)&&t<=r&&r<e}function kr(r,t,e,n){if(!Kp(t,e,n))throw new Error("expected valid "+r+": "+e+" <= n < "+n+", got "+t)}function Vp(r){let t;for(t=0;r>Fa;r>>=Yo,t+=1);return t}const Ua=r=>(Yo<<BigInt(r))-Yo;function Wp(r,t,e){if(Kt(r,"hashLen"),Kt(t,"qByteLen"),typeof e!="function")throw new Error("hmacFn must be a function");const n=m=>new Uint8Array(m),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=n(r),u=n(r),d=0;const h=()=>{c.fill(1),u.fill(0),d=0},f=(...m)=>e(u,ft(c,...m)),p=(m=s)=>{u=f(i,m),c=f(),m.length!==0&&(u=f(o,m),c=f())},g=()=>{if(d++>=a)throw new Error("drbg: tried max amount of iterations");let m=0;const S=[];for(;m<t;){c=f();const v=c.slice();S.push(v),m+=c.length}return ft(...S)};return(m,S)=>{h(),p(m);let v;for(;!(v=S(g()));)p();return h(),v}}function tr(r,t={},e={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function n(i,o,a){const c=r[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>n(a,c,o));s(t,!1),s(e,!0)}function Js(r){const t=new WeakMap;return(e,...n)=>{const s=t.get(e);if(s!==void 0)return s;const i=r(e,...n);return t.set(e,i),i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const He=BigInt(0),De=BigInt(1),Qt=BigInt(2),Id=BigInt(3),Td=BigInt(4),Ld=BigInt(5),Hp=BigInt(7),Dd=BigInt(8),Gp=BigInt(9),Pd=BigInt(16);function be(r,t){const e=r%t;return e>=He?e:t+e}function we(r,t,e){let n=r;for(;t-- >He;)n*=n,n%=e;return n}function Bc(r,t){if(r===He)throw new Error("invert: expected non-zero number");if(t<=He)throw new Error("invert: expected positive modulus, got "+t);let e=be(r,t),n=t,s=He,i=De;for(;e!==He;){const a=n/e,c=n%e,u=s-i*a;n=e,e=c,s=i,i=u}if(n!==De)throw new Error("invert: does not exist");return be(s,t)}function za(r,t,e){if(!r.eql(r.sqr(t),e))throw new Error("Cannot find square root")}function Rd(r,t){const e=(r.ORDER+De)/Td,n=r.pow(t,e);return za(r,n,t),n}function Yp(r,t){const e=(r.ORDER-Ld)/Dd,n=r.mul(t,Qt),s=r.pow(n,e),i=r.mul(t,s),o=r.mul(r.mul(i,Qt),s),a=r.mul(i,r.sub(o,r.ONE));return za(r,a,t),a}function Xp(r){const t=zi(r),e=kd(r),n=e(t,t.neg(t.ONE)),s=e(t,n),i=e(t,t.neg(n)),o=(r+Hp)/Pd;return(a,c)=>{let u=a.pow(c,o),d=a.mul(u,n);const h=a.mul(u,s),f=a.mul(u,i),p=a.eql(a.sqr(d),c),g=a.eql(a.sqr(h),c);u=a.cmov(u,d,p),d=a.cmov(f,h,g);const y=a.eql(a.sqr(d),c),m=a.cmov(u,d,y);return za(a,m,c),m}}function kd(r){if(r<Id)throw new Error("sqrt is not defined for small field");let t=r-De,e=0;for(;t%Qt===He;)t/=Qt,e++;let n=Qt;const s=zi(r);for(;$c(s,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Rd;let i=s.pow(n,t);const o=(t+De)/Qt;return function(c,u){if(c.is0(u))return u;if($c(c,u)!==1)throw new Error("Cannot find square root");let d=e,h=c.mul(c.ONE,i),f=c.pow(u,t),p=c.pow(u,o);for(;!c.eql(f,c.ONE);){if(c.is0(f))return c.ZERO;let g=1,y=c.sqr(f);for(;!c.eql(y,c.ONE);)if(g++,y=c.sqr(y),g===d)throw new Error("Cannot find square root");const m=De<<BigInt(d-g-1),S=c.pow(h,m);d=g,h=c.sqr(S),f=c.mul(f,h),p=c.mul(p,S)}return p}}function Qp(r){return r%Td===Id?Rd:r%Dd===Ld?Yp:r%Pd===Gp?Xp(r):kd(r)}const Zp=(r,t)=>(be(r,t)&De)===De,Jp=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jp(r){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},e=Jp.reduce((n,s)=>(n[s]="function",n),t);return tr(r,e),r}function ey(r,t,e){if(e<He)throw new Error("invalid exponent, negatives unsupported");if(e===He)return r.ONE;if(e===De)return t;let n=r.ONE,s=t;for(;e>He;)e&De&&(n=r.mul(n,s)),s=r.sqr(s),e>>=De;return n}function Md(r,t,e=!1){const n=new Array(t.length).fill(e?r.ZERO:void 0),s=t.reduce((o,a,c)=>r.is0(a)?o:(n[c]=o,r.mul(o,a)),r.ONE),i=r.inv(s);return t.reduceRight((o,a,c)=>r.is0(a)?o:(n[c]=r.mul(o,n[c]),r.mul(o,a)),i),n}function $c(r,t){const e=(r.ORDER-De)/Qt,n=r.pow(t,e),s=r.eql(n,r.ONE),i=r.eql(n,r.ZERO),o=r.eql(n,r.neg(r.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function ty(r,t){t!==void 0&&Kt(t);const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}class ny{constructor(t,e={}){l(this,"ORDER");l(this,"BITS");l(this,"BYTES");l(this,"isLE");l(this,"ZERO",He);l(this,"ONE",De);l(this,"_lengths");l(this,"_sqrt");l(this,"_mod");var o;if(t<=He)throw new Error("invalid field: expected ORDER > 0, got "+t);let n;this.isLE=!1,e!=null&&typeof e=="object"&&(typeof e.BITS=="number"&&(n=e.BITS),typeof e.sqrt=="function"&&(this.sqrt=e.sqrt),typeof e.isLE=="boolean"&&(this.isLE=e.isLE),e.allowedLengths&&(this._lengths=(o=e.allowedLengths)==null?void 0:o.slice()),typeof e.modFromBytes=="boolean"&&(this._mod=e.modFromBytes));const{nBitLength:s,nByteLength:i}=ty(t,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return be(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return He<=t&&t<this.ORDER}is0(t){return t===He}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&De)===De}neg(t){return be(-t,this.ORDER)}eql(t,e){return t===e}sqr(t){return be(t*t,this.ORDER)}add(t,e){return be(t+e,this.ORDER)}sub(t,e){return be(t-e,this.ORDER)}mul(t,e){return be(t*e,this.ORDER)}pow(t,e){return ey(this,t,e)}div(t,e){return be(t*Bc(e,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,e){return t+e}subN(t,e){return t-e}mulN(t,e){return t*e}inv(t){return Bc(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Qp(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?$a(t,this.BYTES):Ba(t,this.BYTES)}fromBytes(t,e=!1){G(t);const{_lengths:n,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(n){if(!n.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+n+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?cn(t):Ui(t);if(a&&(c=be(c,o)),!e&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return Md(this,t)}cmov(t,e,n){return n?e:t}}function zi(r,t={}){return new ny(r,t)}function Nd(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function Od(r){const t=Nd(r);return t+Math.ceil(t/2)}function ry(r,t,e=!1){G(r);const n=r.length,s=Nd(t),i=Od(t);if(n<16||n<i||n>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+n);const o=e?cn(r):Ui(r),a=be(o,t-De)+De;return e?$a(a,s):Ba(a,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bn=BigInt(0),Zt=BigInt(1);function js(r,t){const e=t.negate();return r?e:t}function Ar(r,t){const e=Md(r.Fp,t.map(n=>n.Z));return t.map((n,s)=>r.fromAffine(n.toAffine(e[s])))}function Fd(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function io(r,t){Fd(r,t);const e=Math.ceil(t/r)+1,n=2**(r-1),s=2**r,i=Ua(r),o=BigInt(r);return{windows:e,windowSize:n,mask:i,maxNumber:s,shiftBy:o}}function Uc(r,t,e){const{windowSize:n,mask:s,maxNumber:i,shiftBy:o}=e;let a=Number(r&s),c=r>>o;a>n&&(a-=i,c+=Zt);const u=t*n,d=u+Math.abs(a)-1,h=a===0,f=a<0,p=t%2!==0;return{nextN:c,offset:d,isZero:h,isNeg:f,isNegF:p,offsetF:u}}const oo=new WeakMap,Bd=new WeakMap;function ao(r){return Bd.get(r)||1}function zc(r){if(r!==Bn)throw new Error("invalid wNAF")}class $d{constructor(t,e){l(this,"BASE");l(this,"ZERO");l(this,"Fn");l(this,"bits");this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let s=t;for(;e>Bn;)e&Zt&&(n=n.add(s)),s=s.double(),e>>=Zt;return n}precomputeWindow(t,e){const{windows:n,windowSize:s}=io(e,this.bits),i=[];let o=t,a=o;for(let c=0;c<n;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=io(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:d,isNeg:h,isNegF:f,offsetF:p}=Uc(n,a,o);n=c,d?i=i.add(js(f,e[p])):s=s.add(js(h,e[u]))}return zc(n),{p:s,f:i}}wNAFUnsafe(t,e,n,s=this.ZERO){const i=io(t,this.bits);for(let o=0;o<i.windows&&n!==Bn;o++){const{nextN:a,offset:c,isZero:u,isNeg:d}=Uc(n,o,i);if(n=a,!u){const h=e[c];s=s.add(d?h.negate():h)}}return zc(n),s}getPrecomputes(t,e,n){let s=oo.get(e);return s||(s=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(s=n(s)),oo.set(e,s))),s}cached(t,e,n){const s=ao(t);return this.wNAF(s,this.getPrecomputes(s,t,n),e)}unsafe(t,e,n,s){const i=ao(t);return i===1?this._unsafeLadder(t,e,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,s)}createCache(t,e){Fd(e,this.bits),Bd.set(t,e),oo.delete(t)}hasCache(t){return ao(t)!==1}}function sy(r,t,e,n){let s=t,i=r.ZERO,o=r.ZERO;for(;e>Bn||n>Bn;)e&Zt&&(i=i.add(s)),n&Zt&&(o=o.add(s)),s=s.double(),e>>=Zt,n>>=Zt;return{p1:i,p2:o}}function qc(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return jp(t),t}else return zi(r,{isLE:e})}function Ud(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>Bn))throw new Error(`CURVE.${c} must be positive bigint`)}const s=qc(t.p,e.Fp,n),i=qc(t.n,e.Fn,n),a=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function qa(r,t){return function(n){const s=r(n);return{secretKey:s,publicKey:t(s)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rt=BigInt(0),Ae=BigInt(1),co=BigInt(2),iy=BigInt(8);function oy(r,t,e,n){const s=r.sqr(e),i=r.sqr(n),o=r.add(r.mul(t.a,s),i),a=r.add(r.ONE,r.mul(t.d,r.mul(s,i)));return r.eql(o,a)}function ay(r,t={}){const e=Ud("edwards",r,t,t.FpFnLE),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o}=i;tr(t,{},{uvRatio:"function"});const a=co<<BigInt(s.BYTES*8)-Ae,c=S=>n.create(S),u=t.uvRatio||((S,v)=>{try{return{isValid:!0,value:n.sqrt(n.div(S,v))}}catch{return{isValid:!1,value:Rt}}});if(!oy(n,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function d(S,v,E=!1){const L=E?Ae:Rt;return kr("coordinate "+S,v,L,a),v}function h(S){if(!(S instanceof g))throw new Error("EdwardsPoint expected")}const f=Js((S,v)=>{const{X:E,Y:L,Z:x}=S,_=S.is0();v==null&&(v=_?iy:n.inv(x));const N=c(E*v),T=c(L*v),I=n.mul(x,v);if(_)return{x:Rt,y:Ae};if(I!==Ae)throw new Error("invZ was invalid");return{x:N,y:T}}),p=Js(S=>{const{a:v,d:E}=i;if(S.is0())throw new Error("bad point: ZERO");const{X:L,Y:x,Z:_,T:N}=S,T=c(L*L),I=c(x*x),B=c(_*_),U=c(B*B),k=c(T*v),M=c(B*c(k+I)),w=c(U+c(E*c(T*I)));if(M!==w)throw new Error("bad point: equation left != right (1)");const b=c(L*x),C=c(_*N);if(b!==C)throw new Error("bad point: equation left != right (2)");return!0}),m=class m{constructor(v,E,L,x){l(this,"X");l(this,"Y");l(this,"Z");l(this,"T");this.X=d("x",v),this.Y=d("y",E),this.Z=d("z",L,!0),this.T=d("t",x),Object.freeze(this)}static CURVE(){return i}static fromAffine(v){if(v instanceof m)throw new Error("extended point not allowed");const{x:E,y:L}=v||{};return d("x",E),d("y",L),new m(E,L,Ae,c(E*L))}static fromBytes(v,E=!1){const L=n.BYTES,{a:x,d:_}=i;v=Rr(G(v,L,"point")),an(E,"zip215");const N=Rr(v),T=v[L-1];N[L-1]=T&-129;const I=cn(N),B=E?a:n.ORDER;kr("point.y",I,Rt,B);const U=c(I*I),k=c(U-Ae),M=c(_*U-x);let{isValid:w,value:b}=u(k,M);if(!w)throw new Error("bad point: invalid y coordinate");const C=(b&Ae)===Ae,D=(T&128)!==0;if(!E&&b===Rt&&D)throw new Error("bad point: x=0 and x_0=1");return D!==C&&(b=c(-b)),m.fromAffine({x:b,y:I})}static fromHex(v,E=!1){return m.fromBytes(Pr(v),E)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(v=8,E=!0){return y.createCache(this,v),E||this.multiply(co),this}assertValidity(){p(this)}equals(v){h(v);const{X:E,Y:L,Z:x}=this,{X:_,Y:N,Z:T}=v,I=c(E*T),B=c(_*x),U=c(L*T),k=c(N*x);return I===B&&U===k}is0(){return this.equals(m.ZERO)}negate(){return new m(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:v}=i,{X:E,Y:L,Z:x}=this,_=c(E*E),N=c(L*L),T=c(co*c(x*x)),I=c(v*_),B=E+L,U=c(c(B*B)-_-N),k=I+N,M=k-T,w=I-N,b=c(U*M),C=c(k*w),D=c(U*w),R=c(M*k);return new m(b,C,R,D)}add(v){h(v);const{a:E,d:L}=i,{X:x,Y:_,Z:N,T}=this,{X:I,Y:B,Z:U,T:k}=v,M=c(x*I),w=c(_*B),b=c(T*L*k),C=c(N*U),D=c((x+_)*(I+B)-M-w),R=C-b,A=C+b,O=c(w-E*M),P=c(D*R),F=c(A*O),z=c(D*O),ne=c(R*A);return new m(P,F,ne,z)}subtract(v){return this.add(v.negate())}multiply(v){if(!s.isValidNot0(v))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:E,f:L}=y.cached(this,v,x=>Ar(m,x));return Ar(m,[E,L])[0]}multiplyUnsafe(v,E=m.ZERO){if(!s.isValid(v))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return v===Rt?m.ZERO:this.is0()||v===Ae?this:y.unsafe(this,v,L=>Ar(m,L),E)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return y.unsafe(this,i.n).is0()}toAffine(v){return f(this,v)}clearCofactor(){return o===Ae?this:this.multiplyUnsafe(o)}toBytes(){const{x:v,y:E}=this.toAffine(),L=n.toBytes(E);return L[L.length-1]|=v&Ae?128:0,L}toHex(){return Jr(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(m,"BASE",new m(i.Gx,i.Gy,Ae,c(i.Gx*i.Gy))),l(m,"ZERO",new m(Rt,Ae,Ae,Rt)),l(m,"Fp",n),l(m,"Fn",s);let g=m;const y=new $d(g,s.BITS);return g.BASE.precompute(8),g}function cy(r,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');tr(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=e,{BASE:s,Fp:i,Fn:o}=r,a=e.randomBytes||jr,c=e.adjustScalarBytes||(T=>T),u=e.domain||((T,I,B)=>{if(an(B,"phflag"),I.length||B)throw new Error("Contexts/pre-hash are not supported");return T});function d(T){return o.create(cn(T))}function h(T){const I=E.secretKey;G(T,E.secretKey,"secretKey");const B=G(t(T),2*I,"hashedSecretKey"),U=c(B.slice(0,I)),k=B.slice(I,2*I),M=d(U);return{head:U,prefix:k,scalar:M}}function f(T){const{head:I,prefix:B,scalar:U}=h(T),k=s.multiply(U),M=k.toBytes();return{head:I,prefix:B,scalar:U,point:k,pointBytes:M}}function p(T){return f(T).pointBytes}function g(T=Uint8Array.of(),...I){const B=ft(...I);return d(t(u(B,G(T,void 0,"context"),!!n)))}function y(T,I,B={}){T=G(T,void 0,"message"),n&&(T=n(T));const{prefix:U,scalar:k,pointBytes:M}=f(I),w=g(B.context,U,T),b=s.multiply(w).toBytes(),C=g(B.context,b,M,T),D=o.create(w+C*k);if(!o.isValid(D))throw new Error("sign failed: invalid s");const R=ft(b,o.toBytes(D));return G(R,E.signature,"result")}const m={zip215:!0};function S(T,I,B,U=m){const{context:k,zip215:M}=U,w=E.signature;T=G(T,w,"signature"),I=G(I,void 0,"message"),B=G(B,E.publicKey,"publicKey"),M!==void 0&&an(M,"zip215"),n&&(I=n(I));const b=w/2,C=T.subarray(0,b),D=cn(T.subarray(b,w));let R,A,O;try{R=r.fromBytes(B,M),A=r.fromBytes(C,M),O=s.multiplyUnsafe(D)}catch{return!1}if(!M&&R.isSmallOrder())return!1;const P=g(k,A.toBytes(),R.toBytes(),I);return A.add(R.multiplyUnsafe(P)).subtract(O).clearCofactor().is0()}const v=i.BYTES,E={secretKey:v,publicKey:v,signature:2*v,seed:v};function L(T=a(E.seed)){return G(T,E.seed,"seed")}function x(T){return Bi(T)&&T.length===o.BYTES}function _(T,I){try{return!!r.fromBytes(T,I)}catch{return!1}}const N={getExtendedPublicKey:f,randomSecretKey:L,isValidSecretKey:x,isValidPublicKey:_,toMontgomery(T){const{y:I}=r.fromBytes(T),B=E.publicKey,U=B===32;if(!U&&B!==57)throw new Error("only defined for 25519 and 448");const k=U?i.div(Ae+I,Ae-I):i.div(I-Ae,I+Ae);return i.toBytes(k)},toMontgomerySecret(T){const I=E.secretKey;G(T,I);const B=t(T.subarray(0,I));return c(B).subarray(0,I)}};return Object.freeze({keygen:qa(L,p),getPublicKey:p,sign:y,verify:S,utils:N,Point:r,lengths:E})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ur=BigInt(0),yn=BigInt(1),hs=BigInt(2);function ly(r){return tr(r,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r})}function uy(r){const t=ly(r),{P:e,type:n,adjustScalarBytes:s,powPminus2:i,randomBytes:o}=t,a=n==="x25519";if(!a&&n!=="x448")throw new Error("invalid type");const c=o||jr,u=a?255:448,d=a?32:56,h=BigInt(a?9:5),f=BigInt(a?121665:39081),p=a?hs**BigInt(254):hs**BigInt(447),g=a?BigInt(8)*hs**BigInt(251)-yn:BigInt(4)*hs**BigInt(445)-yn,y=p+g+yn,m=w=>be(w,e),S=v(h);function v(w){return $a(m(w),d)}function E(w){const b=Rr(G(w,d,"uCoordinate"));return a&&(b[31]&=127),m(cn(b))}function L(w){return cn(s(Rr(G(w,d,"scalar"))))}function x(w,b){const C=B(E(b),L(w));if(C===ur)throw new Error("invalid private or public key received");return v(C)}function _(w){return x(w,S)}const N=_,T=x;function I(w,b,C){const D=m(w*(b-C));return b=m(b-D),C=m(C+D),{x_2:b,x_3:C}}function B(w,b){kr("u",w,ur,e),kr("scalar",b,p,y);const C=b,D=w;let R=yn,A=ur,O=w,P=yn,F=ur;for(let ne=BigInt(u-1);ne>=ur;ne--){const Q=C>>ne&yn;F^=Q,{x_2:R,x_3:O}=I(F,R,O),{x_2:A,x_3:P}=I(F,A,P),F=Q;const K=R+A,ae=m(K*K),de=R-A,ye=m(de*de),pe=ae-ye,Ce=O+P,os=O-P,or=m(os*K),bc=m(Ce*de),Ec=or+bc,vc=or-bc;O=m(Ec*Ec),P=m(D*m(vc*vc)),R=m(ae*ye),A=m(pe*(ae+m(f*pe)))}({x_2:R,x_3:O}=I(F,R,O)),{x_2:A,x_3:P}=I(F,A,P);const z=i(A);return m(R*z)}const U={secretKey:d,publicKey:d,seed:d},k=(w=c(d))=>(G(w,U.seed,"seed"),w),M={randomSecretKey:k};return Object.freeze({keygen:qa(k,N),getSharedSecret:T,getPublicKey:N,scalarMult:x,scalarMultBase:_,utils:M,GuBytes:S.slice(),lengths:U})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dy=BigInt(1),Kc=BigInt(2),hy=BigInt(3),fy=BigInt(5),gy=BigInt(8),qi=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),my={p:qi,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:gy,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function zd(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),s=BigInt(80),i=qi,a=r*r%i*r%i,c=we(a,Kc,i)*a%i,u=we(c,dy,i)*r%i,d=we(u,fy,i)*u%i,h=we(d,t,i)*d%i,f=we(h,e,i)*h%i,p=we(f,n,i)*f%i,g=we(p,s,i)*p%i,y=we(g,s,i)*p%i,m=we(y,t,i)*d%i;return{pow_p_5_8:we(m,Kc,i)*r%i,b2:a}}function qd(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}const Vc=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function py(r,t){const e=qi,n=be(t*t*t,e),s=be(n*n*t,e),i=zd(r*s).pow_p_5_8;let o=be(r*n*i,e);const a=be(t*o*o,e),c=o,u=be(o*Vc,e),d=a===r,h=a===be(-r,e),f=a===be(-r*Vc,e);return d&&(o=c),(h||f)&&(o=u),Zp(o,e)&&(o=be(-o,e)),{isValid:d||h,value:o}}const yy=ay(my,{uvRatio:py});function wy(r){return cy(yy,qp,Object.assign({adjustScalarBytes:qd},r))}const ei=wy({}),fs=(()=>{const r=qi;return uy({P:r,type:"x25519",powPminus2:t=>{const{pow_p_5_8:e,b2:n}=zd(t);return be(we(e,hy,r)*n,r)},adjustScalarBytes:qd})})();class Wc extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class by extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const ln={get(r=globalThis){const t=r.crypto;if((t==null?void 0:t.subtle)==null)throw new by("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},Kd=32,Ka=64,Xo=32;let xn;const Vd=(async()=>{try{return await ln.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Ey(){const r=ei.utils.randomSecretKey(),t=ei.getPublicKey(r);return{privateKey:Iy(r,t),publicKey:t}}async function vy(r,t){let e;r.length===Ka?e=r.subarray(0,32):e=r;const n={crv:"Ed25519",kty:"OKP",x:Z(r.subarray(32),"base64url"),d:Z(e,"base64url"),ext:!0,key_ops:["sign"]},s=await ln.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),i=await ln.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Sy(r,t){const e=r.subarray(0,Xo);return ei.sign(t instanceof Uint8Array?t:t.subarray(),e)}async function xy(r,t){return xn==null&&(xn=await Vd),xn?vy(r,t):Sy(r,t)}async function Ay(r,t,e){if(r.buffer instanceof ArrayBuffer){const n=await ln.get().subtle.importKey("raw",r.buffer,{name:"Ed25519"},!1,["verify"]);return await ln.get().subtle.verify({name:"Ed25519"},n,t,e instanceof Uint8Array?e:e.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Cy(r,t,e){return ei.verify(t,e instanceof Uint8Array?e:e.subarray(),r)}async function _y(r,t,e){return xn==null&&(xn=await Vd),xn?Ay(r,t,e):Cy(r,t,e)}function Iy(r,t){const e=new Uint8Array(Ka);for(let n=0;n<Xo;n++)e[n]=r[n],e[Xo+n]=t[n];return e}function Va(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Wd{constructor(t){l(this,"type","Ed25519");l(this,"raw");this.raw=Wa(t,Kd)}toMultihash(){return Qr.digest(xt(this))}toCID(){return ge.createV1(114,this.toMultihash())}toString(){return Ie.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qe(this.raw,t.raw)}verify(t,e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=_y(this.raw,e,t);return Va(s)?s.then(o=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),o}):s}}class Ty{constructor(t,e){l(this,"type","Ed25519");l(this,"raw");l(this,"publicKey");this.raw=Wa(t,Ka),this.publicKey=new Wd(e)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qe(this.raw,t.raw)}sign(t,e){var s,i;(s=e==null?void 0:e.signal)==null||s.throwIfAborted();const n=xy(this.raw,t);return Va(n)?n.then(o=>{var a;return(a=e==null?void 0:e.signal)==null||a.throwIfAborted(),o}):((i=e==null?void 0:e.signal)==null||i.throwIfAborted(),n)}}function Hd(r){return r=Wa(r,Kd),new Wd(r)}async function Ly(){const{privateKey:r,publicKey:t}=Ey();return new Ty(r,t)}function Wa(r,t){if(r=Uint8Array.from(r??[]),r.length!==t)throw new W(`Key must be a Uint8Array of length ${t}, got ${r.length}`);return r}const Dy=Math.pow(2,7),Py=Math.pow(2,14),Ry=Math.pow(2,21),Ha=Math.pow(2,28),Ga=Math.pow(2,35),Ya=Math.pow(2,42),Xa=Math.pow(2,49),se=128,Me=127;function Te(r){if(r<Dy)return 1;if(r<Py)return 2;if(r<Ry)return 3;if(r<Ha)return 4;if(r<Ga)return 5;if(r<Ya)return 6;if(r<Xa)return 7;if(Number.MAX_SAFE_INTEGER!=null&&r>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function ti(r,t,e=0){switch(Te(r)){case 8:t[e++]=r&255|se,r/=128;case 7:t[e++]=r&255|se,r/=128;case 6:t[e++]=r&255|se,r/=128;case 5:t[e++]=r&255|se,r/=128;case 4:t[e++]=r&255|se,r>>>=7;case 3:t[e++]=r&255|se,r>>>=7;case 2:t[e++]=r&255|se,r>>>=7;case 1:{t[e++]=r&255,r>>>=7;break}default:throw new Error("unreachable")}return t}function ky(r,t,e=0){switch(Te(r)){case 8:t.set(e++,r&255|se),r/=128;case 7:t.set(e++,r&255|se),r/=128;case 6:t.set(e++,r&255|se),r/=128;case 5:t.set(e++,r&255|se),r/=128;case 4:t.set(e++,r&255|se),r>>>=7;case 3:t.set(e++,r&255|se),r>>>=7;case 2:t.set(e++,r&255|se),r>>>=7;case 1:{t.set(e++,r&255),r>>>=7;break}default:throw new Error("unreachable")}return t}function Gd(r,t){let e=r[t],n=0;if(n+=e&Me,e<se||(e=r[t+1],n+=(e&Me)<<7,e<se)||(e=r[t+2],n+=(e&Me)<<14,e<se)||(e=r[t+3],n+=(e&Me)<<21,e<se)||(e=r[t+4],n+=(e&Me)*Ha,e<se)||(e=r[t+5],n+=(e&Me)*Ga,e<se)||(e=r[t+6],n+=(e&Me)*Ya,e<se)||(e=r[t+7],n+=(e&Me)*Xa,e<se))return n;throw new RangeError("Could not decode varint")}function My(r,t){let e=r.get(t),n=0;if(n+=e&Me,e<se||(e=r.get(t+1),n+=(e&Me)<<7,e<se)||(e=r.get(t+2),n+=(e&Me)<<14,e<se)||(e=r.get(t+3),n+=(e&Me)<<21,e<se)||(e=r.get(t+4),n+=(e&Me)*Ha,e<se)||(e=r.get(t+5),n+=(e&Me)*Ga,e<se)||(e=r.get(t+6),n+=(e&Me)*Ya,e<se)||(e=r.get(t+7),n+=(e&Me)*Xa,e<se))return n;throw new RangeError("Could not decode varint")}function Cr(r,t,e=0){return t==null&&(t=gt(Te(r))),t instanceof Uint8Array?ti(r,t,e):ky(r,t,e)}function es(r,t=0){return r instanceof Uint8Array?Gd(r,t):My(r,t)}const Qa=new Float32Array([-0]),Ft=new Uint8Array(Qa.buffer);function Ny(r,t,e){Qa[0]=r,t[e]=Ft[0],t[e+1]=Ft[1],t[e+2]=Ft[2],t[e+3]=Ft[3]}function Oy(r,t){return Ft[0]=r[t],Ft[1]=r[t+1],Ft[2]=r[t+2],Ft[3]=r[t+3],Qa[0]}const Za=new Float64Array([-0]),Ne=new Uint8Array(Za.buffer);function Fy(r,t,e){Za[0]=r,t[e]=Ne[0],t[e+1]=Ne[1],t[e+2]=Ne[2],t[e+3]=Ne[3],t[e+4]=Ne[4],t[e+5]=Ne[5],t[e+6]=Ne[6],t[e+7]=Ne[7]}function By(r,t){return Ne[0]=r[t],Ne[1]=r[t+1],Ne[2]=r[t+2],Ne[3]=r[t+3],Ne[4]=r[t+4],Ne[5]=r[t+5],Ne[6]=r[t+6],Ne[7]=r[t+7],Za[0]}const $y=BigInt(Number.MAX_SAFE_INTEGER),Uy=BigInt(Number.MIN_SAFE_INTEGER);class Oe{constructor(t,e){l(this,"lo");l(this,"hi");this.lo=t|0,this.hi=e|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(e+n*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const e=~this.lo+1>>>0;let n=~this.hi>>>0;return e===0&&(n=n+1>>>0),-(BigInt(e)+(BigInt(n)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?e===0?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}static fromBigInt(t){if(t===0n)return sn;if(t<$y&&t>Uy)return this.fromNumber(Number(t));const e=t<0n;e&&(t=-t);let n=t>>32n,s=t-(n<<32n);return e&&(n=~n|0n,s=~s|0n,++s>Hc&&(s=0n,++n>Hc&&(n=0n))),new Oe(Number(s),Number(n))}static fromNumber(t){if(t===0)return sn;const e=t<0;e&&(t=-t);let n=t>>>0,s=(t-n)/4294967296>>>0;return e&&(s=~s>>>0,n=~n>>>0,++n>4294967295&&(n=0,++s>4294967295&&(s=0))),new Oe(n,s)}static from(t){return typeof t=="number"?Oe.fromNumber(t):typeof t=="bigint"?Oe.fromBigInt(t):typeof t=="string"?Oe.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new Oe(t.low>>>0,t.high>>>0):sn}}const sn=new Oe(0,0);sn.toBigInt=function(){return 0n};sn.zzEncode=sn.zzDecode=function(){return this};sn.length=function(){return 1};const Hc=4294967296n;function zy(r){let t=0,e=0;for(let n=0;n<r.length;++n)e=r.charCodeAt(n),e<128?t+=1:e<2048?t+=2:(e&64512)===55296&&(r.charCodeAt(n+1)&64512)===56320?(++n,t+=4):t+=3;return t}function qy(r,t,e){if(e-t<1)return"";let s;const i=[];let o=0,a;for(;t<e;)a=r[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|r[t++]&63:a>239&&a<365?(a=((a&7)<<18|(r[t++]&63)<<12|(r[t++]&63)<<6|r[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(r[t++]&63)<<6|r[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function Yd(r,t,e){const n=e;let s,i;for(let o=0;o<r.length;++o)s=r.charCodeAt(o),s<128?t[e++]=s:s<2048?(t[e++]=s>>6|192,t[e++]=s&63|128):(s&64512)===55296&&((i=r.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[e++]=s>>18|240,t[e++]=s>>12&63|128,t[e++]=s>>6&63|128,t[e++]=s&63|128):(t[e++]=s>>12|224,t[e++]=s>>6&63|128,t[e++]=s&63|128);return e-n}function rt(r,t){return RangeError(`index out of range: ${r.pos} + ${t??1} > ${r.len}`)}function gs(r,t){return(r[t-4]|r[t-3]<<8|r[t-2]<<16|r[t-1]<<24)>>>0}class Ky{constructor(t){l(this,"buf");l(this,"pos");l(this,"len");l(this,"_slice",Uint8Array.prototype.subarray);this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,rt(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw rt(this,4);return gs(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw rt(this,4);return gs(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw rt(this,4);const t=Oy(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw rt(this,4);const t=By(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw rt(this,t);return this.pos+=t,e===n?new Uint8Array(0):this.buf.subarray(e,n)}string(){const t=this.bytes();return qy(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw rt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw rt(this);while(this.buf[this.pos++]&128);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new Oe(0,0);let e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw rt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw rt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw rt(this,8);const t=gs(this.buf,this.pos+=4),e=gs(this.buf,this.pos+=4);return new Oe(t,e)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=Gd(this.buf,this.pos);return this.pos+=Te(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Vy(r){return new Ky(r instanceof Uint8Array?r:r.subarray())}function Ee(r,t,e){const n=Vy(r);return t.decode(n,void 0,e)}function Wy(r){let n,s=8192;return function(o){if(o<1||o>4096)return gt(o);s+o>8192&&(n=gt(8192),s=0);const a=n.subarray(s,s+=o);return s&7&&(s=(s|7)+1),a}}class gr{constructor(t,e,n){l(this,"fn");l(this,"len");l(this,"next");l(this,"val");this.fn=t,this.len=e,this.next=void 0,this.val=n}}function lo(){}class Hy{constructor(t){l(this,"head");l(this,"tail");l(this,"len");l(this,"next");this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const Gy=Wy();function Yy(r){return globalThis.Buffer!=null?gt(r):Gy(r)}class Qo{constructor(){l(this,"len");l(this,"head");l(this,"tail");l(this,"states");this.len=0,this.head=new gr(lo,0,0),this.tail=this.head,this.states=null}_push(t,e,n){return this.tail=this.tail.next=new gr(t,e,n),this.len+=e,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Qy((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(ms,10,Oe.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const e=Oe.fromBigInt(t);return this._push(ms,e.length(),e)}uint64Number(t){return this._push(ti,Te(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const e=Oe.fromBigInt(t).zzEncode();return this._push(ms,e.length(),e)}sint64Number(t){const e=Oe.fromNumber(t).zzEncode();return this._push(ms,e.length(),e)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(uo,1,t?1:0)}fixed32(t){return this._push(dr,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const e=Oe.fromBigInt(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64Number(t){const e=Oe.fromNumber(t);return this._push(dr,4,e.lo)._push(dr,4,e.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Ny,4,t)}double(t){return this._push(Fy,8,t)}bytes(t){const e=t.length>>>0;return e===0?this._push(uo,1,0):this.uint32(e)._push(Zy,e,t)}string(t){const e=zy(t);return e!==0?this.uint32(e)._push(Yd,e,t):this._push(uo,1,0)}fork(){return this.states=new Hy(this),this.head=this.tail=new gr(lo,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new gr(lo,0,0),this.len=0),this}ldelim(){const t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n!==0&&(this.tail.next=t.next,this.tail=e,this.len+=n),this}finish(){let t=this.head.next;const e=Yy(this.len);let n=0;for(;t!=null;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e}}function uo(r,t,e){t[e]=r&255}function Xy(r,t,e){for(;r>127;)t[e++]=r&127|128,r>>>=7;t[e]=r}class Qy extends gr{constructor(e,n){super(Xy,e,n);l(this,"next");this.next=void 0}}function ms(r,t,e){for(;r.hi!==0;)t[e++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)t[e++]=r.lo&127|128,r.lo=r.lo>>>7;t[e++]=r.lo}function dr(r,t,e){t[e]=r&255,t[e+1]=r>>>8&255,t[e+2]=r>>>16&255,t[e+3]=r>>>24}function Zy(r,t,e){t.set(r,e)}globalThis.Buffer!=null&&(Qo.prototype.bytes=function(r){const t=r.length>>>0;return this.uint32(t),t>0&&this._push(Jy,t,r),this},Qo.prototype.string=function(r){const t=globalThis.Buffer.byteLength(r);return this.uint32(t),t>0&&this._push(jy,t,r),this});function Jy(r,t,e){t.set(r,e)}function jy(r,t,e){r.length<40?Yd(r,t,e):t.utf8Write!=null?t.utf8Write(r,e):t.set(Y(r),e)}function ew(){return new Qo}function ve(r,t){const e=ew();return t.encode(r,e,{lengthDelimited:!1}),e.finish()}var ni;(function(r){r[r.VARINT=0]="VARINT",r[r.BIT64=1]="BIT64",r[r.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",r[r.START_GROUP=3]="START_GROUP",r[r.END_GROUP=4]="END_GROUP",r[r.BIT32=5]="BIT32"})(ni||(ni={}));function Xd(r,t,e,n){return{name:r,type:t,encode:e,decode:n}}function nr(r){function t(s){if(r[s.toString()]==null)throw new Error("Invalid enum value");return r[s]}const e=function(i,o){const a=t(i);o.int32(a)},n=function(i){const o=i.int32();return t(o)};return Xd("enum",ni.VARINT,e,n)}function Se(r,t){return Xd("message",ni.LENGTH_DELIMITED,r,t)}class _t extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_LENGTH");l(this,"name","MaxLengthError")}}class Gc extends Error{constructor(){super(...arguments);l(this,"code","ERR_MAX_SIZE");l(this,"name","MaxSizeError")}}var Le;(function(r){r.RSA="RSA",r.Ed25519="Ed25519",r.secp256k1="secp256k1",r.ECDSA="ECDSA"})(Le||(Le={}));var Zo;(function(r){r[r.RSA=0]="RSA",r[r.Ed25519=1]="Ed25519",r[r.secp256k1=2]="secp256k1",r[r.ECDSA=3]="ECDSA"})(Zo||(Zo={}));(function(r){r.codec=()=>nr(Zo)})(Le||(Le={}));var $n;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),Le.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=Le.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})($n||($n={}));var Yc;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.Type!=null&&(n.uint32(8),Le.codec().encode(e.Type,n)),e.Data!=null&&(n.uint32(18),n.bytes(e.Data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.Type=Le.codec().decode(e);break}case 2:{i.Data=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Yc||(Yc={}));function Qd(r){if(isNaN(r)||r<=0)throw new W("random bytes length must be a Number bigger than 0");return jr(r)}class tw{constructor(t,e){l(this,"type","RSA");l(this,"jwk");l(this,"_raw");l(this,"_multihash");this.jwk=t,this._multihash=e}get raw(){return this._raw==null&&(this._raw=ow(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return ge.createV1(114,this._multihash)}toString(){return Ie.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qe(this.raw,t.raw)}verify(t,e,n){return lw(this.jwk,e,t,n)}}const nw=18,rw=1062,sw=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function iw(r){const t=Fi(r[1],{offset:0});return{kty:"RSA",n:Z(t[0],"base64url"),e:Z(t[1],"base64url")}}function ow(r){if(r.n==null||r.e==null)throw new W("JWK was missing components");return Sr([sw,wd(Sr([Go(Y(r.n,"base64url")),Go(Y(r.e,"base64url"))]))]).subarray()}function aw(r,t){if(r.byteLength>=rw)throw new Ta("Key size is too large");const e=Fi(r,{offset:0});return cw(e,r,t)}function cw(r,t,e){const n=iw(r);if(e==null){const s=xr($n.encode({Type:Le.RSA,Data:t}));e=Oi(nw,s)}return new tw(n,e)}async function lw(r,t,e,n){var o,a;const s=await ln.get().subtle.importKey("jwk",r,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);(o=n==null?void 0:n.signal)==null||o.throwIfAborted();const i=await ln.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,e instanceof Uint8Array?e:e.subarray());return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),i}class Zd{constructor(t,e){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if($i(t),G(e,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(e.length>n?t.create().update(e).digest():e);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),on(s)}update(t){return Zs(this),this.iHash.update(t),this}digestInto(t){Zs(this),G(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ki=(r,t,e)=>new Zd(r,t).update(e).digest();Ki.create=(r,t)=>new Zd(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xc=(r,t)=>(r+(r>=0?t:-t)/Jd)/t;function uw(r,t,e){const[[n,s],[i,o]]=t,a=Xc(o*r,e),c=Xc(-s*r,e);let u=r-a*n-c*i,d=-a*s-c*o;const h=u<St,f=d<St;h&&(u=-u),f&&(d=-d);const p=Ua(Math.ceil(Vp(e)/2))+An;if(u<St||u>=p||d<St||d>=p)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:h,k1:u,k2neg:f,k2:d}}function Jo(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function ho(r,t){const e={};for(let n of Object.keys(t))e[n]=r[n]===void 0?t[n]:r[n];return an(e.lowS,"lowS"),an(e.prehash,"prehash"),e.format!==void 0&&Jo(e.format),e}class dw extends Error{constructor(t=""){super(t)}}const kt={Err:dw,_tlv:{encode:(r,t)=>{const{Err:e}=kt;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const n=t.length/2,s=ds(n);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=n>127?ds(s.length/2|128):"";return ds(r)+i+s+t},decode(r,t){const{Err:e}=kt;let n=0;if(r<0||r>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[n++]!==r)throw new e("tlv.decode: wrong tlv");const s=t[n++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new e("tlv.decode(long): indefinite length not supported");if(c>4)throw new e("tlv.decode(long): byte length is too big");const u=t.subarray(n,n+c);if(u.length!==c)throw new e("tlv.decode: length bytes not complete");if(u[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const d of u)o=o<<8|d;if(n+=c,o<128)throw new e("tlv.decode(long): not minimal encoding")}const a=t.subarray(n,n+o);if(a.length!==o)throw new e("tlv.decode: wrong value length");return{v:a,l:t.subarray(n+o)}}},_int:{encode(r){const{Err:t}=kt;if(r<St)throw new t("integer: negative integers are not allowed");let e=ds(r);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(r){const{Err:t}=kt;if(r[0]&128)throw new t("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Ui(r)}},toSig(r){const{Err:t,_int:e,_tlv:n}=kt,s=G(r,void 0,"signature"),{v:i,l:o}=n.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:d}=n.decode(2,c);if(d.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(a),s:e.decode(u)}},hexFromSig(r){const{_tlv:t,_int:e}=kt,n=t.encode(2,e.encode(r.r)),s=t.encode(2,e.encode(r.s)),i=n+s;return t.encode(48,i)}},St=BigInt(0),An=BigInt(1),Jd=BigInt(2),ps=BigInt(3),hw=BigInt(4);function fw(r,t={}){const e=Ud("weierstrass",r,t),{Fp:n,Fn:s}=e;let i=e.CURVE;const{h:o,n:a}=i;tr(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!n.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=eh(n,s);function d(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function h(M,w,b){const{x:C,y:D}=w.toAffine(),R=n.toBytes(C);if(an(b,"isCompressed"),b){d();const A=!n.isOdd(D);return ft(jd(A),R)}else return ft(Uint8Array.of(4),R,n.toBytes(D))}function f(M){G(M,void 0,"Point");const{publicKey:w,publicKeyUncompressed:b}=u,C=M.length,D=M[0],R=M.subarray(1);if(C===w&&(D===2||D===3)){const A=n.fromBytes(R);if(!n.isValid(A))throw new Error("bad point: is not on curve, wrong x");const O=y(A);let P;try{P=n.sqrt(O)}catch(ne){const Q=ne instanceof Error?": "+ne.message:"";throw new Error("bad point: is not on curve, sqrt error"+Q)}d();const F=n.isOdd(P);return(D&1)===1!==F&&(P=n.neg(P)),{x:A,y:P}}else if(C===b&&D===4){const A=n.BYTES,O=n.fromBytes(R.subarray(0,A)),P=n.fromBytes(R.subarray(A,A*2));if(!m(O,P))throw new Error("bad point: is not on curve");return{x:O,y:P}}else throw new Error(`bad point: got length ${C}, expected compressed=${w} or uncompressed=${b}`)}const p=t.toBytes||h,g=t.fromBytes||f;function y(M){const w=n.sqr(M),b=n.mul(w,M);return n.add(n.add(b,n.mul(M,i.a)),i.b)}function m(M,w){const b=n.sqr(w),C=y(M);return n.eql(b,C)}if(!m(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(i.a,ps),hw),v=n.mul(n.sqr(i.b),BigInt(27));if(n.is0(n.add(S,v)))throw new Error("bad curve params: a or b");function E(M,w,b=!1){if(!n.isValid(w)||b&&n.is0(w))throw new Error(`bad point coordinate ${M}`);return w}function L(M){if(!(M instanceof I))throw new Error("Weierstrass Point expected")}function x(M){if(!c||!c.basises)throw new Error("no endo");return uw(M,c.basises,s.ORDER)}const _=Js((M,w)=>{const{X:b,Y:C,Z:D}=M;if(n.eql(D,n.ONE))return{x:b,y:C};const R=M.is0();w==null&&(w=R?n.ONE:n.inv(D));const A=n.mul(b,w),O=n.mul(C,w),P=n.mul(D,w);if(R)return{x:n.ZERO,y:n.ZERO};if(!n.eql(P,n.ONE))throw new Error("invZ was invalid");return{x:A,y:O}}),N=Js(M=>{if(M.is0()){if(t.allowInfinityPoint&&!n.is0(M.Y))return;throw new Error("bad point: ZERO")}const{x:w,y:b}=M.toAffine();if(!n.isValid(w)||!n.isValid(b))throw new Error("bad point: x or y not field elements");if(!m(w,b))throw new Error("bad point: equation left != right");if(!M.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function T(M,w,b,C,D){return b=new I(n.mul(b.X,M),b.Y,b.Z),w=js(C,w),b=js(D,b),w.add(b)}const k=class k{constructor(w,b,C){l(this,"X");l(this,"Y");l(this,"Z");this.X=E("x",w),this.Y=E("y",b,!0),this.Z=E("z",C),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){const{x:b,y:C}=w||{};if(!w||!n.isValid(b)||!n.isValid(C))throw new Error("invalid affine point");if(w instanceof k)throw new Error("projective point not allowed");return n.is0(b)&&n.is0(C)?k.ZERO:new k(b,C,n.ONE)}static fromBytes(w){const b=k.fromAffine(g(G(w,void 0,"point")));return b.assertValidity(),b}static fromHex(w){return k.fromBytes(Pr(w))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,b=!0){return U.createCache(this,w),b||this.multiply(ps),this}assertValidity(){N(this)}hasEvenY(){const{y:w}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(w)}equals(w){L(w);const{X:b,Y:C,Z:D}=this,{X:R,Y:A,Z:O}=w,P=n.eql(n.mul(b,O),n.mul(R,D)),F=n.eql(n.mul(C,O),n.mul(A,D));return P&&F}negate(){return new k(this.X,n.neg(this.Y),this.Z)}double(){const{a:w,b}=i,C=n.mul(b,ps),{X:D,Y:R,Z:A}=this;let O=n.ZERO,P=n.ZERO,F=n.ZERO,z=n.mul(D,D),ne=n.mul(R,R),Q=n.mul(A,A),K=n.mul(D,R);return K=n.add(K,K),F=n.mul(D,A),F=n.add(F,F),O=n.mul(w,F),P=n.mul(C,Q),P=n.add(O,P),O=n.sub(ne,P),P=n.add(ne,P),P=n.mul(O,P),O=n.mul(K,O),F=n.mul(C,F),Q=n.mul(w,Q),K=n.sub(z,Q),K=n.mul(w,K),K=n.add(K,F),F=n.add(z,z),z=n.add(F,z),z=n.add(z,Q),z=n.mul(z,K),P=n.add(P,z),Q=n.mul(R,A),Q=n.add(Q,Q),z=n.mul(Q,K),O=n.sub(O,z),F=n.mul(Q,ne),F=n.add(F,F),F=n.add(F,F),new k(O,P,F)}add(w){L(w);const{X:b,Y:C,Z:D}=this,{X:R,Y:A,Z:O}=w;let P=n.ZERO,F=n.ZERO,z=n.ZERO;const ne=i.a,Q=n.mul(i.b,ps);let K=n.mul(b,R),ae=n.mul(C,A),de=n.mul(D,O),ye=n.add(b,C),pe=n.add(R,A);ye=n.mul(ye,pe),pe=n.add(K,ae),ye=n.sub(ye,pe),pe=n.add(b,D);let Ce=n.add(R,O);return pe=n.mul(pe,Ce),Ce=n.add(K,de),pe=n.sub(pe,Ce),Ce=n.add(C,D),P=n.add(A,O),Ce=n.mul(Ce,P),P=n.add(ae,de),Ce=n.sub(Ce,P),z=n.mul(ne,pe),P=n.mul(Q,de),z=n.add(P,z),P=n.sub(ae,z),z=n.add(ae,z),F=n.mul(P,z),ae=n.add(K,K),ae=n.add(ae,K),de=n.mul(ne,de),pe=n.mul(Q,pe),ae=n.add(ae,de),de=n.sub(K,de),de=n.mul(ne,de),pe=n.add(pe,de),K=n.mul(ae,pe),F=n.add(F,K),K=n.mul(Ce,pe),P=n.mul(ye,P),P=n.sub(P,K),K=n.mul(ye,ae),z=n.mul(Ce,z),z=n.add(z,K),new k(P,F,z)}subtract(w){return this.add(w.negate())}is0(){return this.equals(k.ZERO)}multiply(w){const{endo:b}=t;if(!s.isValidNot0(w))throw new Error("invalid scalar: out of range");let C,D;const R=A=>U.cached(this,A,O=>Ar(k,O));if(b){const{k1neg:A,k1:O,k2neg:P,k2:F}=x(w),{p:z,f:ne}=R(O),{p:Q,f:K}=R(F);D=ne.add(K),C=T(b.beta,z,Q,A,P)}else{const{p:A,f:O}=R(w);C=A,D=O}return Ar(k,[C,D])[0]}multiplyUnsafe(w){const{endo:b}=t,C=this;if(!s.isValid(w))throw new Error("invalid scalar: out of range");if(w===St||C.is0())return k.ZERO;if(w===An)return C;if(U.hasCache(this))return this.multiply(w);if(b){const{k1neg:D,k1:R,k2neg:A,k2:O}=x(w),{p1:P,p2:F}=sy(k,C,R,O);return T(b.beta,P,F,D,A)}else return U.unsafe(C,w)}toAffine(w){return _(this,w)}isTorsionFree(){const{isTorsionFree:w}=t;return o===An?!0:w?w(k,this):U.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:w}=t;return o===An?this:w?w(k,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(w=!0){return an(w,"isCompressed"),this.assertValidity(),p(k,this,w)}toHex(w=!0){return Jr(this.toBytes(w))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}};l(k,"BASE",new k(i.Gx,i.Gy,n.ONE)),l(k,"ZERO",new k(n.ZERO,n.ONE,n.ZERO)),l(k,"Fp",n),l(k,"Fn",s);let I=k;const B=s.BITS,U=new $d(I,t.endo?Math.ceil(B/2):B);return I.BASE.precompute(8),I}function jd(r){return Uint8Array.of(r?2:3)}function eh(r,t){return{secretKey:t.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function gw(r,t={}){const{Fn:e}=r,n=t.randomBytes||jr,s=Object.assign(eh(r.Fp,e),{seed:Od(e.ORDER)});function i(p){try{const g=e.fromBytes(p);return e.isValidNot0(g)}catch{return!1}}function o(p,g){const{publicKey:y,publicKeyUncompressed:m}=s;try{const S=p.length;return g===!0&&S!==y||g===!1&&S!==m?!1:!!r.fromBytes(p)}catch{return!1}}function a(p=n(s.seed)){return ry(G(p,s.seed,"seed"),e.ORDER)}function c(p,g=!0){return r.BASE.multiply(e.fromBytes(p)).toBytes(g)}function u(p){const{secretKey:g,publicKey:y,publicKeyUncompressed:m}=s;if(!Bi(p)||"_lengths"in e&&e._lengths||g===y)return;const S=G(p,void 0,"key").length;return S===y||S===m}function d(p,g,y=!0){if(u(p)===!0)throw new Error("first arg must be private key");if(u(g)===!1)throw new Error("second arg must be public key");const m=e.fromBytes(p);return r.fromBytes(g).multiply(m).toBytes(y)}const h={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},f=qa(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:d,keygen:f,Point:r,utils:h,lengths:s})}function mw(r,t,e={}){$i(t),tr(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),e=Object.assign({},e);const n=e.randomBytes||jr,s=e.hmac||((w,b)=>Ki(t,w,b)),{Fp:i,Fn:o}=r,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p}=gw(r,e),g={prehash:!0,lowS:typeof e.lowS=="boolean"?e.lowS:!0,format:"compact",extraEntropy:!1},y=a*Jd<i.ORDER;function m(w){const b=a>>An;return w>b}function S(w,b){if(!o.isValidNot0(b))throw new Error(`invalid signature ${w}: out of range 1..Point.Fn.ORDER`);return b}function v(){if(y)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(w,b){Jo(b);const C=p.signature,D=b==="compact"?C:b==="recovered"?C+1:void 0;return G(w,D)}class L{constructor(b,C,D){l(this,"r");l(this,"s");l(this,"recovery");if(this.r=S("r",b),this.s=S("s",C),D!=null){if(v(),![0,1,2,3].includes(D))throw new Error("invalid recovery id");this.recovery=D}Object.freeze(this)}static fromBytes(b,C=g.format){E(b,C);let D;if(C==="der"){const{r:P,s:F}=kt.toSig(G(b));return new L(P,F)}C==="recovered"&&(D=b[0],C="compact",b=b.subarray(1));const R=p.signature/2,A=b.subarray(0,R),O=b.subarray(R,R*2);return new L(o.fromBytes(A),o.fromBytes(O),D)}static fromHex(b,C){return this.fromBytes(Pr(b),C)}assertRecovery(){const{recovery:b}=this;if(b==null)throw new Error("invalid recovery id: must be present");return b}addRecoveryBit(b){return new L(this.r,this.s,b)}recoverPublicKey(b){const{r:C,s:D}=this,R=this.assertRecovery(),A=R===2||R===3?C+a:C;if(!i.isValid(A))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const O=i.toBytes(A),P=r.fromBytes(ft(jd((R&1)===0),O)),F=o.inv(A),z=_(G(b,void 0,"msgHash")),ne=o.create(-z*F),Q=o.create(D*F),K=r.BASE.multiplyUnsafe(ne).add(P.multiplyUnsafe(Q));if(K.is0())throw new Error("invalid recovery: point at infinify");return K.assertValidity(),K}hasHighS(){return m(this.s)}toBytes(b=g.format){if(Jo(b),b==="der")return Pr(kt.hexFromSig(this));const{r:C,s:D}=this,R=o.toBytes(C),A=o.toBytes(D);return b==="recovered"?(v(),ft(Uint8Array.of(this.assertRecovery()),R,A)):ft(R,A)}toHex(b){return Jr(this.toBytes(b))}}const x=e.bits2int||function(b){if(b.length>8192)throw new Error("input is too large");const C=Ui(b),D=b.length*8-c;return D>0?C>>BigInt(D):C},_=e.bits2int_modN||function(b){return o.create(x(b))},N=Ua(c);function T(w){return kr("num < 2^"+c,w,St,N),o.toBytes(w)}function I(w,b){return G(w,void 0,"message"),b?G(t(w),void 0,"prehashed message"):w}function B(w,b,C){const{lowS:D,prehash:R,extraEntropy:A}=ho(C,g);w=I(w,R);const O=_(w),P=o.fromBytes(b);if(!o.isValidNot0(P))throw new Error("invalid private key");const F=[T(P),T(O)];if(A!=null&&A!==!1){const K=A===!0?n(p.secretKey):A;F.push(G(K,void 0,"extraEntropy"))}const z=ft(...F),ne=O;function Q(K){const ae=x(K);if(!o.isValidNot0(ae))return;const de=o.inv(ae),ye=r.BASE.multiply(ae).toAffine(),pe=o.create(ye.x);if(pe===St)return;const Ce=o.create(de*o.create(ne+pe*P));if(Ce===St)return;let os=(ye.x===pe?0:2)|Number(ye.y&An),or=Ce;return D&&m(Ce)&&(or=o.neg(Ce),os^=1),new L(pe,or,y?void 0:os)}return{seed:z,k2sig:Q}}function U(w,b,C={}){const{seed:D,k2sig:R}=B(w,b,C);return Wp(t.outputLen,o.BYTES,s)(D,R).toBytes(C.format)}function k(w,b,C,D={}){const{lowS:R,prehash:A,format:O}=ho(D,g);if(C=G(C,void 0,"publicKey"),b=I(b,A),!Bi(w)){const P=w instanceof L?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+P)}E(w,O);try{const P=L.fromBytes(w,O),F=r.fromBytes(C);if(R&&P.hasHighS())return!1;const{r:z,s:ne}=P,Q=_(b),K=o.inv(ne),ae=o.create(Q*K),de=o.create(z*K),ye=r.BASE.multiplyUnsafe(ae).add(F.multiplyUnsafe(de));return ye.is0()?!1:o.create(ye.x)===z}catch{return!1}}function M(w,b,C={}){const{prehash:D}=ho(C,g);return b=I(b,D),L.fromBytes(w,"recovered").recoverPublicKey(b).toBytes()}return Object.freeze({keygen:u,getPublicKey:d,getSharedSecret:h,utils:f,lengths:p,Point:r,sign:U,verify:k,recoverPublicKey:M,Signature:L,hash:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ja={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},pw={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Qc=BigInt(2);function yw(r){const t=Ja.p,e=BigInt(3),n=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,d=u*u*r%t,h=we(d,e,t)*d%t,f=we(h,e,t)*d%t,p=we(f,Qc,t)*u%t,g=we(p,s,t)*p%t,y=we(g,i,t)*g%t,m=we(y,a,t)*y%t,S=we(m,c,t)*m%t,v=we(S,a,t)*y%t,E=we(v,e,t)*d%t,L=we(E,o,t)*g%t,x=we(L,n,t)*u%t,_=we(x,Qc,t);if(!jo.eql(jo.sqr(_),r))throw new Error("Cannot find square root");return _}const jo=zi(Ja.p,{sqrt:yw}),ww=fw(Ja,{Fp:jo,endo:pw}),ri=mw(ww,xr);function bw(r,t,e,n){var i;const s=md.digest(e instanceof Uint8Array?e:e.subarray());if(Va(s))return s.then(({digest:o})=>{var a;return(a=n==null?void 0:n.signal)==null||a.throwIfAborted(),ri.verify(t,o,r,{prehash:!1,format:"der"})}).catch(o=>{throw o.name==="AbortError"?o:new Wc(String(o))});try{return(i=n==null?void 0:n.signal)==null||i.throwIfAborted(),ri.verify(t,s.digest,r,{prehash:!1,format:"der"})}catch(o){throw new Wc(String(o))}}class Ew{constructor(t){l(this,"type","secp256k1");l(this,"raw");l(this,"_key");this._key=Sw(t),this.raw=vw(this._key)}toMultihash(){return Qr.digest(xt(this))}toCID(){return ge.createV1(114,this.toMultihash())}toString(){return Ie.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:qe(this.raw,t.raw)}verify(t,e,n){return bw(this._key,e,t,n)}}function th(r){return new Ew(r)}function vw(r){return ri.Point.fromBytes(r).toBytes()}function Sw(r){try{return ri.Point.fromBytes(r),r}catch(t){throw new Ta(String(t))}}async function xw(r,t){return Ly()}function Vt(r,t){const{Type:e,Data:n}=$n.decode(r),s=n??new Uint8Array;switch(e){case Le.RSA:return aw(s,t);case Le.Ed25519:return Hd(s);case Le.secp256k1:return th(s);case Le.ECDSA:return bd(s);default:throw new Ri}}function Aw(r){const{Type:t,Data:e}=$n.decode(r.digest),n=e??new Uint8Array;switch(t){case Le.Ed25519:return Hd(n);case Le.secp256k1:return th(n);case Le.ECDSA:return bd(n);default:throw new Ri}}function xt(r){return $n.encode({Type:Le[r.type],Data:r.raw})}const nh=Symbol.for("nodejs.util.inspect.custom"),Cw=114;var fu;class ja{constructor(t){l(this,"type");l(this,"multihash");l(this,"publicKey");l(this,"string");l(this,fu,!0);this.type=t.type,this.multihash=t.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return this.string==null&&(this.string=Ie.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return ge.createV1(Cw,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(t==null)return!1;if(t instanceof Uint8Array)return qe(this.multihash.bytes,t);if(typeof t=="string")return this.toString()===t;if(((e=t==null?void 0:t.toMultihash())==null?void 0:e.bytes)!=null)return qe(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(fu=Ra,nh)](){return`PeerId(${this.toString()})`}}class rh extends ja{constructor(e){super({...e,type:"RSA"});l(this,"type","RSA");l(this,"publicKey");this.publicKey=e.publicKey}}class sh extends ja{constructor(e){super({...e,type:"Ed25519"});l(this,"type","Ed25519");l(this,"publicKey");this.publicKey=e.publicKey}}class ih extends ja{constructor(e){super({...e,type:"secp256k1"});l(this,"type","secp256k1");l(this,"publicKey");this.publicKey=e.publicKey}}const _w=2336;var gu,mu;class oh{constructor(t){l(this,"type","url");l(this,"multihash");l(this,"publicKey");l(this,"url");l(this,gu,!0);this.url=t.toString(),this.multihash=Qr.digest(Y(this.url))}[(mu=nh,gu=Ra,mu)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return ge.createV1(_w,this.toMultihash())}toJSON(){return this.toString()}equals(t){return t==null?!1:(t instanceof Uint8Array&&(t=Z(t)),t.toString()===this.toString())}}const Iw=114,Zc=2336;function ct(r,t){let e;if(r.charAt(0)==="1"||r.charAt(0)==="Q")e=Xr(Ie.decode(`z${r}`));else{if(r.startsWith("k51qzi5uqu5")||r.startsWith("kzwfwjn5ji4")||r.startsWith("k2k4r8")||r.startsWith("bafz"))return ns(ge.parse(r));throw new W('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return ts(e)}function Mr(r){if(r.type==="Ed25519")return new sh({multihash:r.toCID().multihash,publicKey:r});if(r.type==="secp256k1")return new ih({multihash:r.toCID().multihash,publicKey:r});if(r.type==="RSA")return new rh({multihash:r.toCID().multihash,publicKey:r});throw new Ri}function Tw(r){return Mr(r.publicKey)}function ts(r){if(Dw(r))return new rh({multihash:r});if(Lw(r))try{const t=Aw(r);if(t.type==="Ed25519")return new sh({multihash:r,publicKey:t});if(t.type==="secp256k1")return new ih({multihash:r,publicKey:t})}catch{const e=Z(r.digest);return new oh(new URL(e))}throw new td("Supplied PeerID Multihash is invalid")}function ns(r){if((r==null?void 0:r.multihash)==null||r.version==null||r.version===1&&r.code!==Iw&&r.code!==Zc)throw new ed("Supplied PeerID CID is invalid");if(r.code===Zc){const t=Z(r.multihash.digest);return new oh(new URL(t))}return ts(r.multihash)}function Lw(r){return r.code===Qr.code}function Dw(r){return r.code===md.code}async function Pw(r){var t,e;if(r.connectionProtector===null&&((e=(t=globalThis.process)==null?void 0:t.env)==null?void 0:e.LIBP2P_FORCE_PNET)!=null)throw new W("Private network is enforced, but no protector was provided");return r}const Un=1e3,zn=Un*60,qn=zn*60,un=qn*24,Nr=un*7,Kn=un*365.25,Or=Kn/12;function Rw(r,t){if(typeof r=="string")return kw(r);if(typeof r=="number")return Ow(r,t);throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(r)}`)}var ah=Rw;function kw(r){if(typeof r!="string"||r.length===0||r.length>100)throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(r)}`);let t=/^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(r);if(!(t!=null&&t.groups))return NaN;let{value:e,unit:n="ms"}=t.groups,s=parseFloat(e),i=n.toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return s*Kn;case"months":case"month":case"mo":return s*Or;case"weeks":case"week":case"w":return s*Nr;case"days":case"day":case"d":return s*un;case"hours":case"hour":case"hrs":case"hr":case"h":return s*qn;case"minutes":case"minute":case"mins":case"min":case"m":return s*zn;case"seconds":case"second":case"secs":case"sec":case"s":return s*Un;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:throw Error(`Unknown unit "${i}" provided to ms.parse(). value=${JSON.stringify(r)}`)}}function Mw(r){let t=Math.abs(r);return t>=Kn?`${Math.round(r/Kn)}y`:t>=Or?`${Math.round(r/Or)}mo`:t>=Nr?`${Math.round(r/Nr)}w`:t>=un?`${Math.round(r/un)}d`:t>=qn?`${Math.round(r/qn)}h`:t>=zn?`${Math.round(r/zn)}m`:t>=Un?`${Math.round(r/Un)}s`:`${r}ms`}function Nw(r){let t=Math.abs(r);return t>=Kn?Gt(r,t,Kn,"year"):t>=Or?Gt(r,t,Or,"month"):t>=Nr?Gt(r,t,Nr,"week"):t>=un?Gt(r,t,un,"day"):t>=qn?Gt(r,t,qn,"hour"):t>=zn?Gt(r,t,zn,"minute"):t>=Un?Gt(r,t,Un,"second"):`${r} ms`}function Ow(r,t){if(typeof r!="number"||!Number.isFinite(r))throw Error("Value provided to ms.format() must be of type number.");return t!=null&&t.long?Nw(r):Mw(r)}function Gt(r,t,e,n){let s=t>=e*1.5;return`${Math.round(r/e)} ${n}${s?"s":""}`}function Fw(r){e.debug=e,e.default=e,e.coerce=c,e.disable=i,e.enable=s,e.enabled=o,e.humanize=ah,e.destroy=u,Object.keys(r).forEach(d=>{e[d]=r[d]}),e.names=[],e.skips=[],e.formatters={};function t(d){let h=0;for(let f=0;f<d.length;f++)h=(h<<5)-h+d.charCodeAt(f),h|=0;return e.colors[Math.abs(h)%e.colors.length]}e.selectColor=t;function e(d){let h,f=null,p,g;function y(...m){if(!y.enabled)return;const S=y,v=Number(new Date),E=v-(h||v);S.diff=E,S.prev=h,S.curr=v,h=v,m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");let L=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,(_,N)=>{if(_==="%%")return"%";L++;const T=e.formatters[N];if(typeof T=="function"){const I=m[L];_=T.call(S,I),m.splice(L,1),L--}return _}),e.formatArgs.call(S,m),(S.log||e.log).apply(S,m)}return y.namespace=d,y.useColors=e.useColors(),y.color=e.selectColor(d),y.extend=n,y.destroy=e.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(p!==e.namespaces&&(p=e.namespaces,g=e.enabled(d)),g),set:m=>{f=m}}),typeof e.init=="function"&&e.init(y),y}function n(d,h){const f=e(this.namespace+(typeof h>"u"?":":h)+d);return f.log=this.log,f}function s(d){e.save(d),e.namespaces=d,e.names=[],e.skips=[];let h;const f=(typeof d=="string"?d:"").split(/[\s,]+/),p=f.length;for(h=0;h<p;h++)f[h]&&(d=f[h].replace(/\*/g,".*?"),d[0]==="-"?e.skips.push(new RegExp("^"+d.substr(1)+"$")):e.names.push(new RegExp("^"+d+"$")))}function i(){const d=[...e.names.map(a),...e.skips.map(a).map(h=>"-"+h)].join(",");return e.enable(""),d}function o(d){if(d[d.length-1]==="*")return!0;let h,f;for(h=0,f=e.skips.length;h<f;h++)if(e.skips[h].test(d))return!1;for(h=0,f=e.names.length;h<f;h++)if(e.names[h].test(d))return!0;return!1}function a(d){return d.toString().substring(2,d.toString().length-2).replace(/\.\*\?$/,"*")}function c(d){return d instanceof Error?d.stack??d.message:d}function u(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return e.setupFormatters(e.formatters),e.enable(e.load()),e}var Bw={};const ht=Ww(),$w=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Uw(){var r,t,e,n,s;return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&((r=navigator.userAgent)==null?void 0:r.toLowerCase().match(/(edge|trident)\/(\d+)/))!=null?!1:typeof document<"u"&&((e=(t=document.documentElement)==null?void 0:t.style)==null?void 0:e.WebkitAppearance)||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&((n=navigator.userAgent)==null?void 0:n.toLowerCase().match(/firefox\/(\d+)/))!=null&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&((s=navigator.userAgent)==null?void 0:s.toLowerCase().match(/applewebkit\/(\d+)/))}function zw(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+ah(this.diff),!this.useColors)return;const t="color: "+this.color;r.splice(1,0,t,"color: inherit");let e=0,n=0;r[0].replace(/%[a-zA-Z%]/g,s=>{s!=="%%"&&(e++,s==="%c"&&(n=e))}),r.splice(n,0,t)}const qw=console.debug??console.log??(()=>{});function Kw(r){try{r?ht==null||ht.setItem("debug",r):ht==null||ht.removeItem("debug")}catch{}}function Vw(){let r;try{r=ht==null?void 0:ht.getItem("debug")}catch{}return!r&&typeof globalThis.process<"u"&&"env"in globalThis.process&&(r=Bw.DEBUG),r}function Ww(){try{return localStorage}catch{}}function Hw(r){r.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}const Ze=Fw({formatArgs:zw,save:Kw,load:Vw,useColors:Uw,setupFormatters:Hw,colors:$w,storage:ht,log:qw});Ze.formatters.b=r=>r==null?"undefined":Ie.baseEncode(r);Ze.formatters.t=r=>r==null?"undefined":Ut.baseEncode(r);Ze.formatters.m=r=>r==null?"undefined":fd.baseEncode(r);Ze.formatters.p=r=>r==null?"undefined":r.toString();Ze.formatters.c=r=>r==null?"undefined":r.toString();Ze.formatters.k=r=>r==null?"undefined":r.toString();Ze.formatters.a=r=>r==null?"undefined":r.toString();Ze.formatters.e=r=>{if(r==null)return"undefined";const t=Jc(r.message),e=Jc(r.stack);return t!=null&&e!=null?e.includes(t)?e:`${t}
${e}`:e??t??r.toString()};function Gw(r){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=r,t.destroy=()=>!0,t.extend=()=>t,t}function ch(){return{forComponent(r){return lh(r)}}}function lh(r){let t=Gw(`${r}:trace`);return Ze.enabled(`${r}:trace`)&&Ze.names.map(e=>e.toString()).find(e=>e.includes(":trace"))!=null&&(t=Ze(`${r}:trace`)),Object.assign(Ze(r),{error:Ze(`${r}:error`),trace:t,newScope:e=>lh(`${r}:${e}`)})}function Jc(r){if(r!=null&&(r=r.trim(),r.length!==0))return r}function _r(r,t){const e={[Symbol.iterator]:()=>e,next:()=>{const n=r.next(),s=n.value;return n.done===!0||s==null?{done:!0,value:void 0}:{done:!1,value:t(s)}}};return e}function fo(r){const t=Xr(Ie.decode(`z${r}`));return ts(t)}class rr{constructor(t){l(this,"map");if(this.map=new Map,t!=null)for(const[e,n]of t.entries())this.map.set(e.toString(),{key:e,value:n})}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(t){return this.map.delete(t.toString())}entries(){return _r(this.map.entries(),t=>[t[1].key,t[1].value])}forEach(t){this.map.forEach((e,n)=>{t(e.value,e.key,this)})}get(t){var e;return(e=this.map.get(t.toString()))==null?void 0:e.value}has(t){return this.map.has(t.toString())}set(t,e){this.map.set(t.toString(),{key:t,value:e})}keys(){return _r(this.map.values(),t=>t.key)}values(){return _r(this.map.values(),t=>t.value)}get size(){return this.map.size}}class Cn{constructor(t){l(this,"set");if(this.set=new Set,t!=null)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return _r(this.set.entries(),t=>{const e=fo(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const n=fo(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return _r(this.set.values(),t=>fo(t))}intersection(t){const e=new Cn;for(const n of t)this.has(n)&&e.add(n);return e}difference(t){const e=new Cn;for(const n of this)t.has(n)||e.add(n);return e}union(t){const e=new Cn;for(const n of t)e.add(n);for(const n of this)e.add(n);return e}}const tc={32:16777619n,64:1099511628211n,128:309485009821345068724781371n,256:374144419156711147060143317175368453031918731002211n,512:35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,1024:5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n},uh={32:2166136261n,64:14695981039346656037n,128:144066263297769815596495629667062367629n,256:100029257958052580907070968620625704837092796014241193945225284501741471925557n,512:9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,1024:14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n},dh=new globalThis.TextEncoder;function Yw(r,t){const e=tc[t];let n=uh[t];for(let s=0;s<r.length;s++)n^=BigInt(r[s]),n=BigInt.asUintN(t,n*e);return n}function Xw(r,t,e){if(e.length===0)throw new Error("The `utf8Buffer` option must have a length greater than zero");const n=tc[t];let s=uh[t],i=r;for(;i.length>0;){const o=dh.encodeInto(i,e);i=i.slice(o.read);for(let a=0;a<o.written;a++)s^=BigInt(e[a]),s=BigInt.asUintN(t,s*n)}return s}function Qw(r,{size:t=32,utf8Buffer:e}={}){if(!tc[t])throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");if(typeof r=="string"){if(e)return Xw(r,t,e);r=dh.encode(r)}return Yw(r,t)}const nc={hash:r=>Number(Qw(r,{size:32})),hashV:(r,t)=>Zw(nc.hash(r,t))};function Zw(r){let t=r.toString(16);return t.length%2===1&&(t=`0${t}`),Y(t,"base16")}const hh=64;class Jt{constructor(t,e,n,s=2){l(this,"fp");l(this,"h");l(this,"seed");if(s>hh)throw new TypeError("Invalid Fingerprint Size");const i=e.hashV(t,n),o=oe(s);for(let a=0;a<o.length;a++)o[a]=i[a];o.length===0&&(o[0]=7),this.fp=o,this.h=e,this.seed=n}hash(){return this.h.hash(this.fp,this.seed)}equals(t){return(t==null?void 0:t.fp)instanceof Uint8Array?qe(this.fp,t.fp):!1}}function si(r,t){return Math.floor(Math.random()*(t-r))+r}class ys{constructor(t){l(this,"contents");this.contents=new Array(t).fill(null)}has(t){if(!(t instanceof Jt))throw new TypeError("Invalid Fingerprint");return this.contents.some(e=>t.equals(e))}add(t){if(!(t instanceof Jt))throw new TypeError("Invalid Fingerprint");for(let e=0;e<this.contents.length;e++)if(this.contents[e]==null)return this.contents[e]=t,!0;return!0}swap(t){if(!(t instanceof Jt))throw new TypeError("Invalid Fingerprint");const e=si(0,this.contents.length-1),n=this.contents[e];return this.contents[e]=t,n}remove(t){if(!(t instanceof Jt))throw new TypeError("Invalid Fingerprint");const e=this.contents.findIndex(n=>t.equals(n));return e>-1?(this.contents[e]=null,!0):!1}}const Jw=500;class jc{constructor(t){l(this,"bucketSize");l(this,"filterSize");l(this,"fingerprintSize");l(this,"buckets");l(this,"count");l(this,"hash");l(this,"seed");this.filterSize=t.filterSize,this.bucketSize=t.bucketSize??4,this.fingerprintSize=t.fingerprintSize??2,this.count=0,this.buckets=[],this.hash=t.hash??nc,this.seed=t.seed??si(0,Math.pow(2,10))}add(t){typeof t=="string"&&(t=Y(t));const e=new Jt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=(n^e.hash())%this.filterSize;if(this.buckets[n]==null&&(this.buckets[n]=new ys(this.bucketSize)),this.buckets[s]==null&&(this.buckets[s]=new ys(this.bucketSize)),this.buckets[n].add(e)||this.buckets[s].add(e))return this.count++,!0;const i=[n,s];let o=i[si(0,i.length-1)];this.buckets[o]==null&&(this.buckets[o]=new ys(this.bucketSize));for(let a=0;a<Jw;a++){const c=this.buckets[o].swap(e);if(c!=null&&(o=(o^c.hash())%this.filterSize,this.buckets[o]==null&&(this.buckets[o]=new ys(this.bucketSize)),this.buckets[o].add(c)))return this.count++,!0}return!1}has(t){var o,a;typeof t=="string"&&(t=Y(t));const e=new Jt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((o=this.buckets[n])==null?void 0:o.has(e))??!1;if(s)return s;const i=(n^e.hash())%this.filterSize;return((a=this.buckets[i])==null?void 0:a.has(e))??!1}remove(t){var a,c;typeof t=="string"&&(t=Y(t));const e=new Jt(t,this.hash,this.seed,this.fingerprintSize),n=this.hash.hash(t,this.seed)%this.filterSize,s=((a=this.buckets[n])==null?void 0:a.remove(e))??!1;if(s)return this.count--,s;const i=(n^e.hash())%this.filterSize,o=((c=this.buckets[i])==null?void 0:c.remove(e))??!1;return o&&this.count--,o}get reliable(){return Math.floor(100*(this.count/this.filterSize))<=90}}const jw={1:.5,2:.84,4:.95,8:.98};function eb(r=.001){return r>.002?2:r>1e-5?4:8}function tb(r,t=.001){const e=eb(t),n=jw[e],s=Math.round(r/n),i=Math.min(Math.ceil(Math.log2(1/t)+Math.log2(2*e)),hh);return{filterSize:s,bucketSize:e,fingerprintSize:i}}class nb{constructor(t){l(this,"filterSize");l(this,"bucketSize");l(this,"fingerprintSize");l(this,"scale");l(this,"filterSeries");l(this,"hash");l(this,"seed");this.bucketSize=t.bucketSize??4,this.filterSize=t.filterSize??(1<<18)/this.bucketSize,this.fingerprintSize=t.fingerprintSize??2,this.scale=t.scale??2,this.hash=t.hash??nc,this.seed=t.seed??si(0,Math.pow(2,10)),this.filterSeries=[new jc({filterSize:this.filterSize,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed})]}add(t){if(typeof t=="string"&&(t=Y(t)),this.has(t))return!0;let e=this.filterSeries.find(n=>n.reliable);if(e==null){const n=this.filterSize*Math.pow(this.scale,this.filterSeries.length);e=new jc({filterSize:n,bucketSize:this.bucketSize,fingerprintSize:this.fingerprintSize,hash:this.hash,seed:this.seed}),this.filterSeries.push(e)}return e.add(t)}has(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].has(t))return!0;return!1}remove(t){typeof t=="string"&&(t=Y(t));for(let e=0;e<this.filterSeries.length;e++)if(this.filterSeries[e].remove(t))return!0;return!1}get count(){return this.filterSeries.reduce((t,e)=>t+e.count,0)}}function Fr(r,t=.001,e){return new nb({...tb(r,t)})}function me(r){var s,i,o,a,c,u;const t=r.getComponents(),e={};let n=0;if(((s=t[n])==null?void 0:s.name)==="ip6zone"&&(e.zone=`${t[n].value}`,n++),t[n].name==="ip4"||t[n].name==="ip6"||t[n].name==="dns"||t[n].name==="dns4"||t[n].name==="dns6"?(e.type=t[n].name,e.host=t[n].value,n++):t[n].name==="dnsaddr"&&(e.type=t[n].name,e.host=`_dnsaddr.${t[n].value}`,n++),(((i=t[n])==null?void 0:i.name)==="tcp"||((o=t[n])==null?void 0:o.name)==="udp")&&(e.protocol=t[n].name==="tcp"?"tcp":"udp",e.port=parseInt(`${t[n].value}`),n++),((a=t[n])==null?void 0:a.name)==="ipcidr"&&(e.type==="ip4"?e.cidr=parseInt(`${t[n].value}`):e.type==="ip6"&&(e.cidr=`${t[n].value}`),n++),e.type==null||e.host==null)throw new W(`Multiaddr ${r} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);return((c=t[n])==null?void 0:c.name)==="tls"&&((u=t[n+1])==null?void 0:u.name)==="sni"&&(e.sni=t[n+1].value,n+=2),e}class rb{constructor(){l(this,"index",0);l(this,"input","")}new(t){return this.index=0,this.input=t,this}readAtomically(t){const e=this.index,n=t();return n===void 0&&(this.index=e),n}parseWith(t){const e=t();if(this.index===this.input.length)return e}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(t){return this.readAtomically(()=>{const e=this.readChar();if(e===t)return e})}readSeparator(t,e,n){return this.readAtomically(()=>{if(!(e>0&&this.readGivenChar(t)===void 0))return n()})}readNumber(t,e,n,s){return this.readAtomically(()=>{let i=0,o=0;const a=this.peekChar();if(a===void 0)return;const c=a==="0",u=2**(8*s)-1;for(;;){const d=this.readAtomically(()=>{const h=this.readChar();if(h===void 0)return;const f=Number.parseInt(h,t);if(!Number.isNaN(f))return f});if(d===void 0)break;if(i*=t,i+=d,i>u||(o+=1,e!==void 0&&o>e))return}if(o!==0)return!n&&c&&o>1?void 0:i})}readIPv4Addr(){return this.readAtomically(()=>{const t=new Uint8Array(4);for(let e=0;e<t.length;e++){const n=this.readSeparator(".",e,()=>this.readNumber(10,3,!1,1));if(n===void 0)return;t[e]=n}return t})}readIPv6Addr(){const t=e=>{for(let n=0;n<e.length/2;n++){const s=n*2;if(n<e.length-3){const o=this.readSeparator(":",n,()=>this.readIPv4Addr());if(o!==void 0)return e[s]=o[0],e[s+1]=o[1],e[s+2]=o[2],e[s+3]=o[3],[s+4,!0]}const i=this.readSeparator(":",n,()=>this.readNumber(16,4,!0,2));if(i===void 0)return[s,!1];e[s]=i>>8,e[s+1]=i&255}return[e.length,!1]};return this.readAtomically(()=>{const e=new Uint8Array(16),[n,s]=t(e);if(n===16)return e;if(s||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const i=new Uint8Array(14),o=16-(n+2),[a]=t(i.subarray(0,o));return e.set(i.subarray(0,a),16-a),e})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const fh=45,sb=15,Vn=new rb;function gh(r){if(!(r.length>sb))return Vn.new(r).parseWith(()=>Vn.readIPv4Addr())}function mh(r){if(r.includes("%")&&(r=r.split("%")[0]),!(r.length>fh))return Vn.new(r).parseWith(()=>Vn.readIPv6Addr())}function ea(r,t=!1){if(r.includes("%")&&(r=r.split("%")[0]),r.length>fh)return;const e=Vn.new(r).parseWith(()=>Vn.readIPAddr());if(e)return t&&e.length===4?Uint8Array.from([0,0,0,0,0,0,0,0,0,0,255,255,e[0],e[1],e[2],e[3]]):e}function ib(r,t,e){let n=0;for(const s of r)if(!(n<t)){if(n>e)break;if(s!==255)return!1;n++}return!0}function ob(r,t,e,n){let s=0;for(const i of r)if(!(s<e)){if(s>n)break;if(i!==t[s])return!1;s++}return!0}function ab(r){switch(r.length){case Br:return r.join(".");case $r:{const t=[];for(let e=0;e<r.length;e++)e%2===0&&t.push(r[e].toString(16).padStart(2,"0")+r[e+1].toString(16).padStart(2,"0"));return t.join(":")}default:throw new Error("Invalid ip length")}}function cb(r){let t=0;for(let[e,n]of r.entries()){if(n===255){t+=8;continue}for(;n&128;)t++,n=n<<1;if(n&128)return-1;for(let s=e+1;s<r.length;s++)if(r[s]!=0)return-1;break}return t}function lb(r){let t="0x";for(const e of r)t+=(e>>4).toString(16)+(e&15).toString(16);return t}const Br=4,$r=16,ub=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function ph(r,t){t.length===$r&&r.length===Br&&ib(t,0,11)&&(t=t.slice(12)),t.length===Br&&r.length===$r&&ob(r,ub,0,11)&&(r=r.slice(12));const e=r.length;if(e!=t.length)throw new Error("Failed to mask ip");const n=new Uint8Array(e);for(let s=0;s<e;s++)n[s]=r[s]&t[s];return n}function db(r,t){if(typeof t=="string"&&(t=ea(t)),t==null)throw new Error("Invalid ip");if(t.length!==r.network.length)return!1;for(let e=0;e<t.length;e++)if((r.network[e]&r.mask[e])!==(t[e]&r.mask[e]))return!1;return!0}function hb(r){const[t,e]=r.split("/");if(!t||!e)throw new Error("Failed to parse given CIDR: "+r);let n=Br,s=gh(t);if(s==null&&(n=$r,s=mh(t),s==null))throw new Error("Failed to parse given CIDR: "+r);const i=parseInt(e,10);if(Number.isNaN(i)||String(i).length!==e.length||i<0||i>n*8)throw new Error("Failed to parse given CIDR: "+r);const o=yh(i,8*n);return{network:ph(s,o),mask:o}}function yh(r,t){if(t!==8*Br&&t!==8*$r)throw new Error("Invalid CIDR mask");if(r<0||r>t)throw new Error("Invalid CIDR mask");const e=t/8,n=new Uint8Array(e);for(let s=0;s<e;s++){if(r>=8){n[s]=255,r-=8;continue}n[s]=255-(255>>r),r=0}return n}class wh{constructor(t,e){if(e==null)({network:this.network,mask:this.mask}=hb(t));else{const n=ea(t);if(n==null)throw new Error("Failed to parse network");e=String(e);const s=parseInt(e,10);if(Number.isNaN(s)||String(s).length!==e.length||s<0||s>n.length*8){const i=ea(e);if(i==null)throw new Error("Failed to parse mask");this.mask=i}else this.mask=yh(s,8*n.length);this.network=ph(n,this.mask)}}contains(t){return db({network:this.network,mask:this.mask},t)}toString(){const t=cb(this.mask),e=t!==-1?String(t):lb(this.mask);return ab(this.network)+"/"+e}}function fb(r,t){return new wh(r).contains(t)}function gb(r){try{const t=me(r);switch(t.type){case"ip6":return fb("2000::/3",t.host);default:return!1}}catch{return!1}}function mb(r){try{const t=me(r);switch(t.type){case"ip4":return t.host.startsWith("169.254.");case"ip6":return t.host.toLowerCase().startsWith("fe80");default:return!1}}catch{return!1}}function pb(r){return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(r)||/^::1$/.test(r)}function ta(r){try{const t=me(r);switch(t.type){case"ip4":case"ip6":return pb(t.host);default:return!1}}catch{return!1}}function at(r){try{return me(r),!0}catch{return!1}}function Wn(r){return!!gh(r)}function bh(r){return!!mh(r)}var yb=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Eh(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var vh;(function(){var r,t,e,n,s,i,o,a;a=function(c){var u,d,h,f;return u=(c&255<<24)>>>24,d=(c&255<<16)>>>16,h=(c&65280)>>>8,f=c&255,[u,d,h,f].join(".")},o=function(c){var u,d,h,f,p,g;for(u=[],h=f=0;f<=3&&c.length!==0;h=++f){if(h>0){if(c[0]!==".")throw new Error("Invalid IP");c=c.substring(1)}g=t(c),p=g[0],d=g[1],c=c.substring(d),u.push(p)}if(c.length!==0)throw new Error("Invalid IP");switch(u.length){case 1:if(u[0]>4294967295)throw new Error("Invalid IP");return u[0]>>>0;case 2:if(u[0]>255||u[1]>16777215)throw new Error("Invalid IP");return(u[0]<<24|u[1])>>>0;case 3:if(u[0]>255||u[1]>255||u[2]>65535)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2])>>>0;case 4:if(u[0]>255||u[1]>255||u[2]>255||u[3]>255)throw new Error("Invalid IP");return(u[0]<<24|u[1]<<16|u[2]<<8|u[3])>>>0;default:throw new Error("Invalid IP")}},e=function(c){return c.charCodeAt(0)},n=e("0"),i=e("a"),s=e("A"),t=function(c){var u,d,h,f,p;for(f=0,u=10,d="9",h=0,c.length>1&&c[h]==="0"&&(c[h+1]==="x"||c[h+1]==="X"?(h+=2,u=16):"0"<=c[h+1]&&c[h+1]<="9"&&(h++,u=8,d="7")),p=h;h<c.length;){if("0"<=c[h]&&c[h]<=d)f=f*u+(e(c[h])-n)>>>0;else if(u===16)if("a"<=c[h]&&c[h]<="f")f=f*u+(10+e(c[h])-i)>>>0;else if("A"<=c[h]&&c[h]<="F")f=f*u+(10+e(c[h])-s)>>>0;else break;else break;if(f>4294967295)throw new Error("too large");h++}if(h===p)throw new Error("empty octet");return[f,h]},r=function(){function c(u,d){var h,f,p;if(typeof u!="string")throw new Error("Missing `net' parameter");if(d||(p=u.split("/",2),u=p[0],d=p[1]),d||(d=32),typeof d=="string"&&d.indexOf(".")>-1){try{this.maskLong=o(d)}catch{throw new Error("Invalid mask: "+d)}for(h=f=32;f>=0;h=--f)if(this.maskLong===4294967295<<32-h>>>0){this.bitmask=h;break}}else if(d||d===0)this.bitmask=parseInt(d,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(o(u)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+u)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+d);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return c.prototype.contains=function(u){return typeof u=="string"&&(u.indexOf("/")>0||u.split(".").length!==4)&&(u=new c(u)),u instanceof c?this.contains(u.base)&&this.contains(u.broadcast||u.last):(o(u)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},c.prototype.next=function(u){return u==null&&(u=1),new c(a(this.netLong+this.size*u),this.mask)},c.prototype.forEach=function(u){var d,h,f;for(f=o(this.first),h=o(this.last),d=0;f<=h;)u(a(f),f,d),d++,f++},c.prototype.toString=function(){return this.base+"/"+this.bitmask},c}(),vh=r}).call(yb);const wb=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],bb=wb.map(r=>new vh(r));function rc(r){for(const t of bb)if(t.contains(r))return!0;return!1}function Eb(r){return/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(r)}function vb(r){const t=r.split(":");if(t.length<2)return!1;const e=t[t.length-1].padStart(4,"0"),n=t[t.length-2].padStart(4,"0"),s=`${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}.${parseInt(e.substring(0,2),16)}.${parseInt(e.substring(2),16)}`;return rc(s)}function Sb(r){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)}function xb(r){const t=r.split(":"),e=t[t.length-1];return rc(e)}function Ab(r){return/^::$/.test(r)||/^::1$/.test(r)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(r)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(r)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(r)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(r)||/^ff([0-9a-fA-F]{2,2}):/i.test(r)}function sc(r){if(Wn(r))return rc(r);if(Eb(r))return vb(r);if(Sb(r))return xb(r);if(bh(r))return Ab(r)}function Hn(r){try{const t=me(r);switch(t.type){case"ip4":case"ip6":return sc(t.host)??!1;default:return t.host==="localhost"}}catch{return!1}}function nt(){const r={};return r.promise=new Promise((t,e)=>{r.resolve=t,r.reject=e}),r}class el{constructor(t){l(this,"buffer");l(this,"mask");l(this,"top");l(this,"btm");l(this,"next");if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){const t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}}class go{constructor(t={}){l(this,"size");l(this,"hwm");l(this,"head");l(this,"tail");this.hwm=t.splitLimit??16,this.head=new el(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return(t==null?void 0:t.byteLength)!=null?t.byteLength:1}push(t){if((t==null?void 0:t.value)!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){const e=this.head;this.head=e.next=new el(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return(t==null?void 0:t.value)!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}let Cb=class extends Error{constructor(e,n){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.code=n??"ABORT_ERR"}};function Vi(r={}){return _b(e=>{const n=e.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},r)}function _b(r,t){t=t??{};let e=t.onEnd,n=new go,s,i,o,a=nt();const c=async()=>{try{return n.isEmpty()?o?{done:!0}:await new Promise((m,S)=>{i=v=>{i=null,n.push(v);try{m(r(n))}catch(E){S(E)}return s}}):r(n)}finally{n.isEmpty()&&queueMicrotask(()=>{a.resolve(),a=nt()})}},u=m=>i!=null?i(m):(n.push(m),s),d=m=>(n=new go,i!=null?i({error:m}):(n.push({error:m}),s)),h=m=>{if(o)return s;if((t==null?void 0:t.objectMode)!==!0&&(m==null?void 0:m.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return u({done:!1,value:m})},f=m=>o?s:(o=!0,m!=null?d(m):u({done:!0})),p=()=>(n=new go,f(),{done:!0}),g=m=>(f(m),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:c,return:p,throw:g,push:h,end:f,get readableLength(){return n.size},onEmpty:async m=>{const S=m==null?void 0:m.signal;if(S==null||S.throwIfAborted(),n.isEmpty())return;let v,E;S!=null&&(v=new Promise((L,x)=>{E=()=>{x(new Cb)},S.addEventListener("abort",E)}));try{await Promise.race([a.promise,v])}finally{E!=null&&S!=null&&(S==null||S.removeEventListener("abort",E))}}},e==null)return s;const y=s;return s={[Symbol.asyncIterator](){return this},next(){return y.next()},throw(m){return y.throw(m),e!=null&&(e(m),e=void 0),{done:!0}},return(){return y.return(),e!=null&&(e(),e=void 0),{done:!0}},push:h,end(m){return y.end(m),e!=null&&(e(m),e=void 0),s},get readableLength(){return y.readableLength},onEmpty:m=>y.onEmpty(m)},s}class Sh extends Error{constructor(t){super(t),this.name="TimeoutError"}}let Ib=class extends Error{constructor(t){super(),this.name="AbortError",this.message=t}};const tl=r=>globalThis.DOMException===void 0?new Ib(r):new DOMException(r),nl=r=>{const t=r.reason===void 0?tl("This operation was aborted."):r.reason;return t instanceof Error?t:tl(t)};function xh(r,t){const{milliseconds:e,fallback:n,message:s,customTimers:i={setTimeout,clearTimeout}}=t;let o,a;const u=new Promise((d,h)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(t.signal){const{signal:p}=t;p.aborted&&h(nl(p)),a=()=>{h(nl(p))},p.addEventListener("abort",a,{once:!0})}if(e===Number.POSITIVE_INFINITY){r.then(d,h);return}const f=new Sh;o=i.setTimeout.call(void 0,()=>{if(n){try{d(n())}catch(p){h(p)}return}typeof r.cancel=="function"&&r.cancel(),s===!1?d():s instanceof Error?h(s):(f.message=s??`Promise timed out after ${e} milliseconds`,h(f))},e),(async()=>{try{d(await r)}catch(p){h(p)}})()}).finally(()=>{u.clear(),a&&t.signal&&t.signal.removeEventListener("abort",a)});return u.clear=()=>{i.clearTimeout.call(void 0,o),o=void 0},u}const Tb=r=>{const t=r.addEventListener||r.on||r.addListener,e=r.removeEventListener||r.off||r.removeListener;if(!t||!e)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(r),removeListener:e.bind(r)}};function Lb(r,t,e){let n;const s=new Promise((i,o)=>{var p;if(e={rejectionEvents:["error"],multiArgs:!1,rejectionMultiArgs:!1,resolveImmediately:!1,...e},!(e.count>=0&&(e.count===Number.POSITIVE_INFINITY||Number.isInteger(e.count))))throw new TypeError("The `count` option should be at least 0 or more");(p=e.signal)==null||p.throwIfAborted();const a=[t].flat(),c=[],{addListener:u,removeListener:d}=Tb(r),h=async(...g)=>{const y=e.multiArgs?g:g[0];if(e.filter)try{if(!await e.filter(y))return}catch(m){n(),o(m);return}c.push(y),e.count===c.length&&(n(),i(c))},f=(...g)=>{n(),o(e.rejectionMultiArgs?g:g[0])};n=()=>{for(const g of a)d(g,h);for(const g of e.rejectionEvents)a.includes(g)||d(g,f)};for(const g of a)u(g,h);for(const g of e.rejectionEvents)a.includes(g)||u(g,f);e.signal&&e.signal.addEventListener("abort",()=>{f(e.signal.reason)},{once:!0}),e.resolveImmediately&&i(c)});if(s.cancel=n,typeof e.timeout=="number"){const i=xh(s,{milliseconds:e.timeout});return i.cancel=()=>{n(),i.clear()},i}return s}function Fe(r,t,e){typeof e=="function"&&(e={filter:e}),e={...e,count:1,resolveImmediately:!1};const n=Lb(r,t,e),s=n.then(i=>i[0]);return s.cancel=n.cancel,s}function ii(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class Db extends Error{constructor(e="Rate limit exceeded",n){super(e);l(this,"remainingPoints");l(this,"msBeforeNext");l(this,"consumedPoints");l(this,"isFirstInDuration");this.name="RateLimitError",this.remainingPoints=n.remainingPoints,this.msBeforeNext=n.msBeforeNext,this.consumedPoints=n.consumedPoints,this.isFirstInDuration=n.isFirstInDuration}}var No;let Pb=(No=class extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}},l(No,"name","QueueFullError"),No);var Oo;let oi=(Oo=class extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError")}},l(Oo,"name","UnexpectedEOFError"),Oo);class Ah extends Error{constructor(){super(...arguments);l(this,"name","MaxEarlyStreamsError")}}l(Ah,"name","MaxEarlyStreamsError");class Ch extends Error{constructor(){super(...arguments);l(this,"name","StreamClosedError")}}l(Ch,"name","StreamClosedError");function Rb(r){return r.reason}async function Wi(r,t,e){if(t==null)return r;const n=Rb;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}let kb=class{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=nt(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new Lr)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}};function Mb(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}let Nb=class{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=Mb(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new Lr),this.cleanup())}async join(t={}){var n;const e=new kb(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await Wi(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}},_h=class extends Xe{constructor(e={}){var n;super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"paused");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.paused=!1,e.metricName!=null&&((n=e.metrics)==null||n.registerMetricGroup(e.metricName,{calculate:()=>({size:this.queue.length,running:this.pending,queued:this.queue.length-this.pending})})),this.sort=e.sort,this.queue=[],this.emitEmpty=ii(this.emitEmpty.bind(this),1),this.emitIdle=ii(this.emitIdle.bind(this),1)}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.tryToStartAnother())}tryToStartAnother(){if(this.paused)return!1;if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.tryToStartAnother(),this.safeDispatchEvent("next")}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new Pb;const s=new Nb(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("completed",{detail:o}),this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Lr)}),this.clear()}async onEmpty(e){this.size!==0&&await Fe(this,"empty",e)}async onSizeLessThan(e,n){this.size<e||await Fe(this,"next",{...n,filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await Fe(this,"idle",e)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Vi({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new Lr("Queue aborted"))};this.addEventListener("completed",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("completed",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}};const Ob=Math.pow(2,20)*4;class ic extends Xe{constructor(e){super();l(this,"status");l(this,"timeline");l(this,"inactivityTimeout");l(this,"maxReadBufferLength");l(this,"maxWriteBufferLength");l(this,"log");l(this,"direction");l(this,"maxMessageSize");l(this,"readStatus");l(this,"writeStatus");l(this,"remoteReadStatus");l(this,"remoteWriteStatus");l(this,"writableNeedsDrain");l(this,"readBuffer");l(this,"writeBuffer");l(this,"sendingData");l(this,"onDrainPromise");this.status="open",this.log=e.log,this.direction=e.direction??"outbound",this.inactivityTimeout=e.inactivityTimeout??12e4,this.maxReadBufferLength=e.maxReadBufferLength??Ob,this.maxWriteBufferLength=e.maxWriteBufferLength,this.maxMessageSize=e.maxMessageSize,this.readBuffer=new J,this.writeBuffer=new J,this.readStatus="readable",this.remoteReadStatus="readable",this.writeStatus="writable",this.remoteWriteStatus="writable",this.sendingData=!1,this.writableNeedsDrain=!1,this.timeline={open:Date.now()},this.processSendQueue=this.processSendQueue.bind(this);const n=()=>{var i;this.writableNeedsDrain&&(this.log.trace("drain event received, continue sending data"),this.writableNeedsDrain=!1,this.processSendQueue()),(i=this.onDrainPromise)==null||i.resolve()};this.addEventListener("drain",n);const s=i=>{var o;(o=this.onDrainPromise)==null||o.reject(i.error??new Ch)};this.addEventListener("close",s)}get readBufferLength(){return this.readBuffer.byteLength}get writeBufferLength(){return this.writeBuffer.byteLength}async onDrain(e){return this.writableNeedsDrain!==!0?Promise.resolve():(this.onDrainPromise==null&&(this.onDrainPromise=Promise.withResolvers()),Wi(this.onDrainPromise.promise,e==null?void 0:e.signal))}async*[Symbol.asyncIterator](){if(this.readStatus!=="readable"&&this.readStatus!=="paused")return;const e=Vi(),n=o=>{e.push(o.data)};this.addEventListener("message",n);const s=o=>{e.end(o.error)};this.addEventListener("close",s);const i=()=>{e.end()};this.addEventListener("remoteCloseWrite",i);try{yield*e}finally{this.removeEventListener("message",n),this.removeEventListener("close",s),this.removeEventListener("remoteCloseWrite",i)}}isReadable(){return this.status==="open"}send(e){if(this.writeStatus==="closed"||this.writeStatus==="closing")throw new Yt(`Cannot write to a stream that is ${this.writeStatus}`);return this.log.trace("append %d bytes to write buffer",e.byteLength),this.writeBuffer.append(e),this.processSendQueue()}abort(e){if(!(this.status==="aborted"||this.status==="reset"||this.status==="closed")){this.log.error("abort with error - %e",e),this.status="aborted",this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle")),this.writeStatus="closed",this.remoteWriteStatus="closed",this.readStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now();try{this.sendReset(e)}catch(n){this.log("failed to send reset to remote - %e",n)}this.dispatchEvent(new Fg(e))}}pause(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Yt("Cannot pause a stream that is closing/closed");this.readStatus!=="paused"&&(this.readStatus="paused",this.sendPause())}resume(){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Yt("Cannot resume a stream that is closing/closed");this.readStatus!=="readable"&&(this.readStatus="readable",this.dispatchReadBuffer(),this.sendResume())}push(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Yt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.append(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}unshift(e){if(this.readStatus==="closed"||this.readStatus==="closing")throw new Yt(`Cannot push data onto a stream that is ${this.readStatus}`);if(e.byteLength!==0){if(this.readBuffer.prepend(e),this.readStatus==="paused"||this.listenerCount("message")===0){this.checkReadBufferLength();return}setTimeout(()=>{this.dispatchReadBuffer()},0)}}onData(e){if(e.byteLength!==0){if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("ignoring data - read status %s",this.readStatus);return}this.readBuffer.append(e),this.dispatchReadBuffer()}}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="message"&&this.readBuffer.byteLength>0&&queueMicrotask(()=>{this.dispatchReadBuffer()})}onRemoteReset(){this.log("remote reset"),this.status="reset",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.timeline.close=Date.now(),this.readBuffer.byteLength===0&&(this.readStatus="closed");const e=new La;this.dispatchEvent(new Bg(e))}onTransportClosed(e){this.log("transport closed"),this.readStatus==="readable"&&this.readBuffer.byteLength===0&&(this.log("close readable end after transport closed and read buffer is empty"),this.readStatus="closed"),this.remoteReadStatus!=="closed"&&(this.remoteReadStatus="closed"),this.remoteWriteStatus!=="closed"&&(this.remoteWriteStatus="closed"),this.writeStatus!=="closed"&&(this.writeStatus="closed"),e!=null?this.abort(e):(this.status==="open"||this.status==="closing")&&(this.timeline.close=Date.now(),this.status="closed",this.writeStatus="closed",this.remoteWriteStatus="closed",this.remoteReadStatus="closed",this.dispatchEvent(new ki))}onRemoteCloseWrite(){this.remoteWriteStatus!=="closed"&&(this.log.trace("on remote close write"),this.remoteWriteStatus="closed",this.safeDispatchEvent("remoteCloseWrite"),this.writeStatus==="closed"&&this.onTransportClosed())}onRemoteCloseRead(){this.log.trace("on remote close read"),this.remoteReadStatus="closed",this.writeBuffer.byteLength>0&&(this.writeBuffer.consume(this.writeBuffer.byteLength),this.safeDispatchEvent("idle"))}processSendQueue(){if(this.writableNeedsDrain)return this.log.trace("not processing send queue as drain is required"),this.checkWriteBufferLength(),!1;if(this.writeBuffer.byteLength===0)return this.log.trace("not processing send queue as no bytes to send"),!0;if(this.sendingData)return this.log.trace("not processing send queue as already sending data"),!0;this.sendingData=!0,this.log.trace("processing send queue with %d queued bytes",this.writeBuffer.byteLength);try{let e=!0;const n=this.writeBuffer.byteLength;let s=0;for(;this.writeBuffer.byteLength>0;){const i=Math.min(this.maxMessageSize??this.writeBuffer.byteLength,this.writeBuffer.byteLength);if(i===0){e=!1;break}const o=this.writeBuffer.sublist(0,i),a=new J(o);this.writeBuffer.consume(o.byteLength);const c=this.sendData(o);if(e=c.canSendMore,s+=c.sentBytes,c.sentBytes!==a.byteLength&&(a.consume(c.sentBytes),this.writeBuffer.prepend(a)),!e)break}return e||(this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer",s,n,this.writeBuffer.byteLength),this.writableNeedsDrain=!0,this.checkWriteBufferLength()),this.writeBuffer.byteLength===0&&this.safeDispatchEvent("idle"),e}finally{this.sendingData=!1}}dispatchReadBuffer(){try{if(this.listenerCount("message")===0){this.log.trace("not dispatching pause buffer as there are no listeners for the message event");return}if(this.readBuffer.byteLength===0){this.log.trace("not dispatching pause buffer as there is no data to dispatch");return}if(this.readStatus==="paused"){this.log.trace("not dispatching pause buffer we are paused");return}if(this.readStatus==="closing"||this.readStatus==="closed"){this.log("dropping %d bytes because the readable end is %s",this.readBuffer.byteLength,this.readStatus),this.readBuffer.consume(this.readBuffer.byteLength);return}const e=this.readBuffer.sublist();this.readBuffer.consume(e.byteLength),this.dispatchEvent(new Og(e))}finally{this.readBuffer.byteLength===0&&this.remoteWriteStatus==="closed"&&(this.log("close readable end after dispatching read buffer and remote writable end is closed"),this.readStatus="closed"),this.checkReadBufferLength()}}checkReadBufferLength(){this.readBuffer.byteLength>this.maxReadBufferLength&&this.abort(new Bo(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`))}checkWriteBufferLength(){this.maxWriteBufferLength!=null&&this.writeBuffer.byteLength>this.maxWriteBufferLength&&this.abort(new Bo(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`))}onMuxerNeedsDrain(){this.writableNeedsDrain=!0}onMuxerDrain(){this.safeDispatchEvent("drain")}}class Ih extends ic{constructor(e){super(e);l(this,"remoteAddr");l(this,"metricPrefix");l(this,"metrics");this.metricPrefix=e.metricPrefix??"",this.metrics=e.metrics,this.remoteAddr=e.remoteAddr,this.addEventListener("close",n=>{var s,i,o,a,c;(s=this.metrics)==null||s.increment({[`${this.metricPrefix}end`]:!0}),n.error!=null?n.local?(i=this.metrics)==null||i.increment({[`${this.metricPrefix}abort`]:!0}):(o=this.metrics)==null||o.increment({[`${this.metricPrefix}reset`]:!0}):n.local?(a=this.metrics)==null||a.increment({[`${this.metricPrefix}_local_close`]:!0}):(c=this.metrics)==null||c.increment({[`${this.metricPrefix}_remote_close`]:!0})})}async close(e){this.status==="open"&&(this.status="closing",this.writeStatus="closing",this.remoteWriteStatus="closing",this.remoteReadStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Fe(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Fe(this,"drain",{...e,rejectionEvents:["close"]})),await this.sendClose(e),this.onTransportClosed())}}function Fb(r){return r==null?!1:typeof r.then=="function"&&typeof r.catch=="function"&&typeof r.finally=="function"}class Th extends Xe{constructor(e,n){super();l(this,"streams");l(this,"protocol");l(this,"status");l(this,"log");l(this,"maConn");l(this,"streamOptions");l(this,"earlyStreams");l(this,"maxEarlyStreams");l(this,"metrics");this.maConn=e,this.protocol=n.protocol,this.streams=[],this.earlyStreams=[],this.status="open",this.log=e.log.newScope(n.name),this.streamOptions=n.streamOptions,this.maxEarlyStreams=n.maxEarlyStreams??10,this.metrics=n.metrics;const s=a=>{try{this.onData(a.data)}catch(c){this.abort(c),this.maConn.abort(c)}};this.maConn.addEventListener("message",s);const i=()=>{this.log("underlying stream drained, signal %d streams to continue writing",this.streams.length),this.streams.forEach(a=>{a.onMuxerDrain()})};this.maConn.addEventListener("drain",i);const o=()=>{this.log("underlying stream closed with status %s and %d streams",this.status,this.streams.length),this.onTransportClosed()};this.maConn.addEventListener("close",o)}send(e){const n=this.maConn.send(e);return n===!1&&(this.log("underlying stream saturated, signal %d streams to pause writing",this.streams.length),this.streams.forEach(s=>{s.onMuxerNeedsDrain()})),n}async close(e){this.status==="closed"||this.status==="closing"||(this.status="closing",await Wi(Promise.all([...this.streams].map(async n=>{await n.close(e)})),e==null?void 0:e.signal),this.status="closed")}abort(e){this.status!=="closed"&&(this.status="closing",[...this.streams].forEach(n=>{n.abort(e)}),this.status="closed")}onTransportClosed(e){this.status="closing";try{[...this.streams].forEach(n=>{n.onTransportClosed(e)})}catch(n){this.abort(n)}this.status="closed"}async createStream(e){if(this.status!=="open")throw new bn;let n=this.onCreateStream({...this.streamOptions,...e});return Fb(n)&&(n=await n),this.streams.push(n),this.cleanUpStream(n),n}onRemoteStream(e){if(this.streams.push(e),this.cleanUpStream(e),this.listenerCount("stream")===0){this.earlyStreams.push(e),this.earlyStreams.length>this.maxEarlyStreams&&this.abort(new Ah(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));return}this.safeDispatchEvent("stream",{detail:e})}cleanUpStream(e){var s;const n=i=>{var a,c,u;const o=this.streams.findIndex(d=>d===e);o!==-1&&this.streams.splice(o,1),i.error!=null?i.local?(a=this.metrics)==null||a.increment({[`${e.direction}_stream_reset`]:!0}):(c=this.metrics)==null||c.increment({[`${e.direction}_stream_abort`]:!0}):(u=this.metrics)==null||u.increment({[`${e.direction}_stream_end`]:!0})};e.addEventListener("close",n),(s=this.metrics)==null||s.increment({[`${e.direction}_stream`]:!0})}addEventListener(...e){super.addEventListener.apply(this,e),e[0]==="stream"&&this.earlyStreams.length>0&&queueMicrotask(()=>{this.earlyStreams.forEach(n=>{this.safeDispatchEvent("stream",{detail:n})}),this.earlyStreams=[]})}}class Lh extends ic{constructor(e){super(e);l(this,"id");l(this,"protocol");this.id=e.id,this.protocol=e.protocol??""}async close(e){this.writeStatus==="closing"||this.writeStatus==="closed"||(this.writeStatus="closing",(this.sendingData||this.writeBuffer.byteLength>0)&&(this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes",this.writeBuffer.byteLength),await Fe(this,"idle",{...e,rejectionEvents:["close"]})),this.writableNeedsDrain&&(this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData),await Fe(this,"drain",{...e,rejectionEvents:["close"]}),this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s",this.writeBuffer.byteLength,this.sendingData)),await this.sendCloseWrite(e),this.writeStatus="closed",this.log("closed writable end gracefully"),this.remoteWriteStatus==="closed"&&this.onTransportClosed())}async closeRead(e){this.readStatus==="closing"||this.readStatus==="closed"||(this.readBuffer.byteLength>0&&this.readBuffer.consume(this.readBuffer.byteLength),this.readStatus="closing",await this.sendCloseRead(e),this.readStatus="closed",this.log("closed readable end gracefully"))}}function dn(r){const t=new globalThis.AbortController;function e(){t.abort();for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}for(const i of r){if((i==null?void 0:i.aborted)===!0){e();break}(i==null?void 0:i.addEventListener)!=null&&i.addEventListener("abort",e)}function n(){for(const i of r)(i==null?void 0:i.removeEventListener)!=null&&i.removeEventListener("abort",e)}const s=t.signal;return s.clear=n,s}class mo{constructor(t){l(this,"movingAverage");l(this,"variance");l(this,"deviation");l(this,"forecast");l(this,"timeSpan");l(this,"previousTime");this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(this.previousTime!=null){const n=this.alpha(e,this.previousTime),s=t-this.movingAverage,i=n*s;this.movingAverage=n*t+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+s*i),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*s}else this.movingAverage=t;this.previousTime=e}}const Bb=1.2,$b=2,Ub=5e3,zb=6e4,qb=5e3;class Kb{constructor(t={}){l(this,"success");l(this,"failure");l(this,"next");l(this,"metric");l(this,"timeoutMultiplier");l(this,"failureMultiplier");l(this,"minTimeout");l(this,"maxTimeout");var n;const e=t.interval??qb;this.success=new mo(e),this.failure=new mo(e),this.next=new mo(e),this.failureMultiplier=t.failureMultiplier??$b,this.timeoutMultiplier=t.timeoutMultiplier??Bb,this.minTimeout=t.minTimeout??Ub,this.maxTimeout=t.maxTimeout??zb,t.metricName!=null&&(this.metric=(n=t.metrics)==null?void 0:n.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){let e=Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier));e<this.minTimeout&&(e=this.minTimeout),e>this.maxTimeout&&(e=this.maxTimeout);const n=AbortSignal.timeout(e),s=dn([t.signal,n]);return s.start=Date.now(),s.timeout=e,s}cleanUp(t){var n,s;const e=Date.now()-t.start;t.aborted?(this.failure.push(e),this.next.push(e*this.failureMultiplier),(n=this.metric)==null||n.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:e})):(this.success.push(e),this.next.push(e),(s=this.metric)==null||s.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:e}))}}class Je extends Error{constructor(){super(...arguments);l(this,"name","InvalidMultiaddrError")}}l(Je,"name","InvalidMultiaddrError");class Gn extends Error{constructor(){super(...arguments);l(this,"name","ValidationError")}}l(Gn,"name","ValidationError");class Dh extends Error{constructor(){super(...arguments);l(this,"name","InvalidParametersError")}}l(Dh,"name","InvalidParametersError");class Ph extends Error{constructor(){super(...arguments);l(this,"name","UnknownProtocolError")}}l(Ph,"name","UnknownProtocolError");const ai=4,_n=6,Rh=273,Vb=33,Yn=41,oc=42,ac=43,kh=53,Mh=54,Nh=55,Oh=56,Wb=132,Hb=301,Gb=302,Fh=400,V=421,Yb=444,Xb=445,Qb=446,Zb=447,In=448,ci=449,Jb=454,Bh=460,$h=461,Uh=465,Ur=466,Tn=480,jb=481,na=443,cc=477,zh=478,e0=479,t0=277,n0=275,r0=276,qh=280,Ir=281,sr=290,Kh=777;function rl(r){return t=>Z(t,r)}function sl(r){return t=>Y(t,r)}function mr(r){return new DataView(r.buffer).getUint16(r.byteOffset).toString()}function En(r){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,typeof r=="string"?parseInt(r):r),new Uint8Array(t)}function s0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=Y(t[0],"base32"),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=En(n);return qt([e,s],e.length+s.length)}function i0(r){const t=r.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=Ut.decode(`b${t[0]}`),n=parseInt(t[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const s=En(n);return qt([e,s],e.length+s.length)}function il(r){const t=r.subarray(0,r.length-2),e=r.subarray(r.length-2),n=Z(t,"base32"),s=mr(e);return`${n}:${s}`}const Vh=function(r){r=r.toString().trim();const t=new Uint8Array(4);return r.split(/\./g).forEach((e,n)=>{const s=parseInt(e,10);if(isNaN(s)||s<0||s>255)throw new Je("Invalid byte value in IP address");t[n]=s}),t},o0=function(r){let t=0;r=r.toString().trim();const e=r.split(":",8);let n;for(n=0;n<e.length;n++){const i=Wn(e[n]);let o;i&&(o=Vh(e[n]),e[n]=Z(o.subarray(0,2),"base16")),o!=null&&++n<8&&e.splice(n,0,Z(o.subarray(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(n=0;n<e.length&&e[n]!=="";n++);const i=[n,1];for(n=9-e.length;n>0;n--)i.push("0");e.splice.apply(e,i)}const s=new Uint8Array(t+16);for(n=0;n<e.length;n++){e[n]===""&&(e[n]="0");const i=parseInt(e[n],16);if(isNaN(i)||i<0||i>65535)throw new Je("Invalid byte value in IP address");s[t++]=i>>8&255,s[t++]=i&255}return s},a0=function(r){if(r.byteLength!==4)throw new Je("IPv4 address was incorrect length");const t=[];for(let e=0;e<r.byteLength;e++)t.push(r[e]);return t.join(".")},c0=function(r){if(r.byteLength!==16)throw new Je("IPv6 address was incorrect length");const t=[];for(let n=0;n<r.byteLength;n+=2){const s=r[n],i=r[n+1],o=`${s.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}`;t.push(o)}const e=t.join(":");try{const n=new URL(`http://[${e}]`);return n.hostname.substring(1,n.hostname.length-1)}catch{throw new Je(`Invalid IPv6 address "${e}"`)}};function l0(r){try{const t=new URL(`http://[${r}]`);return t.hostname.substring(1,t.hostname.length-1)}catch{throw new Je(`Invalid IPv6 address "${r}"`)}}const po=Object.values(Wo).map(r=>r.decoder),u0=function(){let r=po[0].or(po[1]);return po.slice(2).forEach(t=>r=r.or(t)),r}();function d0(r){return u0.decode(r)}function h0(r){return t=>r.encoder.encode(t)}function f0(r){if(parseInt(r).toString()!==r)throw new Gn("Value must be an integer")}function g0(r){if(r<0)throw new Gn("Value must be a positive integer, or zero")}function m0(r){return t=>{if(t>r)throw new Gn(`Value must be smaller than or equal to ${r}`)}}function p0(...r){return t=>{for(const e of r)e(t)}}const ws=p0(f0,g0,m0(65535)),ke=-1;class y0{constructor(){l(this,"protocolsByCode",new Map);l(this,"protocolsByName",new Map)}getProtocol(t){let e;if(typeof t=="string"?e=this.protocolsByName.get(t):e=this.protocolsByCode.get(t),e==null)throw new Ph(`Protocol ${t} was unknown`);return e}addProtocol(t){var e;this.protocolsByCode.set(t.code,t),this.protocolsByName.set(t.name,t),(e=t.aliases)==null||e.forEach(n=>{this.protocolsByName.set(n,t)})}removeProtocol(t){var n;const e=this.protocolsByCode.get(t);e!=null&&(this.protocolsByCode.delete(e.code),this.protocolsByName.delete(e.name),(n=e.aliases)==null||n.forEach(s=>{this.protocolsByName.delete(s)}))}}const ir=new y0,w0=[{code:ai,name:"ip4",size:32,valueToBytes:Vh,bytesToValue:a0,validate:r=>{if(!Wn(r))throw new Gn(`Invalid IPv4 address "${r}"`)}},{code:_n,name:"tcp",size:16,valueToBytes:En,bytesToValue:mr,validate:ws},{code:Rh,name:"udp",size:16,valueToBytes:En,bytesToValue:mr,validate:ws},{code:Vb,name:"dccp",size:16,valueToBytes:En,bytesToValue:mr,validate:ws},{code:Yn,name:"ip6",size:128,valueToBytes:o0,bytesToValue:c0,stringToValue:l0,validate:r=>{if(!bh(r))throw new Gn(`Invalid IPv6 address "${r}"`)}},{code:oc,name:"ip6zone",size:ke},{code:ac,name:"ipcidr",size:8,bytesToValue:rl("base10"),valueToBytes:sl("base10")},{code:kh,name:"dns",size:ke},{code:Mh,name:"dns4",size:ke},{code:Nh,name:"dns6",size:ke},{code:Oh,name:"dnsaddr",size:ke},{code:Wb,name:"sctp",size:16,valueToBytes:En,bytesToValue:mr,validate:ws},{code:Hb,name:"udt"},{code:Gb,name:"utp"},{code:Fh,name:"unix",size:ke,stringToValue:r=>decodeURIComponent(r),valueToString:r=>encodeURIComponent(r)},{code:V,name:"p2p",aliases:["ipfs"],size:ke,bytesToValue:rl("base58btc"),valueToBytes:r=>r.startsWith("Q")||r.startsWith("1")?sl("base58btc")(r):ge.parse(r).multihash.bytes},{code:Yb,name:"onion",size:96,bytesToValue:il,valueToBytes:s0},{code:Xb,name:"onion3",size:296,bytesToValue:il,valueToBytes:i0},{code:Qb,name:"garlic64",size:ke},{code:Zb,name:"garlic32",size:ke},{code:In,name:"tls"},{code:ci,name:"sni",size:ke},{code:Jb,name:"noise"},{code:Bh,name:"quic"},{code:$h,name:"quic-v1"},{code:Uh,name:"webtransport"},{code:Ur,name:"certhash",size:ke,bytesToValue:h0(gd),valueToBytes:d0},{code:Tn,name:"http"},{code:jb,name:"http-path",size:ke,stringToValue:r=>`/${decodeURIComponent(r)}`,valueToString:r=>encodeURIComponent(r.substring(1))},{code:na,name:"https"},{code:cc,name:"ws"},{code:zh,name:"wss"},{code:e0,name:"p2p-websocket-star"},{code:t0,name:"p2p-stardust"},{code:n0,name:"p2p-webrtc-star"},{code:r0,name:"p2p-webrtc-direct"},{code:qh,name:"webrtc-direct"},{code:Ir,name:"webrtc"},{code:sr,name:"p2p-circuit"},{code:Kh,name:"memory",size:ke}];w0.forEach(r=>{ir.addProtocol(r)});function b0(r){var n;const t=[];let e=0;for(;e<r.length;){const s=es(r,e),i=ir.getProtocol(s),o=Te(s),a=x0(i,r,e+o);let c=0;a>0&&i.size===ke&&(c=Te(a));const u=o+c+a,d={code:s,name:i.name,bytes:r.subarray(e,e+u)};if(a>0){const h=e+o+c,f=r.subarray(h,h+a);d.value=((n=i.bytesToValue)==null?void 0:n.call(i,f))??Z(f)}t.push(d),e+=u}return t}function E0(r){var n;let t=0;const e=[];for(const s of r){if(s.bytes==null){const i=ir.getProtocol(s.code),o=Te(s.code);let a,c=0,u=0;s.value!=null&&(a=((n=i.valueToBytes)==null?void 0:n.call(i,s.value))??Y(s.value),c=a.byteLength,i.size===ke&&(u=Te(c)));const d=new Uint8Array(o+u+c);let h=0;ti(s.code,d,h),h+=o,a!=null&&(i.size===ke&&(ti(c,d,h),h+=u),d.set(a,h)),s.bytes=d}e.push(s.bytes),t+=s.bytes.byteLength}return qt(e,t)}function v0(r){var i;if(r.charAt(0)!=="/")throw new Je('String multiaddr must start with "/"');const t=[];let e="protocol",n="",s="";for(let o=1;o<r.length;o++){const a=r.charAt(o);a!=="/"&&(e==="protocol"?s+=r.charAt(o):n+=r.charAt(o));const c=o===r.length-1;if(a==="/"||c){const u=ir.getProtocol(s);if(e==="protocol"){if(u.size==null||u.size===0){t.push({code:u.code,name:u.name}),n="",s="",e="protocol";continue}else if(c)throw new Je(`Component ${s} was missing value`);e="value"}else if(e==="value"){const d={code:u.code,name:u.name};if(u.size!=null&&u.size!==0){if(n==="")throw new Je(`Component ${s} was missing value`);d.value=((i=u.stringToValue)==null?void 0:i.call(u,n))??n}t.push(d),n="",s="",e="protocol"}}}if(s!==""&&n!=="")throw new Je("Incomplete multiaddr");return t}function S0(r){return`/${r.flatMap(t=>{var n;if(t.value==null)return t.name;const e=ir.getProtocol(t.code);if(e==null)throw new Je(`Unknown protocol code ${t.code}`);return[t.name,((n=e.valueToString)==null?void 0:n.call(e,t.value))??t.value]}).join("/")}`}function x0(r,t,e){return r.size==null||r.size===0?0:r.size>0?r.size/8:es(t,e)}const A0=Symbol.for("nodejs.util.inspect.custom"),Wh=Symbol.for("@multiformats/multiaddr");function C0(r){if(r==null&&(r="/"),Hi(r))return r.getComponents();if(r instanceof Uint8Array)return b0(r);if(typeof r=="string")return r=r.replace(/\/(\/)+/,"/").replace(/(\/)+$/,""),r===""&&(r="/"),v0(r);if(Array.isArray(r))return r;throw new Je("Must be a string, Uint8Array, Component[], or another Multiaddr")}var pu,st,Dn,Pn;const vn=class vn{constructor(t="/",e={}){l(this,pu,!0);he(this,st);he(this,Dn);he(this,Pn);fe(this,st,C0(t)),e.validate!==!1&&_0(this)}get bytes(){return $(this,Pn)==null&&fe(this,Pn,E0($(this,st))),$(this,Pn)}toString(){return $(this,Dn)==null&&fe(this,Dn,S0($(this,st))),$(this,Dn)}toJSON(){return this.toString()}getComponents(){return[...$(this,st).map(t=>({...t}))]}encapsulate(t){const e=new vn(t);return new vn([...$(this,st),...e.getComponents()],{validate:!1})}decapsulate(t){const e=t.toString(),n=this.toString(),s=n.lastIndexOf(e);if(s<0)throw new Dh(`Address ${this.toString()} does not contain subaddress: ${e}`);return new vn(n.slice(0,s),{validate:!1})}decapsulateCode(t){let e;for(let n=$(this,st).length-1;n>-1;n--)if($(this,st)[n].code===t){e=n;break}return new vn($(this,st).slice(0,e),{validate:!1})}equals(t){return qe(this.bytes,t.bytes)}[(pu=Wh,A0)](){return`Multiaddr(${this.toString()})`}};st=new WeakMap,Dn=new WeakMap,Pn=new WeakMap;let ra=vn;function _0(r){r.getComponents().forEach(t=>{var n;const e=ir.getProtocol(t.code);t.value!=null&&((n=e.validate)==null||n.call(e,t.value))})}function Hi(r){return!!(r!=null&&r[Wh])}function X(r){return new ra(r)}let ol=class extends Error{constructor(e,n,s){super(e??"The operation was aborted");l(this,"type");l(this,"code");this.type="aborted",this.name=s??"AbortError",this.code=n??"ABORT_ERR"}};async function Hh(r,t,e){if(t==null)return r;if(t.aborted)return r.catch(()=>{}),Promise.reject(new ol(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName));let n;const s=new ol(e==null?void 0:e.errorMessage,e==null?void 0:e.errorCode,e==null?void 0:e.errorName);try{return await Promise.race([r,new Promise((i,o)=>{n=()=>{o(s)},t.addEventListener("abort",n)})])}finally{n!=null&&t.removeEventListener("abort",n)}}class I0{constructor(){l(this,"readNext");l(this,"haveNext");l(this,"ended");l(this,"nextResult");l(this,"error");this.ended=!1,this.readNext=nt(),this.haveNext=nt()}[Symbol.asyncIterator](){return this}async next(){if(this.nextResult==null&&await this.haveNext.promise,this.nextResult==null)throw new Error("HaveNext promise resolved but nextResult was undefined");const t=this.nextResult;return this.nextResult=void 0,this.readNext.resolve(),this.readNext=nt(),t}async throw(t){return this.ended=!0,this.error=t,t!=null&&(this.haveNext.promise.catch(()=>{}),this.haveNext.reject(t)),{done:!0,value:void 0}}async return(){const t={done:!0,value:void 0};return this.ended=!0,this.nextResult=t,this.haveNext.resolve(),t}async push(t,e){await this._push(t,e)}async end(t,e){t!=null?await this.throw(t):await this._push(void 0,e)}async _push(t,e){if(t!=null&&this.ended)throw this.error??new Error("Cannot push value onto an ended pushable");for(;this.nextResult!=null;)await this.readNext.promise;t!=null?this.nextResult={done:!1,value:t}:(this.ended=!0,this.nextResult={done:!0,value:void 0}),this.haveNext.resolve(),this.haveNext=nt(),await Hh(this.readNext.promise,e==null?void 0:e.signal,e)}}function T0(){return new I0}function L0(r){return r[Symbol.asyncIterator]!=null}async function D0(r,t,e){try{await Promise.all(r.map(async n=>{for await(const s of n)await t.push(s,{signal:e}),e.throwIfAborted()})),await t.end(void 0,{signal:e})}catch(n){await t.end(n,{signal:e}).catch(()=>{})}}async function*P0(r){const t=new AbortController,e=T0();D0(r,e,t.signal).catch(()=>{});try{yield*e}finally{t.abort()}}function*R0(r){for(const t of r)yield*t}function sa(...r){const t=[];for(const e of r)L0(e)||t.push(e);return t.length===r.length?R0(t):P0(r)}const k0=4194304;class ia extends Error{constructor(){super(...arguments);l(this,"name","UnwrappedError")}}l(ia,"name","UnwrappedError");let Gh=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}},M0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}},N0=class extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}};function O0(r){return typeof(r==null?void 0:r.closeRead)=="function"}function F0(r){return typeof(r==null?void 0:r.close)=="function"}function yo(r){return O0(r)?r.remoteWriteStatus!=="writable"&&r.readBufferLength===0:F0(r)?r.status!=="open":!1}function B0(r){return(r==null?void 0:r.addEventListener)!=null&&(r==null?void 0:r.removeEventListener)!=null&&(r==null?void 0:r.send)!=null&&(r==null?void 0:r.push)!=null&&(r==null?void 0:r.log)!=null}function Yh(r,t){const e=(t==null?void 0:t.maxBufferSize)??k0,n=new J;let s,i=!1;if(!B0(r))throw new W("Argument should be a Stream or a Multiaddr");const o=d=>{if(n.append(d.data),n.byteLength>e){const h=n.byteLength;n.consume(n.byteLength),s==null||s.reject(new Error(`Read buffer overflow - ${h} > ${e}`))}s==null||s.resolve()};r.addEventListener("message",o);const a=d=>{d.error!=null?s==null||s.reject(d.error):s==null||s.resolve()};r.addEventListener("close",a);const c=()=>{s==null||s.resolve()};r.addEventListener("remoteCloseWrite",c);const u={readBuffer:n,async read(d){if(i===!0)throw new ia("Stream was unwrapped");if(yo(r)){if((d==null?void 0:d.bytes)==null)return null;if(n.byteLength<d.bytes)throw r.log.error("closed after reading %d/%d bytes",n.byteLength,d.bytes),new oi(`Unexpected EOF - stream closed after reading ${n.byteLength}/${d.bytes} bytes`)}const h=(d==null?void 0:d.bytes)??1;for(s=Promise.withResolvers();;){if(n.byteLength>=h){s.resolve();break}if(await Wi(s.promise,d==null?void 0:d.signal),yo(r)){if(n.byteLength===0&&(d==null?void 0:d.bytes)==null)return null;break}s=Promise.withResolvers()}const f=(d==null?void 0:d.bytes)??n.byteLength;if(n.byteLength<f){if(yo(r))throw r.log.error("closed while reading %d/%d bytes",n.byteLength,f),new oi(`Unexpected EOF - stream closed while reading ${n.byteLength}/${f} bytes`);return u.read(d)}const p=n.sublist(0,f);return n.consume(f),p},async write(d,h){if(i===!0)throw new ia("Stream was unwrapped");r.send(d)||await Fe(r,"drain",{signal:h==null?void 0:h.signal,rejectionEvents:["close"]})},unwrap(){return i||(i=!0,r.removeEventListener("message",o),r.removeEventListener("close",a),r.removeEventListener("remoteCloseWrite",c),n.byteLength>0&&(r.log("stream unwrapped with %d unread bytes",n.byteLength),r.push(n))),r}};return u}function zr(r,t={}){const e=Yh(r,t);t.maxDataLength!=null&&t.maxLengthLength==null&&(t.maxLengthLength=Te(t.maxDataLength));const n=(t==null?void 0:t.lengthDecoder)??es,s=(t==null?void 0:t.lengthEncoder)??Cr;return{async read(o){let a=-1;const c=new J;for(;;){const d=await e.read({...o,bytes:1});if(d==null)break;c.append(d);try{a=n(c)}catch(h){if(h instanceof RangeError)continue;throw h}if(a<0)throw new Gh("Invalid message length");if((t==null?void 0:t.maxLengthLength)!=null&&c.byteLength>t.maxLengthLength)throw new N0(`Message length length too long - ${c.byteLength} > ${t.maxLengthLength}`);if(a>-1)break}if((t==null?void 0:t.maxDataLength)!=null&&a>t.maxDataLength)throw new M0(`Message length too long - ${a} > ${t.maxDataLength}`);const u=await e.read({...o,bytes:a});if(u==null)throw r.log.error("tried to read %d bytes but the stream closed",a),new oi(`Unexpected EOF - tried to read ${a} bytes but the stream closed`);if(u.byteLength!==a)throw r.log.error("read %d/%d bytes before the stream closed",u.byteLength,a),new oi(`Unexpected EOF - read ${u.byteLength}/${a} bytes before the stream closed`);return u},async write(o,a){await e.write(new J(s(o.byteLength),o),a)},async writeV(o,a){const c=new J(...o.flatMap(u=>[s(u.byteLength),u]));await e.write(c,a)},unwrap(){return e.unwrap()}}}function hn(r,t){const e=zr(r,t),n={read:async(s,i)=>{const o=await e.read(i);return s.decode(o)},write:async(s,i,o)=>{await e.write(i.encode(s),o)},writeV:async(s,i,o)=>{await e.writeV(s.map(a=>i.encode(a)),o)},pb:s=>({read:async i=>n.read(s,i),write:async(i,o)=>n.write(i,s,o),writeV:async(i,o)=>n.writeV(i,s,o),unwrap:()=>n}),unwrap:()=>e.unwrap()};return n}const $0=1024*1024*4,U0=1024*1024*4;class z0{constructor(t={}){l(this,"buffer");l(this,"maxBufferSize");l(this,"lengthDecoder");l(this,"maxDataLength");l(this,"encodingLength");this.buffer=new J,this.maxBufferSize=t.maxBufferSize??$0,this.maxDataLength=t.maxDataLength??U0,this.lengthDecoder=t.lengthDecoder??es,this.encodingLength=t.encodingLength??Te}*decode(t){if(this.buffer.append(t),this.buffer.byteLength>this.maxBufferSize)throw new W(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);for(;;){let e;try{e=this.lengthDecoder(this.buffer)}catch(i){if(i instanceof RangeError)break;throw i}if(e<0||e>this.maxDataLength)throw new Gh("Invalid message length");const n=this.encodingLength(e),s=n+e;if(this.buffer.byteLength>=s){const i=this.buffer.sublist(n,s);this.buffer.consume(s),i.byteLength>0&&(yield i)}else break}}}const q0=8,lc=1024*1024*4;class K0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidMessageLengthError");l(this,"code","ERR_INVALID_MSG_LENGTH")}}class Xh extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthError");l(this,"code","ERR_MSG_DATA_TOO_LONG")}}class V0 extends Error{constructor(){super(...arguments);l(this,"name","InvalidDataLengthLengthError");l(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class al extends Error{constructor(){super(...arguments);l(this,"name","UnexpectedEOFError");l(this,"code","ERR_UNEXPECTED_EOF")}}function Qh(r){return r[Symbol.asyncIterator]!=null}function Zh(r,t){if(r.byteLength>t)throw new Xh("Message length too long")}const Gi=r=>{const t=Te(r),e=gt(t);return Cr(r,e),Gi.bytes=t,e};Gi.bytes=0;function li(r,t){t=t??{};const e=t.lengthEncoder??Gi,n=(t==null?void 0:t.maxDataLength)??lc;function*s(i){Zh(i,n);const o=e(i.byteLength);o instanceof Uint8Array?yield o:yield*o,i instanceof Uint8Array?yield i:yield*i}return Qh(r)?async function*(){for await(const i of r)yield*s(i)}():function*(){for(const i of r)yield*s(i)}()}li.single=(r,t)=>{t=t??{};const e=t.lengthEncoder??Gi,n=(t==null?void 0:t.maxDataLength)??lc;return Zh(r,n),new J(e(r.byteLength),r)};var Xt;(function(r){r[r.LENGTH=0]="LENGTH",r[r.DATA=1]="DATA"})(Xt||(Xt={}));const uc=r=>{const t=es(r);return uc.bytes=Te(t),t};uc.bytes=0;function oa(r,t){const e=new J;let n=Xt.LENGTH,s=-1;const i=(t==null?void 0:t.lengthDecoder)??uc,o=(t==null?void 0:t.maxLengthLength)??q0,a=(t==null?void 0:t.maxDataLength)??lc;function*c(){for(;e.byteLength>0;){if(n===Xt.LENGTH)try{if(s=i(e),s<0)throw new K0("Invalid message length");if(s>a)throw new Xh("Message length too long");const u=i.bytes;e.consume(u),(t==null?void 0:t.onLength)!=null&&t.onLength(s),n=Xt.DATA}catch(u){if(u instanceof RangeError){if(e.byteLength>o)throw new V0("Message length length too long");break}throw u}if(n===Xt.DATA){if(e.byteLength<s)break;const u=e.sublist(0,s);e.consume(s),(t==null?void 0:t.onData)!=null&&t.onData(u),yield u,n=Xt.LENGTH}}}return Qh(r)?async function*(){for await(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new al("Unexpected end of input")}():function*(){for(const u of r)e.append(u),yield*c();if(e.byteLength>0)throw new al("Unexpected end of input")}()}oa.fromReader=(r,t)=>{let e=1;const n=async function*(){for(;;)try{const{done:i,value:o}=await r.next(e);if(i===!0)return;o!=null&&(yield o)}catch(i){if(i.code==="ERR_UNDER_READ")return{done:!0,value:null};throw i}finally{e=1}}();return oa(n,{...t??{},onLength:i=>{e=i}})};class dc extends _h{has(t){return this.find(t)!=null}find(t){return this.queue.find(e=>t.equals(e.options.peerId))}}let W0=class extends _h{constructor(t={}){super({...t,sort:(e,n)=>e.options.priority>n.options.priority?-1:e.options.priority<n.options.priority?1:0})}};class H0{constructor(t={}){l(this,"memoryStorage");l(this,"points");l(this,"duration");l(this,"blockDuration");l(this,"keyPrefix");this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new G0}consume(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n);let o=this.memoryStorage.incrby(s,e,i);if(o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o.consumedPoints>this.points)throw this.blockDuration>0&&o.consumedPoints<=this.points+e&&(o=this.memoryStorage.set(s,o.consumedPoints,this.blockDuration)),new Db("Rate limit exceeded",o);return o}penalty(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}reward(t,e=1,n={}){const s=this.getKey(t),i=this._getKeySecDuration(n),o=this.memoryStorage.incrby(s,-e,i);return o.remainingPoints=Math.max(this.points-o.consumedPoints,0),o}block(t,e){const n=e*1e3,s=this.points+1;return this.memoryStorage.set(this.getKey(t),s,e),{remainingPoints:0,msBeforeNext:n===0?-1:n,consumedPoints:s,isFirstInDuration:!1}}set(t,e,n=0){const s=(n>=0?n:this.duration)*1e3;return this.memoryStorage.set(this.getKey(t),e,n),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return e!=null&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return(t==null?void 0:t.customDuration)!=null&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class G0{constructor(){l(this,"storage");this.storage=new Map}incrby(t,e,n){const s=this.storage.get(t);if(s!=null){const i=s.expiresAt!=null?s.expiresAt.getTime()-new Date().getTime():-1;return s.expiresAt==null||i>0?(s.value+=e,{remainingPoints:0,msBeforeNext:i,consumedPoints:s.value,isFirstInDuration:!1}):this.set(t,e,n)}return this.set(t,e,n)}set(t,e,n){const s=n*1e3,i=this.storage.get(t);i!=null&&clearTimeout(i.timeoutId);const o={value:e,expiresAt:s>0?new Date(Date.now()+s):void 0};return this.storage.set(t,o),s>0&&(o.timeoutId=setTimeout(()=>{this.storage.delete(t)},s),o.timeoutId.unref!=null&&o.timeoutId.unref()),{remainingPoints:0,msBeforeNext:s===0?-1:s,consumedPoints:o.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(e!=null)return{remainingPoints:0,msBeforeNext:e.expiresAt!=null?e.expiresAt.getTime()-new Date().getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}delete(t){const e=this.storage.get(t);return e!=null?(e.timeoutId!=null&&clearTimeout(e.timeoutId),this.storage.delete(t),!0):!1}}function Y0(r,t,e){let n,s,i=!1;function o(){const u={signal:s.signal};if((e==null?void 0:e.timeout)!=null){const d=dn([s.signal,AbortSignal.timeout(e.timeout)]);u.signal=d}i=!0,Promise.resolve().then(async()=>{await r(u)}).catch(()=>{}).finally(()=>{i=!1,!s.signal.aborted&&(n=setTimeout(o,t))})}const a=ii(o,(e==null?void 0:e.debounce)??100);let c=!1;return{setInterval:u=>{t!==u&&(t=u,n!=null&&(clearTimeout(n),n=setTimeout(o,t)))},setTimeout:u=>{e??(e={}),e.timeout=u},run:()=>{i||(clearTimeout(n),a())},start:()=>{c||(c=!0,s=new AbortController,s.signal,(e==null?void 0:e.runImmediately)===!0?queueMicrotask(()=>{o()}):n=setTimeout(o,t))},stop:()=>{clearTimeout(n),s==null||s.abort(),c=!1}}}class X0 extends Map{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function It(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new X0({name:t,metrics:e}):n=new Map,n}class Q0{constructor(t,e){l(this,"filter");this.filter=Fr(t,e)}has(t){return this.filter.has(t.toMultihash().bytes)}add(t){this.filter.add(t.toMultihash().bytes)}remove(t){var e,n;(n=(e=this.filter).remove)==null||n.call(e,t.toMultihash().bytes)}}function Z0(r,t=.001){return new Q0(r,t)}class J0 extends rr{constructor(e){super();l(this,"metric");const{name:n,metrics:s}=e;this.metric=s.registerMetric(n),this.updateComponentMetric()}set(e,n){return super.set(e,n),this.updateComponentMetric(),this}delete(e){const n=super.delete(e);return this.updateComponentMetric(),n}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function j0(r){const{name:t,metrics:e}=r;let n;return e!=null?n=new J0({name:t,metrics:e}):n=new rr,n}var ui;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&e.payload.byteLength>0&&(n.uint32(26),n.bytes(e.payload)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={publicKey:oe(0),payloadType:oe(0),payload:oe(0),signature:oe(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=e.bytes();break}case 5:{i.signature=e.bytes();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(ui||(ui={}));class eE extends Error{constructor(t="Invalid signature"){super(t),this.name="InvalidSignatureError"}}const Mt=class Mt{constructor(t){l(this,"publicKey");l(this,"payloadType");l(this,"payload");l(this,"signature");l(this,"marshaled");const{publicKey:e,payloadType:n,payload:s,signature:i}=t;this.publicKey=e,this.payloadType=n,this.payload=s,this.signature=i}marshal(){return this.marshaled==null&&(this.marshaled=ui.encode({publicKey:xt(this.publicKey),payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(t){return t==null?!1:qe(this.marshal(),t.marshal())}async validate(t,e){const n=cl(t,this.payloadType,this.payload);return this.publicKey.verify(n.subarray(),this.signature,e)}};l(Mt,"createFromProtobuf",t=>{const e=ui.decode(t),n=Vt(e.publicKey);return new Mt({publicKey:n,payloadType:e.payloadType,payload:e.payload,signature:e.signature})}),l(Mt,"seal",async(t,e,n)=>{if(e==null)throw new Error("Missing private key");const s=t.domain,i=t.codec,o=t.marshal(),a=cl(s,i,o),c=await e.sign(a.subarray(),n);return new Mt({publicKey:e.publicKey,payloadType:i,payload:o,signature:c})}),l(Mt,"openAndCertify",async(t,e,n)=>{const s=Mt.createFromProtobuf(t);if(!await s.validate(e,n))throw new eE("Envelope signature is not valid for the given domain");return s});let fn=Mt;const cl=(r,t,e)=>{const n=Y(r),s=Cr(n.byteLength),i=Cr(t.length),o=Cr(e.length);return new J(s,n,i,t,o,e)},tE="libp2p-peer-record",nE=Uint8Array.from([3,1]);var di;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.multiaddr!=null&&s.multiaddr.byteLength>0&&(i.uint32(10),i.bytes(s.multiaddr)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={multiaddr:oe(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.multiaddr=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)})(r.AddressInfo||(r.AddressInfo={}));let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.peerId!=null&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),e.seq!=null&&e.seq!==0n&&(n.uint32(16),n.uint64(e.seq)),e.addresses!=null)for(const i of e.addresses)n.uint32(26),r.AddressInfo.codec().encode(i,n);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={peerId:oe(0),seq:0n,addresses:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.peerId=e.bytes();break}case 2:{i.seq=e.uint64();break}case 3:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new _t('Decode error - map field "addresses" had too many elements');i.addresses.push(r.AddressInfo.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(di||(di={}));function rE(r,t){const e=(n,s)=>n.toString().localeCompare(s.toString());return r.length!==t.length?!1:(t.sort(e),r.sort(e).every((n,s)=>t[s].equals(n)))}const Et=class Et{constructor(t){l(this,"peerId");l(this,"multiaddrs");l(this,"seqNumber");l(this,"domain",Et.DOMAIN);l(this,"codec",Et.CODEC);l(this,"marshaled");const{peerId:e,multiaddrs:n,seqNumber:s}=t;this.peerId=e,this.multiaddrs=n??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=di.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(t){return!(!(t instanceof Et)||!this.peerId.equals(t.peerId)||this.seqNumber!==t.seqNumber||!rE(this.multiaddrs,t.multiaddrs))}};l(Et,"createFromProtobuf",t=>{const e=di.decode(t),n=ts(Xr(e.peerId)),s=(e.addresses??[]).map(o=>X(o.multiaddr)),i=e.seq;return new Et({peerId:n,multiaddrs:s,seqNumber:i})}),l(Et,"DOMAIN",tE),l(Et,"CODEC",nE);let At=Et;function sE(r){return r[Symbol.asyncIterator]!=null}function aa(r){if(sE(r))return(async()=>{const e=[];for await(const n of r)e.push(n);return e})();const t=[];for(const e of r)t.push(e);return t}var Fo;let Xn=(Fo=class extends Error{constructor(e="The operation was aborted",...n){super(e,...n);l(this,"name","AbortError")}},l(Fo,"name","AbortError"),Fo);async function wo(r,t,e,n){const s=new Xn(n==null?void 0:n.errorMessage);(n==null?void 0:n.errorCode)!=null&&(s.code=n.errorCode);const i=(n==null?void 0:n.errorEvent)??"error";return(e==null?void 0:e.aborted)===!0?Promise.reject(s):new Promise((o,a)=>{function c(){Eo(e,"abort",h),Eo(r,t,u),Eo(r,i,d)}const u=f=>{var p;try{if(((p=n==null?void 0:n.filter)==null?void 0:p.call(n,f))===!1)return}catch(g){c(),a(g);return}c(),o(f)},d=f=>{if(c(),f instanceof Error){a(f);return}a(f.detail??(n==null?void 0:n.error)??new Error(`The "${n==null?void 0:n.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`))},h=()=>{c(),a(s)};bo(e,"abort",h),bo(r,t,u),bo(r,i,d)})}function bo(r,t,e){r!=null&&(Jh(r)?r.addEventListener(t,e):r.addListener(t,e))}function Eo(r,t,e){r!=null&&(Jh(r)?r.removeEventListener(t,e):r.removeListener(t,e))}function Jh(r){return typeof r.addEventListener=="function"&&typeof r.removeEventListener=="function"}class jh extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}l(jh,"name","QueueFullError");class iE{constructor(t){l(this,"deferred");l(this,"signal");var e;this.signal=t,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),(e=this.signal)==null||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject(((t=this.signal)==null?void 0:t.reason)??new Xn)}cleanup(){var t;(t=this.signal)==null||t.removeEventListener("abort",this.onAbort)}}function oE(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}class aE{constructor(t,e){l(this,"id");l(this,"fn");l(this,"options");l(this,"recipients");l(this,"status");l(this,"timeline");l(this,"controller");this.id=oE(),this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,this.controller.signal,this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((e,n)=>{var s;return e&&((s=n.signal)==null?void 0:s.aborted)===!0},!0)&&(this.controller.abort(new Xn),this.cleanup())}async join(t={}){var n;const e=new iE(t.signal);return this.recipients.push(e),(n=t.signal)==null||n.addEventListener("abort",this.onAbort),e.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await Hh(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),(e=t.signal)==null||e.removeEventListener("abort",this.onAbort)})}}function ll(r,t){let e;const n=function(){const s=function(){e=void 0,r()};clearTimeout(e),e=setTimeout(s,t)};return n.start=()=>{},n.stop=()=>{clearTimeout(e)},n}class ul extends Xe{constructor(e={}){super();l(this,"concurrency");l(this,"maxSize");l(this,"queue");l(this,"pending");l(this,"sort");l(this,"autoStart");this.concurrency=e.concurrency??Number.POSITIVE_INFINITY,this.maxSize=e.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=e.autoStart??!0,this.sort=e.sort,this.queue=[],this.emitEmpty=ll(this.emitEmpty.bind(this),1),this.emitIdle=ll(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){this.size===0&&this.safeDispatchEvent("empty")}emitIdle(){this.running===0&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(this.size===0)return this.emitEmpty(),this.running===0&&this.emitIdle(),!1;if(this.pending<this.concurrency){let e;for(const n of this.queue)if(n.status==="queued"){e=n;break}return e==null?!1:(this.safeDispatchEvent("active"),this.pending++,e.run().finally(()=>{for(let n=0;n<this.queue.length;n++)if(this.queue[n]===e){this.queue.splice(n,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(e){this.queue.push(e),this.sort!=null&&this.queue.sort(this.sort)}start(){this.autoStart===!1&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(e,n){var i;if((i=n==null?void 0:n.signal)==null||i.throwIfAborted(),this.size===this.maxSize)throw new jh;const s=new aE(e,n);return this.enqueue(s),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),s.join(n).then(o=>(this.safeDispatchEvent("success",{detail:{job:s,result:o}}),o)).catch(o=>{if(s.status==="queued"){for(let a=0;a<this.queue.length;a++)if(this.queue[a]===s){this.queue.splice(a,1);break}}throw this.safeDispatchEvent("failure",{detail:{job:s,error:o}}),o})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(e=>{e.abort(new Xn)}),this.clear()}async onEmpty(e){this.size!==0&&await wo(this,"empty",e==null?void 0:e.signal)}async onSizeLessThan(e,n){this.size<e||await wo(this,"next",n==null?void 0:n.signal,{filter:()=>this.size<e})}async onIdle(e){this.pending===0&&this.size===0||await wo(this,"idle",e==null?void 0:e.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(e){var u,d,h;(u=e==null?void 0:e.signal)==null||u.throwIfAborted();const n=Vi({objectMode:!0}),s=f=>{f!=null?this.abort():this.clear(),n.end(f)},i=f=>{f.detail!=null&&n.push(f.detail.result)},o=f=>{s(f.detail.error)},a=()=>{s()},c=()=>{s(new Xn("Queue aborted"))};this.addEventListener("success",i),this.addEventListener("failure",o),this.addEventListener("idle",a),(d=e==null?void 0:e.signal)==null||d.addEventListener("abort",c);try{yield*n}finally{this.removeEventListener("success",i),this.removeEventListener("failure",o),this.removeEventListener("idle",a),(h=e==null?void 0:e.signal)==null||h.removeEventListener("abort",c),s()}}}const ef="lock:worker:request-read",tf="lock:worker:abort-read-request",nf="lock:worker:release-read",rf="lock:master:grant-read",sf="lock:master:error-read",of="lock:worker:request-write",af="lock:worker:abort-write-request",cf="lock:worker:release-write",lf="lock:master:grant-write",uf="lock:master:error-write",df="lock:worker:finalize",hf="mortice",cE={singleProcess:!1},dl=(r,t,e,n,s,i,o,a,c)=>u=>{if(u.data==null)return;const d={type:u.data.type,name:u.data.name,identifier:u.data.identifier};d.type===s&&r.safeDispatchEvent(e,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{t.postMessage({type:c,name:d.name,identifier:d.identifier}),await new Promise(h=>{const f=p=>{if((p==null?void 0:p.data)==null)return;const g={type:p.data.type,name:p.data.name,identifier:p.data.identifier};g.type===a&&g.identifier===d.identifier&&(t.removeEventListener("message",f),h())};t.addEventListener("message",f)})},onError:h=>{t.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:h.message,name:h.name,stack:h.stack}})}}}),d.type===i&&r.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier}}),d.type===df&&r.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})},lE=(r=10)=>Math.random().toString().substring(2,r+2);class uE{constructor(t){l(this,"name");l(this,"channel");this.name=t,this.channel=new BroadcastChannel(hf)}readLock(t){return this.sendRequest(ef,tf,rf,sf,nf,t)}writeLock(t){return this.sendRequest(of,af,lf,uf,cf,t)}finalize(){this.channel.postMessage({type:df,name:this.name}),this.channel.close()}async sendRequest(t,e,n,s,i,o){var c;(c=o==null?void 0:o.signal)==null||c.throwIfAborted();const a=lE();return this.channel.postMessage({type:t,identifier:a,name:this.name}),new Promise((u,d)=>{var p;const h=()=>{this.channel.postMessage({type:e,identifier:a,name:this.name})};(p=o==null?void 0:o.signal)==null||p.addEventListener("abort",h,{once:!0});const f=g=>{var y,m,S,v;if(((y=g.data)==null?void 0:y.identifier)===a&&(((m=g.data)==null?void 0:m.type)===n&&(this.channel.removeEventListener("message",f),(S=o==null?void 0:o.signal)==null||S.removeEventListener("abort",h),u(()=>{this.channel.postMessage({type:i,identifier:a,name:this.name})})),g.data.type===s)){this.channel.removeEventListener("message",f),(v=o==null?void 0:o.signal)==null||v.removeEventListener("abort",h);const E=new Error;g.data.error!=null&&(E.message=g.data.error.message,E.name=g.data.error.name,E.stack=g.data.error.stack),d(E)}};this.channel.addEventListener("message",f)})}}const dE=r=>{if(r=Object.assign({},cE,r),!!globalThis.document||r.singleProcess){const e=new BroadcastChannel(hf),n=new Xe;return e.addEventListener("message",dl(n,e,"requestReadLock","abortReadLockRequest",ef,tf,sf,nf,rf)),e.addEventListener("message",dl(n,e,"requestWriteLock","abortWriteLockRequest",of,af,uf,cf,lf)),n}return new uE(r.name)},jt=new Map;let hr;function ff(r){return typeof(r==null?void 0:r.readLock)=="function"&&typeof(r==null?void 0:r.writeLock)=="function"}function hE(r){if(hr==null&&(hr=dE(r),!ff(hr))){const t=hr;t.addEventListener("requestReadLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=jt.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortReadLockRequest",a),i.readLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortReadLockRequest",a)})}),t.addEventListener("requestWriteLock",e=>{const n=e.detail.name,s=e.detail.identifier,i=jt.get(n);if(i==null)return;const o=new AbortController,a=c=>{c.detail.name!==n||c.detail.identifier!==s||o.abort()};t.addEventListener("abortWriteLockRequest",a),i.writeLock({signal:o.signal}).then(async c=>{await e.detail.handler().finally(()=>{c()})}).catch(c=>{e.detail.onError(c)}).finally(()=>{t.removeEventListener("abortWriteLockRequest",a)})}),t.addEventListener("finalizeRequest",e=>{const n=e.detail.name,s=jt.get(n);s!=null&&s.finalize()})}return hr}async function vo(r,t){var o;let e,n;const s=new Promise((a,c)=>{e=a,n=c}),i=()=>{n(new Xn)};return(o=t==null?void 0:t.signal)==null||o.addEventListener("abort",i,{once:!0}),r.add(async()=>{await new Promise(a=>{e(()=>{var c;(c=t==null?void 0:t.signal)==null||c.removeEventListener("abort",i),a()})})},{signal:t==null?void 0:t.signal}).catch(a=>{n(a)}),s}const fE=(r,t)=>{let e=jt.get(r);if(e!=null)return e;const n=hE(t);if(ff(n))return e=n,jt.set(r,e),e;const s=new ul({concurrency:1});let i;return e={async readLock(o){if(i!=null)return vo(i,o);i=new ul({concurrency:t.concurrency,autoStart:!1});const a=i,c=vo(i,o);return s.add(async()=>{a.start(),await a.onIdle().then(()=>{i===a&&(i=null)})}),c},async writeLock(o){return i=null,vo(s,o)},finalize:()=>{jt.delete(r)},queue:s},jt.set(r,e),t.autoFinalize===!0&&s.addEventListener("idle",()=>{e.finalize()},{once:!0}),e},gE={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function mE(r){const t=Object.assign({},gE,r);return fE(t.name,t)}const pE=36e5,yE=216e5;var en;(function(r){(function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&s.value.byteLength>0&&(i.uint32(18),i.bytes(s.value)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{const a={key:"",value:oe(0)},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const u=s.uint32();switch(u>>>3){case 1:{a.key=s.string();break}case 2:{a.value=s.bytes();break}default:{s.skipType(u&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)})(r.Peer$metadataEntry||(r.Peer$metadataEntry={})),function(e){let n;e.codec=()=>(n==null&&(n=Se((s,i,o={})=>{o.lengthDelimited!==!1&&i.fork(),s.key!=null&&s.key!==""&&(i.uint32(10),i.string(s.key)),s.value!=null&&(i.uint32(18),fi.codec().encode(s.value,i)),o.lengthDelimited!==!1&&i.ldelim()},(s,i,o={})=>{var u;const a={key:""},c=i==null?s.len:s.pos+i;for(;s.pos<c;){const d=s.uint32();switch(d>>>3){case 1:{a.key=s.string();break}case 2:{a.value=fi.codec().decode(s,s.uint32(),{limits:(u=o.limits)==null?void 0:u.value});break}default:{s.skipType(d&7);break}}}return a})),n),e.encode=s=>ve(s,e.codec()),e.decode=(s,i)=>Ee(s,e.codec(),i)}(r.Peer$tagsEntry||(r.Peer$tagsEntry={}));let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.addresses!=null)for(const i of e.addresses)n.uint32(10),hi.codec().encode(i,n);if(e.protocols!=null)for(const i of e.protocols)n.uint32(18),n.string(i);if(e.publicKey!=null&&(n.uint32(34),n.bytes(e.publicKey)),e.peerRecordEnvelope!=null&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),e.metadata!=null&&e.metadata.size!==0)for(const[i,o]of e.metadata.entries())n.uint32(50),r.Peer$metadataEntry.codec().encode({key:i,value:o},n);if(e.tags!=null&&e.tags.size!==0)for(const[i,o]of e.tags.entries())n.uint32(58),r.Peer$tagsEntry.codec().encode({key:i,value:o},n);e.updated!=null&&(n.uint32(64),n.uint64Number(e.updated)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c,u,d,h,f;const i={addresses:[],protocols:[],metadata:new Map,tags:new Map},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const p=e.uint32();switch(p>>>3){case 1:{if(((a=s.limits)==null?void 0:a.addresses)!=null&&i.addresses.length===s.limits.addresses)throw new _t('Decode error - map field "addresses" had too many elements');i.addresses.push(hi.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.addresses$}));break}case 2:{if(((u=s.limits)==null?void 0:u.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new _t('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 4:{i.publicKey=e.bytes();break}case 5:{i.peerRecordEnvelope=e.bytes();break}case 6:{if(((d=s.limits)==null?void 0:d.metadata)!=null&&i.metadata.size===s.limits.metadata)throw new Gc('Decode error - map field "metadata" had too many elements');const g=r.Peer$metadataEntry.codec().decode(e,e.uint32());i.metadata.set(g.key,g.value);break}case 7:{if(((h=s.limits)==null?void 0:h.tags)!=null&&i.tags.size===s.limits.tags)throw new Gc('Decode error - map field "tags" had too many elements');const g=r.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:(f=s.limits)==null?void 0:f.tags$value}});i.tags.set(g.key,g.value);break}case 8:{i.updated=e.uint64Number();break}default:{e.skipType(p&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(en||(en={}));var hi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.multiaddr!=null&&e.multiaddr.byteLength>0&&(n.uint32(10),n.bytes(e.multiaddr)),e.isCertified!=null&&(n.uint32(16),n.bool(e.isCertified)),e.observed!=null&&(n.uint32(24),n.uint64Number(e.observed)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={multiaddr:oe(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.multiaddr=e.bytes();break}case 2:{i.isCertified=e.bool();break}case 3:{i.observed=e.uint64Number();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(hi||(hi={}));var fi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.value!=null&&e.value!==0&&(n.uint32(8),n.uint32(e.value)),e.expiry!=null&&(n.uint32(16),n.uint64(e.expiry)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={value:0},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.value=e.uint32();break}case 2:{i.expiry=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(fi||(fi={}));function wE(r,t){if(r.publicKey!=null||t.publicKey==null)return r;let e;r.type==="RSA"&&(e=r.toMultihash());const n=Vt(t.publicKey,e);return Mr(n)}function bE(r,t,e){const n=en.decode(t);return pr(r,n,e)}function pr(r,t,e){const n=new Map,s=BigInt(Date.now());for(const[i,o]of t.tags.entries())o.expiry!=null&&o.expiry<s||n.set(i,o);return{...t,id:wE(r,t),addresses:t.addresses.filter(({observed:i})=>i!=null&&i>Date.now()-e).map(({multiaddr:i,isCertified:o})=>({multiaddr:X(i),isCertified:o??!1})),metadata:t.metadata,peerRecordEnvelope:t.peerRecordEnvelope??void 0,tags:n}}function EE(r,t){return vE(r.addresses,t.addresses)&&SE(r.protocols,t.protocols)&&xE(r.publicKey,t.publicKey)&&AE(r.peerRecordEnvelope,t.peerRecordEnvelope)&&CE(r.metadata,t.metadata)&&_E(r.tags,t.tags)}function vE(r,t){return mf(r,t,(e,n)=>!(e.isCertified!==n.isCertified||!qe(e.multiaddr,n.multiaddr)))}function SE(r,t){return mf(r,t,(e,n)=>e===n)}function xE(r,t){return gf(r,t)}function AE(r,t){return gf(r,t)}function CE(r,t){return pf(r,t,(e,n)=>qe(e,n))}function _E(r,t){return pf(r,t,(e,n)=>e.value===n.value&&e.expiry===n.expiry)}function gf(r,t){return r==null&&t==null?!0:r!=null&&t!=null?qe(r,t):!1}function mf(r,t,e){if(r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(!e(r[n],t[n]))return!1;return!0}function pf(r,t,e){if(r.size!==t.size)return!1;for(const[n,s]of r.entries()){const i=t.get(n);if(i==null||!e(s,i))return!1}return!0}const yt="/",yf=new TextEncoder().encode(yt),bs=yf[0];class $e{constructor(t,e){l(this,"_buf");if(typeof t=="string")this._buf=Y(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==bs)throw new Error("Invalid key")}toString(t="utf8"){return Z(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new $e(t.join(yt))}static random(){return new $e(Math.random().toString().substring(2))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new $e(t):typeof t.uint8Array=="function"?new $e(t.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=yf),this._buf[0]!==bs){const t=new Uint8Array(this._buf.byteLength+1);t.fill(bs,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===bs;)this._buf=this._buf.subarray(0,-1)}less(t){const e=this.list(),n=t.list();for(let s=0;s<e.length;s++){if(n.length<s+1)return!1;const i=e[s],o=n[s];if(i<o)return!0;if(i>o)return!1}return e.length<n.length}reverse(){return $e.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(yt).slice(1)}type(){return IE(this.baseNamespace())}name(){return TE(this.baseNamespace())}instance(t){return new $e(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(yt)||(t+=yt),t+=this.type(),new $e(t)}parent(){const t=this.list();return t.length===1?new $e(yt):new $e(t.slice(0,-1).join(yt))}child(t){return this.toString()===yt?t:t.toString()===yt?this:new $e(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return $e.withNamespaces([...this.namespaces(),...LE(t.map(e=>e.namespaces()))])}}function IE(r){const t=r.split(":");return t.length<2?"":t.slice(0,-1).join(":")}function TE(r){const t=r.split(":");return t[t.length-1]}function LE(r){return[].concat(...r)}const wf="/peers/";function Es(r){if(!vr(r)||r.type==null)throw new W("Invalid PeerId");const t=r.toCID().toString();return new $e(`${wf}${t}`)}async function DE(r,t,e,n,s){const i=new Map;for(const o of e){if(o==null)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=X(o.multiaddr)),!Hi(o.multiaddr))throw new W("Multiaddr was invalid");if(!await t(r,o.multiaddr,s))continue;const a=o.isCertified??!1,c=o.multiaddr.toString(),u=i.get(c);u!=null?o.isCertified=u.isCertified||a:i.set(c,{multiaddr:o.multiaddr,isCertified:a})}return[...i.values()].sort((o,a)=>o.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({isCertified:o,multiaddr:a})=>{var u;const c=(u=a.getComponents().find(d=>d.code===V))==null?void 0:u.value;return r.equals(c)&&(a=a.decapsulate(X(`/p2p/${r}`))),{isCertified:o,multiaddr:a.bytes}})}async function So(r,t,e,n){var f,p;if(t==null)throw new W("Invalid PeerData");if(t.publicKey!=null&&r.publicKey!=null&&!t.publicKey.equals(r.publicKey))throw new W("publicKey bytes do not match peer id publicKey bytes");const s=(f=n.existingPeer)==null?void 0:f.peer;if(s!=null&&!r.equals(s.id))throw new W("peer id did not match existing peer id");let i=(s==null?void 0:s.addresses)??[],o=new Set((s==null?void 0:s.protocols)??[]),a=(s==null?void 0:s.metadata)??new Map,c=(s==null?void 0:s.tags)??new Map,u=s==null?void 0:s.peerRecordEnvelope;if(e==="patch"){if((t.multiaddrs!=null||t.addresses!=null)&&(i=[],t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses)),t.protocols!=null&&(o=new Set(t.protocols)),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);a=vs(g,{validate:hl})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags);c=vs(g,{validate:fl,map:gl})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}if(e==="merge"){if(t.multiaddrs!=null&&i.push(...t.multiaddrs.map(g=>({isCertified:!1,multiaddr:g}))),t.addresses!=null&&i.push(...t.addresses),t.protocols!=null&&(o=new Set([...o,...t.protocols])),t.metadata!=null){const g=t.metadata instanceof Map?[...t.metadata.entries()]:Object.entries(t.metadata);for(const[y,m]of g)m==null?a.delete(y):a.set(y,m);a=vs([...a.entries()],{validate:hl})}if(t.tags!=null){const g=t.tags instanceof Map?[...t.tags.entries()]:Object.entries(t.tags),y=new Map(c);for(const[m,S]of g)S==null?y.delete(m):y.set(m,S);c=vs([...y.entries()],{validate:fl,map:gl})}t.peerRecordEnvelope!=null&&(u=t.peerRecordEnvelope)}let d;(s==null?void 0:s.id.publicKey)!=null?d=xt(s.id.publicKey):t.publicKey!=null?d=xt(t.publicKey):r.publicKey!=null&&(d=xt(r.publicKey));const h={addresses:await DE(r,n.addressFilter??(async()=>!0),i,(p=n.existingPeer)==null?void 0:p.peerPB.addresses,n),protocols:[...o.values()].sort((g,y)=>g.localeCompare(y)),metadata:a,tags:c,publicKey:d,peerRecordEnvelope:u};return h.addresses.forEach(g=>{var y,m,S;g.observed=((S=(m=(y=n.existingPeer)==null?void 0:y.peerPB.addresses)==null?void 0:m.find(v=>qe(v.multiaddr,v.multiaddr)))==null?void 0:S.observed)??Date.now()}),r.type!=="RSA"&&delete h.publicKey,h}function vs(r,t){var n;const e=new Map;for(const[s,i]of r)i!=null&&t.validate(s,i);for(const[s,i]of r.sort(([o],[a])=>o.localeCompare(a)))i!=null&&e.set(s,((n=t.map)==null?void 0:n.call(t,s,i))??i);return e}function hl(r,t){if(typeof r!="string")throw new W("Metadata key must be a string");if(!(t instanceof Uint8Array))throw new W("Metadata value must be a Uint8Array")}function fl(r,t){if(typeof r!="string")throw new W("Tag name must be a string");if(t.value!=null){if(parseInt(`${t.value}`,10)!==t.value)throw new W("Tag value must be an integer");if(t.value<0||t.value>100)throw new W("Tag value must be between 0-100")}if(t.ttl!=null){if(parseInt(`${t.ttl}`,10)!==t.ttl)throw new W("Tag ttl must be an integer");if(t.ttl<0)throw new W("Tag ttl must be between greater than 0")}}function gl(r,t){let e;t.expiry!=null&&(e=t.expiry),t.ttl!=null&&(e=BigInt(Date.now()+Number(t.ttl)));const n={value:t.value??0};return e!=null&&(n.expiry=e),n}function bf(r){const t=r.toString().split("/")[2],e=ge.parse(t,Ut);return ns(e)}function xo(r,t,e){const n=bf(r);return bE(n,t,e)}function PE(r,t){return{prefix:wf,filters:(r.filters??[]).map(e=>({key:n,value:s})=>e(xo(n,s,t))),orders:(r.orders??[]).map(e=>(n,s)=>e(xo(n.key,n.value,t),xo(s.key,s.value,t)))}}var Ye,Rs,ks,Ms;class RE{constructor(t,e={}){he(this,Ye);l(this,"peerId");l(this,"datastore");l(this,"locks");l(this,"addressFilter");l(this,"log");l(this,"maxAddressAge");l(this,"maxPeerAge");this.log=t.logger.forComponent("libp2p:peer-store"),this.peerId=t.peerId,this.datastore=t.datastore,this.addressFilter=e.addressFilter,this.locks=j0({name:"libp2p_peer_store_locks",metrics:t.metrics}),this.maxAddressAge=e.maxAddressAge??pE,this.maxPeerAge=e.maxPeerAge??yE}getLock(t){let e=this.locks.get(t);return e==null&&(e={refs:0,lock:mE({name:t.toString(),singleProcess:!0})},this.locks.set(t,e)),e.refs++,e}maybeRemoveLock(t,e){e.refs--,e.refs===0&&(e.lock.finalize(),this.locks.delete(t))}async getReadLock(t,e){const n=this.getLock(t);try{const s=await n.lock.readLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async getWriteLock(t,e){const n=this.getLock(t);try{const s=await n.lock.writeLock(e);return()=>{s(),this.maybeRemoveLock(t,n)}}catch(s){throw this.maybeRemoveLock(t,n),s}}async has(t,e){try{return await this.load(t,e),!0}catch(n){if(n.name!=="NotFoundError")throw n}return!1}async delete(t,e){this.peerId.equals(t)||await this.datastore.delete(Es(t),e)}async load(t,e){const n=Es(t),s=await this.datastore.get(n,e),i=en.decode(s);if(H(this,Ye,Ms).call(this,t,i))throw await this.datastore.delete(n,e),new $o;return pr(t,i,this.peerId.equals(t)?1/0:this.maxAddressAge)}async save(t,e,n){const s=await H(this,Ye,Rs).call(this,t,n),i=await So(t,e,"patch",{...n,addressFilter:this.addressFilter});return H(this,Ye,ks).call(this,t,i,s)}async patch(t,e,n){const s=await H(this,Ye,Rs).call(this,t,n),i=await So(t,e,"patch",{...n,addressFilter:this.addressFilter,existingPeer:s});return H(this,Ye,ks).call(this,t,i,s)}async merge(t,e,n){const s=await H(this,Ye,Rs).call(this,t,n),i=await So(t,e,"merge",{addressFilter:this.addressFilter,existingPeer:s});return H(this,Ye,ks).call(this,t,i,s)}async*all(t){for await(const{key:e,value:n}of this.datastore.query(PE(t??{},this.maxAddressAge),t)){const s=bf(e);if(s.equals(this.peerId))continue;const i=en.decode(n);if(H(this,Ye,Ms).call(this,s,i)){await this.datastore.delete(e,t);continue}yield pr(s,i,this.peerId.equals(s)?1/0:this.maxAddressAge)}}}Ye=new WeakSet,Rs=async function(t,e){try{const n=Es(t),s=await this.datastore.get(n,e),i=en.decode(s);if(H(this,Ye,Ms).call(this,t,i))throw await this.datastore.delete(n,e),new $o;return{peerPB:i,peer:pr(t,i,this.maxAddressAge)}}catch(n){n.name!=="NotFoundError"&&this.log.error("invalid peer data found in peer store - %e",n)}},ks=async function(t,e,n,s){e.updated=Date.now();const i=en.encode(e);return await this.datastore.put(Es(t),i,s),{peer:pr(t,e,this.maxAddressAge),previous:n==null?void 0:n.peer,updated:n==null||!EE(e,n.peerPB)}},Ms=function(t,e){if(e.updated==null)return!0;if(this.peerId.equals(t))return!1;const n=e.updated<Date.now()-this.maxPeerAge,s=Date.now()-this.maxAddressAge,i=e.addresses.filter(o=>o.observed!=null&&o.observed>s);return n&&i.length===0};var yu,Rn,Ns;yu=Symbol.toStringTag;class kE{constructor(t,e={}){he(this,Rn);l(this,"store");l(this,"events");l(this,"peerId");l(this,"log");l(this,yu,"@libp2p/peer-store");this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new RE(t,e)}async forEach(t,e){for await(const n of this.store.all(e))t(n)}async all(t){return aa(this.store.all(t))}async delete(t,e){const n=await this.store.getReadLock(t,e);try{await this.store.delete(t,e)}finally{n()}}async has(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.has(t,e)}finally{this.log.trace("has release read lock"),n==null||n()}}async get(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.load(t,e)}finally{n==null||n()}}async getInfo(t,e){const n=await this.get(t,e);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:s})=>s)}}async save(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.save(t,e,n);return H(this,Rn,Ns).call(this,t,i),i.peer}finally{s==null||s()}}async patch(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.patch(t,e,n);return H(this,Rn,Ns).call(this,t,i),i.peer}finally{s==null||s()}}async merge(t,e,n){const s=await this.store.getWriteLock(t,n);try{const i=await this.store.merge(t,e,n);return H(this,Rn,Ns).call(this,t,i),i.peer}finally{s==null||s()}}async consumePeerRecord(t,e,n){const s=vr(e)?e:vr(e==null?void 0:e.expectedPeer)?e.expectedPeer:void 0,i=vr(e)||e===void 0?n:e,o=await fn.openAndCertify(t,At.DOMAIN,i),a=ns(o.publicKey.toCID());if((s==null?void 0:s.equals(a))===!1)return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",s,a),!1;const c=At.createFromProtobuf(o.payload);let u;try{u=await this.get(a,i)}catch(d){if(d.name!=="NotFoundError")throw d}if((u==null?void 0:u.peerRecordEnvelope)!=null){const d=fn.createFromProtobuf(u.peerRecordEnvelope),h=At.createFromProtobuf(d.payload);if(h.seqNumber>=c.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",h.seqNumber,c.seqNumber),!1}return await this.patch(c.peerId,{peerRecordEnvelope:t,addresses:c.multiaddrs.map(d=>({isCertified:!0,multiaddr:d}))},i),!0}}Rn=new WeakSet,Ns=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};function ME(r,t={}){return new kE(r,t)}const Sn=class Sn extends Error{constructor(e="Not Found"){super(e);l(this,"name",Sn.name);l(this,"code",Sn.code)}};l(Sn,"name","NotFoundError"),l(Sn,"code","ERR_NOT_FOUND");let ca=Sn;function NE(r){return r[Symbol.asyncIterator]!=null}function ml(r){if(NE(r))return(async()=>{for await(const t of r);})();for(const t of r);}function OE(r){const[t,e]=r[Symbol.asyncIterator]!=null?[r[Symbol.asyncIterator](),Symbol.asyncIterator]:[r[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>t.next(),push:s=>{n.push(s)},next:()=>n.length>0?{done:!1,value:n.shift()}:t.next(),[e](){return this}}}function FE(r){return r[Symbol.asyncIterator]!=null}function wn(r,t){let e=0;if(FE(r))return async function*(){for await(const c of r)await t(c,e++)&&(yield c)}();const n=OE(r),{value:s,done:i}=n.next();if(i===!0)return function*(){}();const o=t(s,e++);if(typeof o.then=="function")return async function*(){await o&&(yield s);for(const c of n)await t(c,e++)&&(yield c)}();const a=t;return function*(){o===!0&&(yield s);for(const c of n)a(c,e++)&&(yield c)}()}function BE(r){return r[Symbol.asyncIterator]!=null}function pl(r,t){return BE(r)?async function*(){yield*(await aa(r)).sort(t)}():function*(){yield*aa(r).sort(t)}()}function $E(r){return r[Symbol.asyncIterator]!=null}function yl(r,t){return $E(r)?async function*(){let e=0;if(!(t<1)){for await(const n of r)if(yield n,e++,e===t)return}}():function*(){let e=0;if(!(t<1)){for(const n of r)if(yield n,e++,e===t)return}}()}class UE{put(t,e,n){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:n,value:s}of t)await this.put(n,s,e),yield n}async*getMany(t,e={}){for await(const n of t)yield{key:n,value:await this.get(n,e)}}async*deleteMany(t,e={}){for await(const n of t)await this.delete(n,e),yield n}batch(){let t=[],e=[];return{put(n,s){t.push({key:n,value:s})},delete(n){e.push(n)},commit:async n=>{await ml(this.putMany(t,n)),t=[],await ml(this.deleteMany(e,n)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let n=this._all(t,e);if(t.prefix!=null){const s=t.prefix;n=wn(n,i=>i.key.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>wn(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>pl(s,i),n)),t.offset!=null){let s=0;const i=t.offset;n=wn(n,()=>s++>=i)}return t.limit!=null&&(n=yl(n,t.limit)),n}queryKeys(t,e){let n=this._allKeys(t,e);if(t.prefix!=null){const s=t.prefix;n=wn(n,i=>i.toString().startsWith(s))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((s,i)=>wn(s,i),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((s,i)=>pl(s,i),n)),t.offset!=null){const s=t.offset;let i=0;n=wn(n,()=>i++>=s)}return t.limit!=null&&(n=yl(n,t.limit)),n}}class zE extends UE{constructor(){super();l(this,"data");this.data=new Map}put(e,n,s){var i;return(i=s==null?void 0:s.signal)==null||i.throwIfAborted(),this.data.set(e.toString(),n),e}get(e,n){var i;(i=n==null?void 0:n.signal)==null||i.throwIfAborted();const s=this.data.get(e.toString());if(s==null)throw new ca;return s}has(e,n){var s;return(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.has(e.toString())}delete(e,n){var s;(s=n==null?void 0:n.signal)==null||s.throwIfAborted(),this.data.delete(e.toString())}*_all(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const[o,a]of this.data.entries())yield{key:new $e(o),value:a},(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}*_allKeys(e,n){var s,i;(s=n==null?void 0:n.signal)==null||s.throwIfAborted();for(const o of this.data.keys())yield new $e(o),(i=n==null?void 0:n.signal)==null||i.throwIfAborted()}}const ce=r=>({match:t=>{const e=t[0];return e==null||e.code!==r||e.value!=null?!1:t.slice(1)}}),q=(r,t)=>({match:e=>{const n=e[0];return(n==null?void 0:n.code)!==r||n.value==null||t!=null&&n.value!==t?!1:e.slice(1)}}),qE=r=>({match:t=>r.match(t)===!1?t:!1}),j=r=>({match:t=>{const e=r.match(t);return e===!1?t:e}}),Ke=(...r)=>({match:t=>{let e;for(const n of r){const s=n.match(t);s!==!1&&(e==null||s.length<e.length)&&(e=s)}return e??!1}}),ie=(...r)=>({match:t=>{for(const e of r){const n=e.match(t);if(n===!1)return!1;t=n}return t}});function ue(...r){function t(s){if(s==null)return!1;let i=s.getComponents();for(const o of r){const a=o.match(i);if(a===!1)return!1;i=a}return i}function e(s){return t(s)!==!1}function n(s){const i=t(s);return i===!1?!1:i.length===0}return{matchers:r,matches:e,exactMatch:n}}const KE=q(V),VE=ue(KE),Yi=q(Mh),Xi=q(Nh),Qi=q(Oh),hc=q(kh);ue(Yi,j(q(V)));ue(Xi,j(q(V)));ue(Qi,j(q(V)));ue(Ke(hc,Qi,Yi,Xi),j(q(V)));const Ef=ie(q(ai),j(q(ac))),vf=ie(j(q(oc)),q(Yn),j(q(ac))),fc=Ke(Ef,vf),gn=Ke(fc,hc,Yi,Xi,Qi),WE=ue(Ke(fc,ie(Ke(hc,Qi,Yi,Xi),j(q(V))))),wl=ue(Ef),bl=ue(vf);ue(fc);const gc=ie(gn,q(_n)),rs=ie(gn,q(Rh)),gi=ue(ie(gc,j(q(V))));ue(rs);const mc=ie(rs,ce(Bh),j(q(V))),Zi=ie(rs,ce($h),j(q(V))),HE=Ke(mc,Zi);ue(mc);const GE=ue(Zi),la=Ke(gn,gc,rs,mc,Zi),Sf=Ke(ie(la,ce(cc),j(q(V)))),mi=ue(Sf),xf=Ke(ie(la,ce(zh),j(q(V))),ie(la,ce(In),j(q(ci)),ce(cc),j(q(V)))),ua=ue(xf),Af=ie(rs,ce(qh),j(q(Ur)),j(q(Ur)),j(q(V))),El=ue(Af),Cf=ie(Zi,ce(Uh),j(q(Ur)),j(q(Ur)),j(q(V))),vl=ue(Cf),pi=Ke(Sf,xf,ie(gc,j(q(V))),ie(HE,j(q(V))),ie(gn,j(q(V))),Af,Cf,q(V)),pc=ue(pi),YE=ie(j(pi),ce(sr),qE(ce(Ir)),j(q(V))),Qn=ue(YE),XE=Ke(ie(pi,ce(sr),ce(Ir),j(q(V))),ie(pi,ce(Ir),j(q(V))),ie(ce(Ir),j(q(V)))),da=ue(XE),QE=Ke(ie(gn,q(_n),ce(Tn),j(q(V))),ie(gn,ce(Tn),j(q(V))));ue(QE);const ZE=ie(gn,Ke(ie(q(_n,"443"),ce(Tn)),ie(q(_n),ce(na)),ie(q(_n),ce(In),ce(Tn)),ie(ce(In),ce(Tn)),ce(In),ce(na)),j(q(V)));ue(ZE);const JE=Ke(ie(q(Kh),j(q(V))));ue(JE);const jE=Ke(ie(q(Fh),j(q(V))));ue(jE);const Sl=864e13;class ev{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=It({name:"libp2p_address_manager_dns_mappings",metrics:t.metrics})}has(t){const e=me(t);let n=e.host;(e.type==="ip4"||e.type==="ip6")&&e.sni!=null&&(n=e.sni);for(const s of this.mappings.values())if(s.domain===n)return!0;return!1}add(t,e){e.forEach(n=>{this.log("add DNS mapping %s to %s",n,t);const s=sc(n)===!0;this.mappings.set(n,{domain:t,verified:s,expires:s?Sl-Date.now():0,lastVerified:s?Sl-Date.now():void 0})})}remove(t){const e=me(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries())i.domain===e.sni&&(this.log("removing %s to %s DNS mapping %e",s,i.domain),this.mappings.delete(s),n=n||i.verified);return n}getAll(t){const e=[];for(let n=0;n<t.length;n++){const s=t[n].multiaddr;if(!at(s))continue;const i=me(s);for(const[o,a]of this.mappings.entries()){if(i.host!==o)continue;const c=this.maybeAddSNIComponent(s,a.domain);c!=null&&(t.splice(n,1),n--,e.push({multiaddr:c,verified:a.verified,type:"dns-mapping",expires:a.expires,lastVerified:a.lastVerified}))}}return e}maybeAddSNIComponent(t,e){var s;const n=t.getComponents();for(let i=0;i<n.length;i++)if(n[i].code===In&&((s=n[i+1])==null?void 0:s.code)!==ci)return n.splice(i+1,0,{name:"sni",code:ci,value:e}),X(n)}confirm(t,e){const n=me(t);let s=n.host;(n.type==="ip4"||n.type==="ip6")&&n.sni!=null&&(s=n.sni);let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("marking %s to %s DNS mapping as verified",o,a.domain),i=a.verified,a.verified=!0,a.expires=Date.now()+e,a.lastVerified=Date.now());return i}unconfirm(t,e){const n=me(t);if(n.type!=="ip4"&&n.type!=="ip6")return!1;const s=n.sni??n.host;let i=!1;for(const[o,a]of this.mappings.entries())a.domain===s&&(this.log("removing verification of %s to %s DNS mapping",o,a.domain),i=i||a.verified,a.verified=!1,a.expires=Date.now()+e);return i}}class tv{constructor(t,e={}){l(this,"log");l(this,"mappings");this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=It({name:"libp2p_address_manager_ip_mappings",metrics:t.metrics})}has(t){const e=me(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;for(const n of this.mappings.values())for(const s of n)if(s.externalIp===e.host)return!0;return!1}add(t,e,n,s=e,i="tcp"){const o=`${t}-${e}-${i}`,a=this.mappings.get(o)??[],c={internalIp:t,internalPort:e,externalIp:n,externalPort:s,externalFamily:Wn(n)?4:6,protocol:i,verified:!1,expires:0};a.push(c),this.mappings.set(o,a)}remove(t){const e=me(t);if(e.type!=="ip4"&&e.type!=="ip6")return!1;let n=!1;for(const[s,i]of this.mappings.entries()){for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===e.host&&a.externalPort===e.port&&a.protocol===e.protocol&&(this.log("removing %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,e.host,e.port,e.protocol),n=n||a.verified,i.splice(o,1),o--)}i.length===0&&this.mappings.delete(s)}return n}getAll(t){const e=[];for(const{multiaddr:n}of t){if(!at(n))continue;const s=me(n);if(s.type!=="ip4"&&s.type!=="ip6")continue;let i;if(s.protocol==="tcp"?i=`${s.host}-${s.port}-tcp`:s.protocol==="udp"&&(i=`${s.host}-${s.port}-udp`),i==null)continue;const o=this.mappings.get(i);if(o!=null)for(const a of o)e.push({multiaddr:this.maybeOverrideIp(n,a.externalIp,a.externalFamily,a.protocol,a.externalPort),verified:a.verified,type:"ip-mapping",expires:a.expires,lastVerified:a.lastVerified})}return e}maybeOverrideIp(t,e,n,s,i){const o=t.getComponents(),a=o.findIndex(u=>u.code===ai||u.code===Yn),c=o.findIndex(u=>u.name===s);return a>-1&&c>-1?(o[a].value=e,o[a].code=n===4?ai:Yn,o[c].value=`${i}`,X(o)):t}confirm(t,e){if(!at(t))return!1;const n=me(t);let s=!1;for(const i of this.mappings.values())for(const o of i)o.externalIp===n.host&&(this.log("marking %s to %s IP mapping as verified",o.internalIp,o.externalIp),s=o.verified,o.verified=!0,o.expires=Date.now()+e,o.lastVerified=Date.now());return s}unconfirm(t,e){if(!at(t))return!1;const n=me(t);let s=!1;for(const i of this.mappings.values())for(let o=0;o<i.length;o++){const a=i[o];a.externalIp===n.host&&a.externalPort===n.port&&a.protocol===n.protocol&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",a.externalIp,a.externalPort,n.host,n.port,n.protocol),s=s||a.verified,a.verified=!1,a.expires=Date.now()+e)}return s}}const nv={maxObservedAddresses:10};class rv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=It({name:"libp2p_address_manager_observed_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??nv.maxObservedAddresses}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(Hn(t)||mb(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:X(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var n;const e=((n=this.addresses.get(t.toString()))==null?void 0:n.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),e}confirm(t,e){const n=t.toString(),s=this.addresses.get(n)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,s),i}}const sv={maxObservedAddresses:10};class iv{constructor(t,e={}){l(this,"log");l(this,"addresses");l(this,"maxObservedAddresses");this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=It({name:"libp2p_address_manager_transport_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??sv.maxObservedAddresses}get(t,e){if(Hn(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const n=this.toKey(t);let s=this.addresses.get(n);return s==null&&(s={verified:!at(t),expires:0},this.addresses.set(n,s)),{multiaddr:t,verified:s.verified,type:"transport",expires:s.expires,lastVerified:s.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var s;const e=this.toKey(t),n=((s=this.addresses.get(e))==null?void 0:s.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(e),n}confirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},i=s.verified;return s.verified=!0,s.expires=Date.now()+e,s.lastVerified=Date.now(),this.addresses.set(n,s),i}unconfirm(t,e){const n=this.toKey(t),s=this.addresses.get(n)??{verified:!1,expires:0},i=s.verified;return s.verified=!1,s.expires=Date.now()+e,this.addresses.set(n,s),i}toKey(t){if(!at(t))return t.toString();const e=me(t);return`${e.host}-${e.port}-${e.protocol}`}}const xl=6e4,Al={addressVerificationTTL:xl*10,addressVerificationRetry:xl*5},ov=r=>r;function Ao(r,t){var n;const e=(n=r.getComponents().findLast(s=>s.code===V))==null?void 0:n.value;return e!=null&&ct(e).equals(t)&&(r=r.decapsulate(X(`/p2p/${t.toString()}`))),r}var wu;wu=Symbol.toStringTag;class av{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"listen");l(this,"announce");l(this,"appendAnnounce");l(this,"announceFilter");l(this,"observed");l(this,"dnsMappings");l(this,"ipMappings");l(this,"transportAddresses");l(this,"observedAddressFilter");l(this,"addressVerificationTTL");l(this,"addressVerificationRetry");l(this,wu,"@libp2p/address-manager");const{listen:n=[],announce:s=[],appendAnnounce:i=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=n.map(o=>o.toString()),this.announce=new Set(s.map(o=>o.toString())),this.appendAnnounce=new Set(i.map(o=>o.toString())),this.observed=new rv(t,e),this.dnsMappings=new ev(t,e),this.ipMappings=new tv(t,e),this.transportAddresses=new iv(t,e),this.announceFilter=e.announceFilter??ov,this.observedAddressFilter=Fr(1024),this.addressVerificationTTL=e.addressVerificationTTL??Al.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??Al.addressVerificationRetry,this._updatePeerStoreAddresses=ii(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(e=>{var n;return((n=e.getComponents().findLast(s=>s.code===V))==null?void 0:n.value)===this.components.peerId.toString()?e.decapsulate(`/p2p/${this.components.peerId.toString()}`):e});this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(e=>{this.log.error("error updating addresses - %e",e)})}getListenAddrs(){return Array.from(this.listen).map(t=>X(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>X(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>X(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=me(t);let n;switch(e.type){case"ip4":{n=`${e.host}:${e.port}`;break}case"ip6":{n=`[${e.host}]:${e.port}`;break}default:return}this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),t=Ao(t,this.components.peerId),!this.ipMappings.has(t)&&(this.dnsMappings.has(t)||this.observed.add(t)))}confirmObservedAddr(t,e){t=Ao(t,this.components.peerId);let n=!0;((e==null?void 0:e.type)==="transport"||this.transportAddresses.has(t))&&!this.transportAddresses.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="dns-mapping"||this.dnsMappings.has(t))&&!this.dnsMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="ip-mapping"||this.ipMappings.has(t))&&!this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1),((e==null?void 0:e.type)==="observed"||this.observed.has(t))&&(this.maybeUpgradeToIPMapping(t)?(this.ipMappings.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL),n=!1):!this.observed.confirm(t,(e==null?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)),n||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=Ao(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(e==null?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(n=>{if(!n.verified)return!1;const s=n.multiaddr.toString();return t.has(s)?!1:(t.add(s),!0)}).map(n=>n.multiaddr);return this.announceFilter(e.map(n=>{const s=X(n),i=s.getComponents().pop();return(i==null?void 0:i.value)===this.components.peerId.toString()?s:s.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(t)}),t.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];e=e.concat(this.components.transportManager.getAddrs().map(s=>this.transportAddresses.get(s,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(s=>{s.updateAnnounceAddrs(n)}),e=e.concat(n.map(s=>({multiaddr:s,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(X(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.add(t,e,n,s,i),this.observed.removePrefixed(`/ip${Wn(n)?4:6}/${n}/${i}/${s}`)}removePublicAddressMapping(t,e,n,s=e,i="tcp"){this.ipMappings.remove(X(`/ip${Wn(n)?4:6}/${n}/${i}/${s}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t)||!at(t))return!1;const e=me(t);if(e.type!=="ip4"||sc(e.host)===!0)return!1;const n=this.components.transportManager.getListeners(),s=[i=>mi.exactMatch(i)||ua.exactMatch(i),i=>gi.exactMatch(i),i=>GE.exactMatch(i)];for(const i of s){if(!i(t))continue;const o=n.filter(u=>u.getAddrs().filter(d=>me(d).type==="ip4"&&i(d)).length>0);if(o.length!==1)continue;const a=o[0].getAddrs().filter(u=>!ta(u)).pop();if(a==null)continue;const c=me(a);return c.port==null?!1:(this.observed.remove(t),this.ipMappings.add(c.host,c.port,e.host,e.port,e.protocol),!0)}return!1}}var Cl;(function(r){r.NOT_STARTED_YET="The libp2p node is not started yet",r.NOT_FOUND="Not found"})(Cl||(Cl={}));class cv extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class lv extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class Co extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class _l extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class uv extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class dv extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class hv extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class Il extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class fv extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class gv extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class mv extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class pv extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class yv extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class Os extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class Ss extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class wv extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class bv extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}class Ev{constructor(t={}){l(this,"components",{});l(this,"_started",!1);this.components={};for(const[e,n]of Object.entries(t))this.components[e]=n;this.components.logger==null&&(this.components.logger=ch())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(e=>Ma(e)).map(async e=>{var n;await((n=e[t])==null?void 0:n.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const vv=["metrics","connectionProtector","dns"],Sv=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function xv(r={}){const t=new Ev(r);return new Proxy(t,{get(n,s,i){if(typeof s=="string"&&!Sv.includes(s)){const o=t.components[s];if(o==null&&!vv.includes(s))throw new cv(`${s} not set`);return o}return Reflect.get(n,s,i)},set(n,s,i){return typeof s=="string"?t.components[s]=i:Reflect.set(n,s,i),!0}})}function Av(r){const t={};for(const e of Object.values(r.components))for(const n of Cv(e))t[n]=!0;for(const e of Object.values(r.components))for(const n of _v(e))if(t[n]!==!0)throw new lv(`Service "${Iv(e)}" required capability "${n}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}function Cv(r){return Array.isArray(r==null?void 0:r[Ct])?r[Ct]:[]}function _v(r){return Array.isArray(r==null?void 0:r[Gs])?r[Gs]:[]}function Iv(r){return(r==null?void 0:r[Symbol.toStringTag])??(r==null?void 0:r.toString())??"unknown"}function Tv(r={}){return r.denyDialMultiaddr==null&&(r.denyDialMultiaddr=t=>mi.matches(t)?!0:Hn(t)),r}class le extends Event{constructor(e,n){super(e);l(this,"type");l(this,"detail");this.type=e,this.detail=n}}function _f(r){var n;if(vr(r))return{peerId:r,multiaddrs:[]};let t=Array.isArray(r)?r:[r],e;if(t.length>0){const s=(n=t[0].getComponents().findLast(i=>i.code===V))==null?void 0:n.value;e=s==null?void 0:ct(s),t.forEach(i=>{var a;if(!Hi(i))throw new Pi("Invalid multiaddr");const o=(a=i.getComponents().findLast(c=>c.code===V))==null?void 0:a.value;if(o==null){if(e!=null)throw new W("Multiaddrs must all have the same peer id or have no peer id")}else{const c=ct(o);if((e==null?void 0:e.equals(c))!==!0)throw new W("Multiaddrs must all have the same peer id or have no peer id")}})}return t=t.filter(s=>!VE.exactMatch(s)),{peerId:e,multiaddrs:t}}const Lv=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];async function Dv(r,t){var s;const e=((s=r==null?void 0:r.streams)==null?void 0:s.map(i=>i.protocol))??[],n=(t==null?void 0:t.closableProtocols)??Lv;if(!(e.filter(i=>i!=null&&!n.includes(i)).length>0))try{await(r==null?void 0:r.close(t))}catch(i){r==null||r.abort(i)}}function ha(r){const t=me(r);let e=t.cidr;if(t.type!=="ip4"&&t.type!=="ip6")throw new W(`Multiaddr ${r} was not an IPv4 or IPv6 address`);if(e==null)switch(t.type){case"ip4":{e=32;break}case"ip6":{e=128;break}default:throw new W(`Multiaddr ${r} was not an IPv4 or IPv6 address`)}return new wh(t.host,e)}function If(r){return!Qn.exactMatch(r)}function Tf(r,t,e){if(r==null||t==null)return;const n=t.sort((i,o)=>i.direct?-1:o.direct?1:0).find(i=>i.limits==null);if(n==null||n.direct||e==null)return n;if(!e.some(i=>If(i)))return n}class Pv{constructor(t,e={}){l(this,"connectionManager");l(this,"peerStore");l(this,"allow");l(this,"events");l(this,"log");this.allow=(e.allow??[]).map(n=>ha(n)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections - %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",e,n),e<=n)return;const s=new rr;for(const c of t){const u=c.remotePeer;if(!s.has(u)){s.set(u,0);try{const d=await this.peerStore.get(u);s.set(u,[...d.tags.values()].reduce((h,f)=>h+f.value,0))}catch(d){d.name!=="NotFoundError"&&this.log.error("error loading peer tags - %e",d)}}}const i=this.sortConnections(t,s),o=Math.max(e-n,0),a=[];for(const c of i)if(this.log("too many connections open - closing a connection to %p",c.remotePeer),this.allow.some(d=>{if(at(c.remoteAddr)){const h=me(c.remoteAddr);return d.contains(h.host)}return!0})||a.push(c),a.length===o)break;await Promise.all(a.map(async c=>{await Dv(c,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:a})}sortConnections(t,e){return t.sort((n,s)=>{const i=n.timeline.open,o=s.timeline.open;return i<o?1:i>o?-1:0}).sort((n,s)=>n.direction==="outbound"&&s.direction==="inbound"?1:n.direction==="inbound"&&s.direction==="outbound"?-1:0).sort((n,s)=>n.streams.length>s.streams.length?1:n.streams.length<s.streams.length?-1:0).sort((n,s)=>{const i=e.get(n.remotePeer)??0,o=e.get(s.remotePeer)??0;return i>o?1:i<o?-1:0})}}const Lf=1e4,Df=1e3,Rv=1e4,yi=1e4,Pf=25,kv=5,Mv=10,Nv=5,Ov="last-dial-failure",Fv="last-dial-success",Rf=500,Bv=32,$v=100,kf=50;function Uv(r,t){const e=gi.exactMatch(r.multiaddr),n=gi.exactMatch(t.multiaddr);if(e&&!n)return-1;if(!e&&n)return 1;const s=ua.exactMatch(r.multiaddr),i=ua.exactMatch(t.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=mi.exactMatch(r.multiaddr),a=mi.exactMatch(t.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const c=da.exactMatch(r.multiaddr),u=da.exactMatch(t.multiaddr);if(c&&!u)return-1;if(!c&&u)return 1;const d=El.exactMatch(r.multiaddr),h=El.exactMatch(t.multiaddr);if(d&&!h)return-1;if(!d&&h)return 1;const f=vl.exactMatch(r.multiaddr),p=vl.exactMatch(t.multiaddr);return f&&!p?-1:!f&&p?1:0}function zv(r,t){const e=ta(r.multiaddr),n=ta(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function qv(r,t){const e=Hn(r.multiaddr),n=Hn(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Kv(r,t){return r.isCertified&&!t.isCertified?-1:!r.isCertified&&t.isCertified?1:0}function Vv(r,t){const e=Qn.exactMatch(r.multiaddr),n=Qn.exactMatch(t.multiaddr);return e&&!n?1:!e&&n?-1:0}function Wv(r){return r.sort(Uv).sort(Kv).sort(Vv).sort(qv).sort(zv)}var Mf={exports:{}};(function(r){var t=Object.prototype.hasOwnProperty,e="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(e=!1));function s(c,u,d){this.fn=c,this.context=u,this.once=d||!1}function i(c,u,d,h,f){if(typeof d!="function")throw new TypeError("The listener must be a function");var p=new s(d,h||c,f),g=e?e+u:u;return c._events[g]?c._events[g].fn?c._events[g]=[c._events[g],p]:c._events[g].push(p):(c._events[g]=p,c._eventsCount++),c}function o(c,u){--c._eventsCount===0?c._events=new n:delete c._events[u]}function a(){this._events=new n,this._eventsCount=0}a.prototype.eventNames=function(){var u=[],d,h;if(this._eventsCount===0)return u;for(h in d=this._events)t.call(d,h)&&u.push(e?h.slice(1):h);return Object.getOwnPropertySymbols?u.concat(Object.getOwnPropertySymbols(d)):u},a.prototype.listeners=function(u){var d=e?e+u:u,h=this._events[d];if(!h)return[];if(h.fn)return[h.fn];for(var f=0,p=h.length,g=new Array(p);f<p;f++)g[f]=h[f].fn;return g},a.prototype.listenerCount=function(u){var d=e?e+u:u,h=this._events[d];return h?h.fn?1:h.length:0},a.prototype.emit=function(u,d,h,f,p,g){var y=e?e+u:u;if(!this._events[y])return!1;var m=this._events[y],S=arguments.length,v,E;if(m.fn){switch(m.once&&this.removeListener(u,m.fn,void 0,!0),S){case 1:return m.fn.call(m.context),!0;case 2:return m.fn.call(m.context,d),!0;case 3:return m.fn.call(m.context,d,h),!0;case 4:return m.fn.call(m.context,d,h,f),!0;case 5:return m.fn.call(m.context,d,h,f,p),!0;case 6:return m.fn.call(m.context,d,h,f,p,g),!0}for(E=1,v=new Array(S-1);E<S;E++)v[E-1]=arguments[E];m.fn.apply(m.context,v)}else{var L=m.length,x;for(E=0;E<L;E++)switch(m[E].once&&this.removeListener(u,m[E].fn,void 0,!0),S){case 1:m[E].fn.call(m[E].context);break;case 2:m[E].fn.call(m[E].context,d);break;case 3:m[E].fn.call(m[E].context,d,h);break;case 4:m[E].fn.call(m[E].context,d,h,f);break;default:if(!v)for(x=1,v=new Array(S-1);x<S;x++)v[x-1]=arguments[x];m[E].fn.apply(m[E].context,v)}}return!0},a.prototype.on=function(u,d,h){return i(this,u,d,h,!1)},a.prototype.once=function(u,d,h){return i(this,u,d,h,!0)},a.prototype.removeListener=function(u,d,h,f){var p=e?e+u:u;if(!this._events[p])return this;if(!d)return o(this,p),this;var g=this._events[p];if(g.fn)g.fn===d&&(!f||g.once)&&(!h||g.context===h)&&o(this,p);else{for(var y=0,m=[],S=g.length;y<S;y++)(g[y].fn!==d||f&&!g[y].once||h&&g[y].context!==h)&&m.push(g[y]);m.length?this._events[p]=m.length===1?m[0]:m:o(this,p)}return this},a.prototype.removeAllListeners=function(u){var d;return u?(d=e?e+u:u,this._events[d]&&o(this,d)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=e,a.EventEmitter=a,r.exports=a})(Mf);var Hv=Mf.exports;const Gv=Eh(Hv);function Yv(r,t,e){let n=0,s=r.length;for(;s>0;){const i=Math.trunc(s/2);let o=n+i;e(r[o],t)<=0?(n=++o,s-=i+1):s=i}return n}var je;class Xv{constructor(){he(this,je,[])}enqueue(t,e){e={priority:0,...e};const n={priority:e.priority,id:e.id,run:t};if(this.size===0||$(this,je)[this.size-1].priority>=e.priority){$(this,je).push(n);return}const s=Yv($(this,je),n,(i,o)=>o.priority-i.priority);$(this,je).splice(s,0,n)}setPriority(t,e){const n=$(this,je).findIndex(i=>i.id===t);if(n===-1)throw new ReferenceError(`No promise function with the id "${t}" exists in the queue.`);const[s]=$(this,je).splice(n,1);this.enqueue(s.run,{priority:e,id:t})}dequeue(){const t=$(this,je).shift();return t==null?void 0:t.run}filter(t){return $(this,je).filter(e=>e.priority===t.priority).map(e=>e.run)}get size(){return $(this,je).length}}je=new WeakMap;var kn,Mn,Ot,Kr,Nn,Vr,et,On,Be,Wr,tt,Fn,vt,Hr,Li,te,Nf,Of,Ff,Bf,$f,Fs,fa,ga,Bs,Uf,$s;class Qv extends Gv{constructor(e){var n,s;super();he(this,te);he(this,kn);he(this,Mn);he(this,Ot,0);he(this,Kr);he(this,Nn);he(this,Vr,0);he(this,et);he(this,On);he(this,Be);he(this,Wr);he(this,tt,0);he(this,Fn);he(this,vt);he(this,Hr);he(this,Li,1n);l(this,"timeout");if(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:Xv,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((n=e.intervalCap)==null?void 0:n.toString())??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((s=e.interval)==null?void 0:s.toString())??""}\` (${typeof e.interval})`);fe(this,kn,e.carryoverConcurrencyCount),fe(this,Mn,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0),fe(this,Kr,e.intervalCap),fe(this,Nn,e.interval),fe(this,Be,new e.queueClass),fe(this,Wr,e.queueClass),this.concurrency=e.concurrency,this.timeout=e.timeout,fe(this,Hr,e.throwOnTimeout===!0),fe(this,vt,e.autoStart===!1)}get concurrency(){return $(this,Fn)}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);fe(this,Fn,e),H(this,te,Bs).call(this)}setPriority(e,n){$(this,Be).setPriority(e,n)}async add(e,n={}){return n.id??(n.id=(ar(this,Li)._++).toString()),n={timeout:this.timeout,throwOnTimeout:$(this,Hr),...n},new Promise((s,i)=>{$(this,Be).enqueue(async()=>{var o;ar(this,tt)._++;try{(o=n.signal)==null||o.throwIfAborted(),ar(this,Ot)._++;let a=e({signal:n.signal});n.timeout&&(a=xh(Promise.resolve(a),{milliseconds:n.timeout})),n.signal&&(a=Promise.race([a,H(this,te,Uf).call(this,n.signal)]));const c=await a;s(c),this.emit("completed",c)}catch(a){if(a instanceof Sh&&!n.throwOnTimeout){s();return}i(a),this.emit("error",a)}finally{H(this,te,Ff).call(this)}},n),this.emit("add"),H(this,te,Fs).call(this)})}async addAll(e,n){return Promise.all(e.map(async s=>this.add(s,n)))}start(){return $(this,vt)?(fe(this,vt,!1),H(this,te,Bs).call(this),this):this}pause(){fe(this,vt,!0)}clear(){fe(this,Be,new($(this,Wr)))}async onEmpty(){$(this,Be).size!==0&&await H(this,te,$s).call(this,"empty")}async onSizeLessThan(e){$(this,Be).size<e||await H(this,te,$s).call(this,"next",()=>$(this,Be).size<e)}async onIdle(){$(this,tt)===0&&$(this,Be).size===0||await H(this,te,$s).call(this,"idle")}get size(){return $(this,Be).size}sizeBy(e){return $(this,Be).filter(e).length}get pending(){return $(this,tt)}get isPaused(){return $(this,vt)}}kn=new WeakMap,Mn=new WeakMap,Ot=new WeakMap,Kr=new WeakMap,Nn=new WeakMap,Vr=new WeakMap,et=new WeakMap,On=new WeakMap,Be=new WeakMap,Wr=new WeakMap,tt=new WeakMap,Fn=new WeakMap,vt=new WeakMap,Hr=new WeakMap,Li=new WeakMap,te=new WeakSet,Nf=function(){return $(this,Mn)||$(this,Ot)<$(this,Kr)},Of=function(){return $(this,tt)<$(this,Fn)},Ff=function(){ar(this,tt)._--,H(this,te,Fs).call(this),this.emit("next")},Bf=function(){H(this,te,ga).call(this),H(this,te,fa).call(this),fe(this,On,void 0)},$f=function(){const e=Date.now();if($(this,et)===void 0){const n=$(this,Vr)-e;if(n<0)fe(this,Ot,$(this,kn)?$(this,tt):0);else return $(this,On)===void 0&&fe(this,On,setTimeout(()=>{H(this,te,Bf).call(this)},n)),!0}return!1},Fs=function(){if($(this,Be).size===0)return $(this,et)&&clearInterval($(this,et)),fe(this,et,void 0),this.emit("empty"),$(this,tt)===0&&this.emit("idle"),!1;if(!$(this,vt)){const e=!$(this,te,$f);if($(this,te,Nf)&&$(this,te,Of)){const n=$(this,Be).dequeue();return n?(this.emit("active"),n(),e&&H(this,te,fa).call(this),!0):!1}}return!1},fa=function(){$(this,Mn)||$(this,et)!==void 0||(fe(this,et,setInterval(()=>{H(this,te,ga).call(this)},$(this,Nn))),fe(this,Vr,Date.now()+$(this,Nn)))},ga=function(){$(this,Ot)===0&&$(this,tt)===0&&$(this,et)&&(clearInterval($(this,et)),fe(this,et,void 0)),fe(this,Ot,$(this,kn)?$(this,tt):0),H(this,te,Bs).call(this)},Bs=function(){for(;H(this,te,Fs).call(this););},Uf=async function(e){return new Promise((n,s)=>{e.addEventListener("abort",()=>{s(e.reason)},{once:!0})})},$s=async function(e,n){return new Promise(s=>{const i=()=>{n&&!n()||(this.off(e,i),s())};this.on(e,i)})};function zf(r){const t=[Wt.A];return r==null?t:Array.isArray(r)?r.length===0?t:r:[r]}const qf=60;function Kf(r){return{Status:r.Status??0,TC:r.TC??r.flag_tc??!1,RD:r.RD??r.flag_rd??!1,RA:r.RA??r.flag_ra??!1,AD:r.AD??r.flag_ad??!1,CD:r.CD??r.flag_cd??!1,Question:(r.Question??r.questions??[]).map(t=>({name:t.name,type:Wt[t.type]})),Answer:(r.Answer??r.answers??[]).map(t=>({name:t.name,type:Wt[t.type],TTL:t.TTL??t.ttl??qf,data:t.data instanceof Uint8Array?Z(t.data):t.data}))}}const Zv=4;function Tl(r,t={}){const e=new Qv({concurrency:t.queryConcurrency??Zv});return async(n,s={})=>{var a;const i=new URLSearchParams;i.set("name",n),zf(s.types).forEach(c=>{i.append("type",Wt[c])}),(a=s.onProgress)==null||a.call(s,new le("dns:query",n));const o=await e.add(async()=>{var d;const c=await fetch(`${r}?${i}`,{headers:{accept:"application/dns-json"},signal:s==null?void 0:s.signal});if(c.status!==200)throw new Error(`Unexpected HTTP status: ${c.status} - ${c.statusText}`);const u=Kf(await c.json());return(d=s.onProgress)==null||d.call(s,new le("dns:response",u)),u},{signal:s.signal});if(o==null)throw new Error("No DNS response received");return o}}function Jv(){return[Tl("https://cloudflare-dns.com/dns-query"),Tl("https://dns.google/resolve")]}var jv=function(r){if(!r)throw Error("hashlru must have a max value, of type number, greater than 0");var t=0,e=Object.create(null),n=Object.create(null);function s(i,o){e[i]=o,t++,t>=r&&(t=0,n=e,e=Object.create(null))}return{has:function(i){return e[i]!==void 0||n[i]!==void 0},remove:function(i){e[i]!==void 0&&(e[i]=void 0),n[i]!==void 0&&(n[i]=void 0)},get:function(i){var o=e[i];if(o!==void 0)return o;if((o=n[i])!==void 0)return s(i,o),o},set:function(i,o){e[i]!==void 0?e[i]=o:s(i,o)},clear:function(){e=Object.create(null),n=Object.create(null)}}};const eS=Eh(jv);class tS{constructor(t){l(this,"lru");this.lru=eS(t)}get(t,e){let n=!0;const s=[];for(const i of e){const o=this.getAnswers(t,i);if(o.length===0){n=!1;break}s.push(...o)}if(n)return Kf({answers:s})}getAnswers(t,e){const n=`${t.toLowerCase()}-${e}`,s=this.lru.get(n);if(s!=null){const i=s.filter(o=>o.expires>Date.now()).map(({expires:o,value:a})=>({...a,TTL:Math.round((o-Date.now())/1e3),type:Wt[a.type]}));return i.length===0&&this.lru.remove(n),i}return[]}add(t,e){const n=`${t.toLowerCase()}-${e.type}`,s=this.lru.get(n)??[];s.push({expires:Date.now()+(e.TTL??qf)*1e3,value:e}),this.lru.set(n,s)}remove(t,e){const n=`${t.toLowerCase()}-${e}`;this.lru.remove(n)}clear(){this.lru.clear()}}function nS(r){return new tS(r)}const rS=1e3;class sS{constructor(t){l(this,"resolvers");l(this,"cache");this.resolvers={},this.cache=nS(t.cacheSize??rS),Object.entries(t.resolvers??{}).forEach(([e,n])=>{Array.isArray(n)||(n=[n]),e.endsWith(".")||(e=`${e}.`),this.resolvers[e]=n}),this.resolvers["."]==null&&(this.resolvers["."]=Jv())}async query(t,e={}){var c,u,d;const n=zf(e.types),s=e.cached!==!1?this.cache.get(t,n):void 0;if(s!=null)return(c=e.onProgress)==null||c.call(e,new le("dns:cache",s)),s;const i=`${t.split(".").pop()}.`,o=(this.resolvers[i]??this.resolvers["."]).sort(()=>Math.random()>.5?-1:1),a=[];for(const h of o){if(((u=e.signal)==null?void 0:u.aborted)===!0)break;try{const f=await h(t,{...e,types:n});for(const p of f.Answer)this.cache.add(t,p);return f}catch(f){a.push(f),(d=e.onProgress)==null||d.call(e,new le("dns:error",f))}}throw a.length===1?a[0]:new AggregateError(a,`DNS lookup of ${t} ${n} failed`)}}var Wt;(function(r){r[r.A=1]="A",r[r.CNAME=5]="CNAME",r[r.TXT=16]="TXT",r[r.AAAA=28]="AAAA"})(Wt||(Wt={}));function iS(r={}){return new sS(r)}class oS{constructor(){l(this,"dns")}canResolve(t){return t.getComponents().some(({name:e})=>e==="dnsaddr")}async resolve(t,e){var c,u;const n=(c=t.getComponents().find(d=>d.name==="dnsaddr"))==null?void 0:c.value;if(n==null)return[t];const i=await this.getDNS(e).query(`_dnsaddr.${n}`,{signal:e==null?void 0:e.signal,types:[Wt.TXT]}),o=(u=t.getComponents().find(d=>d.name==="p2p"))==null?void 0:u.value,a=[];for(const d of i.Answer){const h=d.data.replace(/["']/g,"").trim().split("=")[1];h!=null&&(o!=null&&!h.includes(o)||a.push(X(h)))}return a}getDNS(t){return t.dns!=null?t.dns:(this.dns==null&&(this.dns=iS()),this.dns)}}const Vf=new oS;async function Wf(r,t,e){const n=e.depth??0;if(n>(e.maxRecursiveDepth??Bv))throw new bv("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(t))if(o.canResolve(r)){s=!0;const a=await o.resolve(r,e);for(const c of a)i.push(...await Wf(c,t,{...e,depth:n+1}))}return s===!1&&i.push(r),i}const fr={maxParallelDials:kf,maxDialQueueLength:Rf,maxPeerAddrsToDial:Pf,dialTimeout:Lf,resolvers:{dnsaddr:Vf}};class aS{constructor(t,e={}){l(this,"queue");l(this,"components");l(this,"addressSorter");l(this,"maxPeerAddrsToDial");l(this,"maxDialQueueLength");l(this,"dialTimeout");l(this,"shutDownController");l(this,"connections");l(this,"log");l(this,"resolvers");this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??fr.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??fr.maxDialQueueLength,this.dialTimeout=e.dialTimeout??fr.dialTimeout,this.connections=e.connections??new rr,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.resolvers=e.resolvers??fr.resolvers,this.shutDownController=new AbortController,this.shutDownController.signal,this.queue=new W0({concurrency:e.maxParallelDials??fr.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("failure",n=>{var s;((s=n.detail)==null?void 0:s.error.name)!==Lr.name&&this.log.error("error in dial queue - %e",n.detail.error)})}start(){this.shutDownController=new AbortController,this.shutDownController.signal}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var o,a,c;const{peerId:n,multiaddrs:s}=_f(t);if(n!=null&&e.force!==!0){const u=Tf(n,this.connections.get(n),s);if(u!=null)return this.log("already connected to %a",u.remoteAddr),(o=e.onProgress)==null||o.call(e,new le("dial-queue:already-connected")),u}const i=this.queue.queue.find(u=>{if((n==null?void 0:n.equals(u.options.peerId))===!0)return!0;const d=u.options.multiaddrs;if(d==null)return!1;for(const h of s)if(d.has(h.toString()))return!0;return!1});if(i!=null){this.log("joining existing dial target for %p",n);for(const u of s)i.options.multiaddrs.add(u.toString());return(a=e.onProgress)==null||a.call(e,new le("dial-queue:already-in-dial-queue")),i.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new Er("Dial queue is full");return this.log("creating dial target for %p",n,s.map(u=>u.toString())),(c=e.onProgress)==null||c.call(e,new le("dial-queue:add-to-dial-queue")),this.queue.add(async u=>{var h;(h=u.onProgress)==null||h.call(u,new le("dial-queue:start-dial"));const d=dn([this.shutDownController.signal,u.signal]);try{return await this.dialPeer(u,d)}finally{d.clear()}},{peerId:n,priority:e.priority??Hf,multiaddrs:new Set(s.map(u=>u.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var d;const n=t.peerId,s=t.multiaddrs,i=new Set;let o=t.multiaddrs.size===0,a=0,c=0;const u=[];for(this.log("starting dial to %p",n);o||s.size>0;){c++,o=!1;const h=[],f=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",n,[...f]);const p=await this.calculateMultiaddrs(n,f,{...t,signal:e});for(const g of p){if(i.has(g.multiaddr.toString())){this.log.trace("skipping previously failed multiaddr %a while dialing %p",g.multiaddr,n);continue}h.push(g)}this.log("%s dial to %p with %s",c===1?"starting":"continuing",n,h.map(g=>g.multiaddr.toString())),(d=t==null?void 0:t.onProgress)==null||d.call(t,new le("dial-queue:calculated-addresses",h));for(const g of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new Er("Peer had more than maxPeerAddrsToDial");a++;try{const y=await this.components.transportManager.dial(g.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",g.multiaddr);try{await this.components.peerStore.merge(y.remotePeer,{multiaddrs:[y.remoteAddr],metadata:{[Fv]:Y(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}return y}catch(y){if(this.log.error("dial failed to %a - %e",g.multiaddr,y),i.add(g.multiaddr.toString()),n!=null)try{await this.components.peerStore.merge(n,{metadata:{[Ov]:Y(Date.now().toString())}})}catch(m){this.log.error("could not update last dial failure key for %p - %e",n,m)}if(e.aborted)throw new Ng(y.message);u.push(y)}}}throw u.length===1?u[0]:new AggregateError(u,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,n={}){var h,f;const s=[...e].map(p=>({multiaddr:X(p),isCertified:!1}));if(t!=null){if(this.components.peerId.equals(t))throw new Er("Tried to dial self");if(await((f=(h=this.components.connectionGater).denyDialPeer)==null?void 0:f.call(h,t))===!0)throw new Il("The dial request is blocked by gater.allowDialPeer");if(s.length===0){this.log("loading multiaddrs for %p",t);try{const p=await this.components.peerStore.get(t);s.push(...p.addresses),this.log("loaded multiaddrs for %p",t,s.map(({multiaddr:g})=>g.toString()))}catch(p){if(p.name!=="NotFoundError")throw p}}if(s.length===0){this.log("looking up multiaddrs for %p in the peer routing",t);try{const p=await this.components.peerRouting.findPeer(t,n);this.log("found multiaddrs for %p in the peer routing",t,s.map(({multiaddr:g})=>g.toString())),s.push(...p.multiaddrs.map(g=>({multiaddr:g,isCertified:!1})))}catch(p){p.name==="NoPeerRoutersError"?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,p)}}}let i=(await Promise.all(s.map(async p=>{const g=await Wf(p.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return g.length===1&&g[0].equals(p.multiaddr)?p:g.map(y=>({multiaddr:y,isCertified:!1}))}))).flat();if(t!=null){const p=`/p2p/${t.toString()}`;i=i.map(g=>{const y=g.multiaddr.getComponents().pop();return(y==null?void 0:y.name)!=="p2p"?{multiaddr:g.multiaddr.encapsulate(p),isCertified:g.isCertified}:g})}const o=i.filter(p=>{var y;if(this.components.transportManager.dialTransportForMultiaddr(p.multiaddr)==null)return!1;const g=(y=p.multiaddr.getComponents().findLast(m=>m.code===V))==null?void 0:y.value;return t!=null&&g!=null?t.equals(g):!0}),a=new Map;for(const p of o){const g=p.multiaddr.toString(),y=a.get(g);if(y!=null){y.isCertified=y.isCertified||p.isCertified||!1;continue}a.set(g,p)}const c=[...a.values()];if(c.length===0)throw new mv("The dial request has no valid addresses");const u=[];for(const p of c)this.components.connectionGater.denyDialMultiaddr!=null&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||u.push(p);const d=this.addressSorter==null?Wv(u):u.sort(this.addressSorter);if(d.length===0)throw new Il("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",i.map(({multiaddr:p})=>p.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",d.map(({multiaddr:p})=>p.toString())),d}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const n=await this.calculateMultiaddrs(void 0,new Set(t.map(s=>s.toString())),e);return e.runOnLimitedConnection===!1?n.find(s=>!Qn.matches(s.multiaddr))!=null:!0}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}const cS=Object.prototype.toString,lS=r=>cS.call(r)==="[object Error]",uS=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed","fetch failed","terminated"," A network error occurred.","Network connection lost"]);function dS(r){if(!(r&&lS(r)&&r.name==="TypeError"&&typeof r.message=="string"))return!1;const{message:e,stack:n}=r;return e==="Load failed"?n===void 0||"__sentry_captured__"in r:e.startsWith("error sending request for url")?!0:uS.has(e)}function hS(r){if(typeof r=="number"){if(r<0)throw new TypeError("Expected `retries` to be a non-negative number.");if(Number.isNaN(r))throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.")}else if(r!==void 0)throw new TypeError("Expected `retries` to be a number or Infinity.")}function xs(r,t,{min:e=0,allowInfinity:n=!1}={}){if(t!==void 0){if(typeof t!="number"||Number.isNaN(t))throw new TypeError(`Expected \`${r}\` to be a number${n?" or Infinity":""}.`);if(!n&&!Number.isFinite(t))throw new TypeError(`Expected \`${r}\` to be a finite number.`);if(t<e)throw new TypeError(`Expected \`${r}\` to be â‰¥ ${e}.`)}}class fS extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,{message:t}=t):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}function gS(r,t){const e=Math.max(1,r+1),n=t.randomize?Math.random()+1:1;let s=Math.round(n*t.minTimeout*t.factor**(e-1));return s=Math.min(s,t.maxTimeout),s}function Ll(r,t){return Number.isFinite(t)?t-(performance.now()-r):t}async function mS({error:r,attemptNumber:t,retriesConsumed:e,startTime:n,options:s}){var p,g,y;const i=r instanceof Error?r:new TypeError(`Non-error was thrown: "${r}". You should only throw errors.`);if(i instanceof fS)throw i.originalError;const o=Number.isFinite(s.retries)?Math.max(0,s.retries-e):s.retries,a=s.maxRetryTime??Number.POSITIVE_INFINITY,c=Object.freeze({error:i,attemptNumber:t,retriesLeft:o,retriesConsumed:e});if(await s.onFailedAttempt(c),Ll(n,a)<=0)throw i;const u=await s.shouldConsumeRetry(c),d=Ll(n,a);if(d<=0||o<=0)throw i;if(i instanceof TypeError&&!dS(i)){if(u)throw i;return(p=s.signal)==null||p.throwIfAborted(),!1}if(!await s.shouldRetry(c))throw i;if(!u)return(g=s.signal)==null||g.throwIfAborted(),!1;const h=gS(e,s),f=Math.min(h,d);return f>0&&await new Promise((m,S)=>{var L,x;const v=()=>{var _;clearTimeout(E),(_=s.signal)==null||_.removeEventListener("abort",v),S(s.signal.reason)},E=setTimeout(()=>{var _;(_=s.signal)==null||_.removeEventListener("abort",v),m()},f);s.unref&&((L=E.unref)==null||L.call(E)),(x=s.signal)==null||x.addEventListener("abort",v,{once:!0})}),(y=s.signal)==null||y.throwIfAborted(),!0}async function pS(r,t={}){var i,o,a;if(t={...t},hS(t.retries),Object.hasOwn(t,"forever"))throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");t.retries??(t.retries=10),t.factor??(t.factor=2),t.minTimeout??(t.minTimeout=1e3),t.maxTimeout??(t.maxTimeout=Number.POSITIVE_INFINITY),t.maxRetryTime??(t.maxRetryTime=Number.POSITIVE_INFINITY),t.randomize??(t.randomize=!1),t.onFailedAttempt??(t.onFailedAttempt=()=>{}),t.shouldRetry??(t.shouldRetry=()=>!0),t.shouldConsumeRetry??(t.shouldConsumeRetry=()=>!0),xs("factor",t.factor,{min:0,allowInfinity:!1}),xs("minTimeout",t.minTimeout,{min:0,allowInfinity:!1}),xs("maxTimeout",t.maxTimeout,{min:0,allowInfinity:!0}),xs("maxRetryTime",t.maxRetryTime,{min:0,allowInfinity:!0}),t.factor>0||(t.factor=1),(i=t.signal)==null||i.throwIfAborted();let e=0,n=0;const s=performance.now();for(;!Number.isFinite(t.retries)||n<=t.retries;){e++;try{(o=t.signal)==null||o.throwIfAborted();const c=await r(e);return(a=t.signal)==null||a.throwIfAborted(),c}catch(c){await mS({error:c,attemptNumber:e,retriesConsumed:n,startTime:s,options:t})&&n++}}throw new Error("Retry attempts exhausted without throwing an error.")}class yS{constructor(t,e={}){l(this,"log");l(this,"queue");l(this,"started");l(this,"peerStore");l(this,"retries");l(this,"retryInterval");l(this,"backoffFactor");l(this,"connectionManager");l(this,"events");this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new dc({concurrency:e.maxParallelReconnects??Nv,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",n=>{this.maybeReconnect(n.detail).catch(s=>{this.log.error("failed to maybe reconnect to %p - %e",n.detail,s)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);Dl(e)&&(this.queue.has(t)||this.queue.add(async n=>{await pS(async s=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:n==null?void 0:n.signal})}catch(i){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,s,this.retries,i),i}},{signal:n==null?void 0:n.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",t,n);const s={};[...e.tags.keys()].forEach(i=>{i.startsWith(ka)&&(s[i]=void 0)}),await this.peerStore.merge(t,{tags:s}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async n=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,n)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>Dl(e)]});await Promise.all(t.map(async e=>{await this.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not open connection to keepalive peer - %e",n)})}))}).catch(t=>{this.log.error("error reconnect to peers after start - %e",t)})}stop(){this.started=!1,this.queue.abort()}}function Dl(r){for(const t of r.tags.keys())if(t.startsWith(ka))return!0;return!1}const Hf=50,_o={maxConnections:$v,inboundConnectionThreshold:kv,maxIncomingPendingConnections:Mv};var bu;bu=Symbol.toStringTag;class wS{constructor(t,e={}){l(this,"started");l(this,"connections");l(this,"allow");l(this,"deny");l(this,"maxIncomingPendingConnections");l(this,"incomingPendingConnections");l(this,"outboundPendingConnections");l(this,"maxConnections");l(this,"dialQueue");l(this,"reconnectQueue");l(this,"connectionPruner");l(this,"inboundConnectionRateLimiter");l(this,"peerStore");l(this,"metrics");l(this,"events");l(this,"log");l(this,"peerId");l(this,bu,"@libp2p/connection-manager");var n;if(this.maxConnections=e.maxConnections??_o.maxConnections,this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");this.connections=new rr,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(s=>ha(X(s))),this.deny=(e.deny??[]).map(s=>ha(X(s))),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??_o.maxIncomingPendingConnections,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new H0({points:e.inboundConnectionThreshold??_o.inboundConnectionThreshold,duration:1}),this.connectionPruner=new Pv({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{allow:(n=e.allow)==null?void 0:n.map(s=>X(s))}),this.dialQueue=new aS(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??kf,maxDialQueueLength:e.maxDialQueueLength??Rf,maxPeerAddrsToDial:e.maxPeerAddrsToDial??Pf,dialTimeout:e.dialTimeout??Lf,resolvers:e.resolvers??{dnsaddr:Vf},connections:this.connections}),this.reconnectQueue=new yS({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,n;(t=this.metrics)==null||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const s={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const i of this.connections.values())for(const o of i)s[o.direction]++;return s}}),(e=this.metrics)==null||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const s={};for(const i of this.connections.values())for(const o of i)for(const a of o.streams){const c=`${a.direction} ${a.protocol??"unnegotiated"}`;s[c]=(s[c]??0)+1}return s}}),(n=this.metrics)==null||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const s={};for(const o of this.connections.values())for(const a of o){const c={};for(const u of a.streams){const d=`${u.direction} ${u.protocol??"unnegotiated"}`;c[d]=(c[d]??0)+1}for(const[u,d]of Object.entries(c))s[u]=s[u]??[],s[u].push(d)}const i={};for(let[o,a]of Object.entries(s)){a=a.sort((u,d)=>u-d);const c=Math.floor(a.length*.9);i[o]=a[c]}return i}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await sd(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await id(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const n of e)t.push(Promise.all([Fe(n,"close",{signal:AbortSignal.timeout(500)}),n.close({signal:AbortSignal.timeout(500)})]).catch(s=>{n.abort(s)}));this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(t){if(this.maxConnections<1)throw new W("Connection Manager maxConnections must be greater than 0");let e=!1;t<this.maxConnections&&(e=!0),this.maxConnections=t,e&&this.connectionPruner.maybePruneConnections()}onConnect(t){this._onConnect(t).catch(e=>{this.log.error("could not connect - %e",e)})}async _onConnect(t){const{detail:e}=t;if(!this.started){await e.close();return}if(e.status!=="open")return;const n=e.remotePeer,s=!this.connections.has(n),i=this.connections.get(n)??[];i.push(e),this.connections.set(n,i),n.publicKey!=null&&n.type==="RSA"&&await this.peerStore.patch(n,{publicKey:n.publicKey}),s&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,n=e.remotePeer,i=(this.connections.get(n)??[]).filter(o=>o.id!==e.id);this.connections.set(n,i),i.length===0&&(this.log.trace("peer %p disconnected, removing connection map entry",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:n}))}getConnections(t){if(t!=null)return this.connections.get(t)??[];let e=[];for(const n of this.connections.values())e=e.concat(n);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var n,s;if(!this.started)throw new Dr("Not started");this.outboundPendingConnections++;try{(n=e.signal)==null||n.throwIfAborted();const{peerId:i,multiaddrs:o}=_f(t);if(this.peerId.equals(i))throw new Da("Can not dial self");if(i!=null&&e.force!==!0){this.log("dial %p",i);const d=Tf(i,this.getConnections(i),o);if(d!=null)return this.log("had an existing connection to %p as %a",i,d.remoteAddr),(s=e.onProgress)==null||s.call(e,new le("dial-queue:already-connected")),d}const a=await this.dialQueue.dial(t,{...e,priority:e.priority??Hf});if(a.status!=="open")throw new Vs("Remote closed connection during opening");let c=this.connections.get(a.remotePeer);c==null&&(c=[],this.connections.set(a.remotePeer,c));let u=!1;for(const d of c)if(d.id===a.id&&(u=!0),e.force!==!0&&d.id!==a.id&&d.remoteAddr.equals(a.remoteAddr))return a.abort(new Pi("Duplicate multiaddr connection")),d;return u||c.push(a),a}finally{this.outboundPendingConnections--}}async openStream(t,e,n={}){return(await this.openConnection(t,n)).newStream(e,n)}async closeConnections(t,e={}){const n=this.connections.get(t)??[];await Promise.all(n.map(async s=>{try{await Promise.all([Fe(s,"close",e),s.close(e)])}catch(i){s.abort(i)}}))}acceptIncomingConnection(t){if(this.deny.some(s=>{if(at(t.remoteAddr)){const i=me(t.remoteAddr);return s.contains(i.host)}return!1}))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(s=>{if(at(t.remoteAddr)){const i=me(t.remoteAddr);return s.contains(i.host)}return!0}))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(at(t.remoteAddr)){const s=me(t.remoteAddr);try{this.inboundConnectionRateLimiter.consume(s.host,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,s.host),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(n=>X(n))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}const bS=1e4,ES="1.0.0",vS="ping",SS="ipfs",Pl=32,xS=!0;var Eu,vu;vu=Symbol.toStringTag,Eu=Ct;class AS{constructor(t,e={}){l(this,"protocol");l(this,"components");l(this,"log");l(this,"heartbeatInterval");l(this,"pingIntervalMs");l(this,"abortController");l(this,"timeout");l(this,"abortConnectionOnPingFailure");l(this,vu,"@libp2p/connection-monitor");l(this,Eu,["@libp2p/connection-monitor"]);this.components=t,this.protocol=`/${e.protocolPrefix??SS}/${vS}/${ES}`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??bS,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??xS,this.timeout=new Kb({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,this.abortController.signal,this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var n;let e=Date.now();try{const s=this.timeout.getTimeoutSignal({signal:(n=this.abortController)==null?void 0:n.signal}),i=await t.newStream(this.protocol,{signal:s,runOnLimitedConnection:!0}),o=Yh(i);e=Date.now(),await Promise.all([o.write(Qd(Pl),{signal:s}),o.read({bytes:Pl,signal:s})]),t.rtt=Date.now()-e,await i.close({signal:s})}catch(s){if(s.name!=="UnsupportedProtocolError")throw s;t.rtt=(Date.now()-e)/2}}).catch(e=>{this.log.error("error during heartbeat - %e",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;(t=this.abortController)==null||t.abort(),this.heartbeatInterval!=null&&clearInterval(this.heartbeatInterval)}}var Su;Su=Symbol.toStringTag;class CS{constructor(t,e){l(this,"routers");l(this,"started");l(this,"components");l(this,Su,"@libp2p/content-routing");var n,s,i,o,a;this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()}),getAttributesFromYieldedValue:(c,u)=>({...u,providers:[...Array.isArray(u.providers)?u.providers:[],c.id.toString()]})}))??this.findProviders,this.provide=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.provide,this.cancelReprovide=((i=t.metrics)==null?void 0:i.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([c],u)=>({...u,cid:c.toString()})}))??this.cancelReprovide,this.put=((o=t.metrics)==null?void 0:o.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.put,this.get=((a=t.metrics)==null?void 0:a.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([c])=>({key:Z(c,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(this.routers.length===0)throw new Co("No content routers available");const n=this,s=new Cn;for await(const i of sa(...n.routers.filter(o=>o.findProviders instanceof Function).map(o=>o.findProviders(t,e))))i!=null&&(i.multiaddrs.length>0&&await this.components.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id)&&(s.add(i.id),yield i))}async provide(t,e={}){if(this.routers.length===0)throw new Co("No content routers available");await Promise.all(this.routers.filter(n=>n.provide instanceof Function).map(async n=>{await n.provide(t,e)}))}async cancelReprovide(t,e={}){if(this.routers.length===0)throw new Co("No content routers available");await Promise.all(this.routers.filter(n=>n.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(t,e)}))}async put(t,e,n){if(!this.isStarted())throw new Dr;await Promise.all(this.routers.filter(s=>s.put instanceof Function).map(async s=>{await s.put(t,e,n)}))}async get(t,e){if(!this.isStarted())throw new Dr;return Promise.any(this.routers.filter(n=>n.get instanceof Function).map(async n=>n.get(t,e)))}}const As=globalThis.CustomEvent??Event;async function*_S(r,t={}){let e=t.concurrency??1/0;e<1&&(e=1/0);const n=t.ordered??!1,s=new EventTarget,i=[];let o=nt(),a=nt(),c=!1,u,d=!1;s.addEventListener("task-complete",()=>{a.resolve()}),Promise.resolve().then(async()=>{try{for await(const g of r){if(i.length===e&&(o=nt(),await o.promise),d)break;const y={done:!1};i.push(y),g().then(m=>{y.done=!0,y.ok=!0,y.value=m,s.dispatchEvent(new As("task-complete"))},m=>{y.done=!0,y.err=m,s.dispatchEvent(new As("task-complete"))})}c=!0,s.dispatchEvent(new As("task-complete"))}catch(g){u=g,s.dispatchEvent(new As("task-complete"))}});function h(){var g;return n?(g=i[0])==null?void 0:g.done:!!i.find(y=>y.done)}function*f(){for(;i.length>0&&i[0].done;){const g=i[0];if(i.shift(),g.ok)yield g.value;else throw d=!0,o.resolve(),g.err;o.resolve()}}function*p(){for(;h();)for(let g=0;g<i.length;g++)if(i[g].done){const y=i[g];if(i.splice(g,1),g--,y.ok)yield y.value;else throw d=!0,o.resolve(),y.err;o.resolve()}}for(;;){if(h()||(a=nt(),await a.promise),u!=null||(n?yield*f():yield*p(),u!=null))throw u;if(c&&i.length===0)break}}var xu;xu=Symbol.toStringTag;class IS{constructor(t,e={}){l(this,"log");l(this,"peerId");l(this,"peerStore");l(this,"routers");l(this,xu,"@libp2p/peer-routing");var n,s;this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=((n=t.metrics)==null?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,peer:i.toString()})}))??this.findPeer,this.getClosestPeers=((s=t.metrics)==null?void 0:s.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([i],o)=>({...o,key:Z(i,"base36")}),getAttributesFromYieldedValue:(i,o)=>({...o,peers:[...Array.isArray(o.peers)?o.peers:[],i.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(this.routers.length===0)throw new _l("No peer routers available");if(t.toString()===this.peerId.toString())throw new uv("Should not try to find self");const n=this,s=sa(...this.routers.filter(i=>i.findPeer instanceof Function).map(i=>async function*(){try{yield await i.findPeer(t,e)}catch(o){n.log.error("router failed to find peer - %e",o)}}()));for await(const i of s)if(i!=null)return i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),i;throw new $o}async*getClosestPeers(t,e={}){if(this.routers.length===0)throw new _l("No peer routers available");const n=this,s=Fr(1024);for await(const i of _S(async function*(){const o=sa(...n.routers.filter(a=>a.getClosestPeers instanceof Function).map(a=>a.getClosestPeers(t,e)));for await(let a of o)yield async()=>{if(a.multiaddrs.length===0)try{a=await n.findPeer(a.id,{...e,useCache:!1})}catch(c){n.log.error("could not find peer multiaddrs - %e",c);return}return a}}()))i!=null&&(i.multiaddrs.length>0&&await this.peerStore.merge(i.id,{multiaddrs:i.multiaddrs},e),!s.has(i.id.toMultihash().bytes)&&(s.add(i.id.toMultihash().bytes),yield i))}}function TS(r){return r.reason}async function ma(r,t,e){if(t==null)return r;const n=TS;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}var Au,Cu;class LS extends(Cu=Xe,Au=Symbol.toStringTag,Cu){constructor(e){super();l(this,"peerRouting");l(this,"log");l(this,"walking");l(this,"walkers");l(this,"shutdownController");l(this,"walkController");l(this,"needNext");l(this,Au,"@libp2p/random-walk");this.log=e.logger.forComponent("libp2p:random-walk"),this.peerRouting=e.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,this.shutdownController.signal}start(){this.shutdownController=new AbortController,this.shutdownController.signal}stop(){this.shutdownController.abort()}async*walk(e){var s,i;this.walking||this.startWalk(),this.walkers++;const n=dn([this.shutdownController.signal,e==null?void 0:e.signal]);try{for(;;)(s=this.needNext)==null||s.resolve(),this.needNext=nt(),yield(await Fe(this,"walk:peer",{signal:n,rejectionEvents:["walk:error"]})).detail}catch(o){throw o.detail!=null?o.detail:o}finally{n.clear(),this.walkers--,this.walkers===0&&((i=this.walkController)==null||i.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,this.walkController.signal;const e=dn([this.walkController.signal,this.shutdownController.signal]),n=Date.now();let s=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const i=Qd(32);let o=Date.now();for await(const a of this.peerRouting.getClosestPeers(i,{signal:e}))e.aborted&&this.log("aborting walk"),e.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",a.id,Date.now()-o,this.walkers),s++,this.safeDispatchEvent("walk:peer",{detail:a}),this.walkers===1&&this.needNext!=null&&(this.log("wait for need next"),await ma(this.needNext.promise,e)),o=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",i,this.walkers,s)}catch(i){this.log.error("random walk errored - %e",i),this.safeDispatchEvent("walk:error",{detail:i})}this.log("no walkers left, ended walk")}).catch(i=>{this.log.error("random walk errored - %e",i)}).finally(()=>{this.log("finished walk, found %d peers after %dms",s,Date.now()-n),this.walking=!1})}}const Gf=32,Yf=64;var _u;_u=Symbol.toStringTag;class DS{constructor(t){l(this,"log");l(this,"topologies");l(this,"handlers");l(this,"components");l(this,"middleware");l(this,_u,"@libp2p/registrar");var e;this.components=t,this.log=t.logger.forComponent("libp2p:registrar"),this.middleware=new Map,this.topologies=new Map,(e=t.metrics)==null||e.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const n={};for(const[s,i]of this.topologies)n[s]=i.size;return n}}),this.handlers=It({name:"libp2p_registrar_protocol_handlers",metrics:t.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(e==null)throw new dv(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return e==null?[]:[...e.values()]}async handle(t,e,n){if(this.handlers.has(t)&&(n==null?void 0:n.force)!==!0)throw new hv(`Handler already registered for protocol ${t}`);this.handlers.set(t,{handler:e,options:{maxInboundStreams:Gf,maxOutboundStreams:Yf,...n}}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]},n)}async unhandle(t,e){(Array.isArray(t)?t:[t]).forEach(s=>{this.handlers.delete(s)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},e)}async register(t,e){if(e==null)throw new W("invalid topology");const n=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let s=this.topologies.get(t);return s==null&&(s=new Map,this.topologies.set(t,s)),s.set(n,e),n}unregister(t){for(const[e,n]of this.topologies.entries())n.has(t)&&(n.delete(t),n.size===0&&this.topologies.delete(e))}use(t,e){this.middleware.set(t,e)}unuse(t){this.middleware.delete(t)}getMiddleware(t){return this.middleware.get(t)??[]}async _onDisconnect(t){const e=t.detail,n={signal:AbortSignal.timeout(5e3)};try{const s=await this.components.peerStore.get(e,n);for(const i of s.protocols){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e))!==!1&&((u=a.filter)==null||u.remove(e),await((d=a.onDisconnect)==null?void 0:d.call(a,e)))}))}}catch(s){if(s.name==="NotFoundError")return;this.log.error("could not inform topologies of disconnecting peer %p - %e",e,s)}}async _onPeerUpdate(t){const{peer:e,previous:n}=t.detail,s=((n==null?void 0:n.protocols)??[]).filter(i=>!e.protocols.includes(i));try{for(const i of s){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;((c=a.filter)==null?void 0:c.has(e.id))!==!1&&((u=a.filter)==null||u.remove(e.id),await((d=a.onDisconnect)==null?void 0:d.call(a,e.id)))}))}}catch(i){this.log.error("could not inform topologies of updated peer %p - %e",e.id,i)}}async _onPeerIdentify(t){const e=t.detail.protocols,n=t.detail.connection,s=t.detail.peerId;try{for(const i of e){const o=this.topologies.get(i);o!=null&&await Promise.all([...o.values()].map(async a=>{var c,u,d;n.limits!=null&&a.notifyOnLimitedConnection!==!0||((c=a.filter)==null?void 0:c.has(s))!==!0&&((u=a.filter)==null||u.add(s),await((d=a.onConnect)==null?void 0:d.call(a,s,n)))}))}}catch(i){this.log.error("could not inform topologies of updated peer after identify %p - %e",s,i)}}}var Iu;Iu=Symbol.toStringTag;class PS{constructor(t,e={}){l(this,"log");l(this,"components");l(this,"transports");l(this,"listeners");l(this,"faultTolerance");l(this,"started");l(this,Iu,"@libp2p/transport-manager");this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=It({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=It({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??Hs.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(e==null)throw new W("Transport must have a valid tag");if(this.transports.has(e))throw new W(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,n]of this.listeners)for(this.log("closing listeners for %s",e);n.length>0;){const s=n.pop();s!=null&&t.push(s.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var s;const n=this.dialTransportForMultiaddr(t);if(n==null)throw new wv(`No transport available for address ${String(t)}`);return(s=e==null?void 0:e.onProgress)==null||s.call(e,new le("transport-manager:selected-transport",n[Symbol.toStringTag])),n.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const n of e)t=[...t,...n.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values())if(e.dialFilter([t]).length>0)return e}listenTransportForMultiaddr(t){for(const e of this.transports.values())if(e.listenFilter([t]).length>0)return e}async listen(t){if(!this.isStarted())throw new Dr("Not started");if(t==null||t.length===0){this.log("no addresses were provided for listening, this node is dial only");return}const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(i=>{e.errors.set(i.toString(),new fv)});const n=[];for(const[i,o]of this.transports.entries()){const a=o.listenFilter(t);for(const c of a){this.log("creating listener for %s on %a",i,c);const u=o.createListener({upgrader:this.components.upgrader});let d=this.listeners.get(i)??[];d==null&&(d=[],this.listeners.set(i,d)),d.push(u),u.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:u})}),u.addEventListener("close",()=>{const h=d.findIndex(f=>f===u);d.splice(h,1),this.components.events.safeDispatchEvent("transport:close",{detail:u})}),wl.matches(c)?e.ipv4.attempts++:bl.matches(c)&&e.ipv6.attempts++,n.push(u.listen(c).then(()=>{e.errors.delete(c.toString()),wl.matches(c)&&e.ipv4.success++,bl.matches(c)&&e.ipv6.success++},h=>{throw this.log.error("transport %s could not listen on address %a - %e",i,c,h),e.errors.set(c.toString(),h),h}))}}const s=await Promise.allSettled(n);if(!(s.length>0&&s.every(i=>i.status==="fulfilled"))){if(this.ipv6Unsupported(e)){this.log("all IPv4 addresses succeed but all IPv6 failed");return}if(this.faultTolerance===Hs.NO_FATAL){this.log("failed to listen on any address but fault tolerance allows this");return}throw new gv(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...e.errors.entries()].map(([i,o])=>`
  ${i}: ${`${RS(o)}`.split(`
`).join(`
  `)}
`).join("")}`)}}ipv6Unsupported(t){if(t.ipv4.attempts===0||t.ipv6.attempts===0)return!1;const e=t.ipv4.attempts===t.ipv4.success,n=t.ipv6.success===0;return e&&n}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const n=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const s=e.pop();s!=null&&n.push(s.close())}await Promise.all(n),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}function RS(r){return r.stack!=null&&r.stack.trim()!==""?r.stack:r.message!=null?r.message:r.toString()}const tn="/multistream/1.0.0",Xf=1024,kS=Y(`
`);async function pa(r,t){const n=(await r.read(t)).subarray();if(n.byteLength===0||n[n.length-1]!==kS[0])throw new it("Missing newline");return Z(n).trimEnd()}async function ya(r,t,e={}){if(t=Array.isArray(t)?[...t]:[t],t.length===0)throw new Error("At least one protocol must be specified");const n=r.log.newScope("mss:select"),s=zr(r,{...e,maxDataLength:Xf});for(let i=0;i<t.length;i++){const o=t[i];let a;if(i===0){n.trace('write ["%s", "%s"]',tn,o);const c=Y(`${tn}
`),u=Y(`${o}
`);if(await s.writeV([c,u],e),n.trace("reading multistream-select header"),a=await pa(s,e),n.trace('read "%s"',a),a!==tn){n.error("did not read multistream-select header from response");break}}else n.trace('write "%s"',o),await s.write(Y(`${o}
`),e);if(n.trace("reading protocol response"),a=await pa(s,e),n.trace('read "%s"',a),a===o)return n.trace('selected "%s" after negotiation',a),s.unwrap(),o}throw new nd(`Protocol selection failed - could not negotiate ${t}`)}async function wa(r,t,e={}){t=Array.isArray(t)?t:[t];const n=r.log.newScope("mss:handle"),s=zr(r,{...e,maxDataLength:Xf,maxLengthLength:2});for(;;){n.trace("reading incoming string");const i=await pa(s,e);if(n.trace('read "%s"',i),i===tn){n.trace('respond with "%s" for "%s"',tn,i),await s.write(Y(`${tn}
`),e),n.trace('responded with "%s" for "%s"',tn,i);continue}if(t.includes(i))return n.trace('respond with "%s" for "%s"',i,i),await s.write(Y(`${i}
`),e),n.trace('responded with "%s" for "%s"',i,i),s.unwrap(),i;if(i==="ls"){const o=new J(...t.map(a=>li.single(Y(`${a}
`))),Y(`
`));n.trace('respond with "%s" for %s',t,i),await s.write(o,e),n.trace('responded with "%s" for %s',t,i);continue}n.trace('respond with "na" for "%s"',i),await s.write(Y(`na
`),e),n('responded with "na" for "%s"',i)}}var Tu,Lu,Du;class MS extends(Du=Xe,Lu=Symbol.toStringTag,Tu=kg,Du){constructor(e,n){super();l(this,"id");l(this,"remoteAddr");l(this,"remotePeer");l(this,"direction");l(this,"timeline");l(this,"direct");l(this,"multiplexer");l(this,"encryption");l(this,"limits");l(this,"log");l(this,"maConn");l(this,"muxer");l(this,"components");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"closeTimeout");l(this,Lu,"Connection");l(this,Tu,!0);l(this,"newStream",async(e,n={})=>{var i;if(this.muxer==null)throw new Os("Connection is not multiplexed");if(this.muxer.status!=="open")throw new Vs(`The connection muxer is "${this.muxer.status}" and not "open"`);if(this.maConn.status!=="open")throw new Vs(`The connection is "${this.status}" and not "open"`);if(this.limits!=null&&(n==null?void 0:n.runOnLimitedConnection)!==!0)throw new Uo("Cannot open protocol stream on limited connection");Array.isArray(e)||(e=[e]),this.log.trace("starting new stream for protocols %s",e);const s=await this.muxer.createStream({...n,protocol:e.length===1?e[0]:void 0});this.log.trace("started new stream %s for protocols %s",s.id,e);try{if(n.signal==null){s.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const u=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);n={...n,signal:u}}s.protocol===""?(s.log.trace("selecting protocol from protocols %s",e),s.protocol=await ya(s,e,n),s.log("negotiated protocol %s",s.protocol)):s.log("pre-negotiated protocol %s",s.protocol);const o=FS(s.protocol,this.components.registrar,n),a=Rl(s.protocol,"outbound",this);if(a>o){const u=new Pa(`Too many outbound protocol streams for protocol "${s.protocol}" - ${a}/${o}`);throw s.abort(u),u}await this.components.peerStore.merge(this.remotePeer,{protocols:[s.protocol]}),(i=this.components.metrics)==null||i.trackProtocolStream(s);const c=this.components.registrar.getMiddleware(s.protocol);return await this.runMiddlewareChain(s,this,c)}catch(o){throw s.status==="open"?s.abort(o):this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e",this.direction==="inbound"?"from":"to",this.remoteAddr,e,o),o}});this.components=e,this.id=n.id,this.remoteAddr=n.maConn.remoteAddr,this.remotePeer=n.remotePeer,this.direction=n.direction??"outbound",this.timeline=n.maConn.timeline,this.encryption=n.cryptoProtocol,this.limits=n.limits,this.maConn=n.maConn,this.log=n.maConn.log,this.outboundStreamProtocolNegotiationTimeout=n.outboundStreamProtocolNegotiationTimeout??yi,this.inboundStreamProtocolNegotiationTimeout=n.inboundStreamProtocolNegotiationTimeout??yi,this.closeTimeout=n.closeTimeout??Df,this.direct=If(n.maConn.remoteAddr),this.onIncomingStream=this.onIncomingStream.bind(this),this.remoteAddr.getComponents().find(s=>s.code===V)==null&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),n.muxer!=null&&(this.multiplexer=n.muxer.protocol,this.muxer=n.muxer,this.muxer.addEventListener("stream",this.onIncomingStream)),this.maConn.addEventListener("close",s=>{this.dispatchEvent(new ki(s.local,s.error))})}get streams(){var e;return((e=this.muxer)==null?void 0:e.streams)??[]}get status(){return this.maConn.status}async onIncomingStream(e){var i;const n=e.detail,s=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);n.log("start protocol negotiation, timing out after %dms",this.inboundStreamProtocolNegotiationTimeout);try{if(n.protocol===""){const h=this.components.registrar.getProtocols();n.log.trace("selecting protocol from protocols %s",h),n.protocol=await wa(n,h,{signal:s}),n.log("negotiated protocol %s",n.protocol)}else n.log("pre-negotiated protocol %s",n.protocol);const o=OS(n.protocol,this.components.registrar);if(Rl(n.protocol,"inbound",this)>o)throw new rd(`Too many inbound protocol streams for protocol "${n.protocol}" - limit ${o}`);await this.components.peerStore.merge(this.remotePeer,{protocols:[n.protocol]},{signal:s}),(i=this.components.metrics)==null||i.trackProtocolStream(n);const{handler:c,options:u}=this.components.registrar.getHandler(n.protocol);if(this.limits!=null&&u.runOnLimitedConnection!==!0)throw new Uo("Cannot open protocol stream on limited connection");const d=this.components.registrar.getMiddleware(n.protocol);d.push(async(h,f,p)=>{await c(h,f),p(h,f)}),await this.runMiddlewareChain(n,this,d)}catch(o){n.abort(o)}}async runMiddlewareChain(e,n,s){for(let i=0;i<s.length;i++){const o=s[i];e.log.trace("running middleware",i,o),await new Promise((a,c)=>{try{const u=o(e,n,(d,h)=>{e=d,n=h,a()});u instanceof Promise&&u.catch(c)}catch(u){c(u)}}),e.log.trace("ran middleware",i,o)}return e}async close(e={}){var n;if(this.log("closing connection to %a",this.remoteAddr),e.signal==null){const s=AbortSignal.timeout(this.closeTimeout);e={...e,signal:s}}await((n=this.muxer)==null?void 0:n.close(e)),await this.maConn.close(e)}abort(e){var n;(n=this.muxer)==null||n.abort(e),this.maConn.abort(e)}}function NS(r,t){return new MS(r,t)}function OS(r,t){try{const{options:e}=t.getHandler(r);if(e.maxInboundStreams!=null)return e.maxInboundStreams}catch(e){if(e.name!=="UnhandledProtocolError")throw e}return Gf}function FS(r,t,e={}){try{const{options:n}=t.getHandler(r);if(n.maxOutboundStreams!=null)return n.maxOutboundStreams}catch(n){if(n.name!=="UnhandledProtocolError")throw n}return e.maxOutboundStreams??Yf}function Rl(r,t,e){let n=0;return e.streams.forEach(s=>{s.direction===t&&s.protocol===r&&n++}),n}var Pu;Pu=Symbol.toStringTag;class BS{constructor(t,e){l(this,"components");l(this,"connectionEncrypters");l(this,"streamMuxers");l(this,"inboundUpgradeTimeout");l(this,"inboundStreamProtocolNegotiationTimeout");l(this,"outboundStreamProtocolNegotiationTimeout");l(this,"events");l(this,"metrics");l(this,"connectionCloseTimeout");l(this,Pu,"@libp2p/upgrader");var n,s,i,o;this.components=t,this.connectionEncrypters=It({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),e.connectionEncrypters.forEach(a=>{this.connectionEncrypters.set(a.protocol,a)}),this.streamMuxers=It({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),e.streamMuxers.forEach(a=>{this.streamMuxers.set(a.protocol,a)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??Rv,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??yi,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??yi,this.connectionCloseTimeout=e.connectionCloseTimeout??Df,this.events=t.events,this.metrics={dials:(n=t.metrics)==null?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:(s=t.metrics)==null?void 0:s.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:(i=t.metrics)==null?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:(o=t.metrics)==null?void 0:o.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(t,...e){const n=this.components.connectionGater[t];if(n==null)return;if(await n.apply(this.components.connectionGater,e)===!0)throw new pv(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return dn([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var i,o,a;let n=!1;const s=this.createInboundAbortSignal(e.signal);try{if((i=this.metrics.dials)==null||i.increment({inbound:!0}),n=this.components.connectionManager.acceptIncomingConnection(t),!n)throw new yv("Connection denied");await ma(this.shouldBlockConnection("denyInboundConnection",t),s),await this._performUpgrade(t,"inbound",{...e,signal:s})}catch(c){throw(o=this.metrics.errors)==null||o.increment({inbound:!0}),(a=this.metrics.inboundErrors)==null||a.increment({[c.name??"Error"]:!0}),c}finally{s.clear(),n&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var n,s,i,o;try{(n=this.metrics.dials)==null||n.increment({outbound:!0});const a=(s=t.remoteAddr.getComponents().findLast(d=>d.code===V))==null?void 0:s.value;let c;a!=null&&(c=ct(a),await ma(this.shouldBlockConnection("denyOutboundConnection",c,t),e.signal));let u="outbound";return e.initiator===!1&&(u="inbound"),await this._performUpgrade(t,u,e)}catch(a){throw(i=this.metrics.errors)==null||i.increment({outbound:!0}),(o=this.metrics.outboundErrors)==null||o.increment({[a.name??"Error"]:!0}),a}}async _performUpgrade(t,e,n){var h,f,p,g;let s=t,i,o,a,c;const u=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`;if(t.log=t.log.newScope(`${e}:${u}`),(h=this.components.metrics)==null||h.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e),(n==null?void 0:n.skipProtection)!==!0){const y=this.components.connectionProtector;y!=null&&(t.log("protecting the %s connection",e),s=await y.protect(s,n))}try{if($S(n)){if(n.remotePeer==null)throw new Pi(`${e} connection that skipped encryption must have a peer id`);c="native",i=n.remotePeer}else{const y=(f=t.remoteAddr.getComponents().findLast(S=>S.code===V))==null?void 0:f.value;let m;y!=null&&(m=ct(y)),(p=n==null?void 0:n.onProgress)==null||p.call(n,new le(`upgrader:encrypt-${e}-connection`)),{connection:s,remotePeer:i,protocol:c,streamMuxer:o}=await(e==="inbound"?this._encryptInbound(s,{...n,remotePeer:m}):this._encryptOutbound(s,{...n,remotePeer:m}))}if(i.equals(this.components.peerId)){const y=new Da("Can not dial self");throw t.abort(y),y}await this.shouldBlockConnection(e==="inbound"?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",i,t),(n==null?void 0:n.muxerFactory)!=null?o=n.muxerFactory:o==null&&this.streamMuxers.size>0&&((g=n==null?void 0:n.onProgress)==null||g.call(n,new le(`upgrader:multiplex-${e}-connection`)),o=await(e==="inbound"?this._multiplexInbound(s,this.streamMuxers,n):this._multiplexOutbound(s,this.streamMuxers,n)))}catch(y){throw t.log.error("failed to upgrade %s connection %s %a - %e",e,e==="inbound"?"from":"to",t.remoteAddr,y),y}o!=null&&(t.log("create muxer %s",o.protocol),a=o.createStreamMuxer(s)),await this.shouldBlockConnection(e==="inbound"?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",i,t);const d=this._createConnection({id:u,cryptoProtocol:c,direction:e,maConn:t,stream:s,muxer:a,remotePeer:i,limits:n==null?void 0:n.limits,closeTimeout:this.connectionCloseTimeout});return d.log("successfully upgraded connection"),d}_createConnection(t){const e=NS(this.components,{...t,outboundStreamProtocolNegotiationTimeout:this.outboundStreamProtocolNegotiationTimeout,inboundStreamProtocolNegotiationTimeout:this.inboundStreamProtocolNegotiationTimeout});return e.addEventListener("close",()=>{this.events.safeDispatchEvent("connection:close",{detail:e})}),this.events.safeDispatchEvent("connection:open",{detail:e}),e}async _encryptInbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{const s=await wa(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ss(`no crypto module found for ${s}`);return t.log("encrypting inbound connection using %s",s),{...await i.secureInbound(t,e),protocol:s}}catch(s){throw new Ss(s.message)}}async _encryptOutbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",n);const s=await ya(t,n,e),i=this.connectionEncrypters.get(s);if(i==null)throw new Ss(`no crypto module found for ${s}`);return t.log("encrypting outbound connection using %s",s),{...await i.secureOutbound(t,e),protocol:s}}catch(s){throw new Ss(s.message)}}async _multiplexOutbound(t,e,n){const s=Array.from(e.keys());t.log("outbound selecting muxer %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await ya(t,s,n),o=e.get(i);if(o==null)throw new Os(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing outbound connection - %e",i),new Os(String(i))}}async _multiplexInbound(t,e,n){const s=Array.from(e.keys());t.log("inbound handling muxers %s",s);try{t.log.trace("selecting stream muxer from %s",s);const i=await wa(t,s,n),o=e.get(i);if(o==null)throw new Os(`No muxer configured for protocol "${i}"`);return t.log("selected %s as muxer protocol",i),o}catch(i){throw t.log.error("error multiplexing inbound connection - %e",i),i}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}function $S(r){return r.skipEncryption===!0}const Qf="3.0.6",Zf="js-libp2p";function US(r,t){return`${r??Zf}/${t??Qf} browser/${globalThis.navigator.userAgent}`}var Gr,ba;class zS extends Xe{constructor(e){var d,h,f,p,g,y,m,S,v,E,L;super();he(this,Gr);l(this,"peerId");l(this,"peerStore");l(this,"contentRouting");l(this,"peerRouting");l(this,"metrics");l(this,"services");l(this,"logger");l(this,"status");l(this,"components");l(this,"log");this.status="stopped";const n=new Xe,s=n.dispatchEvent.bind(n);n.dispatchEvent=x=>{const _=s(x),N=this.dispatchEvent(new CustomEvent(x.type,{detail:x.detail}));return _||N},this.peerId=e.peerId,this.logger=e.logger??ch(),this.log=this.logger.forComponent("libp2p"),this.services={};const i=((d=e.nodeInfo)==null?void 0:d.name)??Zf,o=((h=e.nodeInfo)==null?void 0:h.version)??Qf,a=this.components=xv({peerId:e.peerId,privateKey:e.privateKey,nodeInfo:{name:i,version:o,userAgent:((f=e.nodeInfo)==null?void 0:f.userAgent)??US(i,o)},logger:this.logger,events:n,datastore:e.datastore??new zE,connectionGater:Tv(e.connectionGater),dns:e.dns});e.metrics!=null&&(this.metrics=this.configureComponent("metrics",e.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",ME(a,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...e.peerStore})),a.events.addEventListener("peer:update",x=>{if(x.detail.previous==null){const _={id:x.detail.peer.id,multiaddrs:x.detail.peer.addresses.map(N=>N.multiaddr)};a.events.safeDispatchEvent("peer:discovery",{detail:_})}}),e.connectionProtector!=null&&this.configureComponent("connectionProtector",e.connectionProtector(a)),this.components.upgrader=new BS(this.components,{connectionEncrypters:(e.connectionEncrypters??[]).map((x,_)=>this.configureComponent(`connection-encryption-${_}`,x(this.components))),streamMuxers:(e.streamMuxers??[]).map((x,_)=>this.configureComponent(`stream-muxers-${_}`,x(this.components))),inboundUpgradeTimeout:(p=e.connectionManager)==null?void 0:p.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(g=e.connectionManager)==null?void 0:g.inboundStreamProtocolNegotiationTimeout,outboundStreamProtocolNegotiationTimeout:(y=e.connectionManager)==null?void 0:y.outboundStreamProtocolNegotiationTimeout,connectionCloseTimeout:(m=e.connectionManager)==null?void 0:m.connectionCloseTimeout}),this.configureComponent("transportManager",new PS(this.components,e.transportManager)),this.configureComponent("connectionManager",new wS(this.components,e.connectionManager)),((S=e.connectionMonitor)==null?void 0:S.enabled)!==!1&&this.configureComponent("connectionMonitor",new AS(this.components,e.connectionMonitor)),this.configureComponent("registrar",new DS(this.components)),this.configureComponent("addressManager",new av(this.components,e.addresses));const c=(e.peerRouters??[]).map((x,_)=>this.configureComponent(`peer-router-${_}`,x(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new IS(this.components,{routers:c}));const u=(e.contentRouters??[]).map((x,_)=>this.configureComponent(`content-router-${_}`,x(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new CS(this.components,{routers:u})),this.configureComponent("randomWalk",new LS(this.components)),(e.peerDiscovery??[]).forEach((x,_)=>{this.configureComponent(`peer-discovery-${_}`,x(this.components)).addEventListener("peer",T=>{H(this,Gr,ba).call(this,T)})}),(v=e.transports)==null||v.forEach((x,_)=>{this.components.transportManager.add(this.configureComponent(`transport-${_}`,x(this.components)))}),e.services!=null)for(const x of Object.keys(e.services)){const _=e.services[x],N=_(this.components);if(N==null){this.log.error("service factory %s returned null or undefined instance",x);continue}this.services[x]=N,this.configureComponent(x,N),N[xc]!=null&&(this.log("registering service %s for content routing",x),u.push(N[xc])),N[Ac]!=null&&(this.log("registering service %s for peer routing",x),c.push(N[Ac])),N[zo]!=null&&(this.log("registering service %s for peer discovery",x),(L=(E=N[zo]).addEventListener)==null||L.call(E,"peer",T=>{H(this,Gr,ba).call(this,T)}))}Av(a)}configureComponent(e,n){return n==null&&this.log.error("component %s was null or undefined",e),this.components[e]=n,n}async start(){var e,n,s,i;if(this.status==="stopped"){this.status="starting",this.log("libp2p is starting");try{await((n=(e=this.components).beforeStart)==null?void 0:n.call(e)),await this.components.start(),await((i=(s=this.components).afterStart)==null?void 0:i.call(s)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started with peer id %p",this.peerId)}catch(o){throw this.log.error("an error occurred starting libp2p - %e",o),this.status="started",await this.stop(),o}}}async stop(){var e,n,s,i;this.status==="started"&&(this.log("libp2p is stopping"),this.status="stopping",await((n=(e=this.components).beforeStop)==null?void 0:n.call(e)),await this.components.stop(),await((i=(s=this.components).afterStop)==null?void 0:i.call(s)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(e){return this.components.connectionManager.getConnections(e)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const e=new Cn;for(const n of this.components.connectionManager.getConnections())e.add(n.remotePeer);return Array.from(e)}async dial(e,n={}){return this.components.connectionManager.openConnection(e,{priority:75,...n})}async dialProtocol(e,n,s={}){if(n==null)throw new W("no protocols were provided to open a stream");if(n=Array.isArray(n)?n:[n],n.length===0)throw new W("no protocols were provided to open a stream");return this.components.connectionManager.openStream(e,n,s)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(e,n={}){var s;Hi(e)&&(e=ct(((s=e.getComponents().findLast(i=>i.code===V))==null?void 0:s.value)??"")),await this.components.connectionManager.closeConnections(e,n)}async getPublicKey(e,n={}){if(this.log("getPublicKey %p",e),e.publicKey!=null)return e.publicKey;try{const a=await this.peerStore.get(e,n);if(a.id.publicKey!=null)return a.id.publicKey}catch(a){if(a.name!=="NotFoundError")throw a}const s=qt([Y("/pk/"),e.toMultihash().bytes]),i=await this.contentRouting.get(s,n),o=Vt(i);return await this.peerStore.patch(e,{publicKey:o},n),o}async handle(e,n,s){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async i=>{await this.components.registrar.handle(i,n,s)}))}async unhandle(e,n){Array.isArray(e)||(e=[e]),await Promise.all(e.map(async s=>{await this.components.registrar.unhandle(s,n)}))}async register(e,n,s){return this.components.registrar.register(e,n,s)}unregister(e){this.components.registrar.unregister(e)}use(e,n){this.components.registrar.use(e,Array.isArray(n)?n:[n])}unuse(e){this.components.registrar.unuse(e)}async isDialable(e,n={}){return this.components.connectionManager.isDialable(e,n)}}Gr=new WeakSet,ba=function(e){const{detail:n}=e;if(n.id.toString()===this.peerId.toString()){this.log.error("peer discovery mechanism discovered self");return}this.components.peerStore.merge(n.id,{multiaddrs:n.multiaddrs}).catch(s=>{this.log.error("could not update multiaddrs of discovered peer - %e",s)})};async function qS(r={}){r.privateKey??(r.privateKey=await xw());const t=new zS({...await Pw(r),peerId:Tw(r.privateKey)});return r.start!==!1&&await t.start(),t}var Ve;(function(r){(function(n){n.FIN="FIN",n.STOP_SENDING="STOP_SENDING",n.RESET="RESET",n.FIN_ACK="FIN_ACK"})(r.Flag||(r.Flag={}));let t;(function(n){n[n.FIN=0]="FIN",n[n.STOP_SENDING=1]="STOP_SENDING",n[n.RESET=2]="RESET",n[n.FIN_ACK=3]="FIN_ACK"})(t||(t={})),function(n){n.codec=()=>nr(t)}(r.Flag||(r.Flag={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.flag!=null&&(s.uint32(8),r.Flag.codec().encode(n.flag,s)),n.message!=null&&(s.uint32(18),s.bytes(n.message)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.flag=r.Flag.codec().decode(n);break}case 2:{o.message=n.bytes();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(Ve||(Ve={}));const KS=["stun:stun.l.google.com:19302","stun:global.stun.twilio.com:3478","stun:stun.cloudflare.com:3478","stun:stun.services.mozilla.com:3478"];Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");const VS=2*1024*1024,Jf=16*1024;function WS(r=Jf){const t=Te(r-Te(r)),e=1+Te(Object.keys(Ve.Flag).length-1),n=1,s=r-t-e-n,i=Te(s);return t+e+n+i}const HS=WS(),GS=1e4,jf="/webrtc",Ea="/webrtc-signaling/0.0.1";function YS(r){return r.reason}async function XS(r,t,e){if(t==null)return r;const n=YS;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}var kl=function(r,t,e){if(e||arguments.length===2)for(var n=0,s=t.length,i;n<s;n++)(i||!(n in t))&&(i||(i=Array.prototype.slice.call(t,0,n)),i[n]=t[n]);return r.concat(i||Array.prototype.slice.call(t))},QS=function(){function r(t,e,n){this.name=t,this.version=e,this.os=n,this.type="browser"}return r}(),ZS=function(){function r(t){this.version=t,this.type="node",this.name="node",this.os=process.platform}return r}(),JS=function(){function r(t,e,n,s){this.name=t,this.version=e,this.os=n,this.bot=s,this.type="bot-device"}return r}(),jS=function(){function r(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return r}(),e1=function(){function r(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return r}(),t1=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,n1=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,Ml=3,r1=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",t1]],Nl=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function s1(r){return typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new e1:typeof navigator<"u"?o1(navigator.userAgent):c1()}function i1(r){return r!==""&&r1.reduce(function(t,e){var n=e[0],s=e[1];if(t)return t;var i=s.exec(r);return!!i&&[n,i]},!1)}function o1(r){var t=i1(r);if(!t)return null;var e=t[0],n=t[1];if(e==="searchbot")return new jS;var s=n[1]&&n[1].split(".").join("_").split("_").slice(0,3);s?s.length<Ml&&(s=kl(kl([],s,!0),l1(Ml-s.length),!0)):s=[];var i=s.join("."),o=a1(r),a=n1.exec(r);return a&&a[1]?new JS(e,i,o,a[1]):new QS(e,i,o)}function a1(r){for(var t=0,e=Nl.length;t<e;t++){var n=Nl[t],s=n[0],i=n[1],o=i.exec(r);if(o)return s}return null}function c1(){var r=typeof process<"u"&&process.version;return r?new ZS(process.version.slice(1)):null}function l1(r){for(var t=[],e=0;e<r;e++)t.push("0");return t}const Ol=s1(),u1=Ol!=null&&Ol.name==="firefox";async function Fl(r){return r=r??{},typeof r=="function"&&(r=await r()),r.iceServers=r.iceServers??KS.map(t=>({urls:[t]})),r}class d1 extends Lh{constructor(e){super({...e,maxMessageSize:(e.maxMessageSize??Jf)-HS});l(this,"channel");l(this,"incomingData");l(this,"maxBufferedAmount");l(this,"receivedFinAck");l(this,"finAckTimeout");this.channel=e.channel,this.channel.binaryType="arraybuffer",this.incomingData=Vi(),this.maxBufferedAmount=e.maxBufferedAmount??VS,this.finAckTimeout=e.finAckTimeout??GS,this.channel.onclose=()=>{this.log.trace("received datachannel close event"),this.onRemoteCloseWrite(),this.onTransportClosed()},this.channel.onerror=s=>{const i=s.error;this.log.trace("received datachannel error event - %e",i),this.abort(i)},this.channel.onmessage=async s=>{this.log("incoming message %d bytes",s.data.byteLength);const{data:i}=s;i===null||i.byteLength===0||this.incomingData.push(new Uint8Array(i,0,i.byteLength))},this.channel.bufferedAmountLowThreshold=0,this.channel.onbufferedamountlow=()=>{this.writableNeedsDrain&&this.safeDispatchEvent("drain")},Promise.resolve().then(async()=>{for await(const s of oa(this.incomingData))this.processIncomingProtobuf(s)}).catch(s=>{this.log.error("error processing incoming data channel messages - %e",s)});const n=()=>{this.channel.readyState==="open"&&(this.log.trace("stream closed, closing underlying datachannel"),this.channel.close())};this.addEventListener("close",n),this.channel.readyState!=="open"&&(this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data',this.channel.readyState),Fe(this.channel,"open",{rejectionEvents:["close","error"]}).then(()=>{this.log('channel ready state is now "%s", dispatching drain',this.channel.readyState),this.safeDispatchEvent("drain")}).catch(s=>{this.abort(s.error??s)}))}sendNewStream(){}_sendMessage(e){if(this.channel.readyState!=="open")throw new Yt(`Invalid datachannel state - ${this.channel.readyState}`);if(this.log.trace('sending message, channel state "%s"',this.channel.readyState),u1){this.channel.send(e.subarray());return}for(const n of e)this.channel.send(n)}sendData(e){return this.channel.readyState!=="open"?{sentBytes:0,canSendMore:!1}:(this._sendMessage(li.single(Ve.encode({message:e.subarray()}))),{sentBytes:e.byteLength,canSendMore:this.channel.bufferedAmount<this.maxBufferedAmount})}sendReset(e){var n;try{this.log.error("sending reset - %e",e),this._sendFlag(Ve.Flag.RESET),(n=this.receivedFinAck)==null||n.reject(e)}catch(s){this.log.error("failed to send reset - %e",s)}}async sendCloseWrite(e){var i;this._sendFlag(Ve.Flag.FIN),(i=e==null?void 0:e.signal)==null||i.throwIfAborted(),this.receivedFinAck=Promise.withResolvers();const n=(e==null?void 0:e.signal)??AbortSignal.timeout(this.finAckTimeout),s=[Fe(this.channel,"close",{signal:n}),Fe(this.channel,"error",{signal:n})];await Promise.any([XS(this.receivedFinAck.promise,n),...s]).finally(()=>{s.forEach(o=>o.cancel())})}async sendCloseRead(e){var n;this._sendFlag(Ve.Flag.STOP_SENDING),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}processIncomingProtobuf(e){var s,i;const n=Ve.decode(e);n.message!=null&&(this.readStatus==="readable"||this.readStatus==="paused")&&this.onData(new J(n.message)),n.flag!==void 0&&(this.log.trace('incoming flag %s, write status "%s", read status "%s"',n.flag,this.writeStatus,this.readStatus),n.flag===Ve.Flag.FIN&&(this._sendFlag(Ve.Flag.FIN_ACK),this.onRemoteCloseWrite()),n.flag===Ve.Flag.RESET&&((s=this.receivedFinAck)==null||s.reject(new La("The stream was reset")),this.onRemoteReset()),n.flag===Ve.Flag.STOP_SENDING&&this.onRemoteCloseRead(),n.flag===Ve.Flag.FIN_ACK&&((i=this.receivedFinAck)==null||i.resolve()))}_sendFlag(e){if(this.channel.readyState!=="open")return this.log.trace('not sending flag %s because channel is "%s" and not "open"',e.toString(),this.channel.readyState),!1;this.log.trace("sending flag %s",e.toString());const n=Ve.encode({flag:e}),s=li.single(n);try{return this._sendMessage(s),!0}catch(i){this.log.error("could not send flag %s - %e",e.toString(),i)}return!1}sendPause(){}sendResume(){}}function Bl(r){const{channel:t,direction:e,isHandshake:n}=r;return new d1({...r,id:`${t.id}`,log:r.log.newScope(`${n===!0?"handshake":e}:${t.id}`),protocol:""})}class eg{constructor(t){l(this,"protocol");l(this,"peerConnection");l(this,"metrics");l(this,"dataChannelOptions");l(this,"earlyDataChannels");this.onEarlyDataChannel=this.onEarlyDataChannel.bind(this),this.peerConnection=t.peerConnection,this.metrics=t.metrics,this.protocol=t.protocol??jf,this.dataChannelOptions=t.dataChannelOptions??{},this.peerConnection.addEventListener("datachannel",this.onEarlyDataChannel),this.earlyDataChannels=[]}onEarlyDataChannel(t){this.earlyDataChannels.push(t.channel)}createStreamMuxer(t){return this.peerConnection.removeEventListener("datachannel",this.onEarlyDataChannel),new h1(t,{peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,protocol:this.protocol,earlyDataChannels:this.earlyDataChannels})}}class h1 extends Th{constructor(e,n){super(e,{...n,name:"muxer"});l(this,"peerConnection");l(this,"dataChannelOptions");this.peerConnection=n.peerConnection,this.protocol=n.protocol??jf,this.dataChannelOptions=n.dataChannelOptions??{},this.peerConnection.ondatachannel=({channel:s})=>{this.onDataChannel(s)},queueMicrotask(()=>{if(this.status!=="open"){n.earlyDataChannels.forEach(s=>{s.close()});return}n.earlyDataChannels.forEach(s=>{this.onDataChannel(s)})})}onDataChannel(e){if(this.log("incoming datachannel with channel id %d, protocol %s and status %s",e.id,e.protocol,e.readyState),e.label==="init"){this.log.trace("closing init channel %d",e.id),e.close();return}const n=Bl({...this.streamOptions,...this.dataChannelOptions,channel:e,direction:"inbound",log:this.log});this.onRemoteStream(n)}async onCreateStream(e){const n=this.peerConnection.createDataChannel("",{});return this.log("open channel %d for protocol %s",n.id,e==null?void 0:e.protocol),Bl({...e,...this.dataChannelOptions,channel:n,direction:"outbound",log:this.log})}onData(){}}class f1 extends Ih{constructor(e){super(e);l(this,"peerConnection");this.peerConnection=e.peerConnection;const n=e.peerConnection.connectionState;this.peerConnection.onconnectionstatechange=()=>{this.log.trace("peer connection state change %s initial state %s",this.peerConnection.connectionState,n),(this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed"||this.peerConnection.connectionState==="closed")&&(this.onTransportClosed(),this.peerConnection.close())}}sendData(e){return{sentBytes:e.byteLength,canSendMore:!0}}async sendClose(e){var n;this.peerConnection.close(),(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendReset(){this.peerConnection.close()}sendPause(){}sendResume(){}}const $l=r=>new f1(r),tg=globalThis.RTCPeerConnection,ng=globalThis.RTCSessionDescription,g1=globalThis.RTCIceCandidate;class m1 extends Error{constructor(t){super(`WebRTC transport error: ${t}`),this.name="WebRTCTransportError"}}class Bt extends m1{constructor(t="SDP handshake failed"){super(t),this.name="SDPHandshakeFailedError"}}var ot;(function(r){(function(n){n.SDP_OFFER="SDP_OFFER",n.SDP_ANSWER="SDP_ANSWER",n.ICE_CANDIDATE="ICE_CANDIDATE"})(r.Type||(r.Type={}));let t;(function(n){n[n.SDP_OFFER=0]="SDP_OFFER",n[n.SDP_ANSWER=1]="SDP_ANSWER",n[n.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(t||(t={})),function(n){n.codec=()=>nr(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.data!=null&&(s.uint32(18),s.string(n.data)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const c=n.uint32();switch(c>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.data=n.string();break}default:{n.skipType(c&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(ot||(ot={}));const rg=async(r,t,e)=>{var n,s,i,o;try{const a=Promise.withResolvers();for(p1(r,a);;){const c=await Promise.race([a.promise,t.read({signal:e.signal})]);if(c==null){(n=e.signal)==null||n.throwIfAborted();break}if(c.type!==ot.Type.ICE_CANDIDATE)throw new it("ICE candidate message expected");const u=JSON.parse(c.data??"null");if(u===""||u===null){(s=e.onProgress)==null||s.call(e,new le("webrtc:end-of-ice-candidates")),e.log.trace("end-of-candidates received");continue}const d=new g1(u);e.log.trace("%s received new ICE candidate %o",e.direction,u);try{(i=e.onProgress)==null||i.call(e,new le("webrtc:add-ice-candidate",d.candidate)),await r.addIceCandidate(d)}catch(h){e.log.error("%s bad candidate received %o - %e",e.direction,u,h)}}}catch(a){if(e.log.error("%s error parsing ICE candidate - %e",e.direction,a),((o=e.signal)==null?void 0:o.aborted)===!0&&r.connectionState!=="connected")throw a}};function p1(r,t){if(r.connectionState==="connected"){t.resolve();return}r.onconnectionstatechange=e=>{switch(r.connectionState){case"connected":t.resolve();break;case"failed":case"disconnected":case"closed":t.reject(new ju(`RTCPeerConnection connection state became "${r.connectionState}"`));break}}}function sg(r){let t;for(const e of r.getComponents())e.name==="p2p"&&(t=ct(e.value??""));if(t==null)throw new Pi("Remote peerId must be present in multiaddr");return t}async function y1({rtcConfiguration:r,dataChannel:t,signal:e,metrics:n,multiaddr:s,connectionManager:i,transportManager:o,log:a,logger:c,onProgress:u}){const{circuitAddress:d,targetPeer:h}=E1(s);n==null||n.dialerEvents.increment({open:!0}),a.trace("dialing circuit address: %a",d);const f=i.getConnections(h);let p;f.length===0?(u==null||u(new le("webrtc:dial-relay")),p=await o.dial(d,{signal:e,onProgress:u})):(u==null||u(new le("webrtc:reuse-relay-connection")),p=f[0]),u==null||u(new le("webrtc:open-signaling-stream"));const g=await p.newStream(Ea,{signal:e,runOnLimitedConnection:!0}),y=hn(g).pb(ot),m=new tg(r);m.addEventListener("connectionstatechange",()=>{switch(m.connectionState){case"closed":m.close();break}});const S=new eg({peerConnection:m,dataChannelOptions:t});try{const v=m.createDataChannel("init");m.onicecandidate=({candidate:_})=>{if(m.connectionState==="connected"){a.trace("ignore new ice candidate as peer connection is already connected");return}if(_==null||(_==null?void 0:_.candidate)===""){a.trace("initiator detected end of ICE candidates");return}const N=JSON.stringify((_==null?void 0:_.toJSON())??null);a.trace("initiator sending ICE candidate %o",_),y.write({type:ot.Type.ICE_CANDIDATE,data:N},{signal:e}).catch(T=>{a.error("error sending ICE candidate - %e",T)})},m.onicecandidateerror=_=>{a.error("initiator ICE candidate error",_)};const E=await m.createOffer().catch(_=>{throw a.error("could not execute createOffer - %e",_),new Bt("Failed to set createOffer")});a.trace("initiator send SDP offer %s",E.sdp),u==null||u(new le("webrtc:send-sdp-offer")),await y.write({type:ot.Type.SDP_OFFER,data:E.sdp},{signal:e}),await m.setLocalDescription(E).catch(_=>{throw a.error("could not execute setLocalDescription - %e",_),new Bt("Failed to set localDescription")}),u==null||u(new le("webrtc:read-sdp-answer")),a.trace("initiator read SDP answer");const L=await y.read({signal:e});if(L.type!==ot.Type.SDP_ANSWER)throw new Bt("Remote should send an SDP answer");a.trace("initiator received SDP answer %s",L.data);const x=new ng({type:"answer",sdp:L.data});return await m.setRemoteDescription(x).catch(_=>{throw a.error("could not execute setRemoteDescription - %e",_),new Bt("Failed to set remoteDescription")}),a.trace("initiator read candidates until connected"),u==null||u(new le("webrtc:read-ice-candidates")),await rg(m,y,{direction:"initiator",signal:e,log:a,onProgress:u}),a.trace("initiator connected"),v.readyState!=="open"&&(a.trace("wait for init channel to open"),await Fe(v,"open",{signal:e})),a.trace("closing init channel"),v.close(),a.trace("waiting for init channel to close"),await Fe(v,"close",{signal:e}),u==null||u(new le("webrtc:close-signaling-stream")),a.trace("closing signaling channel"),await g.close({signal:e}),a.trace("initiator connected to remote address %s",s),{remoteAddress:s,peerConnection:m,muxerFactory:S}}catch(v){throw a.error("outgoing signaling error - %e",v),m.close(),g.abort(v),v}finally{m.onicecandidate=null,m.onicecandidateerror=null}}const Ul=ue(pc.matchers[0],ce(sr));class yc extends Xe{constructor(e,n){super();l(this,"transportManager");l(this,"shutdownController");l(this,"events");this.transportManager=e.transportManager,this.events=e.events,this.shutdownController=n.shutdownController,this.onTransportListening=this.onTransportListening.bind(this)}async listen(){this.events.addEventListener("transport:listening",this.onTransportListening)}onTransportListening(e){e.detail.getAddrs().filter(s=>Ul.exactMatch(s)).map(s=>s.encapsulate("/webrtc")).length>0&&this.safeDispatchEvent("listening")}getAddrs(){return this.transportManager.getListeners().filter(e=>!(e instanceof yc)).map(e=>e.getAddrs().filter(n=>Ul.exactMatch(n)).map(n=>n.encapsulate("/webrtc"))).flat()}updateAnnounceAddrs(){}async close(){this.events.removeEventListener("transport:listening",this.onTransportListening),this.shutdownController.abort(),queueMicrotask(()=>{this.safeDispatchEvent("close")})}}async function w1(r,t,{peerConnection:e,signal:n,log:s}){s.trace("new inbound signaling stream");const i=hn(r).pb(ot);try{e.onicecandidate=({candidate:h})=>{if(e.connectionState==="connected"){s.trace("ignore new ice candidate as peer connection is already connected");return}if(h==null||(h==null?void 0:h.candidate)===""){s.trace("recipient detected end of ICE candidates");return}const f=JSON.stringify((h==null?void 0:h.toJSON())??null);s.trace("recipient sending ICE candidate %s",f),i.write({type:ot.Type.ICE_CANDIDATE,data:f},{signal:n}).catch(p=>{s.error("error sending ICE candidate - %e",p)})},s.trace("recipient read SDP offer");const c=await i.read({signal:n});if(c.type!==ot.Type.SDP_OFFER)throw new Bt(`expected message type SDP_OFFER, received: ${c.type??"undefined"} `);s.trace("recipient received SDP offer %s",c.data);const u=new ng({type:"offer",sdp:c.data});await e.setRemoteDescription(u).catch(h=>{throw s.error("could not execute setRemoteDescription - %e",h),new Bt("Failed to set remoteDescription")});const d=await e.createAnswer().catch(h=>{throw s.error("could not execute createAnswer - %e",h),new Bt("Failed to create answer")});s.trace("recipient send SDP answer %s",d.sdp),await i.write({type:ot.Type.SDP_ANSWER,data:d.sdp},{signal:n}),await e.setLocalDescription(d).catch(h=>{throw s.error("could not execute setLocalDescription - %e",h),new Bt("Failed to set localDescription")}),s.trace("recipient read candidates until connected"),await rg(e,i,{direction:"recipient",signal:n,log:s})}catch(c){if(e.connectionState!=="connected")throw s.error("error while handling signaling stream from peer %a - %e",t.remoteAddr,c),e.close(),c;s("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected",t.remoteAddr,c)}const o=sg(t.remoteAddr),a=X(`/webrtc/p2p/${o}`);return s.trace("recipient connected to remote address %s",a),{remoteAddress:a,remotePeer:o}}var Ru,ku,Mu,Nu;Nu=od,Mu=Symbol.toStringTag,ku=Ct,Ru=Gs;class b1{constructor(t,e={}){l(this,"components");l(this,"init");l(this,"log");l(this,"_started",!1);l(this,"metrics");l(this,"shutdownController");l(this,Nu,!0);l(this,Mu,"@libp2p/webrtc");l(this,ku,["@libp2p/transport"]);l(this,Ru,["@libp2p/identify","@libp2p/circuit-relay-v2-transport"]);this.components=t,this.init=e,this.log=t.logger.forComponent("libp2p:webrtc"),this.shutdownController=new AbortController,this.shutdownController.signal,t.metrics!=null&&(this.metrics={dialerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dialer events by type"}),listenerEvents:t.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total",{label:"event",help:"Total count of WebRTC listener events by type"})})}isStarted(){return this._started}async start(){await this.components.registrar.handle(Ea,(t,e)=>{const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);this._onProtocol(t,e,n).catch(s=>{this.log.error("failed to handle incoming connect from %p - %e",e.remotePeer,s)}).finally(()=>{n.clear()})},{runOnLimitedConnection:!0}),this._started=!0}async stop(){await this.components.registrar.unhandle(Ea),this._started=!1}createListener(t){return new yc(this.components,{shutdownController:this.shutdownController})}listenFilter(t){return t.filter(da.exactMatch)}dialFilter(t){return this.listenFilter(t)}async dial(t,e){var c;this.log.trace("dialing address: %a",t);const{remoteAddress:n,peerConnection:s,muxerFactory:i}=await y1({rtcConfiguration:await Fl(this.init.rtcConfiguration),dataChannel:this.init.dataChannel,multiaddr:t,dataChannelOptions:this.init.dataChannel,signal:e.signal,connectionManager:this.components.connectionManager,transportManager:this.components.transportManager,log:this.log,logger:this.components.logger,onProgress:e.onProgress}),o=$l({peerConnection:s,remoteAddr:n,metrics:(c=this.metrics)==null?void 0:c.dialerEvents,direction:"outbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")}),a=await e.upgrader.upgradeOutbound(o,{skipProtection:!0,skipEncryption:!0,remotePeer:sg(t),muxerFactory:i,onProgress:e.onProgress,signal:e.signal});return this._closeOnShutdown(s,o),a}async _onProtocol(t,e,n){var o;const s=new tg(await Fl(this.init.rtcConfiguration));s.addEventListener("connectionstatechange",()=>{switch(s.connectionState){case"closed":s.close();break}});const i=new eg({peerConnection:s,dataChannelOptions:this.init.dataChannel});try{const{remoteAddress:a,remotePeer:c}=await w1(t,e,{peerConnection:s,signal:n,log:this.log});await t.close({signal:n});const u=$l({peerConnection:s,remoteAddr:a,metrics:(o=this.metrics)==null?void 0:o.listenerEvents,direction:"inbound",log:this.components.logger.forComponent("libp2p:webrtc:connection")});await this.components.upgrader.upgradeInbound(u,{skipEncryption:!0,skipProtection:!0,remotePeer:c,muxerFactory:i,signal:n}),this._closeOnShutdown(s,u)}catch(a){throw this.log.error("incoming signaling error - %e",a),s.close(),t.abort(a),a}}_closeOnShutdown(t,e){const n=()=>{e.close().catch(s=>{this.log.error("could not close WebRTCMultiaddrConnection - %e",s)})};this.shutdownController.signal.addEventListener("abort",n),t.addEventListener("close",()=>{this.shutdownController.signal.removeEventListener("abort",n)})}}function E1(r){const t=r.getComponents().filter(({name:n})=>n==="p2p").map(({value:n})=>n).pop();if(t==null)throw new W("Destination peer id was missing");return{circuitAddress:X(r.getComponents().filter(({name:n})=>n!=="webrtc")),targetPeer:ct(t)}}const qr=65535,zl=qr-16;var Ou,Fu;const ss=!!((Fu=(Ou=globalThis.process)==null?void 0:Ou.env)!=null&&Fu.DUMP_SESSION_KEYS),ql=16;/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */function v1(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function va(r){if(typeof r!="boolean")throw new Error(`boolean expected, not ${r}`)}function Io(r){if(!Number.isSafeInteger(r)||r<0)throw new Error("positive integer expected, got "+r)}function Ue(r,t,e=""){const n=v1(r),s=r==null?void 0:r.length,i=t!==void 0;if(!n||i&&s!==t){const o=e&&`"${e}" `,a=i?` of length ${t}`:"",c=n?`length=${s}`:`type=${typeof r}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return r}function Kl(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function S1(r,t){Ue(r,void 0,"output");const e=t.outputLen;if(r.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function zt(r){return new Uint32Array(r.buffer,r.byteOffset,Math.floor(r.byteLength/4))}function Zn(...r){for(let t=0;t<r.length;t++)r[t].fill(0)}function x1(r){return new DataView(r.buffer,r.byteOffset,r.byteLength)}const A1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function C1(r,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(r,t)}function _1(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}const I1=(r,t)=>{function e(n,...s){if(Ue(n,void 0,"key"),!A1)throw new Error("Non little-endian hardware is not yet supported");if(r.nonceLength!==void 0){const d=s[0];Ue(d,r.varSizeNonce?void 0:r.nonceLength,"nonce")}const i=r.tagLength;i&&s[1]!==void 0&&Ue(s[1],void 0,"AAD");const o=t(n,...s),a=(d,h)=>{if(h!==void 0){if(d!==2)throw new Error("cipher output not supported");Ue(h,void 0,"output")}};let c=!1;return{encrypt(d,h){if(c)throw new Error("cannot encrypt() twice with same key + nonce");return c=!0,Ue(d),a(o.encrypt.length,h),o.encrypt(d,h)},decrypt(d,h){if(Ue(d),i&&d.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return a(o.decrypt.length,h),o.decrypt(d,h)}}}return Object.assign(e,r),e};function Vl(r,t,e=!0){if(t===void 0)return new Uint8Array(r);if(t.length!==r)throw new Error('"output" expected Uint8Array of length '+r+", got: "+t.length);if(e&&!L1(t))throw new Error("invalid output, must be aligned");return t}function T1(r,t,e){va(e);const n=new Uint8Array(16),s=x1(n);return s.setBigUint64(0,BigInt(t),e),s.setBigUint64(8,BigInt(r),e),n}function L1(r){return r.byteOffset%4===0}function wi(r){return Uint8Array.from(r)}const ig=r=>Uint8Array.from(r.split(""),t=>t.charCodeAt(0)),D1=ig("expand 16-byte k"),P1=ig("expand 32-byte k"),R1=zt(D1),k1=zt(P1);function ee(r,t){return r<<t|r>>>32-t}function Sa(r){return r.byteOffset%4===0}const Cs=64,M1=16,og=2**32-1,Wl=Uint32Array.of();function N1(r,t,e,n,s,i,o,a){const c=s.length,u=new Uint8Array(Cs),d=zt(u),h=Sa(s)&&Sa(i),f=h?zt(s):Wl,p=h?zt(i):Wl;for(let g=0;g<c;o++){if(r(t,e,n,d,o,a),o>=og)throw new Error("arx: counter overflow");const y=Math.min(Cs,c-g);if(h&&y===Cs){const m=g/4;if(g%4!==0)throw new Error("arx: invalid block position");for(let S=0,v;S<M1;S++)v=m+S,p[v]=f[v]^d[S];g+=Cs;continue}for(let m=0,S;m<y;m++)S=g+m,i[S]=s[S]^u[m];g+=y}}function O1(r,t){const{allowShortKeys:e,extendNonceFn:n,counterLength:s,counterRight:i,rounds:o}=C1({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof r!="function")throw new Error("core must be a function");return Io(s),Io(o),va(i),va(e),(a,c,u,d,h=0)=>{Ue(a,void 0,"key"),Ue(c,void 0,"nonce"),Ue(u,void 0,"data");const f=u.length;if(d===void 0&&(d=new Uint8Array(f)),Ue(d,void 0,"output"),Io(h),h<0||h>=og)throw new Error("arx: counter overflow");if(d.length<f)throw new Error(`arx: output (${d.length}) is shorter than data (${f})`);const p=[];let g=a.length,y,m;if(g===32)p.push(y=wi(a)),m=k1;else if(g===16&&e)y=new Uint8Array(32),y.set(a),y.set(a,16),m=R1,p.push(y);else throw Ue(a,32,"arx key"),new Error("invalid key size");Sa(c)||p.push(c=wi(c));const S=zt(y);if(n){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(m,S,zt(c.subarray(0,16)),S),c=c.subarray(16)}const v=16-s;if(v!==c.length)throw new Error(`arx: nonce must be ${v} or 16 bytes`);if(v!==12){const L=new Uint8Array(12);L.set(c,i?0:12-c.length),c=L,p.push(c)}const E=zt(c);return N1(r,m,S,E,u,d,h,o),Zn(...p),d}}function _e(r,t){return r[t++]&255|(r[t++]&255)<<8}class F1{constructor(t){l(this,"blockLen",16);l(this,"outputLen",16);l(this,"buffer",new Uint8Array(16));l(this,"r",new Uint16Array(10));l(this,"h",new Uint16Array(10));l(this,"pad",new Uint16Array(8));l(this,"pos",0);l(this,"finished",!1);t=wi(Ue(t,32,"key"));const e=_e(t,0),n=_e(t,2),s=_e(t,4),i=_e(t,6),o=_e(t,8),a=_e(t,10),c=_e(t,12),u=_e(t,14);this.r[0]=e&8191,this.r[1]=(e>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|i<<9)&8191,this.r[4]=(i>>>4|o<<12)&255,this.r[5]=o>>>1&8190,this.r[6]=(o>>>14|a<<2)&8191,this.r[7]=(a>>>11|c<<5)&8065,this.r[8]=(c>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let d=0;d<8;d++)this.pad[d]=_e(t,16+2*d)}process(t,e,n=!1){const s=n?0:2048,{h:i,r:o}=this,a=o[0],c=o[1],u=o[2],d=o[3],h=o[4],f=o[5],p=o[6],g=o[7],y=o[8],m=o[9],S=_e(t,e+0),v=_e(t,e+2),E=_e(t,e+4),L=_e(t,e+6),x=_e(t,e+8),_=_e(t,e+10),N=_e(t,e+12),T=_e(t,e+14);let I=i[0]+(S&8191),B=i[1]+((S>>>13|v<<3)&8191),U=i[2]+((v>>>10|E<<6)&8191),k=i[3]+((E>>>7|L<<9)&8191),M=i[4]+((L>>>4|x<<12)&8191),w=i[5]+(x>>>1&8191),b=i[6]+((x>>>14|_<<2)&8191),C=i[7]+((_>>>11|N<<5)&8191),D=i[8]+((N>>>8|T<<8)&8191),R=i[9]+(T>>>5|s),A=0,O=A+I*a+B*(5*m)+U*(5*y)+k*(5*g)+M*(5*p);A=O>>>13,O&=8191,O+=w*(5*f)+b*(5*h)+C*(5*d)+D*(5*u)+R*(5*c),A+=O>>>13,O&=8191;let P=A+I*c+B*a+U*(5*m)+k*(5*y)+M*(5*g);A=P>>>13,P&=8191,P+=w*(5*p)+b*(5*f)+C*(5*h)+D*(5*d)+R*(5*u),A+=P>>>13,P&=8191;let F=A+I*u+B*c+U*a+k*(5*m)+M*(5*y);A=F>>>13,F&=8191,F+=w*(5*g)+b*(5*p)+C*(5*f)+D*(5*h)+R*(5*d),A+=F>>>13,F&=8191;let z=A+I*d+B*u+U*c+k*a+M*(5*m);A=z>>>13,z&=8191,z+=w*(5*y)+b*(5*g)+C*(5*p)+D*(5*f)+R*(5*h),A+=z>>>13,z&=8191;let ne=A+I*h+B*d+U*u+k*c+M*a;A=ne>>>13,ne&=8191,ne+=w*(5*m)+b*(5*y)+C*(5*g)+D*(5*p)+R*(5*f),A+=ne>>>13,ne&=8191;let Q=A+I*f+B*h+U*d+k*u+M*c;A=Q>>>13,Q&=8191,Q+=w*a+b*(5*m)+C*(5*y)+D*(5*g)+R*(5*p),A+=Q>>>13,Q&=8191;let K=A+I*p+B*f+U*h+k*d+M*u;A=K>>>13,K&=8191,K+=w*c+b*a+C*(5*m)+D*(5*y)+R*(5*g),A+=K>>>13,K&=8191;let ae=A+I*g+B*p+U*f+k*h+M*d;A=ae>>>13,ae&=8191,ae+=w*u+b*c+C*a+D*(5*m)+R*(5*y),A+=ae>>>13,ae&=8191;let de=A+I*y+B*g+U*p+k*f+M*h;A=de>>>13,de&=8191,de+=w*d+b*u+C*c+D*a+R*(5*m),A+=de>>>13,de&=8191;let ye=A+I*m+B*y+U*g+k*p+M*f;A=ye>>>13,ye&=8191,ye+=w*h+b*d+C*u+D*c+R*a,A+=ye>>>13,ye&=8191,A=(A<<2)+A|0,A=A+O|0,O=A&8191,A=A>>>13,P+=A,i[0]=O,i[1]=P,i[2]=F,i[3]=z,i[4]=ne,i[5]=Q,i[6]=K,i[7]=ae,i[8]=de,i[9]=ye}finalize(){const{h:t,pad:e}=this,n=new Uint16Array(10);let s=t[1]>>>13;t[1]&=8191;for(let a=2;a<10;a++)t[a]+=s,s=t[a]>>>13,t[a]&=8191;t[0]+=s*5,s=t[0]>>>13,t[0]&=8191,t[1]+=s,s=t[1]>>>13,t[1]&=8191,t[2]+=s,n[0]=t[0]+5,s=n[0]>>>13,n[0]&=8191;for(let a=1;a<10;a++)n[a]=t[a]+s,s=n[a]>>>13,n[a]&=8191;n[9]-=8192;let i=(s^1)-1;for(let a=0;a<10;a++)n[a]&=i;i=~i;for(let a=0;a<10;a++)t[a]=t[a]&i|n[a];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let o=t[0]+e[0];t[0]=o&65535;for(let a=1;a<8;a++)o=(t[a]+e[a]|0)+(o>>>16)|0,t[a]=o&65535;Zn(n)}update(t){Kl(this),Ue(t),t=wi(t);const{buffer:e,blockLen:n}=this,s=t.length;for(let i=0;i<s;){const o=Math.min(n-this.pos,s-i);if(o===n){for(;n<=s-i;i+=n)this.process(t,i);continue}e.set(t.subarray(i,i+o),this.pos),this.pos+=o,i+=o,this.pos===n&&(this.process(e,0,!1),this.pos=0)}return this}destroy(){Zn(this.h,this.r,this.buffer,this.pad)}digestInto(t){Kl(this),S1(t,this),this.finished=!0;const{buffer:e,h:n}=this;let{pos:s}=this;if(s){for(e[s++]=1;s<16;s++)e[s]=0;this.process(e,0,!0)}this.finalize();let i=0;for(let o=0;o<8;o++)t[i++]=n[o]>>>0,t[i++]=n[o]>>>8;return t}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}}function B1(r){const t=(n,s)=>r(s).update(n).digest(),e=r(new Uint8Array(32));return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=n=>r(n),t}const $1=B1(r=>new F1(r));function U1(r,t,e,n,s,i=20){let o=r[0],a=r[1],c=r[2],u=r[3],d=t[0],h=t[1],f=t[2],p=t[3],g=t[4],y=t[5],m=t[6],S=t[7],v=s,E=e[0],L=e[1],x=e[2],_=o,N=a,T=c,I=u,B=d,U=h,k=f,M=p,w=g,b=y,C=m,D=S,R=v,A=E,O=L,P=x;for(let z=0;z<i;z+=2)_=_+B|0,R=ee(R^_,16),w=w+R|0,B=ee(B^w,12),_=_+B|0,R=ee(R^_,8),w=w+R|0,B=ee(B^w,7),N=N+U|0,A=ee(A^N,16),b=b+A|0,U=ee(U^b,12),N=N+U|0,A=ee(A^N,8),b=b+A|0,U=ee(U^b,7),T=T+k|0,O=ee(O^T,16),C=C+O|0,k=ee(k^C,12),T=T+k|0,O=ee(O^T,8),C=C+O|0,k=ee(k^C,7),I=I+M|0,P=ee(P^I,16),D=D+P|0,M=ee(M^D,12),I=I+M|0,P=ee(P^I,8),D=D+P|0,M=ee(M^D,7),_=_+U|0,P=ee(P^_,16),C=C+P|0,U=ee(U^C,12),_=_+U|0,P=ee(P^_,8),C=C+P|0,U=ee(U^C,7),N=N+k|0,R=ee(R^N,16),D=D+R|0,k=ee(k^D,12),N=N+k|0,R=ee(R^N,8),D=D+R|0,k=ee(k^D,7),T=T+M|0,A=ee(A^T,16),w=w+A|0,M=ee(M^w,12),T=T+M|0,A=ee(A^T,8),w=w+A|0,M=ee(M^w,7),I=I+B|0,O=ee(O^I,16),b=b+O|0,B=ee(B^b,12),I=I+B|0,O=ee(O^I,8),b=b+O|0,B=ee(B^b,7);let F=0;n[F++]=o+_|0,n[F++]=a+N|0,n[F++]=c+T|0,n[F++]=u+I|0,n[F++]=d+B|0,n[F++]=h+U|0,n[F++]=f+k|0,n[F++]=p+M|0,n[F++]=g+w|0,n[F++]=y+b|0,n[F++]=m+C|0,n[F++]=S+D|0,n[F++]=v+R|0,n[F++]=E+A|0,n[F++]=L+O|0,n[F++]=x+P|0}const z1=O1(U1,{counterRight:!1,counterLength:4,allowShortKeys:!1}),q1=new Uint8Array(16),Hl=(r,t)=>{r.update(t);const e=t.length%16;e&&r.update(q1.subarray(e))},K1=new Uint8Array(32);function Gl(r,t,e,n,s){s!==void 0&&Ue(s,void 0,"AAD");const i=r(t,e,K1),o=T1(n.length,s?s.length:0,!0),a=$1.create(i);s&&Hl(a,s),Hl(a,n),a.update(o);const c=a.digest();return Zn(i,o),c}const V1=r=>(t,e,n)=>({encrypt(i,o){const a=i.length;o=Vl(a+16,o,!1),o.set(i);const c=o.subarray(0,-16);r(t,e,c,c,1);const u=Gl(r,t,e,c,n);return o.set(u,a),Zn(u),o},decrypt(i,o){o=Vl(i.length-16,o,!1);const a=i.subarray(0,-16),c=i.subarray(-16),u=Gl(r,t,e,a,n);if(!_1(c,u))throw new Error("invalid tag");return o.set(i.subarray(0,-16)),r(t,e,o,o,1),Zn(u),o}}),Yl=I1({blockSize:64,nonceLength:12,tagLength:16},V1(z1));function W1(r,t,e){return $i(r),e===void 0&&(e=new Uint8Array(r.outputLen)),Ki(r,e,t)}const To=Uint8Array.of(0),Xl=Uint8Array.of();function H1(r,t,e,n=32){$i(r),Kt(n,"length");const s=r.outputLen;if(n>255*s)throw new Error("Length must be <= 255*HashLen");const i=Math.ceil(n/s);e===void 0?e=Xl:G(e,void 0,"info");const o=new Uint8Array(i*s),a=Ki.create(r,t),c=a._cloneInto(),u=new Uint8Array(a.outputLen);for(let d=0;d<i;d++)To[0]=d+1,c.update(d===0?Xl:u).update(e).update(To).digestInto(u),o.set(u,s*d),a._cloneInto(c);return a.destroy(),c.destroy(),on(u,To),o.slice(0,n)}const G1={hashSHA256(r){return xr(r.subarray())},getHKDF(r,t){const e=W1(xr,t,r),s=H1(xr,e,void 0,96),i=s.subarray(0,32),o=s.subarray(32,64),a=s.subarray(64,96);return[i,o,a]},generateX25519KeyPair(){const r=fs.utils.randomSecretKey();return{publicKey:fs.getPublicKey(r),privateKey:r}},generateX25519KeyPairFromSeed(r){return{publicKey:fs.getPublicKey(r),privateKey:r}},generateX25519SharedKey(r,t){return fs.getSharedSecret(r.subarray(),t.subarray())},chaCha20Poly1305Encrypt(r,t,e,n){return Yl(n,t,e).encrypt(r.subarray())},chaCha20Poly1305Decrypt(r,t,e,n,s){return Yl(n,t,e).decrypt(r.subarray(),s)}},Y1=G1;function X1(r){return{generateKeypair:r.generateX25519KeyPair,dh:(t,e)=>r.generateX25519SharedKey(t.privateKey,e).subarray(0,32),encrypt:r.chaCha20Poly1305Encrypt,decrypt:r.chaCha20Poly1305Decrypt,hash:r.hashSHA256,hkdf:r.getHKDF}}const bi=r=>{const t=gt(2);return t[0]=r>>8,t[1]=r,t};bi.bytes=2;const Ei=r=>{if(r.length<2)throw RangeError("Could not decode int16BE");if(r instanceof Uint8Array){let t=0;return t+=r[0]<<8,t+=r[1],t}return r.getUint16(0)};Ei.bytes=2;function Q1(r){return{xxHandshakeSuccesses:r.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:r.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:r.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:r.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:r.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}function ag(r,t){!t.enabled||!ss||(r?(t(`LOCAL_STATIC_PUBLIC_KEY ${Z(r.publicKey,"hex")}`),t(`LOCAL_STATIC_PRIVATE_KEY ${Z(r.privateKey,"hex")}`)):t("Missing local static keys."))}function cg(r,t){!t.enabled||!ss||(r?(t(`LOCAL_PUBLIC_EPHEMERAL_KEY ${Z(r.publicKey,"hex")}`),t(`LOCAL_PRIVATE_EPHEMERAL_KEY ${Z(r.privateKey,"hex")}`)):t("Missing local ephemeral keys."))}function Z1(r,t){!t.enabled||!ss||t(r?`REMOTE_STATIC_PUBLIC_KEY ${Z(r.subarray(),"hex")}`:"Missing remote static public key.")}function lg(r,t){!t.enabled||!ss||t(r?`REMOTE_EPHEMERAL_PUBLIC_KEY ${Z(r.subarray(),"hex")}`:"Missing remote ephemeral keys.")}function ug(r,t,e){!e.enabled||!ss||(e(`CIPHER_STATE_1 ${r.n.getUint64()} ${r.k&&Z(r.k,"hex")}`),e(`CIPHER_STATE_2 ${t.n.getUint64()} ${t.k&&Z(t.k,"hex")}`))}const Di=class Di extends Error{constructor(e="Invalid crypto exchange"){super(e);l(this,"code");this.code=Di.code}};l(Di,"code","ERR_INVALID_CRYPTO_EXCHANGE");let Tr=Di;const J1=0,j1=4294967295,ex="Cipherstate has reached maximum n, a new handshake must be performed";class tx{constructor(t=J1){l(this,"n");l(this,"bytes");l(this,"view");this.n=t,this.bytes=oe(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,t,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>j1)throw new Error(ex)}}const Ln=oe(0);class _s{constructor(t,e=void 0,n=0){l(this,"k");l(this,"n");l(this,"crypto");this.crypto=t,this.k=e,this.n=new tx(n)}hasKey(){return!!this.k}encryptWithAd(t,e){if(!this.hasKey())return e;this.n.assertValue();const n=this.crypto.encrypt(e,this.n.getBytes(),t,this.k);return this.n.increment(),n}decryptWithAd(t,e,n){if(!this.hasKey())return e;this.n.assertValue();const s=this.crypto.decrypt(e,this.n.getBytes(),t,this.k,n);return this.n.increment(),s}}class nx{constructor(t,e){l(this,"cs");l(this,"ck");l(this,"h");l(this,"crypto");this.crypto=t;const n=Y(e,"utf-8");this.h=sx(t,n),this.ck=this.h,this.cs=new _s(t)}mixKey(t){const[e,n]=this.crypto.hkdf(this.ck,t);this.ck=e,this.cs=new _s(this.crypto,n)}mixHash(t){this.h=this.crypto.hash(new J(this.h,t))}encryptAndHash(t){const e=this.cs.encryptWithAd(this.h,t);return this.mixHash(e),e}decryptAndHash(t){const e=this.cs.decryptWithAd(this.h,t);return this.mixHash(t),e}split(){const[t,e]=this.crypto.hkdf(this.ck,Ln);return[new _s(this.crypto,t),new _s(this.crypto,e)]}}class rx{constructor(t){l(this,"ss");l(this,"s");l(this,"e");l(this,"rs");l(this,"re");l(this,"initiator");l(this,"crypto");const{crypto:e,protocolName:n,prologue:s,initiator:i,s:o,e:a,rs:c,re:u}=t;this.crypto=e,this.ss=new nx(e,n),this.ss.mixHash(s),this.initiator=i,this.s=o,this.e=a,this.rs=c,this.re=u}writeE(){if(this.e)throw new Error("ephemeral keypair is already set");const t=this.crypto.generateKeypair();return this.ss.mixHash(t.publicKey),this.e=t,t.publicKey}writeS(){if(!this.s)throw new Error("static keypair is not set");return this.ss.encryptAndHash(this.s.publicKey)}writeEE(){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.re))}writeES(){if(this.initiator){if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}else{if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}}writeSE(){if(this.initiator){if(!this.s)throw new Error("static keypair is not set");if(!this.re)throw new Error("remote ephemeral public key is not set");this.ss.mixKey(this.crypto.dh(this.s,this.re))}else{if(!this.e)throw new Error("ephemeral keypair is not set");if(!this.rs)throw new Error("remote static public key is not set");this.ss.mixKey(this.crypto.dh(this.e,this.rs))}}readE(t,e=0){if(this.re)throw new Error("remote ephemeral public key is already set");if(t.byteLength<e+32)throw new Error("message is not long enough");this.re=t.sublist(e,e+32),this.ss.mixHash(this.re)}readS(t,e=0){if(this.rs)throw new Error("remote static public key is already set");const n=32+(this.ss.cs.hasKey()?16:0);if(t.byteLength<e+n)throw new Error("message is not long enough");const s=t.sublist(e,e+n);return this.rs=this.ss.decryptAndHash(s),n}readEE(){this.writeEE()}readES(){this.writeES()}readSE(){this.writeSE()}}class dg extends rx{writeMessageA(t){return new J(this.writeE(),this.ss.encryptAndHash(t))}writeMessageB(t){const e=this.writeE();this.writeEE();const n=this.writeS();return this.writeES(),new J(e,n,this.ss.encryptAndHash(t))}writeMessageC(t){const e=this.writeS();return this.writeSE(),new J(e,this.ss.encryptAndHash(t))}readMessageA(t){try{return this.readE(t),this.ss.decryptAndHash(t.sublist(32))}catch(e){throw new Tr(`handshake stage 0 validation fail: ${e.message}`)}}readMessageB(t){try{this.readE(t),this.readEE();const e=this.readS(t,32);return this.readES(),this.ss.decryptAndHash(t.sublist(32+e))}catch(e){throw new Tr(`handshake stage 1 validation fail: ${e.message}`)}}readMessageC(t){try{const e=this.readS(t);return this.readSE(),this.ss.decryptAndHash(t.sublist(e))}catch(e){throw new Tr(`handshake stage 2 validation fail: ${e.message}`)}}}function sx(r,t){if(t.length<=32){const e=oe(32);return e.set(t),e}else return r.hash(t)}var vi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.webtransportCerthashes!=null)for(const i of e.webtransportCerthashes)n.uint32(10),n.bytes(i);if(e.streamMuxers!=null)for(const i of e.streamMuxers)n.uint32(18),n.string(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={webtransportCerthashes:[],streamMuxers:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{if(((a=s.limits)==null?void 0:a.webtransportCerthashes)!=null&&i.webtransportCerthashes.length===s.limits.webtransportCerthashes)throw new _t('Decode error - map field "webtransportCerthashes" had too many elements');i.webtransportCerthashes.push(e.bytes());break}case 2:{if(((c=s.limits)==null?void 0:c.streamMuxers)!=null&&i.streamMuxers.length===s.limits.streamMuxers)throw new _t('Decode error - map field "streamMuxers" had too many elements');i.streamMuxers.push(e.string());break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(vi||(vi={}));var Si;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.identityKey!=null&&e.identityKey.byteLength>0&&(n.uint32(10),n.bytes(e.identityKey)),e.identitySig!=null&&e.identitySig.byteLength>0&&(n.uint32(18),n.bytes(e.identitySig)),e.extensions!=null&&(n.uint32(34),vi.codec().encode(e.extensions,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={identityKey:oe(0),identitySig:oe(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.identityKey=e.bytes();break}case 2:{i.identitySig=e.bytes();break}case 4:{i.extensions=vi.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.extensions});break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Si||(Si={}));async function hg(r,t,e){const n=await r.sign(gg(t));return Si.encode({identityKey:xt(r.publicKey),identitySig:n,extensions:e})}async function fg(r,t,e){try{const n=Si.decode(r),s=Vt(n.identityKey);if((e==null?void 0:e.equals(s))===!1)throw new Error(`Payload identity key ${s} does not match expected remote identity key ${e}`);if(!t)throw new Error("Remote static does not exist");const i=gg(t);if(!await s.verify(i,n.identitySig))throw new Error("Invalid payload signature");return n}catch(n){throw new Ju(n.message)}}function gg(r){const t=Y("noise-libp2p-static-key:");return r instanceof Uint8Array?qt([t,r],t.length+r.length):(r.prepend(t),r)}class ix extends ic{constructor(e,n,s){super({log:e.log,inactivityTimeout:e.inactivityTimeout,maxReadBufferLength:e.maxReadBufferLength,direction:e.direction});l(this,"stream");l(this,"handshake");l(this,"metrics");l(this,"decoder");this.stream=e,this.handshake=n,this.metrics=s,this.decoder=new z0({lengthDecoder:Ei,maxBufferSize:16*1024*1024,encodingLength:()=>2});const i=u=>{try{for(const d of this.decoder.decode(u.data))this.onData(this.decrypt(d))}catch(d){this.abort(d)}};this.stream.addEventListener("message",i);const o=u=>{u.error!=null?u.local===!0?this.abort(u.error):this.onRemoteReset():this.onTransportClosed()};this.stream.addEventListener("close",o);const a=()=>{this.safeDispatchEvent("drain")};this.stream.addEventListener("drain",a);const c=()=>{this.onRemoteCloseWrite()};this.stream.addEventListener("remoteCloseWrite",c)}encrypt(e){var s;const n=new J;for(let i=0;i<e.byteLength;i+=zl){let o=i+zl;o>e.byteLength&&(o=e.byteLength);let a;e instanceof Uint8Array?a=this.handshake.encrypt(e.subarray(i,o)):a=this.handshake.encrypt(e.sublist(i,o)),(s=this.metrics)==null||s.encryptedPackets.increment(),n.append(bi(a.byteLength)),n.append(a)}return n}decrypt(e){var s,i;const n=new J;for(let o=0;o<e.byteLength;o+=qr){let a=o+qr;if(a>e.byteLength&&(a=e.byteLength),a-ql<o)throw new Error("Invalid chunk");let c;e instanceof Uint8Array?c=e.subarray(o,a):c=e.sublist(o,a);const u=e.subarray(o,a-ql);try{const d=this.handshake.decrypt(c,u);(s=this.metrics)==null||s.decryptedPackets.increment(),n.append(d)}catch(d){throw(i=this.metrics)==null||i.decryptErrors.increment(),d}}return n}close(e){return this.stream.close(e)}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}sendReset(e){this.stream.abort(e)}sendData(e){return{sentBytes:e.byteLength,canSendMore:this.stream.send(this.encrypt(e))}}}function Ql(r,t,e){return new ix(r,t,e)}async function ox(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await hg(i,a.publicKey,u),h=new dg({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!0,prologue:o,s:a});ag(h.s,e),e.trace("Stage 0 - Initiator starting to send first message."),await n.write(h.writeMessageA(Ln),t),e.trace("Stage 0 - Initiator finished sending first message."),cg(h.e,e),e.trace("Stage 1 - Initiator waiting to receive first message from responder...");const f=h.readMessageB(await n.read(t));e.trace("Stage 1 - Initiator received the message."),lg(h.re,e),Z1(h.rs,e),e.trace("Initiator going to check remote's signature...");const p=await fg(f,h.rs,c);e.trace("All good with the signature!"),e.trace("Stage 2 - Initiator sending third handshake message."),await n.write(h.writeMessageC(d),t),e.trace("Stage 2 - Initiator sent message with signed payload.");const[g,y]=h.ss.split();return ug(g,y,e),{payload:p,encrypt:m=>g.encryptWithAd(Ln,m),decrypt:(m,S)=>y.decryptWithAd(Ln,m,S)}}async function ax(r,t){const{log:e,connection:n,crypto:s,privateKey:i,prologue:o,s:a,remoteIdentityKey:c,extensions:u}=r,d=await hg(i,a.publicKey,u),h=new dg({crypto:s,protocolName:"Noise_XX_25519_ChaChaPoly_SHA256",initiator:!1,prologue:o,s:a});ag(h.s,e),e.trace("Stage 0 - Responder waiting to receive first message."),h.readMessageA(await n.read(t)),e.trace("Stage 0 - Responder received first message."),lg(h.re,e),e.trace("Stage 1 - Responder sending out first message with signed payload and static key."),await n.write(h.writeMessageB(d),t),e.trace("Stage 1 - Responder sent the second handshake message with signed payload."),cg(h.e,e),e.trace("Stage 2 - Responder waiting for third handshake message...");const f=h.readMessageC(await n.read(t));e.trace("Stage 2 - Responder received the message, finished handshake.");const p=await fg(f,h.rs,c),[g,y]=h.ss.split();return ug(g,y,e),{payload:p,encrypt:m=>y.encryptWithAd(Ln,m),decrypt:(m,S)=>g.decryptWithAd(Ln,m,S)}}var Bu,$u;$u=Symbol.toStringTag,Bu=Ct;class cx{constructor(t,e={}){l(this,"protocol","/noise");l(this,"crypto");l(this,"prologue");l(this,"staticKey");l(this,"extensions");l(this,"metrics");l(this,"components");l(this,"log");l(this,$u,"@chainsafe/libp2p-noise");l(this,Bu,["@libp2p/connection-encryption","@chainsafe/libp2p-noise"]);const{staticNoiseKey:n,extensions:s,crypto:i,prologueBytes:o}=e,{metrics:a}=t;this.components=t,this.log=t.logger.forComponent("libp2p:noise");const c=i??Y1;this.crypto=X1(c),this.extensions={webtransportCerthashes:[],...s},this.metrics=a?Q1(a):void 0,n?this.staticKey=c.generateX25519KeyPairFromSeed(n):this.staticKey=c.generateX25519KeyPair(),this.prologue=o??oe(0)}async secureOutbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=zr(t,{lengthEncoder:bi,lengthDecoder:Ei,maxDataLength:qr}),i=await this.performHandshakeInitiator(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Vt(i.payload.identityKey);return{connection:Ql(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:Mr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}getStreamMuxer(t){if(t==null||t.length===0)return;const e=this.components.upgrader.getStreamMuxers();if(e!=null)for(const n of t){const s=e.get(n);if(s!=null)return s}if(t.length)throw new Mg("Early muxer negotiation was requested but the initiator and responder had no common muxers")}async secureInbound(t,e){var a,c,u;const n=((a=t.log)==null?void 0:a.newScope("noise"))??this.log,s=zr(t,{lengthEncoder:bi,lengthDecoder:Ei,maxDataLength:qr}),i=await this.performHandshakeResponder(s,this.components.privateKey,n,(c=e==null?void 0:e.remotePeer)==null?void 0:c.publicKey,e),o=Vt(i.payload.identityKey);return{connection:Ql(s.unwrap(),i,this.metrics),remoteExtensions:i.payload.extensions,remotePeer:Mr(o),streamMuxer:(e==null?void 0:e.skipStreamMuxerNegotiation)===!0?void 0:this.getStreamMuxer((u=i.payload.extensions)==null?void 0:u.streamMuxers)}}async performHandshakeInitiator(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await ox({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}async performHandshakeResponder(t,e,n,s,i){var c,u;let o;const a=(i==null?void 0:i.skipStreamMuxerNegotiation)===!0?[]:[...this.components.upgrader.getStreamMuxers().keys()];try{o=await ax({connection:t,privateKey:e,remoteIdentityKey:s,log:n.newScope("xxhandshake"),crypto:this.crypto,prologue:this.prologue,s:this.staticKey,extensions:{streamMuxers:a,webtransportCerthashes:[],...this.extensions}},i),(c=this.metrics)==null||c.xxHandshakeSuccesses.increment()}catch(d){throw(u=this.metrics)==null||u.xxHandshakeErrors.increment(),d}return o}}function lx(r={}){return t=>new cx(t,r)}function ux(r){return t=>new b1(t,r)}function dx(r){return r.reason}async function Zl(r,t,e){if(t==null)return r;const n=dx;if(t.aborted)return r.catch(()=>{}),Promise.reject(n(t));let s;try{return await Promise.race([r,new Promise((i,o)=>{s=()=>{o(n(t))},t.addEventListener("abort",s)})])}finally{s!=null&&t.removeEventListener("abort",s)}}var xe;(function(r){r[r.Data=0]="Data",r[r.WindowUpdate=1]="WindowUpdate",r[r.Ping=2]="Ping",r[r.GoAway=3]="GoAway"})(xe||(xe={}));var re;(function(r){r[r.SYN=1]="SYN",r[r.ACK=2]="ACK",r[r.FIN=4]="FIN",r[r.RST=8]="RST"})(re||(re={}));Object.values(re).filter(r=>typeof r!="string");const hx=0;var Qe;(function(r){r[r.NormalTermination=0]="NormalTermination",r[r.ProtocolError=1]="ProtocolError",r[r.InternalError=2]="InternalError"})(Qe||(Qe={}));const nn=12;class is extends Error{constructor(e,n){super(e);l(this,"reason");this.name="ProtocolError",this.reason=n}}l(is,"name","ProtocolError");function fx(r){return(r==null?void 0:r.reason)!==null}class rn extends is{constructor(t="The frame was invalid"){super(t,Qe.ProtocolError),this.name="InvalidFrameError"}}l(rn,"name","InvalidFrameError");class mg extends is{constructor(t="Un-requested ping error"){super(t,Qe.ProtocolError),this.name="UnRequestedPingError"}}l(mg,"name","UnRequestedPingError");class pg extends is{constructor(t="Not matching ping error"){super(t,Qe.ProtocolError),this.name="NotMatchingPingError"}}l(pg,"name","NotMatchingPingError");class yg extends is{constructor(t="Receive window exceeded"){super(t,Qe.ProtocolError),this.name="ReceiveWindowExceededError"}}l(yg,"name","ReceiveWindowExceededError");const wg=256*1024,gx=16*1024*1024,Is={enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3};function mx(r){var t,e,n,s,i,o,a,c;if(r.keepAliveInterval!=null&&r.keepAliveInterval<=0)throw new W("keep-alive interval must be positive");if(r.maxInboundStreams!=null&&r.maxInboundStreams<0)throw new W("max inbound streams must be larger or equal 0");if(r.maxOutboundStreams!=null&&r.maxOutboundStreams<0)throw new W("max outbound streams must be larger or equal 0");if(r.maxMessageSize!=null&&r.maxMessageSize<1024)throw new W("MaxMessageSize must be greater than a kilobyte");if(((t=r.streamOptions)==null?void 0:t.initialStreamWindowSize)!=null&&((e=r.streamOptions)==null?void 0:e.initialStreamWindowSize)<wg)throw new W("InitialStreamWindowSize must be larger or equal 256 kB");if(((n=r.streamOptions)==null?void 0:n.maxStreamWindowSize)!=null&&((s=r.streamOptions)==null?void 0:s.initialStreamWindowSize)!=null&&((i=r.streamOptions)==null?void 0:i.maxStreamWindowSize)<((o=r.streamOptions)==null?void 0:o.initialStreamWindowSize))throw new W("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");if(((a=r.streamOptions)==null?void 0:a.maxStreamWindowSize)!=null&&((c=r.streamOptions)==null?void 0:c.maxStreamWindowSize)>2**32-1)throw new W("MaxStreamWindowSize must be less than equal MAX_UINT32")}function px(r){return r.header.type===xe.Data&&r.data!==null}const Jl=2**24;function yx(r){if(r[0]!==hx)throw new rn("Invalid frame version");return{type:r[1],flag:(r[2]<<8)+r[3],streamID:r[4]*Jl+(r[5]<<16)+(r[6]<<8)+r[7],length:r[8]*Jl+(r[9]<<16)+(r[10]<<8)+r[11]}}class wx{constructor(){l(this,"buffer");this.buffer=new J}*emitFrames(t){for(this.buffer.append(t);;){const e=this.readFrame();if(e===void 0)break;yield e}}readFrame(){let t=nn;if(this.buffer.byteLength<nn)return;const e=yx(this.buffer.subarray(0,nn));if(e.type===xe.Data){if(t+=e.length,this.buffer.byteLength<t)return;const n=this.buffer.sublist(nn,t);return this.buffer.consume(t),{header:e,data:n}}return this.buffer.consume(t),{header:e}}}function jl(r){const t=new Uint8Array(nn);return t[1]=r.type,t[2]=r.flag>>>8,t[3]=r.flag,t[4]=r.streamID>>>24,t[5]=r.streamID>>>16,t[6]=r.streamID>>>8,t[7]=r.streamID,t[8]=r.length>>>24,t[9]=r.length>>>16,t[10]=r.length>>>8,t[11]=r.length,t}var We;(function(r){r[r.Init=0]="Init",r[r.SYNSent=1]="SYNSent",r[r.SYNReceived=2]="SYNReceived",r[r.Established=3]="Established",r[r.Finished=4]="Finished",r[r.Paused=5]="Paused"})(We||(We={}));class bx extends Lh{constructor(e){const n=e.initialStreamWindowSize??wg;super({...e,maxMessageSize:n-nn});l(this,"streamId");l(this,"state");l(this,"sendWindowCapacity");l(this,"recvWindow");l(this,"recvWindowCapacity");l(this,"maxStreamWindowSize");l(this,"epochStart");l(this,"getRTT");l(this,"sendFrame");this.streamId=e.streamId,this.state=e.state,this.sendWindowCapacity=n,this.recvWindow=n,this.recvWindowCapacity=this.recvWindow,this.maxStreamWindowSize=e.maxStreamWindowSize??gx,this.epochStart=Date.now(),this.getRTT=e.getRTT,this.sendFrame=e.sendFrame;const s=()=>{this.state=We.Finished};this.addEventListener("close",s)}sendData(e){var o,a;const n=e.byteLength;let s=0,i=!0;for((o=this.log)==null||o.trace("send window capacity is %d bytes",this.sendWindowCapacity);e.byteLength>0;){if(this.sendWindowCapacity===0){i=!1,(a=this.log)==null||a.trace("sent %d/%d bytes, exhausted send window, waiting for window update",s,n);break}const c=Math.min(this.sendWindowCapacity,e.byteLength),u=this.getSendFlags(),d=e.sublist(0,c);e.consume(c);const h=this.sendFrame({type:xe.Data,flag:u,streamID:this.streamId,length:c},d);if(this.sendWindowCapacity-=c,s+=c,!h){i=h,this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity",s,n);break}}return{sentBytes:s,canSendMore:i}}async sendReset(){this.sendFrame({type:xe.WindowUpdate,flag:re.RST,streamID:this.streamId,length:0})}async sendCloseWrite(){const e=this.getSendFlags()|re.FIN;this.sendFrame({type:xe.WindowUpdate,flag:e,streamID:this.streamId,length:0})}async sendCloseRead(e){var n;(n=e==null?void 0:e.signal)==null||n.throwIfAborted()}sendPause(){this.state=We.Paused}sendResume(){this.state=We.Established,this.sendWindowUpdate()}handleWindowUpdate(e){var n;this.processFlags(e.header.flag),this.sendWindowCapacity+=e.header.length,this.maxMessageSize=this.sendWindowCapacity-nn,this.maxMessageSize<0&&(this.maxMessageSize=0),this.maxMessageSize!==0&&this.writeBuffer.byteLength>0&&((n=this.log)==null||n.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s",e.header.length,this.writeBuffer.byteLength,this.sendingData),this.safeDispatchEvent("drain"))}handleData(e){if(!px(e))throw new rn("Frame was not data frame");if(this.processFlags(e.header.flag),this.recvWindowCapacity<e.header.length)throw new yg("Receive window exceeded");this.recvWindowCapacity-=e.header.length,this.onData(e.data),this.sendWindowUpdate()}processFlags(e){(e&re.ACK)===re.ACK&&this.state===We.SYNSent&&(this.state=We.Established),(e&re.FIN)===re.FIN&&this.onRemoteCloseWrite(),(e&re.RST)===re.RST&&this.onRemoteReset()}getSendFlags(){switch(this.state){case We.Init:return this.state=We.SYNSent,re.SYN;case We.SYNReceived:return this.state=We.Established,re.ACK;default:return 0}}sendWindowUpdate(){if(this.state===We.Paused){this.epochStart=Date.now();return}const e=this.getSendFlags(),n=Date.now(),s=this.getRTT();if(e===0&&s>-1&&n-this.epochStart<=s*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&e===0)return;const i=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=n,this.sendFrame({type:xe.WindowUpdate,flag:e,streamID:this.streamId,length:i})}}function eu(r){return{type:xe[r.type],flags:[(r.flag&re.SYN)===re.SYN?"SYN":void 0,(r.flag&re.ACK)===re.ACK?"ACK":void 0,(r.flag&re.FIN)===re.FIN?"FIN":void 0,(r.flag&re.RST)===re.RST?"RST":void 0].filter(Boolean),streamID:r.streamID,length:r.length}}const bg="/yamux/1.0.0";var Uu,zu;zu=Symbol.toStringTag,Uu=Ct;class Ex{constructor(t={}){l(this,"protocol",bg);l(this,"_init");l(this,zu,"@chainsafe/libp2p-yamux");l(this,Uu,["@libp2p/stream-multiplexing"]);this._init=t}createStreamMuxer(t){return new vx(t,{...this._init})}}class vx extends Th{constructor(e,n={}){super(e,{...n,protocol:bg,name:"yamux"});l(this,"nextStreamID");l(this,"nextPingID");l(this,"activePing");l(this,"rtt");l(this,"client");l(this,"localGoAway");l(this,"remoteGoAway");l(this,"numInboundStreams");l(this,"numOutboundStreams");l(this,"decoder");l(this,"keepAlive");l(this,"enableKeepAlive");l(this,"keepAliveInterval");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");this.client=e.direction==="outbound",mx(n),this.enableKeepAlive=n.enableKeepAlive??Is.enableKeepAlive,this.keepAliveInterval=n.keepAliveInterval??Is.keepAliveInterval,this.maxInboundStreams=n.maxInboundStreams??Is.maxInboundStreams,this.maxOutboundStreams=n.maxOutboundStreams??Is.maxOutboundStreams,this.decoder=new wx,this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=-1,this.log.trace("muxer created"),this.enableKeepAlive&&(this.log.trace("muxer keepalive enabled interval=%s",this.keepAliveInterval),this.keepAlive=Y0(async s=>{try{await this.ping(s)}catch(i){this.log.error("ping error: %s",i)}},this.keepAliveInterval,{runImmediately:!0}),this.keepAlive.start())}onData(e){for(const n of this.decoder.emitFrames(e))this.handleFrame(n)}onCreateStream(){if(this.remoteGoAway!==void 0)throw new bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new bn("Muxer closed locally");const e=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.maxOutboundStreams)throw new Pa("max outbound streams exceeded");this.log.trace("new outgoing stream id=%s",e);const n=this._newStream(e,We.Init,"outbound");return this.numOutboundStreams++,queueMicrotask(()=>{n.sendWindowUpdate()}),n}async ping(e){if(this.remoteGoAway!==void 0)throw new bn("Muxer closed remotely");if(this.localGoAway!==void 0)throw new bn("Muxer closed locally");if(this.activePing!=null)return Zl(this.activePing.promise,e==null?void 0:e.signal);this.activePing=Object.assign(Promise.withResolvers(),{id:this.nextPingID++,start:Date.now()}),this.sendPing(this.activePing.id);try{this.rtt=await Zl(this.activePing.promise,e==null?void 0:e.signal)}finally{this.activePing=void 0}return this.rtt}getRTT(){return this.rtt}async close(e={}){var n;if(this.status==="open")try{const s=(e==null?void 0:e.reason)??Qe.NormalTermination;this.log.trace("muxer close reason=%s",Qe[s]),await super.close(e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}abort(e){var n;if(this.status==="open")try{super.abort(e);let s=Qe.InternalError;fx(e)&&(s=e.reason),this.log.error("muxer abort reason=%s error=%s",s,e),this.sendGoAway(s)}finally{(n=this.keepAlive)==null||n.stop()}}onTransportClosed(){var e;try{super.onTransportClosed()}finally{(e=this.keepAlive)==null||e.stop()}}_newStream(e,n,s){if(this.streams.find(o=>o.streamId===e)!=null)throw new W("Stream already exists with that id");const i=new bx({...this.streamOptions,id:`${e}`,streamId:e,state:n,direction:s,sendFrame:this.sendFrame.bind(this),log:this.log.newScope(`${s}:${e}`),getRTT:this.getRTT.bind(this)});return i.addEventListener("close",()=>{this.closeStream(e)},{once:!0}),i}closeStream(e){this.client===(e%2===0)?this.numInboundStreams--:this.numOutboundStreams--}handleFrame(e){const{streamID:n,type:s,length:i}=e.header;if(this.log.trace("received frame %o",eu(e.header)),n===0)switch(s){case xe.Ping:{this.handlePing(e.header);return}case xe.GoAway:{this.handleGoAway(i);return}default:throw new rn("Invalid frame type")}else switch(e.header.type){case xe.Data:case xe.WindowUpdate:{this.handleStreamMessage(e);return}default:throw new rn("Invalid frame type")}}handlePing(e){if(e.flag===re.SYN)this.log.trace("received ping request pingId=%s",e.length),this.sendPing(e.length,re.ACK);else if(e.flag===re.ACK)this.log.trace("received ping response pingId=%s",e.length),this.handlePingResponse(e.length);else throw new rn("Invalid frame flag")}handlePingResponse(e){if(this.activePing===void 0)throw new mg("ping not requested");if(this.activePing.id!==e)throw new pg("ping doesn't match our id");this.activePing.resolve(Date.now()-this.activePing.start)}handleGoAway(e){this.log.trace("received GoAway reason=%s",Qe[e]??"unknown"),this.remoteGoAway=e,e===Qe.NormalTermination?this.onTransportClosed():this.abort(new Error("Remote sent GoAway"))}handleStreamMessage(e){const{streamID:n,flag:s,type:i}=e.header;(s&re.SYN)===re.SYN&&this.incomingStream(n);const o=this.streams.find(a=>a.streamId===n);if(o===void 0){this.log.trace("frame for missing stream id=%s",n);return}switch(i){case xe.WindowUpdate:{o.handleWindowUpdate(e);return}case xe.Data:{o.handleData(e);return}default:throw new Error("unreachable")}}incomingStream(e){if(this.client!==(e%2===0))throw new W("Both endpoints are clients");if(this.streams.find(s=>s.streamId===e))return;if(this.log.trace("new incoming stream id=%s",e),this.localGoAway!==void 0){this.sendFrame({type:xe.WindowUpdate,flag:re.RST,streamID:e,length:0});return}if(this.numInboundStreams>=this.maxInboundStreams){this.log("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:xe.WindowUpdate,flag:re.RST,streamID:e,length:0});return}const n=this._newStream(e,We.SYNReceived,"inbound");this.numInboundStreams++,this.onRemoteStream(n)}sendFrame(e,n){let s;if(e.type===xe.Data){if(n==null)throw new rn("Invalid frame");s=new J(jl(e),n)}else s=jl(e);return this.log.trace("sending frame %o",eu(e)),this.send(s)}sendPing(e,n=re.SYN){n===re.SYN?this.log.trace("sending ping request pingId=%s",e):this.log.trace("sending ping response pingId=%s",e),this.sendFrame({type:xe.Ping,flag:n,streamID:0,length:e})}sendGoAway(e=Qe.NormalTermination){this.log("sending GoAway reason=%s",Qe[e]),this.localGoAway=e,this.sendFrame({type:xe.GoAway,flag:0,streamID:0,length:e})}}function Sx(r={}){return()=>new Ex(r)}const xx="0.1.0",Ax="id",Cx="1.0.0",_x=1024*8;var xi;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.protocolVersion!=null&&(n.uint32(42),n.string(e.protocolVersion)),e.agentVersion!=null&&(n.uint32(50),n.string(e.agentVersion)),e.publicKey!=null&&(n.uint32(10),n.bytes(e.publicKey)),e.listenAddrs!=null)for(const i of e.listenAddrs)n.uint32(18),n.bytes(i);if(e.observedAddr!=null&&(n.uint32(34),n.bytes(e.observedAddr)),e.protocols!=null)for(const i of e.protocols)n.uint32(26),n.string(i);e.signedPeerRecord!=null&&(n.uint32(66),n.bytes(e.signedPeerRecord)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={listenAddrs:[],protocols:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 5:{i.protocolVersion=e.string();break}case 6:{i.agentVersion=e.string();break}case 1:{i.publicKey=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.listenAddrs)!=null&&i.listenAddrs.length===s.limits.listenAddrs)throw new _t('Decode error - map field "listenAddrs" had too many elements');i.listenAddrs.push(e.bytes());break}case 4:{i.observedAddr=e.bytes();break}case 3:{if(((c=s.limits)==null?void 0:c.protocols)!=null&&i.protocols.length===s.limits.protocols)throw new _t('Decode error - map field "protocols" had too many elements');i.protocols.push(e.string());break}case 8:{i.signedPeerRecord=e.bytes();break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(xi||(xi={}));const wt={protocolPrefix:"ipfs",timeout:5e3,maxInboundStreams:1,maxOutboundStreams:1,maxObservedAddresses:10,maxMessageSize:_x,runOnConnectionOpen:!0,runOnLimitedConnection:!0};function Ix(r){if(r!=null&&r.length>0)try{return X(r)}catch{}}async function Tx(r,t,e,n,s){if(e("received identify from %p",n.remotePeer),s==null)throw new it("message was null or undefined");const i={};if(s.listenAddrs.length>0&&(i.addresses=s.listenAddrs.map(c=>({isCertified:!1,multiaddr:X(c)}))),s.protocols.length>0&&(i.protocols=s.protocols),s.publicKey!=null){const c=Vt(s.publicKey);if(!Mr(c).equals(n.remotePeer))throw new it("public key did not match remote PeerId");i.publicKey=c}let o;if(s.signedPeerRecord!=null){e.trace("received signedPeerRecord from %p",n.remotePeer);let c=s.signedPeerRecord;const u=await fn.openAndCertify(c,At.DOMAIN);let d=At.createFromProtobuf(u.payload);const h=ns(u.publicKey.toCID());if(!d.peerId.equals(h))throw new it("signing key does not match PeerId in the PeerRecord");if(!n.remotePeer.equals(d.peerId))throw new it("signing key does not match remote PeerId");let f;try{f=await r.get(d.peerId)}catch(p){if(p.name!=="NotFoundError")throw p}if(f!=null&&(i.metadata=f.metadata,f.peerRecordEnvelope!=null)){const p=fn.createFromProtobuf(f.peerRecordEnvelope),g=At.createFromProtobuf(p.payload);g.seqNumber>=d.seqNumber&&(e("sequence number was lower or equal to existing sequence number - stored: %d received: %d",g.seqNumber,d.seqNumber),d=g,c=f.peerRecordEnvelope)}i.peerRecordEnvelope=c,i.addresses=d.multiaddrs.map(p=>({isCertified:!0,multiaddr:p})),o={seq:d.seqNumber,addresses:d.multiaddrs}}else e("%p did not send a signed peer record",n.remotePeer);if(e.trace("patching %p with",n.remotePeer,i),await r.patch(n.remotePeer,i),s.agentVersion!=null||s.protocolVersion!=null){const c={};s.agentVersion!=null&&(c.AgentVersion=Y(s.agentVersion)),s.protocolVersion!=null&&(c.ProtocolVersion=Y(s.protocolVersion)),e.trace("merging %p metadata",n.remotePeer,c),await r.merge(n.remotePeer,{metadata:c})}const a={peerId:n.remotePeer,protocolVersion:s.protocolVersion,agentVersion:s.agentVersion,publicKey:s.publicKey,listenAddrs:s.listenAddrs.map(c=>X(c)),observedAddr:s.observedAddr==null?void 0:X(s.observedAddr),protocols:s.protocols,signedPeerRecord:o,connection:n};return t.safeDispatchEvent("peer:identify",{detail:a}),a}class Lx{constructor(t,e){l(this,"host");l(this,"components");l(this,"protocol");l(this,"started");l(this,"timeout");l(this,"maxInboundStreams");l(this,"maxOutboundStreams");l(this,"maxMessageSize");l(this,"maxObservedAddresses");l(this,"runOnLimitedConnection");l(this,"log");this.protocol=e.protocol,this.started=!1,this.components=t,this.log=e.log,this.timeout=e.timeout??wt.timeout,this.maxInboundStreams=e.maxInboundStreams??wt.maxInboundStreams,this.maxOutboundStreams=e.maxOutboundStreams??wt.maxOutboundStreams,this.maxMessageSize=e.maxMessageSize??wt.maxMessageSize,this.maxObservedAddresses=e.maxObservedAddresses??wt.maxObservedAddresses,this.runOnLimitedConnection=e.runOnLimitedConnection??wt.runOnLimitedConnection,this.host={protocolVersion:`${e.protocolPrefix??wt.protocolPrefix}/${xx}`,agentVersion:t.nodeInfo.userAgent},this.handleProtocol=this.handleProtocol.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.peerStore.merge(this.components.peerId,{metadata:{AgentVersion:Y(this.host.agentVersion),ProtocolVersion:Y(this.host.protocolVersion)}}),await this.components.registrar.handle(this.protocol,this.handleProtocol,{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnLimitedConnection:this.runOnLimitedConnection}),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}}var qu,Ku;class Dx extends(Ku=Lx,qu=Ct,Ku){constructor(e,n={}){super(e,{...n,protocol:`/${n.protocolPrefix??wt.protocolPrefix}/${Ax}/${Cx}`,log:e.logger.forComponent("libp2p:identify")});l(this,qu,["@libp2p/identify"]);(n.runOnConnectionOpen??wt.runOnConnectionOpen)&&e.events.addEventListener("connection:open",s=>{const i=s.detail;this.identify(i).catch(()=>{})})}async _identify(e,n={}){let s,i;if(n.signal==null){const o=AbortSignal.timeout(this.timeout);n={...n,signal:o}}this.log("run identify on new connection %a",e.remoteAddr);try{s=await e.newStream(this.protocol,{...n,runOnLimitedConnection:this.runOnLimitedConnection}),i=s.log.newScope("identify");const o=hn(s,{maxDataLength:this.maxMessageSize}).pb(xi),a=await o.read(n);return await o.unwrap().unwrap().close(n),a}catch(o){throw i==null||i.error("identify failed - %e",o),s==null||s.abort(o),o}}async identify(e,n={}){const s=await this._identify(e,n),{publicKey:i,protocols:o,observedAddr:a}=s;if(i==null)throw new it("Public key was missing from identify message");const c=Vt(i),u=ns(c.toCID());if(!e.remotePeer.equals(u))throw new it("Identified peer does not match the expected peer");if(this.components.peerId.equals(u))throw new it("Identified peer is our own peer id?");return this.maybeAddObservedAddress(a),this.log("completed for peer %p and protocols %o",u,o),Tx(this.components.peerStore,this.components.events,this.log,e,s)}maybeAddObservedAddress(e){const n=Ix(e);if(n==null||(this.log.trace("our observed address was %a",n),Hn(n)))return;const s=n.getComponents();if((s[0].code===Yn||s[0].code===oc&&s[1].code===Yn)&&!gb(n)){this.log.trace("our observed address was IPv6 but not a global unicast address");return}gi.exactMatch(n)||(this.log.trace("storing the observed address"),this.components.addressManager.addObservedAddr(n))}async handleProtocol(e,n){const s=e.log.newScope("identify");s("responding to identify");const i=AbortSignal.timeout(this.timeout),o=await this.components.peerStore.get(this.components.peerId,{signal:i}),a=this.components.addressManager.getAddresses().map(h=>h.decapsulateCode(V));let c=o.peerRecordEnvelope;if(a.length>0&&c==null){const h=new At({peerId:this.components.peerId,multiaddrs:a});c=(await fn.seal(h,this.components.privateKey,{signal:i})).marshal().subarray()}let u=n.remoteAddr.bytes;WE.matches(n.remoteAddr)||(u=void 0);const d=hn(e).pb(xi);s("send response"),await d.write({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:xt(this.components.privateKey.publicKey),listenAddrs:a.map(h=>h.bytes),signedPeerRecord:c,observedAddr:u,protocols:o.protocols},{signal:i}),s("close write"),await d.unwrap().unwrap().close({signal:i})}}function Px(r={}){return t=>new Dx(t,r)}const Rx=1,Eg=5e3,kx=100,Ts=`${ka}-circuit-relay`;BigInt(1<<17);const Ai="/libp2p/circuit/relay/0.2.0/hop",tu="/libp2p/circuit/relay/0.2.0/stop",nu=300,Mx=4096,Nx=.001;var Jn;(function(r){(function(n){n.RESERVE="RESERVE",n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.RESERVE=0]="RESERVE",n[n.CONNECT=1]="CONNECT",n[n.STATUS=2]="STATUS"})(t||(t={})),function(n){n.codec=()=>nr(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),jn.codec().encode(n.peer,s)),n.reservation!=null&&(s.uint32(26),Ci.codec().encode(n.reservation,s)),n.limit!=null&&(s.uint32(34),er.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(40),ze.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u,d;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const h=n.uint32();switch(h>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=jn.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.reservation=Ci.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.reservation});break}case 4:{o.limit=er.codec().decode(n,n.uint32(),{limits:(d=i.limits)==null?void 0:d.limit});break}case 5:{o.status=ze.codec().decode(n);break}default:{n.skipType(h&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(Jn||(Jn={}));var bt;(function(r){(function(n){n.CONNECT="CONNECT",n.STATUS="STATUS"})(r.Type||(r.Type={}));let t;(function(n){n[n.CONNECT=0]="CONNECT",n[n.STATUS=1]="STATUS"})(t||(t={})),function(n){n.codec=()=>nr(t)}(r.Type||(r.Type={}));let e;r.codec=()=>(e==null&&(e=Se((n,s,i={})=>{i.lengthDelimited!==!1&&s.fork(),n.type!=null&&(s.uint32(8),r.Type.codec().encode(n.type,s)),n.peer!=null&&(s.uint32(18),jn.codec().encode(n.peer,s)),n.limit!=null&&(s.uint32(26),er.codec().encode(n.limit,s)),n.status!=null&&(s.uint32(32),ze.codec().encode(n.status,s)),i.lengthDelimited!==!1&&s.ldelim()},(n,s,i={})=>{var c,u;const o={},a=s==null?n.len:n.pos+s;for(;n.pos<a;){const d=n.uint32();switch(d>>>3){case 1:{o.type=r.Type.codec().decode(n);break}case 2:{o.peer=jn.codec().decode(n,n.uint32(),{limits:(c=i.limits)==null?void 0:c.peer});break}case 3:{o.limit=er.codec().decode(n,n.uint32(),{limits:(u=i.limits)==null?void 0:u.limit});break}case 4:{o.status=ze.codec().decode(n);break}default:{n.skipType(d&7);break}}}return o})),e),r.encode=n=>ve(n,r.codec()),r.decode=(n,s)=>Ee(n,r.codec(),s)})(bt||(bt={}));var jn;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.id!=null&&e.id.byteLength>0&&(n.uint32(10),n.bytes(e.id)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={id:oe(0),addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.id=e.bytes();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new _t('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(jn||(jn={}));var Ci;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{if(s.lengthDelimited!==!1&&n.fork(),e.expire!=null&&e.expire!==0n&&(n.uint32(8),n.uint64(e.expire)),e.addrs!=null)for(const i of e.addrs)n.uint32(18),n.bytes(i);e.voucher!=null&&(n.uint32(26),Ii.codec().encode(e.voucher,n)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a,c;const i={expire:0n,addrs:[]},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const u=e.uint32();switch(u>>>3){case 1:{i.expire=e.uint64();break}case 2:{if(((a=s.limits)==null?void 0:a.addrs)!=null&&i.addrs.length===s.limits.addrs)throw new _t('Decode error - map field "addrs" had too many elements');i.addrs.push(e.bytes());break}case 3:{i.voucher=Ii.codec().decode(e,e.uint32(),{limits:(c=s.limits)==null?void 0:c.voucher});break}default:{e.skipType(u&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Ci||(Ci={}));var er;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.duration!=null&&(n.uint32(8),n.uint32(e.duration)),e.data!=null&&(n.uint32(16),n.uint64(e.data)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.duration=e.uint32();break}case 2:{i.data=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(er||(er={}));var ze;(function(r){r.UNUSED="UNUSED",r.OK="OK",r.RESERVATION_REFUSED="RESERVATION_REFUSED",r.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",r.PERMISSION_DENIED="PERMISSION_DENIED",r.CONNECTION_FAILED="CONNECTION_FAILED",r.NO_RESERVATION="NO_RESERVATION",r.MALFORMED_MESSAGE="MALFORMED_MESSAGE",r.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(ze||(ze={}));var xa;(function(r){r[r.UNUSED=0]="UNUSED",r[r.OK=100]="OK",r[r.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",r[r.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",r[r.PERMISSION_DENIED=202]="PERMISSION_DENIED",r[r.CONNECTION_FAILED=203]="CONNECTION_FAILED",r[r.NO_RESERVATION=204]="NO_RESERVATION",r[r.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",r[r.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(xa||(xa={}));(function(r){r.codec=()=>nr(xa)})(ze||(ze={}));var _i;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.relay!=null&&e.relay.byteLength>0&&(n.uint32(10),n.bytes(e.relay)),e.peer!=null&&e.peer.byteLength>0&&(n.uint32(18),n.bytes(e.peer)),e.expiration!=null&&e.expiration!==0n&&(n.uint32(24),n.uint64(e.expiration)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{const i={relay:oe(0),peer:oe(0),expiration:0n},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const a=e.uint32();switch(a>>>3){case 1:{i.relay=e.bytes();break}case 2:{i.peer=e.bytes();break}case 3:{i.expiration=e.uint64();break}default:{e.skipType(a&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(_i||(_i={}));var Ii;(function(r){let t;r.codec=()=>(t==null&&(t=Se((e,n,s={})=>{s.lengthDelimited!==!1&&n.fork(),e.publicKey!=null&&e.publicKey.byteLength>0&&(n.uint32(10),n.bytes(e.publicKey)),e.payloadType!=null&&e.payloadType.byteLength>0&&(n.uint32(18),n.bytes(e.payloadType)),e.payload!=null&&(n.uint32(26),_i.codec().encode(e.payload,n)),e.signature!=null&&e.signature.byteLength>0&&(n.uint32(42),n.bytes(e.signature)),s.lengthDelimited!==!1&&n.ldelim()},(e,n,s={})=>{var a;const i={publicKey:oe(0),payloadType:oe(0),signature:oe(0)},o=n==null?e.len:e.pos+n;for(;e.pos<o;){const c=e.uint32();switch(c>>>3){case 1:{i.publicKey=e.bytes();break}case 2:{i.payloadType=e.bytes();break}case 3:{i.payload=_i.codec().decode(e,e.uint32(),{limits:(a=s.limits)==null?void 0:a.payload});break}case 5:{i.signature=e.bytes();break}default:{e.skipType(c&7);break}}}return i})),t),r.encode=e=>ve(e,r.codec()),r.decode=(e,n)=>Ee(e,r.codec(),n)})(Ii||(Ii={}));class Aa extends Error{constructor(){super(...arguments);l(this,"name","HadEnoughRelaysError")}}l(Aa,"name","HadEnoughRelaysError");class vg extends Error{constructor(){super(...arguments);l(this,"name","DoubleRelayError")}}l(vg,"name","DoubleRelayError");class Sg extends Error{constructor(){super(...arguments);l(this,"name","RelayQueueFullError")}}l(Sg,"name","RelayQueueFullError");function ru(r){const t=r*BigInt(1e3),e=new Date().getTime();return Number(t-BigInt(e))}class su{constructor(t){l(this,"expires");l(this,"bytes");(t==null?void 0:t.duration)!=null&&(t==null?void 0:t.duration)!==0&&(this.expires=Date.now()+t.duration*1e3),this.bytes=t==null?void 0:t.data,this.bytes===0n&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(t){this.bytes!=null&&(this.bytes-=BigInt(t.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(this.expires==null&&this.bytes==null)return;const t={};if(this.bytes!=null){const e=this;Object.defineProperty(t,"bytes",{get(){return e.bytes}})}if(this.expires!=null){const e=this;Object.defineProperty(t,"seconds",{get(){return Math.round(((e.expires??0)-Date.now())/1e3)}})}return t}}const xg=ue(ie(pc.matchers[0],ce(sr))),Ag=ue(ce(sr));class Ox extends Xe{constructor(e,n={}){super();l(this,"components");l(this,"started");l(this,"running");l(this,"topologyId");l(this,"log");l(this,"discoveryController");l(this,"filter");l(this,"queue");this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=n.filter,this.discoveryController=new AbortController,this.discoveryController.signal,this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(Ai,{filter:this.filter,onConnect:e=>{var n,s;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,(n=this.queue)==null?void 0:n.size,(s=this.queue)==null?void 0:s.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){this.topologyId!=null&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,this.discoveryController.signal,this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var s;this.log("searching peer store for relays");const e=await this.components.peerStore.all({filters:[i=>i.protocols.includes(Ai)],orders:[()=>Math.random()<.5?1:-1,(i,o)=>{const a=iu(i),c=iu(o);return a>c?-1:c>a?1:0}]});for(const i of e)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",e.length);const n=this.queue=new dc({concurrency:5});this.log("start random walk");for await(const i of this.components.randomWalk.walk({signal:this.discoveryController.signal})){if(this.log.trace("found random peer %p",i.id),n.has(i.id)){this.log.trace("random peer %p was already in queue",i.id);continue}if(((s=this.components.connectionManager.getConnections(i.id))==null?void 0:s.length)>0){this.log.trace("random peer %p was already connected",i.id);continue}if(!await this.components.connectionManager.isDialable(i.multiaddrs)){this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(o=>o.toString()));continue}n.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await n.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,n.size,n.running),n.add(this.dialPeer,{peerId:i.id,signal:this.discoveryController.signal}).catch(o=>{this.log.error("error opening connection to random peer %p - %e",i.id,o)})}this.log("stop random walk"),await n.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network - %e",e)}))}stopDiscovery(){var e,n;this.log("stop discovery"),this.running=!1,(e=this.discoveryController)==null||e.abort(),(n=this.queue)==null||n.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p",e.detail.id),this.maybeDialPeer(e).catch(n=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,n)})}async maybeDialPeer(e){var i,o;if(this.queue==null)return;const n=e.detail.id,s=e.detail.multiaddrs;if(this.queue.has(n)){this.log.trace("random peer %p was already in queue",n);return}if(((i=this.components.connectionManager.getConnections(n))==null?void 0:i.length)>0){this.log.trace("random peer %p was already connected",n);return}if(!await this.components.connectionManager.isDialable(s)){this.log.trace("random peer %p was not dialable",n);return}(o=this.queue)==null||o.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(a=>{this.log.error("error opening connection to discovered peer %p - %e",e.detail.id,a)})}async dialPeer({peerId:e,signal:n}){const s=dn([AbortSignal.timeout(5e3),n]);try{await this.components.connectionManager.openConnection(e,{signal:s})}finally{s.clear()}}}function iu(r){const t=r.metadata.get("last-dial-success");return t==null?0:new Date(Z(t)).getTime()}class Fx extends Xe{constructor(e,n={}){super();l(this,"connectionManager");l(this,"addressManager");l(this,"reservationStore");l(this,"listeningAddrs");l(this,"log");l(this,"listenTimeout");l(this,"reservationId");l(this,"relay");l(this,"_onRemoveRelayPeer",e=>{var n,s;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,(n=this.relay)==null?void 0:n.equals(e.detail.relay)),((s=this.relay)==null?void 0:s.equals(e.detail.relay))===!0&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(i=>{this.addressManager.removeObservedAddr(i)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))});l(this,"_onAddRelayPeer",e=>{const{details:n}=e.detail;n.type!=="configured"&&n.id===this.reservationId&&this.addedRelay(e.detail)});this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=n.listenTimeout??Eg,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(Ag.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else if(xg.exactMatch(e)){this.log("listen on specific relay server %a",e);const n=AbortSignal.timeout(this.listenTimeout),s=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(s,{signal:n});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const o=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(o)}}else throw new Ws(`Could not listen on p2p-circuit address "${e}"`)}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(n=>X(n).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(n=>{this.addressManager.confirmObservedAddr(n,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}function Bx(r){return new Fx(r)}const $x="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";let Ux=(r=21)=>{let t="",e=crypto.getRandomValues(new Uint8Array(r|=0));for(;r--;)t+=$x[e[r]&63];return t};const zx=60*1e3*10,qx=60*1e3*5,Kx=30*1e3;var Ge,Cg,yr,wr;class Vx extends Xe{constructor(e,n){super();he(this,Ge);l(this,"peerId");l(this,"connectionManager");l(this,"peerStore");l(this,"events");l(this,"reserveQueue");l(this,"reservations");l(this,"pendingReservations");l(this,"maxReservationQueueLength");l(this,"reservationCompletionTimeout");l(this,"started");l(this,"log");l(this,"relayFilter");this.log=e.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=e.peerId,this.connectionManager=e.connectionManager,this.peerStore=e.peerStore,this.events=e.events,this.reservations=new rr,this.pendingReservations=[],this.maxReservationQueueLength=(n==null?void 0:n.maxReservationQueueLength)??kx,this.reservationCompletionTimeout=(n==null?void 0:n.reservationCompletionTimeout)??Eg,this.started=!1,this.relayFilter=Fr(100),this.reserveQueue=new dc({concurrency:(n==null?void 0:n.reservationConcurrency)??Rx,metricName:"libp2p_relay_reservation_queue",metrics:e.metrics}),this.events.addEventListener("connection:close",s=>{[...this.reservations.values()].find(o=>o.connection===s.detail.id)!=null&&H(this,Ge,yr).call(this,s.detail.remotePeer).catch(o=>{this.log("could not remove relay %p - %e",s.detail,o)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const e=await this.peerStore.all({filters:[n=>n.tags.has(Ts)]});this.log("removing tag from %d old relays",e.length),await Promise.all(e.map(async n=>{await this.peerStore.merge(n.id,{tags:{[Ts]:void 0}})})),this.log("redialing %d old relays",e.length),await Promise.all(e.map(async n=>this.addRelay(n.id,"discovered"))),H(this,Ge,wr).call(this)}).catch(e=>{this.log.error("failed to clean up and redial old relays during afterStart - %e",e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const e=Ux();return this.pendingReservations.push(e),H(this,Ge,wr).call(this),e}async addRelay(e,n){if(this.peerId.equals(e))throw this.log.trace("not trying to use self as relay"),new Ws("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Sg("The reservation queue is full");const s=this.reserveQueue.find(e);if(s!=null)return this.log.trace("potential relay peer %p is already in the reservation queue",e),s.join();if(this.relayFilter.has(e.toMultihash().bytes))throw new Ws("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",e),this.reserveQueue.add(async()=>{const i=Date.now();try{const o=this.reservations.get(e);if(o!=null){const y=this.connectionManager.getConnections(e);let m=!1;if(y.length===0&&this.log("already have relay reservation with %p but we are no longer connected",e),y.map(S=>S.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",e),m=!0),m&&ru(o.reservation.expire)>zx)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",e),{relay:e,details:o};await H(this,Ge,yr).call(this,e)}if(n==="discovered"&&this.pendingReservations.length===0)throw new Aa("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);const c=await this.connectionManager.openConnection(e,{signal:a});if(Qn.matches(c.remoteAddr))throw new vg("not creating reservation over relayed connection");const u=await H(this,Ge,Cg).call(this,c,{signal:a}),d=ru(u.expire);this.log("created reservation on relay peer %p, expiry date is %s",e,new Date(Date.now()+d).toString());const h=Math.min(Math.max(d-qx,Kx),Math.pow(2,31)-1),f=setTimeout(()=>{this.log("refresh reservation to relay %p",e),this.addRelay(e,n).catch(async y=>{this.log.error("could not refresh reservation to relay %p - %e",e,y),await H(this,Ge,yr).call(this,e)}).catch(y=>{this.log.error("could not remove expired reservation to relay %p - %e",e,y)})},h);let p;if(n==="discovered"){const y=this.pendingReservations.pop();if(y==null)throw new Aa("Made reservation on relay but did not need any more discovered relays");p={timeout:f,reservation:u,type:n,connection:c.id,id:y}}else p={timeout:f,reservation:u,type:n,connection:c.id};this.reservations.set(e,p),await this.peerStore.merge(e,{tags:{[Ts]:{value:1,ttl:d}}}),H(this,Ge,wr).call(this);const g={relay:e,details:p};return this.safeDispatchEvent("relay:created-reservation",{detail:g}),g}catch(o){throw n==="discovered"&&o.name==="HadEnoughRelaysError"||this.log.error("could not reserve slot on %p after %dms - %e",e,Date.now()-i,o),(o.name==="DialError"||o.name==="UnsupportedProtocolError")&&this.relayFilter.add(e.toMultihash().bytes),H(this,Ge,yr).call(this,e).catch(a=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",e,a)}),o}},{peerId:e})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var n;return(n=this.reservations.get(e))==null?void 0:n.reservation}reservationCount(e){return e==null?this.reservations.size:[...this.reservations.values()].reduce((n,s)=>(s.type===e&&n++,n),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}Ge=new WeakSet,Cg=async function(e,n){var u;(u=n.signal)==null||u.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const s=await e.newStream(Ai,n),o=hn(s).pb(Jn);this.log.trace("send RESERVE to %p",e.remotePeer),await o.write({type:Jn.Type.RESERVE},n);let a;try{this.log.trace("reading response from %p",e.remotePeer),a=await o.read(n)}catch(d){throw s.abort(d),d}finally{s.status!=="closed"&&await s.close(n)}if(this.log.trace("read response %s",a.status),a.status===ze.OK&&a.reservation!=null){const d=new Set;d.add(e.remoteAddr.toString());for(const h of a.reservation.addrs){let f=X(h);f.getComponents().find(p=>p.code===V)==null&&(f=f.encapsulate(`/p2p/${e.remotePeer}`)),f=X(f.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),d.add(f.toString())}return a.reservation.addrs=[...d].map(h=>X(h).bytes),a.reservation}const c=`reservation failed with status ${a.status??"undefined"}`;throw this.log.error(c),new Error(c)},yr=async function(e){const n=this.reservations.get(e);n!=null&&(this.log("removing relay reservation with %p from local store",e),clearTimeout(n.timeout),this.reservations.delete(e),n.type==="discovered"&&this.pendingReservations.push(n.id),await this.peerStore.merge(e,{tags:{[Ts]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:e,details:n}}),H(this,Ge,wr).call(this))},wr=function(){if(this.pendingReservations.length===0){this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),this.safeDispatchEvent("relay:found-enough-relays");return}this.relayFilter=Fr(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};class Wx extends Ih{constructor(e){super({...e,direction:e.stream.direction});l(this,"stream");l(this,"init");this.init=e,this.stream=e.stream,this.stream.addEventListener("close",n=>{this.onTransportClosed(n.error)}),this.stream.addEventListener("remoteCloseWrite",n=>{this.onRemoteCloseWrite(),this.close().catch(s=>{this.abort(s)})}),this.stream.addEventListener("message",n=>{var s;(s=e.onDataRead)==null||s.call(e,n.data),this.onData(n.data)}),this.stream.addEventListener("drain",()=>{this.safeDispatchEvent("drain")})}sendData(e){var n,s;return(s=(n=this.init).onDataWrite)==null||s.call(n,e),{sentBytes:e.byteLength,canSendMore:this.stream.send(e)}}async sendClose(e){await this.stream.close(e)}sendReset(){this.stream.abort(new Error("An error occurred"))}sendPause(){this.stream.pause()}sendResume(){this.stream.resume()}}function ou(r){return new Wx(r)}const Hx=r=>{if(r.peer==null)return!1;try{r.peer.addrs.forEach(X)}catch{return!1}return!0},au={maxInboundStopStreams:nu,maxOutboundStopStreams:nu};var Vu,Wu,Hu,Gu;class Gx{constructor(t,e={}){l(this,"components");l(this,"discovery");l(this,"reservationStore");l(this,"maxInboundStopStreams");l(this,"maxOutboundStopStreams");l(this,"started");l(this,"log");l(this,"shutdownController");l(this,Gu,"@libp2p/circuit-relay-v2-transport");l(this,Hu,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]);l(this,Vu,!0);this.components=t,this.log=t.logger.forComponent("libp2p:circuit-relay:transport"),this.maxInboundStopStreams=e.maxInboundStopStreams??au.maxInboundStopStreams,this.maxOutboundStopStreams=e.maxOutboundStopStreams??au.maxOutboundStopStreams,this.shutdownController=new AbortController,this.discovery=new Ox(t,{filter:e.discoveryFilter??Z0(Mx,Nx)}),this.discovery.addEventListener("relay:discover",n=>{this.reservationStore.addRelay(n.detail,"discovered").catch(s=>{s.name!=="HadEnoughRelaysError"&&s.name!=="RelayQueueFullError"&&this.log.error("could not add discovered relay %p - %e",n.detail,s)})}),this.reservationStore=new Vx(t,e),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var n;(n=this.discovery)==null||n.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var n;(n=this.discovery)==null||n.stopDiscovery()}),this.started=!1,this.onStop=this.onStop.bind(this)}get[(Gu=Symbol.toStringTag,Hu=Ct,Wu=Gs,Vu=od,Wu)](){return this.discovery!=null?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,this.shutdownController.signal,await this.components.registrar.handle(tu,this.onStop,{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await sd(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await id(this.discovery,this.reservationStore),await this.components.registrar.unhandle(tu),this.started=!1}async dial(t,e){var p,g,y,m,S,v,E,L;const n=t.toString().split("/p2p-circuit"),s=X(n[0]),i=X(n[n.length-1]),o=(p=s.getComponents().find(x=>x.code===V))==null?void 0:p.value,a=(g=i.getComponents().find(x=>x.code===V))==null?void 0:g.value;if(o==null||a==null){const x=`ircuit relay dial to ${t.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${x}`),new Er(`C${x}`)}const c=ct(o),u=ct(a);let h=this.components.connectionManager.getConnections(c)[0];h==null?(await this.components.peerStore.merge(c,{multiaddrs:[s]}),(y=e.onProgress)==null||y.call(e,new le("circuit-relay:open-connection")),h=await this.components.connectionManager.openConnection(c,e)):(m=e.onProgress)==null||m.call(e,new le("circuit-relay:reuse-connection"));let f;try{(S=e.onProgress)==null||S.call(e,new le("circuit-relay:open-hop-stream")),f=await h.newStream(Ai,e);const x=hn(f).pb(Jn);(v=e.onProgress)==null||v.call(e,new le("circuit-relay:write-connect-message")),await x.write({type:Jn.Type.CONNECT,peer:{id:u.toMultihash().bytes,addrs:[X(i).bytes]}},e),(E=e.onProgress)==null||E.call(e,new le("circuit-relay:read-connect-response"));const _=await x.read(e);if(_.status!==ze.OK)throw new it(`failed to connect via relay with status ${((L=_==null?void 0:_.status)==null?void 0:L.toString())??"undefined"}`);const N=new su(_.limit),T=ou({stream:x.unwrap().unwrap(),remoteAddr:t,localAddr:s.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),onDataRead:N.onData,onDataWrite:N.onData,log:f.log.newScope("circuit-relay:connection")}),I=await this.components.upgrader.upgradeOutbound(T,{...e,limits:N.getLimits()});return I.log("outbound relayed connection established to %p with limits %o, over connection %s",I.remotePeer,_.limit??"none",h.id),I}catch(x){throw this.log.error("circuit relay dial to destination %p via relay %p failed - %e",u,c,x),f==null||f.abort(x),x}}createListener(t){return Bx({peerId:this.components.peerId,connectionManager:this.components.connectionManager,addressManager:this.components.addressManager,reservationStore:this.reservationStore,logger:this.components.logger})}listenFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>xg.exactMatch(e)||Ag.exactMatch(e))}dialFilter(t){return t=Array.isArray(t)?t:[t],t.filter(e=>Qn.exactMatch(e))}async onStop(t,e){var s,i;const n=this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);try{if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.components.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(p){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e",p)}const o=hn(t).pb(bt),a=await o.read({signal:n});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,a.type),(a==null?void 0:a.type)===void 0){this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await o.write({type:bt.Type.STATUS,status:ze.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(a.type!==bt.Type.CONNECT){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:bt.Type.STATUS,status:ze.UNEXPECTED_MESSAGE},{signal:n}),await t.close({signal:n});return}if(!Hx(a)){this.log.error("invalid stop connect request via peer %p",e.remotePeer),await o.write({type:bt.Type.STATUS,status:ze.MALFORMED_MESSAGE},{signal:n}),await t.close({signal:n});return}const c=ts(Xr(a.peer.id));if(await((i=(s=this.components.connectionGater).denyInboundRelayedConnection)==null?void 0:i.call(s,e.remotePeer,c))===!0){this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await o.write({type:bt.Type.STATUS,status:ze.PERMISSION_DENIED},{signal:n}),await t.close({signal:n});return}this.log.trace("sending success response to %p",e.remotePeer),await o.write({type:bt.Type.STATUS,status:ze.OK},{signal:n});const u=new su(a.limit),d=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${c.toString()}`),h=this.components.addressManager.getAddresses()[0],f=ou({stream:o.unwrap().unwrap(),remoteAddr:d,localAddr:h,onDataRead:u.onData,onDataWrite:u.onData,log:t.log.newScope("circuit-relay:connection")});await this.components.upgrader.upgradeInbound(f,{limits:u.getLimits(),signal:n}),f.log("inbound relayed connection established to %p with limits %o, over connection %s",c,a.limit??"none",e.id)}finally{n==null||n.clear()}}}function Yx(r={}){return t=>new Gx(t,r)}const Xx="bootstrap",Qx=50,Zx=1e3;var Yu,Xu,Qu,Zu;class _g extends(Zu=Xe,Qu=zo,Xu=Symbol.toStringTag,Yu=Ct,Zu){constructor(e,n={list:[]}){if(n.list==null||n.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super();l(this,"log");l(this,"timer");l(this,"list");l(this,"timeout");l(this,"components");l(this,"_init");l(this,Qu,this);l(this,Xu,"@libp2p/bootstrap");l(this,Yu,["@libp2p/peer-discovery"]);this.components=e,this.log=e.logger.forComponent("libp2p:bootstrap"),this.timeout=n.timeout??Zx,this.list=n.list.map(s=>X(s)).filter(s=>{var o;return pc.matches(s)?((o=s.getComponents().findLast(a=>a.code===V))==null?void 0:o.value)==null?(this.log.error("invalid bootstrap multiaddr without peer id"),!1):!0:(this.log.error("invalid multiaddr %a",s),!1)}).map(s=>{var i;return{id:ct(((i=s.getComponents().findLast(o=>o.code===V))==null?void 0:i.value)??""),multiaddrs:[s]}}),this._init=n}isStarted(){return!!this.timer}start(){this.isStarted()||(this.log("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(e=>{this.log.error("failed to discover bootstrap peers - %e",e)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const e of this.list){if(await this.components.peerStore.merge(e.id,{tags:{[this._init.tagName??Xx]:{value:this._init.tagValue??Qx,ttl:this._init.tagTTL}},multiaddrs:e.multiaddrs}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:e}),this.components.connectionManager.openConnection(e.id).catch(n=>{this.log.error("could not dial bootstrap peer %p - %e",e.id,n)})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}l(_g,"tag","bootstrap");function Jx(r){return t=>new _g(t,r)}const jx=location.hostname.split("."),Ig=jx[0],e2=location.pathname==="/"||location.pathname===""?`${Ig}.github.io`:location.pathname.split("/")[1],lt=`${Ig}/${e2}`,t2="data/state.json",Ca=`https://api.github.com/repos/${lt}/contents/${t2}`,_a="gitchain_github_access_token",Ti=`https://api.github.com/repos/${lt}/issues`,cu="/gitchain/tx/1.0.0",$t="data/server-peer.json",n2=5*60*1e3;let Nt=null,Us=!1,lu=null;function Tg(r,t,e,n){const s=`${r}${t}${e}${JSON.stringify(n)}`;return CryptoJS.SHA256(s).toString()}function r2(){const r=new Date().toISOString();return{index:0,previousHash:"0",timestamp:r,transactions:[],hash:Tg(0,"0",r,[])}}function Lg(r){return JSON.stringify(r,Object.keys(r).sort())}function Ia(r){const e=sha3.keccak256(r).match(/.{2}/g);if(!e)throw new Error("Failed to parse hex string");return new Uint8Array(e.map(n=>parseInt(n,16)))}function s2(r){const t=new Uint8Array(r.length/2);for(let e=0;e<r.length;e+=2)t[e/2]=parseInt(r.substr(e,2),16);return t}function br(r){return Array.from(r,t=>t.toString(16).padStart(2,"0")).join("")}function wc(r){try{const t=Ia(Lg({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})),e=s2(r.signature);if(e.length!==65)return!1;const n=br(e.slice(0,32)),s=br(e.slice(32,64)),i=e[64]-27,o=new ec("secp256k1"),a=br(t),c={r:n,s},u=o.recoverPubKey(a,c,i),d=Ia(u.encode("array",!0).slice(1));return`0x${br(d.slice(-20))}`.toLowerCase()===r.from.toLowerCase()}catch{return!1}}async function i2(r,t){const e=br(Ia(Lg({from:r.from,to:r.to,amount:r.amount,nonce:r.nonce})));return wc(r)?(t.nonces[r.from]||0)+1!==r.nonce?{valid:!1,txid:e}:r.from.toLowerCase()!==Ks.toLowerCase()&&(t.balances[r.from]||0)<r.amount?{valid:!1,txid:e}:!/^0x[a-fA-F0-9]{40}$/.test(r.from)||!/^0x[a-fA-F0-9]{40}$/.test(r.to)?{valid:!1,txid:e}:(t.pending.push(r),{valid:!0,txid:e}):{valid:!1,txid:e}}async function o2(r){if(r.pending.length===0)return null;const t=[],e={...r.balances},n={...r.nonces};for(const u of r.pending)wc(u)&&(n[u.from]||0)+1===u.nonce&&(u.from.toLowerCase()===Ks.toLowerCase()||(e[u.from]||0)>=u.amount)&&(u.from.toLowerCase()!==Ks.toLowerCase()&&(e[u.from]=(e[u.from]||0)-u.amount),e[u.to]=(e[u.to]||0)+u.amount,n[u.from]=u.nonce,t.push(u));if(t.length===0)return r.pending=[],null;const s=r.chain.length,i=r.chain.length>0?r.chain[r.chain.length-1].hash:"0",o=new Date().toISOString(),a=Tg(s,i,o,t),c={index:s,previousHash:i,timestamp:o,transactions:t,hash:a};return r.chain.push(c),r.pending=[],r.balances=e,r.nonces=n,s}function Ht(){var t;let r=localStorage.getItem(_a);if(!r){if(r=(t=document.getElementById("githubAccessToken"))==null?void 0:t.value,!r)return console.log("No GitHub access token provided"),alert("Please enter your GitHub access token."),null;localStorage.setItem(_a,r)}return console.log("Retrieved GitHub access token"),r}async function a2(r){console.log("Entering initP2P, isHost:",r),Us=r;try{console.log("Creating libp2p node..."),Nt=await qS({addresses:{listen:["/webrtc","/p2p-circuit"]},transports:[Yx({hop:{enabled:!1}}),ux({iceServers:[{urls:"stun:stun.l.google.com:19302"}]})],connectionEncrypters:[lx()],streamMuxers:[Sx()],peerDiscovery:[Jx({list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbX7TbXrHRQHh2","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqduuO5wL","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76C42gEOzRVzYVdigitaltA5dyxuEXsBC","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp"]})],services:{identify:Px()},connectionGater:{denyDialMultiaddr:async()=>!1}}),console.log("Starting libp2p node..."),await Nt.start(),console.log("libp2p started, peerId:",Nt.peerId.toString()),console.log("Waiting for libp2p initialization..."),await new Promise(e=>setTimeout(e,1e3)),Nt.addEventListener("peer:connect",e=>{console.log("Connected to peer:",e.detail.toString())}),console.log("Registering protocol handler for:",cu),await Nt.handle(cu,async({stream:e,connection:n})=>{console.log("Incoming TX stream from",n.remotePeer.toString());const s=await l2(e);try{const i=JSON.parse(s);if(wc(i)){console.log("Valid TX received, creating GitHub issue");const o=JSON.stringify({type:"gitchain_txn",repo:lt,txn:i}),a=await fetch(Ti,{method:"POST",headers:{Authorization:`token ${Ht()}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({title:`tx ${i.from} to ${i.to}`,body:o})});a.ok?console.log("Created issue for anonymous TX"):console.error("Failed to create issue:",a.status,await a.text())}else console.error("Invalid TX from P2P")}catch(i){console.error("Error processing TX:",i)}e.close()}),Us&&(console.log("Host mode: Advertising peer info"),await uu(),console.log("Setting interval for periodic peer advertising"),setInterval(uu,n2),window.addEventListener("beforeunload",async()=>{console.log("Window unloading, deleting server peer file"),await c2()})),console.log("initP2P completed successfully")}catch(t){console.error("Failed to initialize P2P:",t),Us&&alert("The server appears to be temporarily down. Please check your network or contact the blockchain administrator.")}}async function uu(r=3,t=1e3){if(console.log("Entering advertiseServerPeer, retries:",r),!Us||!Nt)return console.log("Not in host mode or libp2p not initialized"),!1;const e=Nt.peerId.toString(),n=Nt.getMultiaddrs().map(a=>a.toString()),s={peerId:e,multiaddrs:n,timestamp:Date.now()},i=JSON.stringify(s,null,2);if(console.log("Peer info to advertise:",i),i===lu)return console.log("No change in peer info, skipping update"),!0;lu=i;const o=Ht();if(!o)return console.error("No PAT available for advertising peer"),!1;for(let a=1;a<=r;a++){console.log(`Attempt ${a}/${r} to advertise peer info`);try{console.log("Fetching SHA for",$t);const c=await Dg($t);console.log("SHA:",c||"none (new file)");const u={message:"Update server peer info",content:btoa(i),branch:"main"};c&&(u.sha=c),console.log("Sending PUT request to:",`https://api.github.com/repos/${lt}/contents/${$t}`);const d=await fetch(`https://api.github.com/repos/${lt}/contents/${$t}`,{method:"PUT",headers:{Authorization:`token ${o}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(u)});if(d.ok)return console.log("Advertised peer info successfully"),!0;{const h=await d.text();if(console.error(`Attempt ${a}/${r} - Failed to advertise peer: ${d.status} ${h}`),(d.status===403||d.status===429)&&(console.log(`Retrying after ${t}ms due to ${d.status}`),a<r)){await new Promise(f=>setTimeout(f,t));continue}throw new Error(`HTTP ${d.status}: ${h}`)}}catch(c){if(console.error(`Attempt ${a}/${r} - Error advertising peer:`,c),a===r)return console.error("All retries failed, alerting user"),alert("Failed to advertise server peer info. Ensure your PAT has repo scope and check API rate limits. Contact the administrator if the issue persists."),!1;await new Promise(u=>setTimeout(u,t))}}return console.log("Exiting advertiseServerPeer, failed after all retries"),!1}async function c2(){console.log("Entering deleteServerPeerFile");const r=Ht();if(!r){console.log("No PAT available for deleting server peer file");return}try{console.log("Fetching SHA for",$t);const t=await Dg($t);if(!t){console.log("No server peer file to delete");return}console.log("Sending DELETE request for",$t);const e=await fetch(`https://api.github.com/repos/${lt}/contents/${$t}`,{method:"DELETE",headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({message:"Remove server peer info on unload",sha:t})});e.ok?console.log("Deleted server peer file successfully"):console.error("Failed to delete peer file:",e.status,await e.text())}catch(t){console.error("Error deleting peer file:",t)}}async function Dg(r){console.log("Entering getFileSha for",r);const t=Ht();if(!t)return console.log("No PAT available for fetching SHA"),null;try{console.log("Fetching SHA from:",`https://api.github.com/repos/${lt}/contents/${r}?ref=main`);const e=await fetch(`https://api.github.com/repos/${lt}/contents/${r}?ref=main`,{headers:{Authorization:`token ${t}`,Accept:"application/vnd.github.v3+json"}});if(e.ok){const n=await e.json();return console.log("SHA retrieved:",n.sha),n.sha}return e.status===404?(console.log("File does not exist, returning null SHA"),null):(console.error(`Failed to fetch SHA for ${r}: ${e.status} ${await e.text()}`),null)}catch(e){return console.error(`Error fetching SHA for ${r}:`,e),null}}async function l2(r){console.log("Reading stream to string");const t=[];for await(const s of r.source)t.push(s);const e=qt(t),n=Z(e);return console.log("Stream read complete, length:",n.length),n}async function zs(){console.log("Entering fetchState");const r=Ht();if(!r)return console.log("No PAT available for fetching state"),null;try{console.log("Fetching state from:",Ca);const t=await fetch(`${Ca}?ref=main`,{headers:{Authorization:`token ${r}`,Accept:"application/vnd.github.v3+json"}});if(!t.ok){if(t.status===404)return console.log("State file not found"),null;throw console.error("Error fetching state:",t.status,await t.text()),new Error(`Error fetching state: ${t.statusText}`)}const e=await t.json(),n=JSON.parse(atob(e.content));return console.log("State fetched, chain length:",n.chain.length),{content:n,sha:e.sha}}catch(t){return console.error("Error fetching state:",t),null}}async function qs(r,t,e,n=3){console.log("Entering updateState, message:",e);const s=Ht();if(!s)return console.log("No PAT available for updating state"),!1;const i=btoa(JSON.stringify(r,null,2));try{const o={message:e,content:i,branch:"main"};t&&(o.sha=t),console.log("Sending PUT request to update state");const a=await fetch(Ca,{method:"PUT",headers:{Authorization:`token ${s}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify(o)});if(!a.ok){if(a.status===409&&n>0){console.log("Conflict detected, retrying...");const c=await zs();if(!c)throw new Error("Failed to refetch");return qs(r,c.sha,e,n-1)}throw console.error("Error updating state:",a.status,await a.text()),new Error(`Error updating state: ${a.statusText}`)}return console.log("State updated successfully"),!0}catch(o){return console.error("Error updating state:",o),!1}}async function Ls(r,t,e){console.log("Entering closeIssueWithComment, issue:",r);const n=Ht();if(!n){console.log("No PAT available for closing issue");return}const s=e&&t!==null?`Confirmed in block ${t}`:"Invalid transaction",i="Gitchain is an innovative centralized blockchain using GitHub for storage and processing. It enables secure, transparent transactions via issues. Join the experiment in decentralized finance today!",o=`https://github.com/${lt}`,a=`${s}. ${i} Learn more: ${o} (Repo: ${lt})`;console.log("Creating comment for issue:",r),await fetch(`${Ti}/${r}/comments`,{method:"POST",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({body:a})}),console.log("Closing issue:",r),await fetch(`${Ti}/${r}`,{method:"PATCH",headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.v3+json","Content-Type":"application/json"},body:JSON.stringify({state:"closed"})})}async function u2(){console.log("Entering processTxns");const r=document.getElementById("output"),t=document.getElementById("processingMessage");t.classList.add("visible");let e=await zs(),n=e==null?void 0:e.content;if(!n){if(console.log("No state found, initializing"),n={chain:[r2()],pending:[],balances:{[Ks]:1e6},nonces:{},lastProcessedDate:new Date(0).toISOString()},!await qs(n,null,"Initialize state")){console.log("Failed to initialize state"),r.textContent+=`
Failed to initialize.`,t.classList.remove("visible");return}e=await zs(),n=e.content}console.log("Fetching open issues");const i=await(await fetch(`${Ti}?state=open&sort=created&direction=asc&per_page=100`,{headers:{Authorization:`token ${Ht()}`,Accept:"application/vnd.github.v3+json"}})).json();let o=n.lastProcessedDate;for(const a of i){if(!a.title.toLowerCase().startsWith("tx")||new Date(a.created_at)<=new Date(n.lastProcessedDate))continue;let c;try{const g=JSON.parse(a.body);if(g.type!=="gitchain_txn"){console.log("Skipping non-gitchain issue:",a.number),await Ls(a.number,null,!1);continue}if(g.repo!==lt){console.log("Skipping issue from wrong repo:",a.number),await Ls(a.number,null,!1);continue}c=g.txn}catch{console.log("Invalid issue body, closing:",a.number),await Ls(a.number,null,!1);continue}console.log("Processing transaction from issue:",a.number);const{valid:u,txid:d}=await i2(c,n);console.log(`Transaction ID: ${d}, valid: ${u}`);const h=u?await o2(n):null;if(await Ls(a.number,h,u),u&&h!==null?(console.log(`Transaction ID: ${d} settled in block ${h}`),r.textContent+=`
Processed txn ${d} from issue #${a.number} in block ${h}`):(console.log(`Rejected invalid txn from issue #${a.number}`),r.textContent+=`
Rejected invalid txn from issue #${a.number}`),!await qs(n,e.sha,`Process issue #${a.number}`)){console.log("Failed to update state after issue:",a.number),r.textContent+=`
Failed to update state after issue #${a.number}`,t.classList.remove("visible");return}e=await zs(),n=e.content;const p=a.created_at;new Date(p)>new Date(o)&&(o=p)}o!==n.lastProcessedDate&&(console.log("Updating last processed date:",o),n.lastProcessedDate=o,await qs(n,e.sha,"Update last processed date")),console.log("processTxns completed"),t.classList.remove("visible")}window.addEventListener("load",()=>{console.log("Window loaded, checking for PAT"),localStorage.getItem(_a)?(console.log("PAT found, initializing P2P as host"),a2(!0)):(console.log("No PAT found, prompting user"),alert("Enter your GitHub access token (repo contents read/write, issues read/write) and save.")),console.log("Setting interval for transaction processing"),setInterval(()=>{u2()},15e3)});
